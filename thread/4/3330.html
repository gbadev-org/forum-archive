<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Unaligned halfword read behaviour? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Unaligned halfword read behaviour?</h2>
<div id="posts">
<div class="post">
    <h4>#20070 - gladius - Sat May 01, 2004 4:22 am</h4>
    <div class="postbody"><span class="postbody">I know that halfword reads on <b style="color:#FFA34F">unaligned</b> addresses are a no-no (undefined by the ARM spec.), but I was wondering what the actual behaviour is.
<br/>
<br/>
I seem to recall it would load 8 bits of the halfword from the <b style="color:#FFA34F">unaligned</b> access into the register, but my memory is sketchy, and I don't have access to hardware at this moment.
<br/>
<br/>
Thanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20075 - poslundc - Sat May 01, 2004 1:09 pm</h4>
    <div class="postbody"><span class="postbody">IIRC, the last bit of the address is ignored, so if you <b style="color:#FFA34F">read</b> a halfword from  an odd address then it is rounded down to an even address.
<br/>
<br/>
In other words:
<br/>
<br/>
*(u16 *)(0x03000000)
<br/>
and
<br/>
*(u16 *)(0x03000001)
<br/>
<br/>
... should produce the same result.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#25504 - ecurtz - Tue Aug 24, 2004 4:36 am</h4>
    <div class="postbody"><span class="postbody">According to <a class="postlink" href="http://www.arm.com/support/faqip/3661.html" target="_blank">this FAQ</a> at ARM an <b style="color:#FFA34F">unaligned</b> <b style="color:#FFA34F">read</b> on the 7TDMI has the (very desirable in my case) behavior of reading the entire word, but shifting the addressed byte into the low byte of the result. This seems to imply that I can just use word loads with shifts instead of half word loads, which require extra work. I tried this on hardware a second ago and it works, are there any gotchas I need to know about or is this kosher?
<br/>
<br/>
(Actually as I typed this up I realized the behavior may differ between cartridge and EWRAM. I'll go make another test case...)
<br/>
&lt;edit&gt; I just tried it from cart and it seemed fine. Is this a common trick? Is there some gotcha about the "A flag in bit 1 of CP15 register" that means I'll get an exception at some point? &lt;/edit&gt;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#25732 - torne - Fri Aug 27, 2004 7:30 pm</h4>
    <div class="postbody"><span class="postbody">Yes, it will work that way. CP15 is the system control coprocessor and is not present on the GBA, so the alignment error bit in it will unsuprisingly not be set ;)
<br/>
<br/>
I've never needed to use this, but it's legit on a system such as the GBA where you can depend on the memory controller's behaviour.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#25769 - ecurtz - Sat Aug 28, 2004 5:11 am</h4>
    <div class="postbody"><span class="postbody">Thanks for the confirmation torne.
<br/>
<br/>
It seems like there would be a number of cases where this would be useful. I ran into it looking up entries in a color table.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
