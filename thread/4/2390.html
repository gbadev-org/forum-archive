<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Is anyone still using rectangular collision boundaries? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Is anyone still using rectangular collision boundaries?</h2>
<div id="posts">
<div class="post">
    <h4>#12818 - shunyata - Thu Nov 27, 2003 6:44 pm</h4>
    <div class="postbody"><span class="postbody">?cause I?m working on two different very fast detection-algorithms intruducing some concepts I havn?t seen anyone else implement..
<br/>
<br/>
is it worth investing my precious time in completing these or should I move on to arbitrary bounding-shapes?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12819 - sajiimori - Thu Nov 27, 2003 6:52 pm</h4>
    <div class="postbody"><span class="postbody">Of course, lots of people use collision rects.  What's your idea?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12820 - shunyata - Thu Nov 27, 2003 7:29 pm</h4>
    <div class="postbody"><span class="postbody">well one is simple, it expands the sector method. instead of registering the sector in which an object resides, it keeps track of the sectors where bounding points reside;
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">struct bound_point
<br/>
{
<br/>
    byte x;
<br/>
    byte y;
<br/>
    byte type;
<br/>
    byte filler;
<br/>
};
<br/>
<br/>
// values of type
<br/>
enum {TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT};
<br/>
<br/>
// each collidable object includes a bounding point array
<br/>
// which is indexed with the same enumeration
<br/>
bound_point bounds[4];</td> </tr></table><span class="postbody">
<br/>
<br/>
I?m using a sector size of 30 x 20 pixels so that 4 levels of binary exclusion can be used when determining which sectors contain points. Objects with larger bounds than the sector size use multiple aligned point arrays. the containment algorithm switches on the type of its point arguments and can then determine whether the objects the points belong to have collided. using this technique we elliminate the shores of making sure objects are checked for collision in all sectors they overlap.
<br/>
<br/>
i just started developing this, and I havn?t yet determined wheather it will be too space-intensive.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12821 - tepples - Thu Nov 27, 2003 7:39 pm</h4>
    <div class="postbody"><span class="postbody">Conceptually, a typical collision detection routine will go like this:
<br/>
<br/>
1. <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=1488" target="_blank">Axis sorting</a> (1D extent test), to reject the most sprites that do not possibly overlap. Some engines use a sector method.
<br/>
2. Bounding rectangle test, to reject more sprites that do not overlap.
<br/>
3. More complicated tests, sometimes.
<br/>
<br/>
It seems you're replacing step 1 with what amounts to a bitmap test, scaling each sprite's bounding rectangle down by a factor and checking it against all other sprites that have been drawn in that cell. I'd like to see how this technique's speed fares against that of sorting at various densities of sprites in a playfield.
<br/>
<br/>
If you're worried about space, develop it on a PC first, where you get 32+ MiB of space to roam in. Complicated algorithms with complicated data structures are a very good candidate for PC based prototyping.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12822 - shunyata - Thu Nov 27, 2003 7:40 pm</h4>
    <div class="postbody"><span class="postbody">we can make it smaller by using bounds instead of points 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">struct bound
<br/>
{
<br/>
    byte value;
<br/>
    byte type;
<br/>
};
<br/>
<br/>
// values for type
<br/>
enum {LEFT, TOP, BOTTOM, RIGHT};</td> </tr></table><span class="postbody">
<br/>
<br/>
but that makes it slower...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12823 - shunyata - Thu Nov 27, 2003 7:56 pm</h4>
    <div class="postbody"><span class="postbody">well, you might see it as partitioning the bounding rectangle into 1-4 segments each bounded by a point and two sector edges (which are determined by the 'type' variable of the point) of the sector. the special cases where 2 or 4 bounding points from one object reside in the same sector are quite easy to take care of (by keeping track of the diagonal direction from which an object has been determined to be contained)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12828 - col - Fri Nov 28, 2003 2:58 pm</h4>
    <div class="postbody"><span class="postbody">[quote="shunyata"]...using this technique we elliminate the shores of making sure objects are checked for collision in all sectors they overlap.
<br/>
quote]
<br/>
<br/>
Hi Shunyata
<br/>
<br/>
From your description, it sounds to me like you are not elliminating any shores(chores?). More like you are moving the work around a bit so it seems that there is less?
<br/>
<br/>
Also, there seem to be some problems with the logic of your system...
<br/>
<br/>
Maybe i don't fully understand what you are doing?
<br/>
but is sounds like in trying to simplify the actual box overlap test by turning it into 4 point tests- 1 for each corner, you are actually going to increase the workload - with many extra conditionals and special cases...
<br/>
<br/>
a couple of examples :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
-------------------------------------------------------
<br/>
|1                |2                |3                |            
<br/>
|          boxA   |                 |                 |
<br/>
|           ------|-----------------|------           |
<br/>
|          |      |                 |      |          |
<br/>
-------------------------------------------------------
<br/>
|4         |      |5    boxB        |6     |          |
<br/>
|          |      |       -------   |      |          |
<br/>
|          |      |      |       |  |      |          |
<br/>
|          |      |       -------   |      |          |
<br/>
-------------------------------------------------------
<br/>
|7         |      |8                |9     |          |
<br/>
|          |      |                 |      |          |
<br/>
|           ------|-----------------|------           |
<br/>
|                 |                 |                 |
<br/>
-------------------------------------------------------
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
what if you have 1 bounding box (boxA) with corners in sectors 1, 3, 7 &amp; 9 (with your sector size, this could happen with any box greater than 31x21) - and another (boxA) that has all its points in sector 5?
<br/>
Ok, so usually, a collision would be detected before boxB got inside of boxA, but not always...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
-------------------------------------------------------
<br/>
|1                |2                |3                |            
<br/>
|          boxA   |                 |                 |
<br/>
|           ------|-----------------|---              |
<br/>
|          |      |                 |   |             |
<br/>
-------------------------------------------------------
<br/>
|4         |      |5                |6  |             |
<br/>
|          |      |            boxB |   |             |
<br/>
|          |      |               --|---|-------------|---
<br/>
|          |      |              |  |   |             |   |
<br/>
-------------------------------------------------------
<br/>
|7         |      |8             |  |9  |             |   |
<br/>
|           ------|--------------|--|---              |   |
<br/>
|                 |              |  |                 |   |
<br/>
|                 |              |  |                 |   |
<br/>
-------------------------------------------------------   |
<br/>
                                 |                        |
<br/>
                                  ------------------------
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
The above example is possibly more worrying. The two boxes overlap, but none of the corner points from boxA share sectors with any of boxBs corner points !
<br/>
Still probably uncommon, but if you don't 'catch' this special case, you will have to be constantly aware when designing levels etc. or you might create game situations where this happens every time !
<br/>
<br/>
<br/>
The standard 2d collision box test methods described by tepples are very efficient - its going to be pretty difficult to improve on them unless you have some very 'custom' situations in your game.
<br/>
<br/>
If I have misunderstood your technique, and your system deals gracefully with the situations that i have described - please explain the system again.
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12831 - shunyata - Fri Nov 28, 2003 4:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I?m using a sector size of 30 x 20 pixels so that 4 levels of binary exclusion can be used when determining which sectors contain points. Objects with larger bounds than the sector size use multiple aligned point arrays. </td> </tr></table><span class="postbody">
<br/>
<br/>
this means that there are no boxes larger than the sector size, so none of your situations can arise. also concerning the point tests, I hope you realize the importance of the type variable in the point structure. it makes the containment test faster than rect vs rect, ofcource you have to do 4 of them, but if you use a traditional sector-method (sorting the positions of objects into sectors), you have to either
<br/>
1) test 3 sorrounding sectors in addition to the sector where the object registered, because you cant be sure if it extends into them without testing
<br/>
2) make 4 different displaced sector sorts
<br/>
and both of these metods require a sector size larger than the largest object boundary
<br/>
<br/>
as for the special cases where 2 or 4 points from the same object boundary reside in the same sector, I will post the code once i?ve done it, it is perhaps not entirely intuitive to see. my computer works very poorly so I?m not sure when I can get to it.
<br/>
<br/>
and yes; 'chores' is what I was trying to spell..:) i?m from sweden and currently hostage under a foreign language..i can assure you that you would be wining a lot more if i posed in swedish :p 
<br/>
<br/>
holler if you want me to explain further.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12838 - col - Fri Nov 28, 2003 6:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
[quote="shunyata"]<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I?m using a sector size of 30 x 20 pixels so that 4 levels of binary exclusion can be used when determining which sectors contain points. Objects with larger bounds than the sector size use multiple aligned point arrays. </td> </tr></table><span class="postbody">
<br/>
<br/>
this means that there are no boxes larger than the sector size, so none of your situations can arise. also concerning the point tests, 
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
I'm not sure what you mean by '4 levels' of binary exclusion?
<br/>
Also, I've never read or heard of 'aligned point arrays', so maybe you could explain what they are - and how they will help
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I hope you realize the importance of the type variable in the point structure.
<br/>
</td> </tr></table><span class="postbody">
<br/>
yes - it is very clear.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">it makes the containment test faster than rect vs rect, ofcource you have to do 4 of them
<br/>
</td> </tr></table><span class="postbody">
<br/>
rect vs rect uses up to 4 comparisons - if you use an early termination test, then when you average out over many tests it works out at 2.5 comparisons per test !
<br/>
your point test uses 3 comparisons just to deal with the type info, then it uses 0 to 2(0 for internal points) to do the actual test.
<br/>
<br/>
it looks to me as though with any box &gt; 30x20, you are potentially going to need at least 9 not 4 tests - unless your 'aligned point arrays' help in this situation (and result in an overall cpu saving)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
...but if you use a traditional sector-method (sorting the positions of objects into sectors), you have to either
<br/>
1) test 3 sorrounding sectors in addition to the sector where the object registered, because you cant be sure if it extends into them without testing
<br/>
2) make 4 different displaced sector sorts
<br/>
and both of these metods require a sector size larger than the largest object boundary
<br/>
</td> </tr></table><span class="postbody">
<br/>
yes
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
as for the special cases where 2 or 4 points from the same object boundary reside in the same sector, I will post the code once i?ve done it, it is perhaps not entirely intuitive to see. my computer works very poorly so I?m not sure when I can get to it.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I'm sure there are many ways you could process your special cases - thats not the issue. The issue is that you have to test for each case - its this testing that is the real danger to efficiency
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
holler if you want me to explain further.
<br/>
</td> </tr></table><span class="postbody">
<br/>
:)
<br/>
<br/>
I really hope you have discovered a 'better way' to do collision detection. My worry is all the tricks you use to get around the problems with traditional methods might take more cpu time that the original problems did.
<br/>
<br/>
I guess I will just have to wait and see :)
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12848 - shunyata - Fri Nov 28, 2003 7:33 pm</h4>
    <div class="postbody"><span class="postbody">hey col, what does your rect-vs-rect code look like?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12855 - col - Fri Nov 28, 2003 10:05 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>shunyata wrote:</b></span></td> </tr> <tr> <td class="quote">hey col, what does your rect-vs-rect code look like?</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
It's a bog standard rectangle overlap check.
<br/>
roughly:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if(     boxB.x1 &gt; boxA.x2
<br/>
     || boxA.x2 &lt; boxB.x1
<br/>
     || boxB.y1 &gt; boxA.y2
<br/>
     || boxA.y2 &lt; boxB.y1 ){
<br/>
    return NO_COLLISION;
<br/>
}
<br/>
return COLLISION;
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12857 - shunyata - Fri Nov 28, 2003 11:45 pm</h4>
    <div class="postbody"><span class="postbody">yeah, that?s the bare basics, but I need a test that returns the direction of collision
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*        ______________
<br/>
         |7 |6 |5 |4 |3 |
<br/>
         |__|__|__|__|__| 
<br/>
         |8 |  |  |  |2 |
<br/>
         |__|__|__|__|__|
<br/>
         |9 |  |or|  |1 |
<br/>
         |__|__|ig|__|__|
<br/>
         |10|  |  |  |16|
<br/>
         |__|__|__|__|__|
<br/>
         |11|12|13|14|15|
<br/>
         |__|__|__|__|__|
<br/>
  */
<br/>
sbyte col_detect(byte* box_1, byte* box_2)
<br/>
{
<br/>
   if (box_1[TOP] &gt;= box_2[TOP] &amp;&amp; box_1[TOP] &lt;= box_2[BOTTOM])
<br/>
   {
<br/>
<br/>
/*     _ _ _        
<br/>
      |2   _|_ _  
<br/>
      |_ _|_|   | 
<br/>
          |_ _ 1|            |     
<br/>
                             v       */
<br/>
   
<br/>
      if (box_1[LEFT] &gt;= box_2[LEFT] &amp;&amp; box_1[LEFT] &lt;= box_2[RIGHT])
<br/>
      {
<br/>
         return (7);
<br/>
      }
<br/>
<br/>
/*       _ _ _
<br/>
       _|2 _ _|_
<br/>
      | |_ _ _| |
<br/>
      |         |
<br/>
      |_ _ _ _ 1|            |
<br/>
                             v       */
<br/>
      
<br/>
      else if (box_1[LEFT] &lt; box_2[LEFT] &amp;&amp; box_1[RIGHT] &gt; box_2[RIGHT])
<br/>
      {
<br/>
         return (5);
<br/>
      }
<br/>
   }
<br/>
<br/>
   if (box_1[RIGHT] &gt;= box_2[LEFT] &amp;&amp; box_1[RIGHT] &lt;= box_2[RIGHT])
<br/>
   {
<br/>
<br/>
/*         _ _ _    
<br/>
       _ _|_   2| 
<br/>
      |   |_|_ _| 
<br/>
      |1 _ _|                |
<br/>
                             v       */
<br/>
<br/>
      if (box_1[TOP] &gt;= box_2[TOP] &amp;&amp; box_1[TOP] &lt;= box_2[BOTTOM])
<br/>
      {
<br/>
         return (3);
<br/>
      }
<br/>
      
<br/>
/*      _ _ _ _ _ _ 
<br/>
       |          _|_ _
<br/>
       |         | |  2|
<br/>
       |         |_|_ _|
<br/>
       |1 _ _ _ _ _|         |
<br/>
                             v       */
<br/>
<br/>
      else if(box_1[TOP] &lt; box_2[TOP] &amp;&amp; box_1[BOTTOM] &gt; box_2[BOTTOM])
<br/>
      {
<br/>
         return (1);
<br/>
      }
<br/>
   }
<br/>
<br/>
   if (box_1[BOTTOM] &gt;= box_2[TOP] &amp;&amp; box_1[BOTTOM] &lt;= box_2[BOTTOM])
<br/>
   {
<br/>
<br/>
/*     _ _ _      
<br/>
      |1   _|_ _  
<br/>
      |_ _|_|   | 
<br/>
          |_ _ 2|            |       
<br/>
                             v       */
<br/>
   
<br/>
      if (box_1[RIGHT] &gt;= box_2[LEFT] &amp;&amp; box_1[RIGHT] &lt;= box_2[RIGHT])
<br/>
      {
<br/>
         return (15);
<br/>
      }
<br/>
      
<br/>
/*      _ _ _ _ _
<br/>
       |1        |
<br/>
       |  _ _ _  |
<br/>
       |_|_ _ _|_|
<br/>
         |_ _ 2|             |
<br/>
                             v       */
<br/>
<br/>
      else if (box_1[RIGHT] &gt; box_2[RIGHT] &amp;&amp; box_1[LEFT] &lt; box_2[LEFT])
<br/>
      {
<br/>
         return (13);
<br/>
      }
<br/>
   }
<br/>
<br/>
   if (box_1[LEFT] &gt;= box_2[LEFT] &amp;&amp; box_1[LEFT] &lt;= box_2[RIGHT])
<br/>
   {
<br/>
<br/>
/*         _ _ _    
<br/>
       _ _|_   1| 
<br/>
      |   |_|_ _|
<br/>
      |2 _ _|               |        
<br/>
                            v       */
<br/>
<br/>
      if (box_1[BOTTOM] &gt;= box_2[TOP] &amp;&amp; box_1[BOTTOM] &lt;= box_2[BOTTOM])
<br/>
      {
<br/>
         return (11);
<br/>
      }
<br/>
<br/>
/*         _ _ _ _ _ _  
<br/>
        _ |_         1|
<br/>
      |   | |         |  
<br/>
      |2 _|_|         |
<br/>
          |_ _ _ _ _ _|     |
<br/>
                            v       */
<br/>
   
<br/>
      else if (box_1[BOTTOM] &gt; box_2[BOTTOM] &amp;&amp; box_1[TOP] &lt; box_2[TOP])
<br/>
      {
<br/>
         return (9);
<br/>
      }
<br/>
   }
<br/>
<br/>
   return (0);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
that?s where the sector-point algorithm comes into play
<br/>
<br/>
to clarify everything else i?ll just post the code when (and if) it?s done. i do believe this sector-point algorithm would be faster for this type of collision detection, but i realize it might be a bit of an overkill for the gba. in the worst case we?ll need dynamic datastructures and i?m not up for writing my own heap implementation and all that stuff. 
<br/>
<br/>
how fast is malloc() / new, pretty awful right? 
<br/>
<br/>
well maybe i?ll just settle for the bare-bones rect-outside-rect method with 1d sorting.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12858 - crossraleigh - Sat Nov 29, 2003 12:01 am</h4>
    <div class="postbody"><span class="postbody">On several different topics now, tepples has kindly suggested using axis-sorting collision detection, and I have come to favor it over using sectors. The GBA screen is pretty small for full fledged screen sectoring anyway.
<br/>
<br/>
If you keep a list of all the sprites sorted by Y coordinate, you can just move backwards or forwards in the list until you find a sprite that is higher than the top or lower than the bottom of the sprite you want to test. While X-sorting is usually better for collision detection (the locations should be spread out more), Y-sorting takes care of Z-ordering as well; you just loop through and apply the list to OAM.
<br/>
<br/>
To save memory you'll keep sprites in a list anyway, right? So you might as well keep them sorted. Unless you're doing a linear side-scroller, like Mario, where almost all the Y coordindates match up, I think this sorting is quicker. And in games like mario, Z-ordering isn't that important, so you can use X-sorting.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12859 - poslundc - Sat Nov 29, 2003 12:25 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>crossraleigh wrote:</b></span></td> </tr> <tr> <td class="quote">While X-sorting is usually better for collision detection (the locations should be spread out more), Y-sorting takes care of Z-ordering as well; you just loop through and apply the list to OAM.</td> </tr></table><span class="postbody">
<br/>
<br/>
Hey now, that's a very good point! &lt;makes a mental note for when it comes time to write collision-detection code&gt;
<br/>
<br/>
Nothing I love more than killing multiple birds with single projectiles.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12863 - yaustar - Sat Nov 29, 2003 12:48 am</h4>
    <div class="postbody"><span class="postbody">may I ask for an example of x/y ordering and ask what is z-ordering<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12864 - shunyata - Sat Nov 29, 2003 12:58 am</h4>
    <div class="postbody"><span class="postbody">well, I agree with you crossraleigh, in most cases 1d-sorting would be enough (and the z-order trick ain?t half bad either). but i?m writing a spaceshooter with quite a lot of objects, that?s why i bother (and also for the sense of completeness). and remember, the faster the col-det the more time over for cool software-effects ;D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12899 - crossraleigh - Sun Nov 30, 2003 5:10 am</h4>
    <div class="postbody"><span class="postbody">yaustar, I'll try explaining:
<br/>
<br/>
Z-ordering is simple. The GBA draws sprites that have the same priority in the order they are placed in OAM; sprites lowest in memory are drawn first. Usually you want objects furthest away (from the 'camera') to be drawn first, so you need to keep them ordered in OAM by their 'Z coordinate'.
<br/>
<br/>
To be kept sorted by their X or Y values, sprites need to be in a doubly linked list. Every time you move a sprite, just make sure you move it in the list. When they are Y sorted, you don't need to worry about changes in X values, and for changes in Y values, here is some pseudocode:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if sprite.direction == UP
<br/>
        while sprite.y - sprite.speed &gt; i.y
<br/>
                i = i.prev
<br/>
        sprite.insert_before i
<br/>
if sprite.direction == DOWN
<br/>
        while sprite.y + sprite.speed &lt; i.y
<br/>
                i = i.next
<br/>
        sprite.insert_after i
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
tepples has also suggested using a Shellsort to reorder the sprites, but I think that is overkill unless you have some really hyperactive sprites and the list will drasticly change each frame.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12914 - yaustar - Sun Nov 30, 2003 4:15 pm</h4>
    <div class="postbody"><span class="postbody">ok, but how does keeping the y-coords sorted help with the collision detection?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
for(i=0; i &lt; no of sprites; i++)
<br/>
{
<br/>
    //do y checking here
<br/>
<br/>
    if(sprites[i].y + SPRITE_HEIGHT &lt; sprites[i+1].y)
<br/>
    {
<br/>
         break;
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Something like this maybe?<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12918 - sajiimori - Sun Nov 30, 2003 6:51 pm</h4>
    <div class="postbody"><span class="postbody">Yup, just like that.  :-)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13290 - haduken - Wed Dec 10, 2003 8:22 pm</h4>
    <div class="postbody"><span class="postbody">And what's wrong with rectangular collision detection? It works just fine for most sidescrolling games.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13292 - yaustar - Wed Dec 10, 2003 8:40 pm</h4>
    <div class="postbody"><span class="postbody">This is still a variation of the rectangle collision detection but making it quicker by not comparing all the sprites with each other.<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
