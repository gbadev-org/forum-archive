<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Clarification, please - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Clarification, please</h2>
<div id="posts">
<div class="post">
    <h4>#47765 - sparda - Wed Jul 13, 2005 4:58 am</h4>
    <div class="postbody"><span class="postbody">Hello everyone,
<br/>
<br/>
I have a situation. I've been looking through Programming Forums for an answer to my question, an i havent found it yet. So i've dicided to ask for the answer here in the Coding forum.
<br/>
<br/>
I want to know the EXACT meaning of Object Oriented Programming, because this has peeked my curiousity for a long time now. I've looked through, google, yahoo, altavista, ect, and what i get is a definition that is not understandable at all to me!
<br/>
<br/>
So in other words, can anyone explain what Object Oriented Programming is in simple ENGLISH? or at least try to. I know a some C programming, so i think i might be able to understand some of the terminology. Any help would be greatly appreciated. Thank you.<br/>_________________<br/>genius is 1% inspiration, 99% perspiration .</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#47777 - poslundc - Wed Jul 13, 2005 8:23 am</h4>
    <div class="postbody"><span class="postbody">Object-oriented programming is a fairly broadly-used term. To be somewhat technical, I'd define it as a paradigm for programming that is based on using sophisticated data-types in the code-space to represent entities with common properties in the problem-space.
<br/>
<br/>
In other words, the OOP paradigm is to use structures to represent types of entities that need to be represented - such as an Employee, or a Car, or a Sprite, or a Menu - and to let <span style="font-style: italic">those objects</span> define and take care of their own functionality, operations, etc. rather than just randomly accessing any element of your structure from anywhere in your code. The resulting <span style="font-style: italic">encapsulation</span> of data can often result in code that is less error-prone and more modular.
<br/>
<br/>
An OOP language (such as C++) provides features to support this paradigm, such as methods, inheritance, access restriction, and built-in polymorphism.
<br/>
<br/>
<span style="font-style: italic">There is nothing you can do in an OOP language you cannot do in a regular language.</span> OOP languages simply provide you with tools that make it very natural to follow this paradigm.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#47788 - poslundc - Wed Jul 13, 2005 4:12 pm</h4>
    <div class="postbody"><span class="postbody">Follow-up post: one of the biggest and most driving concept between "regular" programming and OOP is the desire for encapsulation and modularity. Generally speaking, the less a module needs to know about the implementation details of another module in order to access it, the less error-prone and easier to modify it's likely to be. Take an example from C:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct Employee
<br/>
{
<br/>
     float     salary;
<br/>
}
<br/>
Employee;</td> </tr></table><span class="postbody">
<br/>
<br/>
In this example, Employee objects may be passed around the program and anyone can read or modify the employee's salary. Now take a potential C++ example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class Employee
<br/>
{
<br/>
public:
<br/>
     void SetSalary(float);
<br/>
     float GetSalary();
<br/>
<br/>
private:
<br/>
     float     m_salary;
<br/>
};</td> </tr></table><span class="postbody">
<br/>
<br/>
In this example, the Employee objects may be passed around, but they <span style="font-style: italic">cannot directly access the m_salary variable</span>, and instead must go through the SetSalary() and GetSalary() functions (also called <span style="font-style: italic">methods</span>).
<br/>
<br/>
While this may seem a lot more cumbersome (and it is), it provides the valuable feature of encapsulation in that <span style="font-style: italic">only the Employee class knows the specifics of how the salary is being stored</span>. It would be possible to change how the salary is being stored - you could, for example, eliminate the m_salary variable entirely and instead use a lookup table - and <span style="font-weight: bold">the rest of the program would never have to know about it</span>, and nothing would have to be recoded, except for the methods specific to the Employee class.
<br/>
<br/>
And again, this type of encapsulation can be achieved just as well in a regular programming language. In addition to my Employee C struct, I could have had declared global functions like:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void EMP_SetSalary(Employee *, float salary);
<br/>
float EMP_GetSalary(Employee *);</td> </tr></table><span class="postbody">
<br/>
<br/>
... and then simply relied on my own discipline as a programmer not to modify the salary field of the struct directly.
<br/>
<br/>
Whether one method is better than the other is up for debate and flame-wars. But if you want to make use of the paradigm, OOP languages are certainly designed for it and generally make it faster to write the necessary code. They are not the holy grail, though, and not without their flaws. :/
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#47794 - sajiimori - Wed Jul 13, 2005 5:52 pm</h4>
    <div class="postbody"><span class="postbody">That basically covers it.
<br/>
<br/>
My personal experience was that the object oriented features of C++ made no sense until I got good at C and then read a book that explained the purpose of every new feature ("Thinking in C++" by Bruce Eckel).
<br/>
<br/>
Incidentally, I'm glad the book wasn't "Thinking in OOP" because that would have placed an unnecessary restriction on the way I use C++.  As it is, I treat the language as a tool box that I can dig through to help me solve problems, even if the solution isn't very objecty.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
