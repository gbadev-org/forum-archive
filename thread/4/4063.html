<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Multiple interrupts handler. - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Multiple interrupts handler.</h2>
<div id="posts">
<div class="post">
    <h4>#26311 - Lord Graga - Sun Sep 12, 2004 6:43 pm</h4>
    <div class="postbody"><span class="postbody">Heya. I am looking for an interrupt handler that supports multiple interrupts.
<br/>
<br/>
I have tried to use the one from jeff's crt0, but it doesn't seem like that I can get it right.
<br/>
<br/>
<br/>
I am using DevkitARM.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26328 - Krakken - Mon Sep 13, 2004 1:00 am</h4>
    <div class="postbody"><span class="postbody">TONC has a good one.
<br/>
<a href="http://user.chem.tue.nl/jakvijn/tonc/interrupts.htm" target="_blank">http://user.chem.tue.nl/jakvijn/tonc/interrupts.htm</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26332 - col - Mon Sep 13, 2004 2:45 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lord Graga wrote:</b></span></td> </tr> <tr> <td class="quote">Heya. I am looking for an interrupt handler that supports multiple interrupts.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Do you mean a re-entrant handler?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I have tried to use the one from jeff's crt0, but it doesn't seem like that I can get it right.
<br/>
</td> </tr></table><span class="postbody">
<br/>
what are the symptoms? is it just not working at all? 
<br/>
or is it working, but causing instability?
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26484 - Lord Graga - Thu Sep 16, 2004 10:38 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>col wrote:</b></span></td> </tr> <tr> <td class="quote">Do you mean a re-entrant handler?</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, I probably do. I do not know much about interrupts, and until not, I have just used the handler that came with libgba, which is a single interrupts handler.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>col wrote:</b></span></td> </tr> <tr> <td class="quote">what are the symptoms? is it just not working at all? </td> </tr></table><span class="postbody">
<br/>
<br/>
With screen, which is a sign of something that has fucked up badly, which probably means that some registers has been changed on a time where they should not be changed/etc.
<br/>
<br/>
<br/>
LG</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26490 - col - Fri Sep 17, 2004 12:33 am</h4>
    <div class="postbody"><span class="postbody">That's not a whole lot to go on :)
<br/>
<br/>
Anyway, here's another question:
<br/>
When you tried Jeff Fs multiple interrupt code, did you set it to switch back to the user stack, or to use the irq stack ?
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27057 - abilyk - Sat Oct 02, 2004 7:18 am</h4>
    <div class="postbody"><span class="postbody">Lord Graga,
<br/>
<br/>
You say you're looking for an interrupt handler that supports multiple interrupts.  By that do you mean nested interrupts?  I've seen a lot of information on handlers that can support more than one interrupt... you just use a series of if statements and process all interrupts that are both enabled in REG_IE and requested in REG_IF.  In contrast, I haven't seen much information on how to deal with nested interrupts (an interrupt can be interrupted by another interrupt).
<br/>
<br/>
I needed to support nested interrupts because I plan to do some scanline tricks using the HBlank interrupt.  If some random interrupt is currently being processed when an HBlank interrupt fires, it's imperative that I halt the current interrupt and deal with the HBlank;  if I wait for the first interrupt to finish, I may miss the HBlank window completely.  Using info I found in GBATEK, the Cowbite Spec, TONC, and on this forum, I've written my own nested interrupt handler in ARM assembly.
<br/>
<br/>
I've spent the last week or so researching and programming, and I believe I understand how the whole process works and that my code does what it should.  Following is the relevant info I've found in my research and the code for my interrupt handler.  If I have all my facts straight here, hopefully some people will benefit from it.  If I'm incorrect in places, or if there are problems with my code (I'm a newbie to ARM assembly), I'd be happy for someone to set the record straight.
<br/>
<br/>
----------------------
<br/>
<br/>
In order for an interrupt to be requested (its bit in REG_IF to be set to 1), the interrupt enable flag in the appropriate hardware register must be set.  For example, in order for HBlank interrupts to be requested, bit 4 of REG_DISPSTAT must be set to 1.  Once this bit in REG_DISPSTAT is set, the HBlank request bit in REG_IF will be set to 1 every time an HBlank occurs, even if interrupts are disabled in REG_IME, REG_IE, and the CPSR (current program state register).
<br/>
<br/>
If interrupts are disabled in either REG_IME (bit 0 cleared to 0) or in the CPSR (bit 7 set to 1), no interrupts can occur.  Interrupts must be enabled in both REG_IME and the CPSR in order for interrupts to be able to occur.
<br/>
<br/>
If interrupts are enabled in both REG_IME and the CPSR, an interrupt will occur when an interrupt's flag is set in both REG_IE and REG_IF.  In most cases, interrupts will be enabled in both REG_IME and the CPSR, a particular interrupt will be enabled in REG_IE, and it is not until that particular interrupt is requested and its bit set in REG_IF that the interrupt actually occurs.  However, it is possible that a particular interrupt will be enabled in REG_IE and requested in REG_IF, but it cannot yet occur because interrupts are disabled in either (or both) REG_IME and/or the CPSR.  Once interrupts are enabled in both REG_IME and the CPSR, the interrupt will immediately occur, even if it was requested a number of cycles/frames/minutes ago.
<br/>
<br/>
<br/>
<br/>
When an interrupt occurs, the following events happen, in order:
<br/>
<br/>
<span style="font-weight: bold">Performed immediately when a CPU IRQ exception occurs:</span>
<br/>
<ul><li>The PC (program counter), which points to the next instruction of your interrupted process, is saved to LR (link register).
<br/>
</li><li>The CPSR is saved to SPSR_irq (saved program state register for IRQ mode).
<br/>
</li><li>The CPSR is updated to ARM state and IRQ mode.
<br/>
</li><li>Interrupts are disabled in the CPSR.
<br/>
</li><li>The PC is set to 0x18 (the exception vector for IRQs).</li></ul>
<br/>
<br/>
<span style="font-weight: bold">Interrupt exception vector:</span>
<br/>
<ul><li>Branch to 0x128 (the interrupt handler in the BIOS).</li></ul>
<br/>
<br/>
<span style="font-weight: bold">BIOS interrupt handler:</span>
<br/>
<ul><li>Registers r0-r3,r12,r14 are pushed onto the IRQ stack (not the system/user mode stack).
<br/>
</li><li>The PC, which points to the BIOS instruction after the upcoming branch, is saved to LR_irq.
<br/>
</li><li>Branch to the address stored in 0x03007FFC (should be a pointer to your interrupt handler, must be compiled as ARM).</li></ul>
<br/>
<br/>
<span style="font-weight: bold">My nested interrupt handler:</span>
<br/>
<ul><li>Push any registers that must not be trashed.  I had to push r4-r7, LR_irq.
<br/>
</li><li>Determine which interrupts to service by &amp;-ing (bitwise AND-ing) the values of REG_IE and REG_IF.
<br/>
</li><li>Acknowledge in REG_IF the interrupts you are going to service by setting the appropriate bits to 1.  Yes, they were 1 to begin with, but setting them to 1 clears them to 0.  Do it, it works.  Note that writing a 0 to a bit does nothing.  If REG_IF has two bits set, but you only want to acknowledge and clear one of the bits, writing a 1 to that bit does what you want.  The bit that you wrote a 1 to will be cleared to 0, and the other bit, which you wrote a 0 to, will still be set to 1.  Also note that if you do not acknowledge an occurred interrupt in REG_IF, the interrupt will erroneously occur again as soon as interrupts are re-enabled in the CSPR.
<br/>
</li><li>Acknowledge in IWRAM address 0x03007FF8 (I call this ISR_RAM_IF, but I've seen it called BIOS_IF) the interrupts you are going to service by setting the appropriate bits to 1.  The memory at this address is not a special-case register like the funky REG_IF explained above.   If you write 0 to all the bits, all the bits will become 0, and vice-versa.  You must use bitwise OR (C code would be <span style="font-weight: bold">ISR_RAM_IF = ISR_RAM_IF | flags_to_clear;</span>) in order to not overwrite any bits that should be maintained.  Note that if you do not acknowledge an occurred interrupt in ISR_RAM_IF, SWI (software interrupt) calls which deal with interrupts (like SWI 4, IntrWait) will not work correctly.
<br/>
</li><li>Save contents of SPSR_irq.  If a nested interrupt occurs, SPSR_irq will be overwritten, so we must preserve it.
<br/>
</li><li>Disable interrupts in REG_IME.  They're already disabled in the CPSR, but since we want interrupts to remain disabled for the time being and the next step is to enable interrupts in the CPSR, we must disable interrupts here so they remain disabled.
<br/>
</li><li>Enable interrupts in the CPSR.  Interrupts will remain disabled because they are disabled in REG_IME.
<br/>
</li><li>For each possible interrupt (in order of priority),
<br/>
<ul><li>Test to see if it is one of the interrupts to be serviced.  If not, move on to the next interrupt.  If so, continue processing this interrupt.
<br/>
</li><li>If the interrupt is highest priority and cannot be interrupted (like HBlank is in my case), just call that interrupt's ISR (interrupt service routine).
<br/>
</li><li>If the interrupt is medium priority -- it can be interrupted by some interrupts but not by others -- disable the specific lower-priority interrupts in REG_IE, enable interrupts in REG_IME, and call the interrupt's ISR.  It can be interrupted only by the higher-priority interrupts that you did not disable in REG_IME.  After the interrupt's ISR returns, disable interrupts in REG_IME and re-enable the lower-priority interrupts you had disabled in REG_IE.
<br/>
</li><li>Otherwise, if the interrupt is low priority -- it can be interrupted by any interrupt -- enable interrupts in REG_IME, call the interrupt's ISR, and then disable interrupts in REG_IME again.</li></ul>
<br/>
</li><li>After all interrupts have been processed, restore the contents of SPSR_irq.
<br/>
</li><li>Enable interrupts in REG_IME.
<br/>
</li><li>Pop the registers you pushed in the beginning.
<br/>
</li><li>Return to caller.</li></ul>
<br/>
<br/>
<span style="font-weight: bold">BIOS interrupt handler (again):</span>
<br/>
<ul><li>Registers r0-r3,r12,r14 are popped off the IRQ stack.
<br/>
</li><li>Restore the contents of CPSR from SPSR_irq.
<br/>
</li><li>The PC is set to the next instruction of your initially-interrupted process, at which point everything is back to pre-interrupt state (barring any changes your ISR made, of course).</li></ul>
<br/>
<br/>
<br/>
Here's my code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*
<br/>
    ------------------------------------------------------------------------------------
<br/>
     interrupt.S
<br/>
     andrew p. bilyk
<br/>
     dungeon monkey studios
<br/>
     September 21, 2004
<br/>
    ------------------------------------------------------------------------------------
<br/>
    
<br/>
    
<br/>
    ------------------------------------------------------------------------------------
<br/>
     Unused registers
<br/>
    ------------------------------------------------------------------------------------
<br/>
    r1
<br/>
    r2
<br/>
    r3
<br/>
    r8
<br/>
    r9
<br/>
    r10
<br/>
    r11 = FP (frame pointer)
<br/>
    r12 = IP
<br/>
    r13 = SP (stack pointer)
<br/>
    r15 = PC (program counter)
<br/>
    
<br/>
    
<br/>
    ------------------------------------------------------------------------------------
<br/>
     Used by MainInterruptServiceRoutine
<br/>
    ------------------------------------------------------------------------------------
<br/>
    r0  = scratch data
<br/>
    r4  = interrupts_to_be_serviced
<br/>
    r5  = enabled_interrupts
<br/>
    r6  = saved_spsr_irq
<br/>
    r7  = REG_BASE_ADDRESS
<br/>
    r14 = LR (link register)
<br/>
*/
<br/>
<br/>
<br/>
    .section  .iwram
<br/>
    .align    2
<br/>
    .global   MainInterruptServiceRoutine
<br/>
    .type     MainInterruptServiceRoutine,function
<br/>
    
<br/>
    
<br/>
@ void MainInterruptServiceRoutine(void)
<br/>
@----------------------------------------
<br/>
MainInterruptServiceRoutine:
<br/>
<br/>
    @ save contents of r4-r7 and link register
<br/>
    @ we'll be using r4-r7, and a function call to an IRQ handler will overwrite lr
<br/>
    stmfd   sp!, {r4-r7, lr}      @ push r4-r7 &amp; link register
<br/>
    
<br/>
    @ store base address used to refer to REG_IE, REG_IF, REG_IME, &amp; ISR_RAM_IF
<br/>
    mov     r7,    #0x4000000     @ r7 = 0x4000000
<br/>
    add     r7, r7, #0x200        @ r7 = REG_BASE_ADDRESS = 0x4000200
<br/>
    
<br/>
    @ determine which interrupts to service (enabled_interrupts &amp; requested_interrupts)
<br/>
    ldr     r5, [r7]              @ r5_lo = enabled_interrupts = REG_IE;  r5_hi = requested_interrupts = REG_IF
<br/>
    and     r4, r5, r5,lsr#16     @ r4 = interrupts_to_be_serviced = REG_IE &amp; REG_IF
<br/>
    
<br/>
    @ acknowledge interrupts_to_be_serviced in REG_IF
<br/>
    strh    r4, [r7, #0x2]        @ REG_IF = r4 = interrupts_to_be_serviced
<br/>
    
<br/>
    @ acknowledge interrupts_to_be_serviced in ISR_RAM_IF
<br/>
    ldr     r0, [r7, #-0x208]     @ r0 = ISR_RAM_IF
<br/>
    orr     r0, r0, r4            @ r0 = ISR_RAM_IF | interrupts_to_be_serviced
<br/>
    str     r0, [r7, #-0x208]     @ ISR_RAM_IF = r0 = ISR_RAM_IF | interrupts_to_be_serviced
<br/>
    
<br/>
    @ save contents of SPSR_irq;  if a nested interrupt occurs, it will overwrite the register
<br/>
    mrs     r6, spsr              @ r6 = saved_spsr_irq = SPSR_irq
<br/>
    
<br/>
    @ disable interrupts via REG_IME
<br/>
    mov     r0, #0                @ r0 = 0
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 0
<br/>
    
<br/>
    @ enable interrupts via CPSR (but they are still disabled due to REG_IME)
<br/>
    mrs     r0, cpsr              @ r0 = CPSR
<br/>
    bic     r0, r0, #0x80         @ set CPSR's IRQ flag to enable by clearing bit 7
<br/>
    msr     cpsr, r0              @ CPSR = r0
<br/>
<br/>
<br/>
.L_HBLANK:
<br/>
    @ if((interrupts_to_be_serviced &amp; HBlank flag) != 0), handle interrupt
<br/>
    @ otherwise, branch to next test
<br/>
    tst     r4, #0x0002           @ test interrupts_to_be_serviced &amp; HBlank flag
<br/>
    beq     .L_TIMER_0            @ if result of test == 0, branch to next test
<br/>
    
<br/>
    @ call specific ISR
<br/>
    ldr     r0, .L_HBLANK_ISR     @ load address of function pointer into r0
<br/>
    ldr     r0, [r0]              @ load function pointer into r0
<br/>
    mov     lr, pc                @ save program counter in link register
<br/>
    bx      r0                    @ call ISR pointed to by the function pointer
<br/>
    
<br/>
<br/>
.L_TIMER_0:
<br/>
    @ if((interrupts_to_be_serviced &amp; Timer_0 flag) != 0), handle interrupt
<br/>
    @ otherwise, branch to next test
<br/>
    tst     r4, #0x0008           @ test interrupts_to_be_serviced &amp; Timer_0 flag
<br/>
    beq     .L_KEYPAD             @ if result of test == 0, branch to next test
<br/>
    
<br/>
    @ temporarily disable lower-priority interrupts via REG_IE
<br/>
    bic     r0, r5, #0x1000       @ r0 = enabled_interrupts &amp; ~(key input flag)
<br/>
    bic     r0, r0, #0x0001       @ r0 = r0 &amp; ~(vblank flag)
<br/>
    strh    r0, [r7]              @ REG_IE = r0 = enabled_interrupts &amp; ~lower_priority_flags
<br/>
    
<br/>
    @ re-enable interrupts via REG_IME
<br/>
    mov     r0, #1                @ r0 = 1
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 1
<br/>
    
<br/>
    @ call Timer 0 ISR
<br/>
    ldr     r0, .L_TIMER_0_ISR    @ load address of function pointer into r0
<br/>
    ldr     r0, [r0]              @ load function pointer into r0
<br/>
    mov     lr, pc                @ save program counter in link register
<br/>
    bx      r0                    @ call ISR pointed to by the function pointer
<br/>
    
<br/>
    @ disable interrupts via REG_IME
<br/>
    mov     r0, #0                @ r0 = 0
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 0
<br/>
    
<br/>
    @ re-enable lower-priority interrupts via REG_IE
<br/>
    strh    r5, [r7]              @ REG_IE = r5 = enabled_interrupts
<br/>
    
<br/>
<br/>
.L_KEYPAD:
<br/>
    @ if((interrupts_to_be_serviced &amp; Keypad flag) != 0), handle interrupt
<br/>
    @ otherwise, branch to next test
<br/>
    tst     r4, #0x1000           @ test interrupts_to_be_serviced &amp; Keypad flag
<br/>
    beq     .L_VBLANK             @ if result of test == 0, branch to next test
<br/>
<br/>
    @ re-enable interrupts via REG_IME
<br/>
    mov     r0, #1                @ r0 = 1
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 1
<br/>
    
<br/>
    @ call Keypad ISR
<br/>
    ldr     r0, .L_KEYPAD_ISR     @ load address of function pointer into r0
<br/>
    ldr     r0, [r0]              @ load function pointer into r0
<br/>
    mov     lr, pc                @ save program counter in link register
<br/>
    bx      r0                    @ call ISR pointed to by the function pointer
<br/>
    
<br/>
    @ disable interrupts via REG_IME
<br/>
    mov     r0, #0                @ r0 = 0
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 0
<br/>
<br/>
<br/>
.L_VBLANK:
<br/>
    @ if((interrupts_to_be_serviced &amp; VBlank flag) != 0), handle interrupt
<br/>
    @ otherwise, branch to next test
<br/>
    tst     r4, #0x0001           @ test interrupts_to_be_serviced &amp; VBlank flag
<br/>
    beq     .L_END                @ if result of test == 0, branch to next test
<br/>
    
<br/>
    @ re-enable interrupts via REG_IME
<br/>
    mov     r0, #1                @ r0 = 1
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 1
<br/>
    
<br/>
    @ call Vblank ISR
<br/>
    ldr     r0, .L_VBLANK_ISR     @ load address of function pointer into r0
<br/>
    ldr     r0, [r0]              @ load function pointer into r0
<br/>
    mov     lr, pc                @ save program counter in link register
<br/>
    bx      r0                    @ call ISR pointed to by the function pointer
<br/>
    
<br/>
    @ disable interrupts via REG_IME
<br/>
    mov     r0, #0                @ r0 = 0
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 0
<br/>
<br/>
    
<br/>
.L_END:
<br/>
    @ restore contents of SPSR_irq
<br/>
    msr     spsr, r6              @ SPSR_irq = r6
<br/>
    
<br/>
    @ re-enable interrupts via REG_IME
<br/>
    mov     r0, #1                @ r0 = 1
<br/>
    strh    r0, [r7, #0x8]        @ REG_IME = r0 = 1
<br/>
    
<br/>
    @ restore contents of r4-r7 and link register
<br/>
    ldmfd   sp!, {r4-r7, lr}      @ pop r4-r7 &amp; link register
<br/>
    
<br/>
    @ return to caller
<br/>
    bx      lr                    @ return to caller
<br/>
<br/>
<br/>
.L_HBLANK_ISR:
<br/>
    .word    hblank_isr
<br/>
<br/>
<br/>
.L_TIMER_0_ISR:
<br/>
    .word    timer_0_isr
<br/>
<br/>
<br/>
.L_KEYPAD_ISR:
<br/>
    .word    keypad_isr
<br/>
<br/>
<br/>
.L_VBLANK_ISR:
<br/>
    .word    vblank_isr
<br/>
<br/>
<br/>
.Lfe1:
<br/>
    .size    MainInterruptServiceRoutine,.Lfe1-MainInterruptServiceRoutine
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27442 - col - Wed Oct 13, 2004 2:39 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ save contents of SPSR_irq;  if a nested interrupt occurs, it will overwrite the register
<br/>
    mrs     r6, spsr              @ r6 = saved_spsr_irq = SPSR_irq 
<br/>
</td> </tr></table><span class="postbody">
<br/>
what happens to the 'saved' SPSR_irq in r6 if a nested interrupt occurs ?
<br/>
<br/>
<br/>
<br/>
col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27448 - abilyk - Wed Oct 13, 2004 3:32 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>col wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
what happens to the 'saved' SPSR_irq in r6 if a nested interrupt occurs ?</td> </tr></table><span class="postbody">
<br/>
<br/>
When a nested interrupt occurs, the current interrupt-handling process is put on hold and the whole interrupt procedure starts again for the new interrupt, starting with saving the PC to LR.  r6 is not accessed until the process reaches my interrupt handler.  The first instruction pushes r6 and other registers to the stack, and shortly afterwards r6 is overwritten (by the new interrupt's saved SPSR_irq).  But after this new interrupt is processed, and right before my interrupt handler returns to the caller, the previous contents of r6 and other registers are restored by being popped from the stack.  After a few instructions from the BIOS interrupt handler, none of which touch r6, control returns to our initial interrupt-handling process with the correct contents of r6 in place.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28664 - DekuTree64 - Thu Nov 04, 2004 4:46 am</h4>
    <div class="postbody"><span class="postbody">Hi Andrew, 
<br/>
<br/>
I was doing some testing on this idea, and I think I ran across a problem. When you have a meduim/low priority interrupt, enable interrupts, and then mov lr, pc to branch to the handler, then at any time another interrupt could occurr, overwriting LR and leaving that handler to return to the wrong function. As long as the handler saves LR right away, there would only be a few cycle window, but it certainly can happen.
<br/>
<br/>
I've only come up with two possible solutions so far. One would be to use a different register for the return address in all your interrupt handlers (but then you'd have to do them all in assembly, and never use lr for anything), and the other is to switch back to system mode and save the system SPSR/LR as well before reenabling interrupts in IME. Switching to system mode seems to work, but I haven't gotten it to run 100% reliably yet, so I may have overlooked some other case as well.
<br/>
What do you think, any other good solutions?<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28679 - abilyk - Thu Nov 04, 2004 6:49 am</h4>
    <div class="postbody"><span class="postbody">Deku, you're right.  Going through all the steps I have listed above, there is potential for error if a nested interrupt occurs at that precise moment.  However, if this is actually the case, couldn't the same issue occur when an initial interrupt is triggered?  In user mode, you branch from function A to function B, but before you can push LR onto the stack, an interrupt occurs, and you would run into the problem you just described.
<br/>
<br/>
Instead, I think that LR will be actually be preserved in both these instances.  Upon some more research, I believe that the steps in my "Performed immediately when a CPU IRQ exception occurs" and "BIOS interrupt handler (again)" sections are incomplete, or perhaps out-of-order.  I'll try to correct this within the next day or two, so we can get to the bottom of the issue, one way or another.
<br/>
<br/>
Thanks for bringing this to my attention.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28681 - DekuTree64 - Thu Nov 04, 2004 8:28 am</h4>
    <div class="postbody"><span class="postbody">Yes, the LR_IRQ register is there to prevent that very problem. Normally the system mode LR is used, so when the initial interrupt occurrs, it gets bank-swapped wth LR_IRQ before the old PC is saved. 
<br/>
The problem is when the interrupt occurrs while you're in IRQ mode already. No state switch happens so the 'current' LR_IRQ gets overwritten first thing before branching to the IRQ exception vector. 
<br/>
<br/>
After a little more thought, it does make sense that you should never allow an interrupt to happen while in IRQ mode. The hardware just wasn't designed for it. 
<br/>
The only restriction that switching to system mode puts on the rest of your program is that the stack pointer always has to be valid, but unless you go doing crazy assembly stuff using it as a general register, that should always be the case. 
<br/>
<br/>
I'll have another go at it tomorrow morning. I think my real problem lies elsewhere, but at least that little bug is caught before it caused any trouble.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30534 - abilyk - Wed Dec 01, 2004 10:17 pm</h4>
    <div class="postbody"><span class="postbody">I haven't had much time at all lately to devote to this problem, but I'm about to get back to it and have been thinking about some potential solutions.  The simplest idea I've had, though it seems like a hack, is to avoid using LR altogether when calling each specific ISR.  Instead of saving the PC to LR, I could save it to r8, which I'm not using and is guaranteed not to be overwritten.  When returning from each specific ISR, I'd have to pop the return address from r8 instead of LR.  Since GCC wouldn't know to do this, I'd have to write each specific ISR in assembly (which is probably in my best interest anyway) or at least modify the compiled C code.  See any holes in this approach?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30559 - DekuTree64 - Thu Dec 02, 2004 5:14 am</h4>
    <div class="postbody"><span class="postbody">Yes, I believe that will be 100% reliable, just forces you to use assembly. But while you're already doing a non-standard return sequence, you could make it even simpler and just have your handler functions branch directly to the return location in the main interrupt handler, rather than storing the address in r8 or any other register, since it will always be the same anyway. Only a couple cycles difference to mov r8, pc and then store/load it though.
<br/>
<br/>
Switching to system mode does indeed work too. The procedure is as follows:
<br/>
<br/>
Disable interrupts in IME
<br/>
Load SPSR and save it somewhere
<br/>
Load CPSR and save it somewhere
<br/>
Set mode in your CPSR copy to SYS (0x1f), and clear the IRQ/FIQ disable bits (FIQ isn't really necessary, but is normally enabled)
<br/>
Move to CSPR
<br/>
Enable interrupts in IME
<br/>
<br/>
Call handler, do anything you want
<br/>
<br/>
Disable interrupts in IME
<br/>
Load your saved copy of the original CPSR and SPSR
<br/>
Move those two back into current CPSR/SPSR
<br/>
Enable interrupts in IME
<br/>
Return to BIOS
<br/>
<br/>
Either way has its disadvantages, but personally I would use the system mode switch, because it doesn't force you into writing non-standard assembly code.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30561 - abilyk - Thu Dec 02, 2004 5:37 am</h4>
    <div class="postbody"><span class="postbody">Ha.  This "new solution" I thought I stumbled upon, you suggested it yourself almost a month ago when you first found the problem.  It's been so long that I had completely forgotten about it and thought it up again myself.  I probably will do the system mode switch, as I tend to be a perfectionist and having those non-standard returns just... bothers me.  Thanks for the sequence of events there, that'll help.  Once I get it completely nailed down I'll compile all this ISR info into a doc and send it off to Simon -- it's still on the to-do list.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
