<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Multiplayer Packet Methods [Fully Explained] - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Multiplayer Packet Methods [Fully Explained]</h2>
<div id="posts">
<div class="post">
    <h4>#28741 - Krakken - Fri Nov 05, 2004 7:08 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I'm making a multiplayer game. I've real lots and lots on serial communication over time and am working on a packeting system for multiplayer transfers.
<br/>
<br/>
So far, i've worked out a system. I'll explain it in a second and I just would like some feedback on optimising or improving the system; or even if it's any good for that matter.
<br/>
<br/>
<span style="color: darkblue">
<br/>
<span style="font-weight: bold">System Overview</span>
<br/>
The system works on a set of packets to send data. Each packet can contain pretty much anything. It implements pretty reliable transfer but can only do one byte per transfer. I intend on syncing transfers to frames so 60 transfers can be made per second - therefore a total of 60 bytes from each person.
<br/>
<br/>
<span style="font-weight: bold">How It Works</span>
<br/>
It works by sending a header followed by a checksum and then the data with information attached to it. If there is a problem at any point the master will cancel the packet and re-transfer all the data.
<br/>
<br/>
<span style="font-weight: bold">A List of Features Needed For it to Work</span>
<br/>
<br/>
<span style="font-style: italic">Transfer Type</span>
<br/>
This indicates the type of transfer:
<br/>
 - 00: Header
<br/>
 - 01: CheckSum
<br/>
 - 02: Normal Data
<br/>
 - 03: Error/Resend Request
<br/>
<br/>
<span style="font-style: italic">Packet ID</span>
<br/>
The ID of the packet so that the right data can be resent on error. Also, so the data is reconstructed into the correct place. Every struct/whatever has it's own packet ID.
<br/>
<br/>
<span style="font-style: italic">Transfer Bytes</span>
<br/>
The amount of bytes that need transferring for the particular packet.
<br/>
<br/>
<span style="font-style: italic">CheckSum</span>
<br/>
To verify data.
<br/>
<br/>
<span style="font-style: italic">Data</span>
<br/>
The actual data to transfer.
<br/>
<br/>
<span style="font-weight: bold">The System Itself</span>
<br/>
The actual system works as follows.
<br/>
<br/>
<span style="font-style: italic">The Packet Header</span>
<br/>
The header is a 16-bit short value which is layed out like follows:
<br/>
</span><span style="color: darkred">
<br/>
F E D C B A 9 8 7 6 5 4 3 2 1 0</span>
<br/>
<span style="color: green">T T</span> <span style="color: orange">P P P P P P</span> <span style="color: magenta">B B B B B B B B</span>
<br/>
<span style="color: darkblue">
<br/>
T: Packet Type (2 bits) = <span style="font-weight: bold">00</span> (see above for explanation)
<br/>
P: Packet ID (6 bits)
<br/>
B: Bytes to Transfer (8 bits)
<br/>
<br/>
<span style="font-style: italic">The CheckSum</span>
<br/>
Following the header, all units send out a checksum for their data structure. The format is as follows:
<br/>
</span><span style="color: darkred">
<br/>
F E D C B A 9 8 7 6 5 4 3 2 1 0</span>
<br/>
<span style="color: green">T T</span> <span style="color: cyan">C C C C C C C C C C C C C C</span>
<br/>
<span style="color: darkblue">
<br/>
T: Packet Type (2 bits) = <span style="font-weight: bold">01</span> (see above for explanation)
<br/>
C: CheckSum (14 bits)
<br/>
<br/>
<span style="font-style: italic">The Data</span>
<br/>
The data is immediately sent after the CheckSum. It is contually sent until it reaches the specified size from the header. The format is as follows.
<br/>
</span><span style="color: darkred">
<br/>
F E D C B A 9 8 7 6 5 4 3 2 1 0</span>
<br/>
<span style="color: green">T T</span> <span style="color: orange">P P P P P P</span> <span style="color: black">D D D D D D D D</span>
<br/>
<span style="color: darkblue">
<br/>
T: Packet Type (2 bits) = <span style="font-weight: bold">02</span> (see above for explanation)
<br/>
P: Packet ID (6 bits)
<br/>
D: Data (8 bits)
<br/>
<br/>
<span style="font-style: italic">The Error</span>
<br/>
When an error occures, the following is sent to the master.
<br/>
</span><span style="color: darkred">
<br/>
F E D C B A 9 8 7 6 5 4 3 2 1 0</span>
<br/>
<span style="color: green">T T</span> <span style="color: orange">P P P P P P</span> <span style="color: darkred">X X X X X X X X</span>
<br/>
<span style="color: darkblue">
<br/>
T: Packet Type (2 bits) = <span style="font-weight: bold">03</span> (see above for explanation)
<br/>
P: Packet ID (6 bits)
<br/>
X: N/A (8 bits)
<br/>
<br/>
<span style="font-weight: bold">The Communication Method</span>
<br/>
Only the master machine constructs headers it informs all slave units to create a CheckSum from "Packet ID" data of size "Bytes to Transfer". All units then send back their CheckSum to each other and the transfer begins.
<br/>
<br/>
When data is recieved, it is reconstructed in sequence into temporary storage. Then it is tested against the checksum and if there is a match the data is copied into the appropriate "Packet ID" structure for that player. If not, it returns an error message to the master.
<br/>
<br/>
If the master recieves an error command, it will restart the transfer.
<br/>
</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28811 - Miked0801 - Sat Nov 06, 2004 8:48 pm</h4>
    <div class="postbody"><span class="postbody">You're missing a couple of very important steps.
<br/>
<br/>
1. How do the slaves/master know when a transfer has been successful?  If they just go when they've received a valid data packet, it doesn't give the master time to send a message if another unit sent bad data and you are out of sync.
<br/>
<br/>
2. Look at eack step and ask yourself what happens if data is corrupted at this step and how does the system recover.  What if packet header is missed, then you've lost a bunch of time as crap is sent to all slaves until a checksum occurs - if you're sending 64 byte packets, that's over 32 bad transfers and you've jssut dropped a frame.  Same for other steps.
<br/>
<br/>
3. You're going to need to sync to gameloop not to vsync else chaos will ensue (or you'll need a whole bunch of if code to handle timing issues that will popup)
<br/>
<br/>
4.  There is no reason at all to keep sending packet type and ID each frame.  You're halving your transfer speed for no good reason.  Send it once in the header and be done with it.
<br/>
<br/>
5.  Transfer speed is going to be really, really slow!  You can send roughly 40 bytes in a frame - less with heavy interrupts (like hblanks, vblanks, and music.)  If another interrupt takes your SIO out, you have the chance of dropping a packet and therefore a frame.  Also, keep in mind all the CPU overhead that all these interrupts firing off cost you.  I've found that it can eat upwards of 15% of your CPU time if you let it get greedy.
<br/>
<br/>
That's it for now.  Good luck on getting it up and running! (not sarcastically)
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28830 - Krakken - Sun Nov 07, 2004 8:05 am</h4>
    <div class="postbody"><span class="postbody">Hi Miked,
<br/>
<br/>
Thanks for your suggestions, I was hoping I would get a reply from you.
<br/>
<br/>
I have taken what you said into consideration and have re-worked the system a little so that it should work properly now.
<br/>
<br/>
-----
<br/>
<br/>
1: Data is now transferred 16-bits at a time.
<br/>
2: I have completely removed the type bit, I soon realised that it was unneccary if I just make the units remember what state they are in rather than having to be told.
<br/>
3: I have incorperated a success faliure system. 0xF0F0 is a success and anything else is seen as a faliure.
<br/>
<br/>
-----
<br/>
<br/>
The format now looks like this:
<br/>
<br/>
Header: 8-bits PacketID, 8-bits Bytes to Transfer
<br/>
CheckSum: 16-bits
<br/>
Data: 16-bits
<br/>
Verification: 16-bits (0xF0F0 = Success, Anything Else = Faliure)
<br/>
<br/>
-----
<br/>
<br/>
I have made a flowchart to show the new system (it doesn't incorperate the point I made below). It should give you a better idea rather than trying to visualise it from words.
<br/>
<br/>
<a href="http://www.users.on.net/~krakken/GBA/MultiPlayerFlowchart.png">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
-----
<br/>
<br/>
One point that stumped me was how I should sync to my gameloop. How exactly do you mean?
<br/>
<br/>
Also, i've just thought. I think it would be a good idea to echo the header back to the master after it is sent and before the checksumas verification.
<br/>
<br/>
Thanks again,
<br/>
Krakken.
<br/>
<br/>
PS: This is the 3rd time I have written this... Things kept messing up before like me accidentally closing the window and then following a link before posting it. :(</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
