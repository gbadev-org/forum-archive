<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>XOR crypto? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > XOR crypto?</h2>
<div id="posts">
<div class="post">
    <h4>#33819 - LOst? - Sun Jan 09, 2005 5:58 pm</h4>
    <div class="postbody"><span class="postbody">A lot of people talk about XOR encryption in the DS forum.
<br/>
<br/>
I wonder how to code XOR enctyption for my hi-score data (so that no one can edit it with a hexeditor).
<br/>
How does it work?
<br/>
An idea of mine: byte ^= magic_number?
<br/>
<br/>
C++ explanation would be great. I hope it is simple to code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33820 - Soccr743 - Sun Jan 09, 2005 6:10 pm</h4>
    <div class="postbody"><span class="postbody">XOR encryption is definitely not the best way to go since it can be easily broken compared to other forms.
<br/>
<br/>
You have a key of a certain length that you use to xor byte by byte against your data. Then you get the encrypted data from that output.
<br/>
<br/>
So a quick mockup would be:
<br/>
<br/>
char key [8] = "aIm0z9c2";
<br/>
char data [18] = "Hello how are you?";
<br/>
char xor_data [18];
<br/>
int data_place = 0;
<br/>
int key_place = 0;
<br/>
while(data_place++ &lt; sizeof(data)){
<br/>
     xor_data[data_place] = data[data_place] ^ key[key_place];
<br/>
     key_place++;
<br/>
     key_place = (key_place &lt; sizeof(key)) ? key_place : 0;
<br/>
}
<br/>
<br/>
I think that would be what you are looking for. But remember that this isnt the most secure method at all...
<br/>
<br/>
-----Soccr743-----<br/>_________________<br/><a class="postlink" href="http://www.cubedstudios.com/" target="_blank">http://www.cubedstudios.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33821 - LOst? - Sun Jan 09, 2005 6:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I think that would be what you are looking for. But remember that this isnt the most secure method at all...
<br/>
<br/>
-----Soccr743-----</td> </tr></table><span class="postbody">
<br/>
<br/>
Thank you for the help! Yea I know it isn't thje safest form, but it is safer than plane ascii :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33822 - poslundc - Sun Jan 09, 2005 6:21 pm</h4>
    <div class="postbody"><span class="postbody">For simple storing of something like high score data, if all you want to do is make it tamper-resistant, then XOR-encryption is probably plenty. (More than most games bother with, anyway.)
<br/>
<br/>
The importance of XOR for encryption is that you can encrypt a value by XORing it against a magic number, and then XOR it against that same magic number to obtain the original value. In other words,
<br/>
<br/>
C = A ^ B to encrypt, and then
<br/>
A = C ^ B to decrypt.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33823 - LOst? - Sun Jan 09, 2005 6:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">For simple storing of something like high score data, if all you want to do is make it tamper-resistant, then XOR-encryption is probably plenty. (More than most games bother with, anyway.)
<br/>
<br/>
The importance of XOR for encryption is that you can encrypt a value by XORing it against a magic number, and then XOR it against that same magic number to obtain the original value. In other words,
<br/>
<br/>
C = A ^ B to encrypt, and then
<br/>
A = C ^ B to decrypt.
<br/>
<br/>
Dan.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yea, that's what I thought. Now Soccr743 also reminded me that you can use more than just one byte as a magic number.
<br/>
<br/>
Interesting to see XOR being useful for something else other than turning a flag on and off.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33833 - Soccr743 - Sun Jan 09, 2005 8:06 pm</h4>
    <div class="postbody"><span class="postbody">Yea definitely use more then one of what you call "a magic number" if you are going to use XOR to encrypt bytes of data.
<br/>
<br/>
Because if you use only one then you have a message Hello that goes into something like y9jj4 (hypothetically) because both l's xored with the same byte become the same thing. If you have a key of a longer length, it will not repeat the same letters as often.
<br/>
<br/>
-----Soccr743-----<br/>_________________<br/><a class="postlink" href="http://www.cubedstudios.com/" target="_blank">http://www.cubedstudios.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33840 - LOst? - Sun Jan 09, 2005 9:13 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Soccr743 wrote:</b></span></td> </tr> <tr> <td class="quote">Yea definitely use more then one of what you call "a magic number" if you are going to use XOR to encrypt bytes of data.
<br/>
<br/>
Because if you use only one then you have a message Hello that goes into something like y9jj4 (hypothetically) because both l's xored with the same byte become the same thing. If you have a key of a longer length, it will not repeat the same letters as often.
<br/>
<br/>
-----Soccr743-----</td> </tr></table><span class="postbody">
<br/>
<br/>
Yea. I mostly want to hide repeated letters and numbers so thank you for sharing your code example and your ideas!
<br/>
<br/>
I will probably XOR the hi-score, and then compress it with LZSS &gt;=D
<br/>
It will not compress any good, but it with make the crypted data harder to mess with.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33851 - bertsnks - Sun Jan 09, 2005 11:42 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Soccr743 wrote:</b></span></td> </tr> <tr> <td class="quote">Yea definitely use more then one of what you call "a magic number" if you are going to use XOR to encrypt bytes of data.
<br/>
<br/>
Because if you use only one then you have a message Hello that goes into something like y9jj4 (hypothetically) because both l's xored with the same byte become the same thing. If you have a key of a longer length, it will not repeat the same letters as often.
<br/>
<br/>
-----Soccr743-----</td> </tr></table><span class="postbody">
<br/>
<br/>
Yea. I mostly want to hide repeated letters and numbers so thank you for sharing your code example and your ideas!
<br/>
<br/>
I will probably XOR the hi-score, and then compress it with LZSS &gt;=D
<br/>
It will not compress any good, but it with make the crypted data harder to mess with.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Not quite. A high score number, split into bytes will mostly have different bytes. LZSS cannot compress different bytes, and thus your highscore would show up uncompressed in a hex editor.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33872 - LOst? - Mon Jan 10, 2005 5:29 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>bertsnks wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Soccr743 wrote:</b></span></td> </tr> <tr> <td class="quote">Yea definitely use more then one of what you call "a magic number" if you are going to use XOR to encrypt bytes of data.
<br/>
<br/>
Because if you use only one then you have a message Hello that goes into something like y9jj4 (hypothetically) because both l's xored with the same byte become the same thing. If you have a key of a longer length, it will not repeat the same letters as often.
<br/>
<br/>
-----Soccr743-----</td> </tr></table><span class="postbody">
<br/>
<br/>
Yea. I mostly want to hide repeated letters and numbers so thank you for sharing your code example and your ideas!
<br/>
<br/>
I will probably XOR the hi-score, and then compress it with LZSS &gt;=D
<br/>
It will not compress any good, but it with make the crypted data harder to mess with.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Not quite. A high score number, split into bytes will mostly have different bytes. LZSS cannot compress different bytes, and thus your highscore would show up uncompressed in a hex editor.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Yea I just saw that x.x;;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33874 - tepples - Mon Jan 10, 2005 5:37 am</h4>
    <div class="postbody"><span class="postbody">If you want to compress and encrypt, it's usually wise to compress first, as encryption covers up the correlations that compression relies on. Besides, why would you need to compress a high score table?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33875 - LOst? - Mon Jan 10, 2005 5:58 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">If you want to compress and encrypt, it's usually wise to compress first, as encryption covers up the correlations that compression relies on. Besides, why would you need to compress a high score table?</td> </tr></table><span class="postbody">
<br/>
<br/>
It was before I knew XOR crypto. I thought it would be a way to hide the score by compressing it with someting as high as LZSS. But when I tried it, it just added bytes more than compressing it, and the names and score weren't hidden.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33891 - denopqrihg - Mon Jan 10, 2005 9:14 pm</h4>
    <div class="postbody"><span class="postbody">Even the save in Pokemon R/S uses only XOR encryption (and not too good :-)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33893 - sgeos - Mon Jan 10, 2005 9:36 pm</h4>
    <div class="postbody"><span class="postbody">You could seed an RNG to create a weak one time key:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void xor_encrypt(char *p_data, int p_size, unsigned long p_seed)
<br/>
{
<br/>
   unsigned long   old_seed;
<br/>
   unsigned char   xor_mask;
<br/>
   int      i;
<br/>
<br/>
   /* Save current RNG state
<br/>
    */
<br/>
   old_seed = get_rng_seed();
<br/>
<br/>
   /* Seed one time key
<br/>
    */
<br/>
   seed_rng(p_seed);
<br/>
<br/>
   /* Encrypt data
<br/>
    */
<br/>
   for (i = 0; i &lt; p_size; i++) {
<br/>
      xor_mask = (unsigned char) rng_range(0, 255);
<br/>
      data[i] ^= xor_mask;
<br/>
   }
<br/>
<br/>
   /* Restore old RNG state
<br/>
    */
<br/>
   seed_rng(old_seed);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Call it once to encrypt, call it again to decrypt.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33927 - LOst? - Tue Jan 11, 2005 5:18 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">You could seed an RNG to create a weak one time key:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void xor_encrypt(char *p_data, int p_size, unsigned long p_seed)
<br/>
{
<br/>
   unsigned long   old_seed;
<br/>
   unsigned char   xor_mask;
<br/>
   int      i;
<br/>
<br/>
   /* Save current RNG state
<br/>
    */
<br/>
   old_seed = get_rng_seed();
<br/>
<br/>
   /* Seed one time key
<br/>
    */
<br/>
   seed_rng(p_seed);
<br/>
<br/>
   /* Encrypt data
<br/>
    */
<br/>
   for (i = 0; i &lt; p_size; i++) {
<br/>
      xor_mask = (unsigned char) rng_range(0, 255);
<br/>
      data[i] ^= xor_mask;
<br/>
   }
<br/>
<br/>
   /* Restore old RNG state
<br/>
    */
<br/>
   seed_rng(old_seed);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Call it once to encrypt, call it again to decrypt.
<br/>
<br/>
-Brendan</span></td> </tr></table><span class="postbody">
<br/>
<br/>
One problem. I don't know what a RNG is.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33930 - poslundc - Tue Jan 11, 2005 5:30 am</h4>
    <div class="postbody"><span class="postbody">RNG == <a class="postlink" href="http://www.google.com/search?q=random+number+generator" target="_blank">Random Number Generator</a>
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33938 - phantom-inker - Tue Jan 11, 2005 9:38 am</h4>
    <div class="postbody"><span class="postbody">Rather than using an external RNG, I tend to prefer just hacking together a simple linear-congruential-feedback generator.  The code's insanely simple, and compiles to very efficient assembly, even if it's not <span style="font-style: italic">super</span>-random.  It certainly saves having to have an external set of RNG functions.
<br/>
<br/>
Here's how to convert the code above, using the classic 69069 multiplier, and 1234567 (any interesting nonzero number will do) for <span style="font-style: italic">c</span>:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void xor_encrypt(char *data, int size, unsigned long seed)
<br/>
{
<br/>
   int i;
<br/>
<br/>
   /* Make the seed more stable, so that zero seeds don't produce bad results.
<br/>
      Could use an XOR or add here instead if speed was vital. */
<br/>
   seed = seed * 69069 + 1234567;
<br/>
<br/>
   /* Encrypt data */
<br/>
   for (i = 0; i &lt; size; i++) {
<br/>
      seed = seed * 69069 + 1234567;
<br/>
      data[i] ^= (char)((seed &gt;&gt; 24) &amp; 0xFF);
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
In this example, <span style="font-style: italic">seed</span> will cycle with 2^32 period.  Not too shabby for a one-line PRNG.  The lack of function calls alone will usually make this many times faster than the other version above.  Note that we shift down the high bits of <span style="font-style: italic">seed</span> when we XOR, because they cycle with longer periods than the low bits.
<br/>
<br/>
If 69069 doesn't make you feel good enough, you could try 1664525, which is known to be an even better multiplier for LCGs like this that have period 2^32.  (Note:  Don't just pick any old number for a multiplier; you're best off using one that's known to be good.  See Knuth 3.3.4 for more details, if you dare.)
<br/>
<br/>
You can speed this up and shrink it a little by switching to pointers, too.  Here's a version that's faster, smaller, <span style="font-style: italic">and</span> more random:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void xor_encrypt(char *data, int size, unsigned long seed)
<br/>
{
<br/>
   /* Make the seed more stable, so that zero seeds don't produce bad results. */
<br/>
   seed ^= 0xDEADBEEF;
<br/>
<br/>
   /* Encrypt data */
<br/>
   while (size--) {
<br/>
      seed = seed * 1664525 + 1234567;
<br/>
      *data++ ^= (char)((seed &gt;&gt; 24) &amp; 0xFF);
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Nice, huh?<br/>_________________<br/>Do you suppose if I put a signature here, anyone would read it?  No?  I didn't think so either.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33949 - poslundc - Tue Jan 11, 2005 2:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>phantom-inker wrote:</b></span></td> </tr> <tr> <td class="quote">Rather than using an external RNG, I tend to prefer just hacking together a simple linear-congruential-feedback generator.</td> </tr></table><span class="postbody">
<br/>
<br/>
LCG's aren't really an "alternative" to random-number generators; for all intents and purposes a good LCG <span style="font-style: italic">is</span> a random-number generator (pseudo-random, of course). In fact, the Unix rand() function is an LCG, I believe.
<br/>
<br/>
While I wouldn't want to use it for statistical applications, real-money gambling, or serious cryptography or anything, I am hard-pressed to think of a handheld console videogame where an LCG would be insufficient as a random-number generator, especially given the efficiency they provide.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33966 - Miked0801 - Tue Jan 11, 2005 7:29 pm</h4>
    <div class="postbody"><span class="postbody">It's suprising how these types of generators do fail though.  We used a very similiar routine on Heroes of M&amp;M - GBC (turn based strategy game) and were very suprised at how non-random it could become depending on timing.  Nothing like losing 5 fights in a row where you had a 75% chance (on paper) of winning.  We ended up generating a table of 256 entries, each 8-bit number occuring once, and prime number stepping through it.  Only 256 different combos I know, but it felt much better :)
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33969 - poslundc - Tue Jan 11, 2005 7:41 pm</h4>
    <div class="postbody"><span class="postbody">That's a good point that I left out, and especially in a turn-based game there are more opportunities to fall into a pattern than an action-based game.
<br/>
<br/>
LCGs are also heavily affected by the parameters used for them. I don't suppose you'd remember what you used back on M&amp;M, would you? I've been using <a class="postlink" href="http://random.mat.sbg.ac.at/~charly/server/node3.html#SECTION00036000000000000000" target="_blank">BCPL</a> and it's performed pretty well for me so far in practice (at least I never have noticed any suspicious patterns emerging), but it would be good to know if it's less reliable for turn-based apps.
<br/>
<br/>
Thanks,
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33975 - LOst? - Tue Jan 11, 2005 9:24 pm</h4>
    <div class="postbody"><span class="postbody">I don't even know what a seed is.
<br/>
And I don't know how you can make the XOR mask by a random number when you need the same number the next time (probably after a restart of the GBA) to encrypt the data.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33980 - phantom-inker - Tue Jan 11, 2005 10:42 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">I don't even know what a seed is.
<br/>
And I don't know how you can make the XOR mask by a random number when you need the same number the next time (probably after a restart of the GBA) to encrypt the data.</td> </tr></table><span class="postbody">
<br/>
A seed is just some number you pick for it to start with.  Zero will work.
<br/>
<br/>
To encrypt your data, call the function I gave above like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">xor_encrypt(my_data, size_of_my_data, 0);</td> </tr></table><span class="postbody">
<br/>
To decrypt your data, call the function like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">xor_encrypt(my_data, size_of_my_data, 0);</td> </tr></table><span class="postbody">
<br/>
Notice that it's the same to encrypt or decrypt...  distressingly symmetric, but good enough for simple information hiding. ;)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mike0801 wrote:</b></span></td> </tr> <tr> <td class="quote">We used a very similiar routine on Heroes of M&amp;M - GBC (turn based strategy game) and were very suprised at how non-random it could become depending on timing.</td> </tr></table><span class="postbody">
<br/>
Were you using the high bits of the seed, or the low ones?  The low bits have very poor behavior in an LCG, having relatively short periods.  The high bits, though, are usually pretty random, with very long periods (the top bit of the RNGs I gave above only cycles with period 2^32, for example).  I've had very little problems with just sampling off the top four bits of every iteration and using those --- of course, that requires a lot more multiplies, and does shorten the overall period to 2^29.  But that's good enough for most "predictable" RNGs.<br/>_________________<br/>Do you suppose if I put a signature here, anyone would read it?  No?  I didn't think so either.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34021 - Miked0801 - Wed Jan 12, 2005 8:02 pm</h4>
    <div class="postbody"><span class="postbody">Lol again - GBC == software multiply and 2Mhz CPU.  Our random calls tended to be pretty simple.  I'm looking at the original Z80 code right now and, it burnzzzes!  It burnnnzzzes!  Stop the pain!  Argh!  Ok, now that I remember how to read Z80....
<br/>
<br/>
We stepped through the table sequentially and did a software mod to get our number.
<br/>
<br/>
We tried taking the seed, indexing into the table, take that value / 8, xor the value there to the index and add the system clock to that.  Then rotate the whole seed weird.  Dunno where we got that.  I'd post the Z80, but no one would be able to read it.
<br/>
<br/>
We also tried the Twister? algorithm at one point, but again for the GBC, the simple table/mod function worked best.
<br/>
<br/>
Wow that was fun :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34073 - LOst? - Thu Jan 13, 2005 5:33 am</h4>
    <div class="postbody"><span class="postbody">Z80 will be the very last processor I will look into. I hate it. How can you produce a game using it anyway? I don't like 8-bit games to begin with. I have own a Sega Master System so I know the result of Z80.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34075 - tepples - Thu Jan 13, 2005 7:08 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Z80 will be the very last processor I will look into. I hate it. How can you produce a game using it anyway?</td> </tr></table><span class="postbody">
<br/>
First of all, you need an F2A and a GB Bridge.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34091 - poslundc - Thu Jan 13, 2005 2:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Z80 will be the very last processor I will look into. I hate it. How can you produce a game using it anyway? I don't like 8-bit games to begin with. I have own a Sega Master System so I know the result of Z80.</td> </tr></table><span class="postbody">
<br/>
<br/>
God, it makes me feel old that I find this quote so upsetting. Get off your high horse, boy; I've done some Z80 programming in the past and I'm frankly amazed by what has been done with it on platforms like the GB. Your predecessors have spun straw into gold, and paved the way for the technology you take for granted.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34127 - Miked0801 - Thu Jan 13, 2005 10:28 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Z80 will be the very last processor I will look into. I hate it. How can you produce a game using it anyway? I don't like 8-bit games to begin with. I have own a Sega Master System so I know the result of Z80.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
You're making me feel old as well.  The Z80 in many ways is superior to the 8086/8088 intruction set.  More registers, less arbitrary reliance on certain registers needed for certain commands, did I mention more registers (shadow).  Alas, the GB had a bastardized Casio chip in it emulating a Z80 missing 60% of the register space and 50% of the cool ops.  Grumble.
<br/>
<br/>
And the Sega master system "results" have more to do with the word Sega than Z80...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34139 - phantom-inker - Fri Jan 14, 2005 4:07 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Lol again - GBC == software multiply and 2Mhz CPU.</td> </tr></table><span class="postbody">
<br/>
True.  I forgot the architecture.  But, still, coding up a simple LCG for a low modulus (16 bits?) wouldn't be too hard, and it'd be easy to perform an exhaustive search for a "good" multiplier for a small modulus (based on the spectral test).  Once you've found your multiplier, coding up a good 8-bit assembly implementation of a fixued multiplication is probably only about 100-ish instructions (least, that's what I'd expect on a 6502; it's probably a similar order on a Z80).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Z80 will be the very last processor I will look into. I hate it. How can you produce a game using it anyway?</td> </tr></table><span class="postbody">
<br/>
You'd be surprised what you can do on an 8-bit processor.  I cut my teeth on a 6502 at 1 MHz twenty years ago (yay for the Apple ][!).  You can learn a lot from simpler computers if you take a little time to study them.<br/>_________________<br/>Do you suppose if I put a signature here, anyone would read it?  No?  I didn't think so either.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34141 - LOst? - Fri Jan 14, 2005 4:27 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Z80 will be the very last processor I will look into. I hate it. How can you produce a game using it anyway? I don't like 8-bit games to begin with. I have own a Sega Master System so I know the result of Z80.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
You're making me feel old as well.  The Z80 in many ways is superior to the 8086/8088 intruction set.  More registers, less arbitrary reliance on certain registers needed for certain commands, did I mention more registers (shadow).  Alas, the GB had a bastardized Casio chip in it emulating a Z80 missing 60% of the register space and 50% of the cool ops.  Grumble.
<br/>
<br/>
And the Sega master system "results" have more to do with the word Sega than Z80...</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Wow, I just made a huge mistake. I had no idea Gameboy used the Z80 unil this very moment. Now I see why I shouldn't have said that on a Gameboy messageboard.
<br/>
Of course Z80 is okay. But Gameboy sucks man *shot*
<br/>
<br/>
Okay enough of the jokes. I'm not a very big fan of 8 bit or the old Gameboy. Some of you have worked a lot with it so of course I made you upset. I'm 16 bit all the way. I even see GBA as 16 bit. As long as you can jump 32-bit/24-bit. I kinda hate 286 for 16 bit segment/offset jumps.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
