<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Help making up multiplication with bitwise shifts! - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Help making up multiplication with bitwise shifts!</h2>
<div id="posts">
<div class="post">
    <h4>#63441 - LOst? - Tue Dec 13, 2005 4:57 am</h4>
    <div class="postbody"><span class="postbody">Okay, last time I wanted help, it was all about fixed point math and divide. People helped me to see how to construct fixed point fractions.
<br/>
<br/>
Now I have run into another problem. I need to construct bitshifts to replace multiplication.
<br/>
<br/>
Here are two examples...
<br/>
<br/>
Using slow multiplication:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
1 * 12 = 12
<br/>
4 * 12 = 48
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And using bitshifts and additions instead:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
((1 &lt;&lt; 2) + ((1 &lt;&lt; 2) &lt;&lt; 1)) = 12
<br/>
((4 &lt;&lt; 2) + ((4 &lt;&lt; 2) &lt;&lt; 1)) = 48
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Using slow multiplication:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
1 * 1152 = 1152
<br/>
4 * 1152 = 4608
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And using bitshifts and additions instead:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
((1 &lt;&lt; 7) + ((1 &lt;&lt; 7) &lt;&lt; 3)) = 1152
<br/>
((4 &lt;&lt; 7) + ((4 &lt;&lt; 7) &lt;&lt; 3)) = 4608
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Now, is there any technique I should use to come up with these bitwise/addition formulas?
<br/>
<br/>
I want to be able to do this in bitwise/addition formula:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
1 * 14 = 14
<br/>
4 * 14 = 56
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
How do I do? How must I think?<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63444 - caitsith2 - Tue Dec 13, 2005 5:19 am</h4>
    <div class="postbody"><span class="postbody">I would assume the slow way is something like
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int multiply(int operand1, int operand2)
<br/>
{
<br/>
    int i,j=0;
<br/>
    for(i=0;i&lt;operand1;i++)
<br/>
        j+=operand2;
<br/>
    return j;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
As such, The faster multiplication, using shift + adds,  follows something like this.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int multiply(int operand1, int operand2)
<br/>
{
<br/>
    int i=operand1, j=operand2,k=0;
<br/>
<br/>
    while(i&gt;0)
<br/>
    {
<br/>
         if(i&amp;1)
<br/>
         {
<br/>
              k+=j;
<br/>
              j&lt;&lt;=1;
<br/>
              i&gt;&gt;=1;
<br/>
         }
<br/>
    }
<br/>
<br/>
    return k;
<br/>
<br/>
    return j;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63445 - LOst? - Tue Dec 13, 2005 5:28 am</h4>
    <div class="postbody"><span class="postbody">No no! No while loops!
<br/>
<br/>
1 and 4 is the changing factor. The variable that is. The other factor is replaced with bitshifts and addition of the changing factor. You have two changing factors which I am not looking for.
<br/>
<br/>
<br/>
I can try myself by testing...
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// 1 * 14 = 14
<br/>
<br/>
a = 1;
<br/>
a = a &lt;&lt; 2; // 4
<br/>
b = a &lt;&lt; 1; // 8
<br/>
c = a &gt;&gt; 1; // 2
<br/>
result = a + b + c; // 4 + 8 + 2 = 14 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
But it took me time to come up with this! How can I come up with this easier? Is there a 14 / 2... 14 / 4... 14 / 8 test method of any kind?<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63457 - gladius - Tue Dec 13, 2005 8:28 am</h4>
    <div class="postbody"><span class="postbody">If this is targetting the gba or ds, multiplies are pretty darn quick.  Especially when the high 24 or 16 bits of one of the terms are the same (which they would be in your examples).
<br/>
<br/>
High 24 bits same = 1 cycle
<br/>
High 16 bits same  = 2 cycles
<br/>
High 8 bits same = 3 cycles
<br/>
Default = 4 cycles
<br/>
<br/>
mla always adds one cycle.
<br/>
<br/>
If you really feel the need to bust out the shifts, the easiest way to calculate the shifts in general is probably to write a very simple search program to do it for you.  Use some heuristics, while there may be a greedy method that works I can't prove an easy one to myself right now :).  In general it sounds like a class of problems known as dynamic programming, where you can solve a larger problem with stored information about a bunch of equivalent smaller versions of the problem.  There might be some smart way to solve it using the prime factorization of the multiplier as well.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63461 - Cearn - Tue Dec 13, 2005 10:16 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gladius wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
High 24 bits same = 1 cycle
<br/>
High 16 bits same  = 2 cycles
<br/>
High 8 bits same = 3 cycles
<br/>
Default = 4 cycles
<br/>
</td> </tr></table><span class="postbody">
<br/>
Sorry to be pedantic about this, but this is true for IWRAM, not in general. The proper timing is 1<span style="font-style: italic">S</span>+m<span style="font-style: italic">I</span> for MUL and 1<span style="font-style: italic">S</span>+(m+1)<span style="font-style: italic">I</span> for MLA. 1<span style="font-style: italic">S</span> is a sequential access and <span style="font-style: italic">I</span> an internal access. <span style="font-style: italic">I</span> always takes 1 cycle, but <span style="font-style: italic">S</span> is subject to waitstates and takes 1 cycle in IWRAM, 3 in EWRAM or ROM (ignoring waitstate settings for the moment). Thumb shifts/adds/subs are 1<span style="font-style: italic">S</span> as well, so in the slower sections a simple mul will often be faster. ARM/IWRAM changes things a little because the <span style="font-style: italic">S</span>/<span style="font-style: italic">I</span> ratio is different and you can combine add/sub with a shift, but it's still true that you shouldn't could muls out so fast.
<br/>
<br/>
The <span style="font-style: italic">m</span> is the number of significant bytes of the <span style="font-style: italic">second</span> argument in the assembly instruction. I don't know if GCC automatically transfers the one with the least amount of bits to the second arg.
<br/>
<br/>
<a class="postlink" href="http://nocash.emubase.de/gbatek.htm#arm7multiplyandmultiplyaccumulatemulmla" target="_blank">GBATek, multiply</a>. PBU Martin.
<br/>
<br/>
PS: 14 = 16-2, or (8-1)&lt;&lt;1. The key is the number of bit clusters.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63464 - LOst? - Tue Dec 13, 2005 10:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">14 = 16-2, or (8-1)&lt;&lt;1. The key is the number of bit clusters.</td> </tr></table><span class="postbody">
<br/>
I have a factor to multiply with. And the factor changes. Therefore there is only one way to move the bits in order to get the same result for any factor.
<br/>
<br/>
If you need to know what i am using this for, I am using this method for a jump table, and for data access, and for scroll offsets. And I have run out of cycles this time. I have no choice or else my Vblank will not work. So please help me!<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63470 - kusma - Tue Dec 13, 2005 12:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Sorry to be pedantic about this, but this is true for IWRAM, not in general. The proper timing is 1<span style="font-style: italic">S</span>+m<span style="font-style: italic">I</span> for MUL and 1<span style="font-style: italic">S</span>+(m+1)<span style="font-style: italic">I</span> for MLA. 1<span style="font-style: italic">S</span> is a sequential access and <span style="font-style: italic">I</span> an internal access. <span style="font-style: italic">I</span> always takes 1 cycle, but <span style="font-style: italic">S</span> is subject to waitstates and takes 1 cycle in IWRAM, 3 in EWRAM or ROM (ignoring waitstate settings for the moment). Thumb shifts/adds/subs are 1<span style="font-style: italic">S</span> as well, so in the slower sections a simple mul will often be faster. ARM/IWRAM changes things a little because the <span style="font-style: italic">S</span>/<span style="font-style: italic">I</span> ratio is different and you can combine add/sub with a shift, but it's still true that you shouldn't could muls out so fast.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
as long as you're doing the adds the sequential access goes for it too, so his point is perfectly valid.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63474 - Cearn - Tue Dec 13, 2005 1:43 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Sorry to be pedantic about this, but this is true for IWRAM, not in general. The proper timing is 1<span style="font-style: italic">S</span>+m<span style="font-style: italic">I</span> for MUL and 1<span style="font-style: italic">S</span>+(m+1)<span style="font-style: italic">I</span> for MLA. 1<span style="font-style: italic">S</span> is a sequential access and <span style="font-style: italic">I</span> an internal access. <span style="font-style: italic">I</span> always takes 1 cycle, but <span style="font-style: italic">S</span> is subject to waitstates and takes 1 cycle in IWRAM, 3 in EWRAM or ROM (ignoring waitstate settings for the moment). Thumb shifts/adds/subs are 1<span style="font-style: italic">S</span> as well, so in the slower sections a simple mul will often be faster. ARM/IWRAM changes things a little because the <span style="font-style: italic">S</span>/<span style="font-style: italic">I</span> ratio is different and you can combine add/sub with a shift, but it's still true that you shouldn't could muls out so fast.
<br/>
</td> </tr></table><span class="postbody">as long as you're doing the adds the sequential access goes for it too, so his point is perfectly valid.</span></td> </tr></table><span class="postbody">
<br/>
What I meant was that the break-even point between MUL and ADD/SUB+LSL depends on the section you're in. Take the worst case scenerio for a MUL: 1S+4I.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
        | mul | can be used for x other instructions
<br/>
ROM     |  7  | 7/3 ~ 2
<br/>
IWRAM   |  5  | 5/1 = 5
<br/>
</td> </tr></table><span class="postbody">
<br/>
In ROM, a MUL will be faster if you need more than 2 instructions to compensate, in IWRAM you're allowed up to 5. Mind you, this is for the <span style="font-style: italic">worst</span> case for MUL. Well, almost;:you still have to load multiplicants to the registers, but looking at the calculation alone, this should be right.
<br/>
<br/>
I fully agree that GBA/DS MULs can be quick, but there are nuances that should not be overlooked so easily.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lost? wrote:</b></span></td> </tr> <tr> <td class="quote">I have a factor to multiply with. And the factor changes. Therefore there is only one way to move the bits in order to get the same result for any factor. 
<br/>
<br/>
If you need to know what i am using this for, I am using this method for a jump table, and for data access, and for scroll offsets. And I have run out of cycles this time. I have no choice or else my Vblank will not work. So please help me!</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not sure I understand ... you're trying to replace multiplications with shifts when <span style="font-style: italic">both</span> arguments are variable? When one of them is constant, it's easy:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// y= x*12= x*(4-1)*4
<br/>
rsb y, x, x, lsl #2
<br/>
mov y, y, lsl #2
<br/>
<br/>
// y= x*14= x*(8-1)*2
<br/>
rsb y, x, x, lsl #3
<br/>
mov y, y, lsl #1
<br/>
<br/>
// y= x*1152= x*(8+1)*128
<br/>
add y, x, x, lsl #3
<br/>
mov y, y, lsl #7</td> </tr></table><span class="postbody">
<br/>
but when both are variable, that would be tricky. 
<br/>
<br/>
Just for the record, are you already in working in ARM asm and putting it in IWRAM? I'll probably get a "pfft, duh!" thrown at me, but I just want to make sure.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63502 - Miked0801 - Tue Dec 13, 2005 8:25 pm</h4>
    <div class="postbody"><span class="postbody">And just for the record, optimizing 1-3 cycles for a multiply call is silly in just about any case you can think of.  If you need this optimization, make sure that the terms are ordered such that you get savings that way.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63505 - gladius - Tue Dec 13, 2005 8:37 pm</h4>
    <div class="postbody"><span class="postbody">My post was made assuming iwram/arm (or cached inst on the ds).  You have to be careful with cycle analysis on paper.  It usually doesn't turn out the way one would expect.
<br/>
<br/>
In any case, I should have posted this advice instead: You should probably look at your algorithmic complexity before getting down to the cycle.  Unless you are doing on the order of a few hundred thousand of these multiplies a second, it probably doesn't make too much of a difference which method you use.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63531 - Touchstone - Wed Dec 14, 2005 1:36 am</h4>
    <div class="postbody"><span class="postbody">To answer your question, it's as easy as singeling out the bits that are set for the value that you want to multiply with.
<br/>
<br/>
For example: 1152 in binary is 10010000000
<br/>
<br/>
That means bit 10 and bit 7 is set (counting the least significant bit as bit 0), so you want to shift your variable up twice. First 10 bits and then 7 bits, then add those two shift results together.
<br/>
<br/>
But yeah, it's already been pointed out that this is probably not the thing you want to optimize firstly if you want to make your code quicker.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63559 - gladius - Wed Dec 14, 2005 7:32 am</h4>
    <div class="postbody"><span class="postbody">Touchstone: That method makes an excellent starting point, but it is not optimal.  Consider any term 2^x - 1, so all the bits will be set.  It's better to just do (a &lt;&lt; x) - a, as opposed to (a &lt;&lt; 0) + (a &lt;&lt; 1) + ... (a &lt;&lt; x - 1).  For example, multiplying by 255 could be done by a * 256 - a optimally, while the other method requires 8 shifts (8 bits set).
<br/>
<br/>
It's actually a pretty interesting algorithmic problem, although I'm sure some compiler genius came up with a great way to do it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63563 - DekuTree64 - Wed Dec 14, 2005 9:01 am</h4>
    <div class="postbody"><span class="postbody">Hmm, extending Touchstone's idea, use the (1&lt;&lt;x) - 1 pattern to get groups of bits at a time:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">a * 0111 0110 (118 decimal)
<br/>
<br/>
temp = (a &lt;&lt; 3) - a;rsb temp, a, a, lsl #3   ;(a * 0000 0111)
<br/>
temp += temp &lt;&lt; 4  ;add temp,temp,temp,lsl #4;(a * 0111 0111)
<br/>
a = temp - a       ;sub a, temp, a           ;(a * 0111 0110)</td> </tr></table><span class="postbody">
<br/>
Or better yet,
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">temp = a + (a &lt;&lt; 3);add temp, a, a, lsl #3   ;(a * 0000 1001)
<br/>
a = (a &lt;&lt; 7) - temp;rsb a, temp, a, lsl #7   ;(a * 0111 0110)</td> </tr></table><span class="postbody">
<br/>
Still no sure-fire algorithm, but better than straight trial-and-error.
<br/>
<br/>
I'll try a big one
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">a * 1010 0111 0110 1001 (42857 decimal)
<br/>
<br/>
add temp, a, a, lsl #2            (a * 0000 0000 0000 0101)
<br/>
add tmp2, temp, temp, lsl #3      (a * 0000 0000 0010 1101)
<br/>
add tmp2, tmp2, temp, lsl #10     (a * 0001 0100 0010 1101)
<br/>
add tmp2, tmp2, a, lsl #6         (a * 0001 0100 0110 1101)
<br/>
add tmp2, tmp2, a, lsl #7         (a * 0001 0100 1110 1101)
<br/>
add a, a, tmp2, lsl #3            (a * 1010 0111 0110 1001)</td> </tr></table><span class="postbody">
<br/>
Ouch :)<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63570 - gladius - Wed Dec 14, 2005 11:23 am</h4>
    <div class="postbody"><span class="postbody">DekuTree64: Yes, that's a quite efficient greedy method.  It breaks down when grouping doesn't work well though.  I finally broke down and wrote a (way too complex probably :P) searcher for this and it came up with some interesting results.
<br/>
<br/>
For example, 45 = 101101 in binary.  There is this quite elegant two instruction multiply:
<br/>
b = a + a &lt;&lt; 3
<br/>
a = b + b &lt;&lt; 4
<br/>
<br/>
Your 42857 example the best I could find was 6 steps (although different steps). 
<br/>
[edit: actually it found a 5 step path:
<br/>
42857 = 75753 - 257 &lt;&lt; 7
<br/>
75753 = 8417 + 8417 &lt;&lt; 3
<br/>
8417 = 8481 - 1 &lt;&lt; 6
<br/>
8481 = 257 + 257 &lt;&lt; 5
<br/>
257 = 1 + 1 &lt;&lt; 8
<br/>
]
<br/>
<br/>
An interesting one is 43690 (or 0xAAAA, 1010101010101010b).  It is solved in 4 steps with:
<br/>
a = a + a &lt;&lt; 8
<br/>
b = a &lt;&lt; 7;
<br/>
a = b + a &lt;&lt; 5;
<br/>
result = a + a &gt;&gt; 4
<br/>
<br/>
The (absolutely a complete mess code):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;vector&gt;
<br/>
#include &lt;queue&gt;
<br/>
#include &lt;map&gt;
<br/>
#include &lt;cstdio&gt;
<br/>
#include &lt;cstdlib&gt;
<br/>
using namespace std;
<br/>
<br/>
struct node {
<br/>
    node() {}
<br/>
    node(int _num,int _size,int _prev,int _op) : number(_num), size(_size), prev(_prev),op(_op) { }
<br/>
    int number, size, prev, op;
<br/>
};
<br/>
bool operator&lt;(const node &amp;n1, const node &amp;n2) {
<br/>
    if (n1.size != n2.size) return n1.size &gt; n2.size;
<br/>
    if (n1.number != n2.number) return n1.number &lt; n2.number;
<br/>
    if (n1.prev != n2.prev) return n1.prev &lt; n2.prev;
<br/>
    return n1.op &lt; n2.op;
<br/>
}
<br/>
<br/>
vector&lt;bool&gt; hit;
<br/>
map&lt;int, node&gt; cache;
<br/>
priority_queue&lt;node&gt; q;
<br/>
<br/>
int log2int(int num) {
<br/>
    int log2 = 0;
<br/>
    for (;num;log2++) { num &amp;= num - 1; }
<br/>
    return log2;
<br/>
}
<br/>
void pushcheck(priority_queue&lt;node&gt; &amp;q, node &amp;n) {
<br/>
    if (n.number &lt; 0) return;
<br/>
    if (n.number &gt;= hit.size()) return;
<br/>
    if (!hit[n.number]) q.push(n);
<br/>
}
<br/>
int main() {
<br/>
    const int target = 43690;
<br/>
    int log2target = log2int(target)+1;
<br/>
    q.push(node(1, 1, -1, 0));
<br/>
    hit = vector&lt;bool&gt;(target * 5, false);
<br/>
    while (!q.empty()) {
<br/>
        node top = q.top(); q.pop();
<br/>
        if (top.size &gt; 6) continue;
<br/>
        if (top.number &gt; target * 4) continue;
<br/>
<br/>
        if (top.number == target) {
<br/>
            // result
<br/>
            printf("Result: \n");
<br/>
            for(;;) {
<br/>
                int data = top.op &gt;&gt; 4;
<br/>
                int tmp = abs(top.number - top.prev);
<br/>
                switch (top.op &amp; 0xf) {
<br/>
                    case 1: printf("%d = %d &lt;&lt; %d\n", top.number, top.prev, data); break;
<br/>
                    case 2: printf("%d = %d + %d &lt;&lt; %d\n", top.number, top.prev, tmp &gt;&gt; data, data); break;
<br/>
                    case 3: printf("%d = %d - %d &lt;&lt; %d\n", top.number, top.prev, tmp &gt;&gt; data, data); break;
<br/>
                    case 4: printf("%d = %d + %d &gt;&gt; %d\n", top.number, top.prev, tmp &lt;&lt; data, data); break;
<br/>
                    case 5: printf("%d = %d - %d &gt;&gt; %d\n", top.number, top.prev, tmp &lt;&lt; data, data); break;
<br/>
                }
<br/>
                if (top.prev == -1) break;
<br/>
                top = cache[top.prev];
<br/>
            }
<br/>
            break;
<br/>
        }
<br/>
<br/>
        if (hit[top.number]) continue;
<br/>
        hit[top.number] = true;
<br/>
        cache[top.number] = top;
<br/>
<br/>
        node cur = top;
<br/>
        for (int i = 0; i &lt; log2target; i++) {
<br/>
            pushcheck(q,node(top.number &lt;&lt; i, top.size + 1, top.number, 1 | (i &lt;&lt; 4)));
<br/>
        }
<br/>
        for(;;) {
<br/>
            for (int i = 0; i &lt; log2target; i++) {
<br/>
                pushcheck(q,node(top.number + (cur.number &lt;&lt; i), top.size + 1, top.number, 2 | (i &lt;&lt; 4)));
<br/>
                pushcheck(q,node(top.number - (cur.number &lt;&lt; i), top.size + 1, top.number, 3 | (i &lt;&lt; 4)));
<br/>
            }
<br/>
            for (int i = 1,j; (j=(cur.number&gt;&gt;i)) &gt; 0; i++) {
<br/>
                pushcheck(q,node(top.number + j, top.size + 1, top.number, 4 | (i &lt;&lt; 4)));
<br/>
                pushcheck(q,node(top.number - j, top.size + 1, top.number, 5 | (i &lt;&lt; 4)));
<br/>
            }
<br/>
            if (cur.prev == -1) break;
<br/>
            cur = cache[cur.prev];
<br/>
        }
<br/>
<br/>
    }
<br/>
    return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63766 - LOst? - Fri Dec 16, 2005 4:54 am</h4>
    <div class="postbody"><span class="postbody">gladius, I have never seen anything like this before. Your code uses C++ stuff I never new existed.
<br/>
<br/>
It looks like it's working. I got a lot of warnings when I compiled it in VC++ 6.
<br/>
<br/>
EDIT: Your program goes really fast with numbers up to 511, and it hangs with numbers 512 and higher.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Compiling...
<br/>
mulbit.cpp
<br/>
D:\Programming\mulbit\mulbit.cpp(24) : warning C4786: 'std::reverse_bidirectional_iterator&lt;std::_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::iterator,std::p
<br/>
air&lt;int const ,node&gt;,std::pair&lt;int const ,node&gt; &amp;,std::pair&lt;int const ,node&gt; *,int&gt;' : identifier was truncated to '255' characters in the debug information
<br/>
D:\Programming\mulbit\mulbit.cpp(24) : warning C4786: 'std::reverse_bidirectional_iterator&lt;std::_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::const_iterator,
<br/>
std::pair&lt;int const ,node&gt;,std::pair&lt;int const ,node&gt; const &amp;,std::pair&lt;int const ,node&gt; const *,int&gt;' : identifier was truncated to '255' characters in the debug information
<br/>
D:\Programming\mulbit\mulbit.cpp(24) : warning C4786: 'std::pair&lt;std::_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::iterator,std::_Tree&lt;int,std::pair&lt;int con
<br/>
st ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::iterator&gt;' : identifier was truncated to '255' characters in the debug information
<br/>
D:\Programming\mulbit\mulbit.cpp(24) : warning C4786: 'std::pair&lt;std::_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::const_iterator,std::_Tree&lt;int,std::pair&lt;i
<br/>
nt const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::const_iterator&gt;' : identifier was truncated to '255' characters in the debug information
<br/>
c:\microsoft visual studio\vc98\include\xtree(183) : warning C4786: 'std::_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::~_Tree&lt;int,std::pair&lt;int const ,node&gt;
<br/>
,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;' : identifier was truncated to '255' characters in the debug information
<br/>
c:\microsoft visual studio\vc98\include\xtree(160) : warning C4786: 'std::_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Tree&lt;int,std::pair&lt;int const ,node&gt;,
<br/>
std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;' : identifier was truncated to '255' characters in the debug information
<br/>
c:\microsoft visual studio\vc98\include\utility(21) : warning C4786: 'std::pair&lt;std::_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::iterator,bool&gt;::pair&lt;std::
<br/>
_Tree&lt;int,std::pair&lt;int const ,node&gt;,std::map&lt;int,node,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::_Kfn,std::less&lt;int&gt;,std::allocator&lt;node&gt; &gt;::iterator,bool&gt;' : identifier was truncated to '255' characters in the debug information
<br/>
<br/>
mulbit.obj - 0 error(s), 7 warning(s)</td> </tr></table><span class="postbody"><br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63773 - gauauu - Fri Dec 16, 2005 5:43 am</h4>
    <div class="postbody"><span class="postbody">Some of that stuff you've never seen before is probably templates.  Simple tutorial here:  <a class="postlink" href="http://www.cplusplus.com/doc/tutorial/templates.html" target="_blank">http://www.cplusplus.com/doc/tutorial/templates.html</a>.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63775 - gladius - Fri Dec 16, 2005 6:25 am</h4>
    <div class="postbody"><span class="postbody">It (ab)uses the STL, so if you aren't familiar with that it would look quite strange.
<br/>
<br/>
It's not freezing on numbers higher than 512 here, but my log2int function was completely wrong.  It counted the number of set bits.
<br/>
<br/>
The correct function looks like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int log2int(int num) {
<br/>
    int log2 = 0;
<br/>
    for (;num;log2++) { num = num &amp; (~(1&lt;&lt;log2)); }
<br/>
    return log2;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Using that function I actually improved the old result for 42857, it's now:
<br/>
42857 = 43537 - 43537 &gt;&gt; 6
<br/>
43537 = 2561 + 2561 &lt;&lt; 4
<br/>
2561 = 2049 + 1 &lt;&lt; 9
<br/>
2049 = 1 + 1 &lt;&lt; 11
<br/>
<br/>
It also handles 512 fine now, giving what one would expect:
<br/>
512 = 1 &lt;&lt; 9.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63786 - DekuTree64 - Fri Dec 16, 2005 7:57 am</h4>
    <div class="postbody"><span class="postbody">Nice to see some actual code (although I don't really understand how it works :/ )
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gladius wrote:</b></span></td> </tr> <tr> <td class="quote">Using that function I actually improved the old result for 42857, it's now:
<br/>
42857 = 43537 - 43537 &gt;&gt; 6
<br/>
43537 = 2561 + 2561 &lt;&lt; 4
<br/>
2561 = 2049 + 1 &lt;&lt; 9
<br/>
2049 = 1 + 1 &lt;&lt; 11
<br/>
</td> </tr></table><span class="postbody">
<br/>
Hmm, that doesn't quite work, due to the shift-down. Any bits that are shifted off must be 0, otherwise they will still contribute to the result because the other number has been multiplied by them already. 
<br/>
For example, 42857 * 10 should be 428570, but
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">10 + 10 &lt;&lt; 11        = 10 + 20480     = 20490
<br/>
20490 + 10 &lt;&lt; 9      = 20490 + 5120   = 25610
<br/>
25610 + 25610 &lt;&lt; 4   = 25610 + 409760 = 435370
<br/>
435370 - 435370 &gt;&gt; 6 = 435370 - 6802  = 428568</td> </tr></table><span class="postbody"><br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63787 - LOst? - Fri Dec 16, 2005 8:06 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
1125 = 1285 - 1280 &gt;&gt; 3
<br/>
1285 = 257 + 257 &lt;&lt; 2
<br/>
257 = 1 + 1 &lt;&lt; 8
<br/>
<br/>
((((x + (x &lt;&lt; 8)) + (((x + (x &lt;&lt; 8)) &lt;&lt; 2)) - (1280 &gt;&gt; 3)) = x * 1125
<br/>
</td> </tr></table><span class="postbody">
<br/>
I like your program and it seems to work. But the constant "- (1280 &gt;&gt; 3)" scares me. Is there any other way to get this number with just bitshifting x? For some reason I want addition only because subtraction is addition of two's complement notation, which doesn't seem like a shortcut to me.<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63799 - gladius - Fri Dec 16, 2005 11:18 am</h4>
    <div class="postbody"><span class="postbody">DekuTree64: That's a great observation, and I didn't even consider it.  Those shifts to the right are busted.  Back to a 5 step multiplication without that then.
<br/>
<br/>
42857 = 43113 - 1 &lt;&lt; 8
<br/>
43113 = 34901 + 2053 &lt;&lt; 2
<br/>
34901 = 2053 + 2053 &lt;&lt; 4
<br/>
2053 = 2049 + 1 &lt;&lt; 2
<br/>
2049 = 1 + 1 &lt;&lt; 11
<br/>
<br/>
Lost: That 1280 is actually 1285, but the way I coded it, it was tough to reconstruct the number we built from, so it generated (1285 &gt;&gt; 3) &lt;&lt; 3 to print, hence chopping of the bottom 3 bits and giving you 1280.  As DekuTree64 pointed out, that is not correct.
<br/>
<br/>
Using the updated program, the best result is
<br/>
<br/>
1125 = 225 + 225 &lt;&lt; 2
<br/>
225 = 257 - 1 &lt;&lt; 5
<br/>
257 = 1 + 1 &lt;&lt; 8
<br/>
<br/>
So, still 3 steps, and this one actually works :).
<br/>
<br/>
This algorithm is basically trying to find the shortest path in a graph, where the graph's nodes are integers, and the connections between the nodes are a + b &lt;&lt; n of some sort.
<br/>
<br/>
It uses a pretty standard priority queue implementation of a Dijkstra shortest-path search to give O(m logn) performance where m is the number of edges, and n is the number of nodes.
<br/>
<br/>
Updated program below (pretty small change):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;vector&gt;
<br/>
#include &lt;queue&gt;
<br/>
#include &lt;map&gt;
<br/>
#include &lt;cstdio&gt;
<br/>
#include &lt;cstdlib&gt;
<br/>
using namespace std;
<br/>
<br/>
struct node {
<br/>
    node() {}
<br/>
    node(int _num,int _size,int _prev,int _op) : number(_num), size(_size), prev(_prev),op(_op) { }
<br/>
    int number, size, prev, op;
<br/>
};
<br/>
bool operator&lt;(const node &amp;n1, const node &amp;n2) {
<br/>
    if (n1.size != n2.size) return n1.size &gt; n2.size;
<br/>
    if (n1.number != n2.number) return n1.number &lt; n2.number;
<br/>
    if (n1.prev != n2.prev) return n1.prev &lt; n2.prev;
<br/>
    return n1.op &lt; n2.op;
<br/>
}
<br/>
<br/>
vector&lt;bool&gt; hit;
<br/>
map&lt;int, node&gt; cache;
<br/>
priority_queue&lt;node&gt; q;
<br/>
<br/>
int log2int(int num) {
<br/>
    int log2 = 0;
<br/>
    for (;num;log2++) { num = num &amp; (~(1&lt;&lt;log2)); }
<br/>
    return log2;
<br/>
}
<br/>
void pushcheck(priority_queue&lt;node&gt; &amp;q, node &amp;n) {
<br/>
    if (n.number &lt; 0) return;
<br/>
    if (n.number &gt;= hit.size()) return;
<br/>
    if (!hit[n.number]) q.push(n);
<br/>
}
<br/>
int main() {
<br/>
    const int target = 1125;
<br/>
    int log2target = log2int(target)+1;
<br/>
    q.push(node(1, 1, -1, 0));
<br/>
    hit = vector&lt;bool&gt;(target * 5, false);
<br/>
    while (!q.empty()) {
<br/>
        node top = q.top(); q.pop();
<br/>
        if (top.size &gt; 6) continue;
<br/>
        if (top.number &gt; target * 4) continue;
<br/>
<br/>
        if (top.number == target) {
<br/>
            // result
<br/>
            printf("Result: \n");
<br/>
            for(;;) {
<br/>
                int data = top.op &gt;&gt; 4;
<br/>
                int tmp = abs(top.number - top.prev);
<br/>
                switch (top.op &amp; 0xf) {
<br/>
                    case 1: printf("%d = %d &lt;&lt; %d\n", top.number, top.prev, data); break;
<br/>
                    case 2: printf("%d = %d + %d &lt;&lt; %d\n", top.number, top.prev, tmp &gt;&gt; data, data); break;
<br/>
                    case 3: printf("%d = %d - %d &lt;&lt; %d\n", top.number, top.prev, tmp &gt;&gt; data, data); break;
<br/>
                    case 4: printf("%d = %d + %d &gt;&gt; %d\n", top.number, top.prev, tmp &lt;&lt; data, data); break;
<br/>
                    case 5: printf("%d = %d - %d &gt;&gt; %d\n", top.number, top.prev, tmp &lt;&lt; data, data); break;
<br/>
                }
<br/>
                if (top.prev == -1) break;
<br/>
                top = cache[top.prev];
<br/>
            }
<br/>
            break;
<br/>
        }
<br/>
<br/>
        if (hit[top.number]) continue;
<br/>
        hit[top.number] = true;
<br/>
        cache[top.number] = top;
<br/>
<br/>
        node cur = top;
<br/>
        for (int i = 0; i &lt; log2target; i++) {
<br/>
            pushcheck(q,node(top.number &lt;&lt; i, top.size + 1, top.number, 1 | (i &lt;&lt; 4)));
<br/>
        }
<br/>
        for(;;) {
<br/>
            for (int i = 0; i &lt; log2target; i++) {
<br/>
                pushcheck(q,node(top.number + (cur.number &lt;&lt; i), top.size + 1, top.number, 2 | (i &lt;&lt; 4)));
<br/>
                pushcheck(q,node(top.number - (cur.number &lt;&lt; i), top.size + 1, top.number, 3 | (i &lt;&lt; 4)));
<br/>
            }
<br/>
            for (int i = 1,j; (j=(cur.number&gt;&gt;i)) &gt; 0; i++) {
<br/>
                if ((j &lt;&lt; i) != cur.number) break;
<br/>
                pushcheck(q,node(top.number + j, top.size + 1, top.number, 4 | (i &lt;&lt; 4)));
<br/>
                pushcheck(q,node(top.number - j, top.size + 1, top.number, 5 | (i &lt;&lt; 4)));
<br/>
            }
<br/>
            if (cur.prev == -1) break;
<br/>
            cur = cache[cur.prev];
<br/>
        }
<br/>
<br/>
    }
<br/>
    return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
