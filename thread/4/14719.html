<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>SPRITES - MOVEMENT AND SPEED - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > SPRITES - MOVEMENT AND SPEED</h2>
<div id="posts">
<div class="post">
    <h4>#147649 - noodle - Tue Dec 25, 2007 11:16 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
I am relatively new to the concept of sprite animation and movement and was wondering if someone could help.
<br/>
<br/>
Basically the problem is that I have 10 sprites and I want to be able to move them at different speeds from each other.
<br/>
<br/>
how can this be acomplished?
<br/>
<br/>
Thanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147651 - Kyoufu Kawa - Tue Dec 25, 2007 12:49 pm</h4>
    <div class="postbody"><span class="postbody">For each sprite, you could have a <span style="font-style: italic">delta</span> variable. Each game cycle, you increase the sprite's position by that value. That way, one sprite can move one pixel per frame, while another could move three, for example.
<br/>
<br/>
That's the simple way.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147668 - tepples - Tue Dec 25, 2007 9:31 pm</h4>
    <div class="postbody"><span class="postbody">Another tip: Learn <a class="postlink" href="http://en.wikipedia.org/wiki/Fixed-point_arithmetic" target="_blank">fixed-point arithmetic</a>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147674 - noodle - Tue Dec 25, 2007 11:52 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Kyoufu Kawa wrote:</b></span></td> </tr> <tr> <td class="quote">For each sprite, you could have a <span style="font-style: italic">delta</span> variable. Each game cycle, you increase the sprite's position by that value. That way, one sprite can move one pixel per frame, while another could move three, for example.
<br/>
<br/>
That's the simple way.</td> </tr></table><span class="postbody">
<br/>
<br/>
Hi,
<br/>
Thanks for replying to my post,
<br/>
I am wondering, how is the delta variable calculated and also is it a floating point or an integer?
<br/>
I have noticed a lot of sprite structs use 'int' to hold sprites x and y coords.
<br/>
<br/>
One more thing, are the sprites movement calculated every 1/60th sec video frame or every program loop?
<br/>
<br/>
Thanks Again</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147676 - tepples - Tue Dec 25, 2007 11:56 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote">I am wondering, how is the delta variable calculated and also is it a floating point or an integer?</td> </tr></table><span class="postbody">
<br/>
The GBA doesn't have floating-point hardware. So to fake floating-point math, a lot of programs use an integer and treat it as having a constant denominator of 256 or something.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">One more thing, are the sprites movement calculated every 1/60th sec video frame or every program loop?</td> </tr></table><span class="postbody">
<br/>
Sprites are moved every program loop. But this is the same as every video frame because most programs call a "wait for vertical blank" at one point in the loop.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147677 - noodle - Wed Dec 26, 2007 12:24 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The GBA doesn't have floating-point hardware. So to fake floating-point math, a lot of programs use an integer and treat it as having a constant denominator of 256 or something.</td> </tr></table><span class="postbody">
<br/>
Would this mean that the value stored against say sprite.x is not the actual sprite pixel coordinate on the map or screen?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Sprites are moved every program loop. But this is the same as every video frame because most programs call a "wait for vertical blank" at one point in the loop.</td> </tr></table><span class="postbody">
<br/>
wouldn't the waiting for vertical blank halt the program loop until vblank has occured, hence making the whole program really slow?
<br/>
<br/>
I tried something before where I updated the sprite movement every vblank, however this meant that the sprite was limited to a movement of 60 pixels every second.
<br/>
<br/>
I also considered applying more than one pixel per movement of the sprite, however this messed up the collision detection routine and the sprite was able to travel through other objects in its way.
<br/>
<br/>
Thanks again.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147679 - tepples - Wed Dec 26, 2007 12:54 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The GBA doesn't have floating-point hardware. So to fake floating-point math, a lot of programs use an integer and treat it as having a constant denominator of 256 or something.</td> </tr></table><span class="postbody">
<br/>
Would this mean that the value stored against say sprite.x is not the actual sprite pixel coordinate on the map or screen?</span></td> </tr></table><span class="postbody">
<br/>
The coordinate stored in OAM is the actual coordinate on the screen. But some games use a different coordinate system within the game logic and then translate that to screen coordinates. (See <a class="postlink" href="http://en.wikipedia.org/wiki/Coordinates_%28mathematics%29" target="_blank">Coordinates (mathematics)</a> and <a class="postlink" href="http://en.wikipedia.org/wiki/Coordinate_system" target="_blank">Coordinate system</a> on Wikipedia.) This is especially common in games where objects smoothly speed up, slow down, or turn corners, or in games where the screen scrolls.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Sprites are moved every program loop. But this is the same as every video frame because most programs call a "wait for vertical blank" at one point in the loop.</td> </tr></table><span class="postbody">
<br/>
wouldn't the waiting for vertical blank halt the program loop until vblank has occured, hence making the whole program really slow?</span></td> </tr></table><span class="postbody">
<br/>
That's exactly what you want. "Really slow" to a computer is "playably fast" to a human.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I also considered applying more than one pixel per movement of the sprite, however this messed up the collision detection routine and the sprite was able to travel through other objects in its way.</td> </tr></table><span class="postbody">
<br/>
That's strange. How wide were the objects?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147698 - noodle - Wed Dec 26, 2007 1:30 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Tepples,
<br/>
<br/>
For the purposes of sprite speed and collision, I am attempting to create a sort of partical/bouncyball program where each ball moves at different speeds from each other and has the ability to bounce off each other also.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Quote: 
<br/>
I also considered applying more than one pixel per movement of the sprite, however this messed up the collision detection routine and the sprite was able to travel through other objects in its way. 
<br/>
<br/>
That's strange. How wide were the objects?</td> </tr></table><span class="postbody">
<br/>
<br/>
The objects are 8x8 each in size, I tried adding +10 to the pixel coord to make it move more quickly, but it took the ball to the opposite side of the other side of the ball which I wanted to test collision, so effectively the ball passed straight through the other one as the collision test was not applied. the only way for the collision test to work is to apply a maximum one pixel at a time to the sprite coord, which defeats the purpose of adding +10 for speed reasons.
<br/>
<br/>
Regarding the waiting for vertical blank, this would mean that the pixels will move one pixel every 1/60th second which means it would take 4 seconds to move from left to right of screen. I wanted some balls to move a lot faster than this but at the same time work with the collision detection.
<br/>
<br/>
Thanks again, really appreciate the response.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147699 - Peter - Wed Dec 26, 2007 1:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote"> so effectively the ball passed straight through the other one as the collision test was not applied.</td> </tr></table><span class="postbody">
<br/>
You don't only have to test the target position, but the entire way from point A to B, where A is the current position and B being the destination. 
<br/>
<br/>
Also a common mistake is to quit the collision detection routine once a hit has been detected, which is wrong. You need to test all relevant objects and return the one with the nearest distance.<br/>_________________<br/>Kind Regards,
<br/>
Peter</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147701 - noodle - Wed Dec 26, 2007 3:16 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Peter wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote"> so effectively the ball passed straight through the other one as the collision test was not applied.</td> </tr></table><span class="postbody">
<br/>
You don't only have to test the target position, but the entire way from point A to B, where A is the current position and B being the destination. 
<br/>
<br/>
Also a common mistake is to quit the collision detection routine once a hit has been detected, which is wrong. You need to test all relevant objects and return the one with the nearest distance.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
This is one way, although I only require to test for collisions till ball hits the next, at which point it will deflect. Also not sure about the 'target position' how does this work?
<br/>
<br/>
Till now I have seen code which looks like below:
<br/>
Sprite.x += xdirection (which seemed to relate directly to the pixel coords on screen).
<br/>
<br/>
However the creates some issues:
<br/>
If I update per program loop/cycle, the sprite will be too fast, If I update per vblank, the sprite will be too slow. If I add more than one pixel at a time then collision detection doesnt work).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147703 - Peter - Wed Dec 26, 2007 4:58 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote">If I add more than one pixel at a time then collision detection doesnt work).</td> </tr></table><span class="postbody">
<br/>
And this is exactly what I meant. If you move an object from point A to B, you must test for collision along the way from A to B and not only B.<br/>_________________<br/>Kind Regards,
<br/>
Peter</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147704 - Dwedit - Wed Dec 26, 2007 5:08 pm</h4>
    <div class="postbody"><span class="postbody">If you're using equality with a single value to test collisions, you're doing it wrong.  Normally collision detection is done by testing if two bounding boxes overlap.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147722 - noodle - Wed Dec 26, 2007 11:42 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">If you're using equality with a single value to test collisions, you're doing it wrong.  Normally collision detection is done by testing if two bounding boxes overlap.</td> </tr></table><span class="postbody">
<br/>
nope, not using that.
<br/>
I am testing using the bounding box overlap.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147724 - noodle - Wed Dec 26, 2007 11:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Peter wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote">If I add more than one pixel at a time then collision detection doesnt work).</td> </tr></table><span class="postbody">
<br/>
And this is exactly what I meant. If you move an object from point A to B, you must test for collision along the way from A to B and not only B.</span></td> </tr></table><span class="postbody">
<br/>
Thanks Peter,
<br/>
<br/>
I think that some kind of sub pixel coordinates are required here, not sure if this is the most common way to apply sprite movment (i.e is this same method used in all games/applications by professionals).
<br/>
Tepples' fixed point math suggestion seems to be the most tempting as it would make sub-pixel movement likely. I would have to store the coordinates as some other value instead of pixel/map coords.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147727 - tepples - Thu Dec 27, 2007 12:02 am</h4>
    <div class="postbody"><span class="postbody">Forza for Xbox runs the game engine four times per frame and then updates the screen. If you want to have wicked-fast bouncing balls, that might be the best option.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147730 - Peter - Thu Dec 27, 2007 1:01 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote">I think that some kind of sub pixel coordinates are required here</td> </tr></table><span class="postbody">
<br/>
Hm?
<br/>
<br/>
I thought the problem is this:
<br/>
A = start position
<br/>
B = target position
<br/>
c = collidable object (a wall, whatever)
<br/>
O = your object
<br/>
<br/>
1st Frame:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
A  c   B
<br/>
O
<br/>
</td> </tr></table><span class="postbody">
<br/>
... advance position of object...
<br/>
<br/>
next Frame:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
A  c   B
<br/>
.......O
<br/>
</td> </tr></table><span class="postbody">
<br/>
O moved to B without colliding with c. This was your problem, wasn't it?<br/>_________________<br/>Kind Regards,
<br/>
Peter</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147782 - noodle - Thu Dec 27, 2007 10:06 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote">Hi,
<br/>
I am relatively new to the concept of sprite animation and movement and was wondering if someone could help.
<br/>
<br/>
Basically the problem is that I have 10 sprites and I want to be able to move them at different speeds from each other.
<br/>
<br/>
how can this be acomplished?
<br/>
<br/>
Thanks.</td> </tr></table><span class="postbody">
<br/>
<br/>
My problem is as it has always been, to be able to move the sprites at different speeds from each other, while still being able to allow collision detection to work correctly, which would require that the sprite moves no more than a maximum of 1 pixel per cycle.
<br/>
<br/>
I have noticed in your interesting 'text diagram' that you have used the terms 'first frame' and 'next frame'. Wouldnt the collision detection be occuring every program cycle, regardless of how much the sprite has travelled in between frames?
<br/>
<br/>
Always open to new suggestions
<br/>
Thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147790 - tepples - Thu Dec 27, 2007 11:35 pm</h4>
    <div class="postbody"><span class="postbody">Why would collision detection require that objects move no more than 1 pixel per cycle, unless the objects are only 1 pixel in size? Say I have a 16-pixel ball moving at 8 pixels per game cycle toward a 16-pixel ball sitting still. Even if the two balls penetrate by 8 pixels, it's still possible to "rewind" the objects by part of a game cycle and compute their trajectories.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147801 - keldon - Fri Dec 28, 2007 4:15 am</h4>
    <div class="postbody"><span class="postbody">I did write a post in this topic about it but the iron set off the RCD circuit breaker before I managed to post (destroying it without a decent firefox restore). But in short you can calculate the collision point between two moving circles with a number of calculations where the code will not allow one object to pass through another!
<br/>
<br/>
See <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=12409" target="_blank">Circle-Circle Collision and Reaction (Frame-Independent)</a> for more info on how it can be achieved - the Jar files contain demo's however I'm in the process of switching over servers!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147809 - phonymike - Fri Dec 28, 2007 8:47 am</h4>
    <div class="postbody"><span class="postbody">I would just run the detection loop for every one pixel a sprite moves. so if you jump from position 1 to position 10 on one frame, then run the routine 10 times then update the sprite.
<br/>
<br/>
frame 1: increase position variable by 1, detect collision. increase position by 1, detect etc. say a collision happens at position 7, break the loop, and you're left with 7. now call any routine such as sound.
<br/>
<br/>
frame 2: update the on screen sprite to position 7.
<br/>
<br/>
at least that's a quick and dirty way of doing it. I figure a maximum speed of 10 pixels per frame per sprite would take no more time to calculate than it would to copy an 8x8 sprite to memory, it may sound slow but would pry take 0.05% of the time you have per frame.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147813 - Peter - Fri Dec 28, 2007 11:14 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>phonymike wrote:</b></span></td> </tr> <tr> <td class="quote">I would just run the detection loop for every one pixel a sprite moves. so if you jump from position 1 to position 10 on one frame, then run the routine 10 times then update the sprite.</td> </tr></table><span class="postbody">
<br/>
I would create an area of the tavelled distance. For example if your object moves from x=10 to x=20 and its height=5, you can represent the movement as a rectangle and thus perform basic rectangle overlapping tests. This becomes a bit tricker if the movement is diagonal.
<br/>
<br/>
Personally I prefer using lines, as those are very easy to test against all kind of shapes.<br/>_________________<br/>Kind Regards,
<br/>
Peter</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147816 - noodle - Fri Dec 28, 2007 12:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Why would collision detection require that objects move no more than 1 pixel per cycle, unless the objects are only 1 pixel in size? Say I have a 16-pixel ball moving at 8 pixels per game cycle toward a 16-pixel ball sitting still. Even if the two balls penetrate by 8 pixels, it's still possible to "rewind" the objects by part of a game cycle and compute their trajectories.</td> </tr></table><span class="postbody">
<br/>
Thanks for response guys.
<br/>
<br/>
One pixel per cycle is too fast, adding more than this per cycle would be really wierd, not to mention the fact that collision detection would miss items from pixel coordinates in between (see previous posts for explanation on this).
<br/>
<br/>
Probably something I have missed, however cannot figure out what is missing if I didn't know it existed, kind of a catch 22 situation.
<br/>
I have looked for some kind of tutorials on sprite speed and have had no luck.
<br/>
<br/>
Thanks again</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147817 - noodle - Fri Dec 28, 2007 12:49 pm</h4>
    <div class="postbody"><span class="postbody">I think that my problem might be relating to the difference between the 'frame rate' and program cycle and how often to call the collision detection.
<br/>
<br/>
Will have one last shot at it here.
<br/>
<br/>
Also wondering what 'equality' and 'delta' are (mentioned in previous posts).
<br/>
<br/>
Thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147819 - keldon - Fri Dec 28, 2007 1:40 pm</h4>
    <div class="postbody"><span class="postbody">Calculating it using the method I described is [probably] quicker than doing ten checks per frame; but nonetheless is still not so error prone and restricting.
<br/>
<br/>
One thing I should point out is that geometric shapes have various [simple] methods for collision detection. The code I have written is in Java for detecting moving circle/circle collisions (and also giving their position).
<br/>
<br/>
Also when looking for your solution you should search for search terms based on what you are trying to detect a collision for. For example if you are searching for moving circle/circle then google for "moving circle collision detection" or something - but like I said if that's what you're after I have code for it! Mine also returns the point (or distance) of collision, which allows you to calculate multiple bounces within a single frame (correctly).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147826 - bpoint - Fri Dec 28, 2007 7:55 pm</h4>
    <div class="postbody"><span class="postbody">Just my two cents...
<br/>
<br/>
The proper method of doing frame-independant collision detection is to create a line (or ray) from the previous frame's position to the current frame's position.  You can then check collision with an object as being a line, circle, or box doing simple 2D math calculations.
<br/>
<br/>
For example, if you built a wall as a line in 2D space, then you can check to see if a player collided with the wall by doing a line-to-line intersection calculation.  Typically the intersection check also returns the point of intersection so you can determine how far the player should advance in order to keep him from passing through the wall.  A box collision check would just test each of the four sides of the box, each as a line by itself.
<br/>
<br/>
Most of these calculations are simple algebra.  A very good site describing pretty much all of the algorithms you'll need can be found at <a class="postlink" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/" target="_blank">Paul Bourke's Geometry Page</a>, specifically "The intersection of a line with another line (2D)".</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147829 - keldon - Fri Dec 28, 2007 8:47 pm</h4>
    <div class="postbody"><span class="postbody">I don't see moving circle/circle!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147832 - bpoint - Fri Dec 28, 2007 9:06 pm</h4>
    <div class="postbody"><span class="postbody">That's because you don't actually do a circle-to-circle collision test, you do a <a class="postlink" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/sphereline/" target="_blank">line-to-circle</a> test, where the line is the midpoint of the circle from the previous frame to the current frame.
<br/>
<br/>
When you find the intersection point, you simply offset your original circle from the intersection by it's radius to obtain a position that does not collide with the circle you are testing.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147848 - keldon - Sat Dec 29, 2007 1:28 am</h4>
    <div class="postbody"><span class="postbody">Well I just sketched it out and it's essentially the exact same calculations I use to find the point of collision too, I just think of it as a circle/circle as that's how I draw it.
<br/>
<br/>
And that is a good link so I think I'll bookmark that site too.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147902 - Ruben - Sun Dec 30, 2007 4:06 am</h4>
    <div class="postbody"><span class="postbody">I personally think that the problem would be with your collision detection script, not the amount of pixels moved. You said that if you move 10 pixels p/f, collision doesn't work, right? I think that this is what you are doing:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//DON'T do this...
<br/>
void CheckCollision(int dir) {
<br/>
 int x=0, y=0;
<br/>
 if(!(PixelsMoved++ &amp; 7)) {
<br/>
  if(dir == 0) x++;
<br/>
  else y++;
<br/>
 }
<br/>
 sprite.x += x, sprite.y += y;
<br/>
}
<br/>
<br/>
//Better to check against co-ordinates, not pixels moved
<br/>
u8 CheckCollision(sprite* spr) {
<br/>
 int x, y;
<br/>
 u8* map_col = (u8*)map_col_table;
<br/>
 
<br/>
 //assuming that X and Y are pixel coordinates...
<br/>
 x = spr-&gt;x&gt;&gt;3, y = spr-&gt;y&gt;&gt;3;
<br/>
 
<br/>
 //... return the nearest tile coordinate
<br/>
 return map_col[y*mapsize_x+x];
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
OK, maybe a bit rushed but I think you get the idea. Hope it helped.
<br/>
<br/>
BTW: edited 4 times or so. I do too many mistakes in a rush...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147929 - noodle - Sun Dec 30, 2007 6:16 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
After chewing through most of the posts and looking for the correct answer, I have found that there are many different ways of dealing with the issue of sprite speed.
<br/>
<br/>
Regarding the adding more than one pixel per cycle/frame, Do I take this as a given and that it must be done?
<br/>
<br/>
Assuming yes then this would mean that I would have to adjust and modify the basic collision bounding box technique (or introduce some support code to allow proper action to be performed after collision detected).
<br/>
<br/>
For Example, If the increment was 10 then this might take the sprite inside a solid brick wall, so some sort of back-tracking code might be needed to compliment the standard boundary box testing.
<br/>
<br/>
Is the above quite a common method or is it something rarely used?
<br/>
<br/>
Thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148134 - Miked0801 - Wed Jan 02, 2008 8:00 pm</h4>
    <div class="postbody"><span class="postbody">We pretty much lamed out on most of the games I worked on.  Just did a current position box/box or circle/circle check and if colided solid, backup to previous tic's position (or side along the surface if requested.)  We've rarely had issues with missed collisions or such.  We just try to make sure that our characters never relatively travel faster that the size of their collisions boxes.  Cheesy, but cheap and effective.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148168 - Ruben - Thu Jan 03, 2008 7:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>noodle wrote:</b></span></td> </tr> <tr> <td class="quote">Is the above quite a common method or is it something rarely used?
<br/>
<br/>
Thanks</td> </tr></table><span class="postbody">
<br/>
I'm quite sure that this method is used a lot in tile-collision based games, but since you didn't specify whether your planning to check collision against the the circle or the tile, I kinda just figured it would be easier to explain tile collision testing.
<br/>
<br/>
For example (assuming you are using pixel co-ordinates):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//I supose this is your current script
<br/>
u8 CheckCollision(sprite* spr) {
<br/>
 return map_col_table[spr-&gt;map_y * map_size_x + spr-&gt;map_x];
<br/>
}
<br/>
<br/>
void UpdateObjects() {
<br/>
 spr* Obj0, Obj1;
<br/>
 if(IS_PRESSED(KEY_UP)) { //Move sprite up
<br/>
  spr-&gt;screen_pos_y--;
<br/>
  spr-&gt;pixels_moved_y++;
<br/>
 }
<br/>
 if(IS_PRESSED(KEY_DOWN)) { //Move sprite down
<br/>
  spr-&gt;screen_pos_y++;
<br/>
  spr-&gt;pixels_moved_y++;
<br/>
 }
<br/>
 if(IS_PRESSED(KEY_LEFT)) { //Move sprite left
<br/>
  spr-&gt;screen_pos_x--;
<br/>
  spr-&gt;pixels_moved_x++;
<br/>
 }
<br/>
 if(IS_PRESSED(KEY_RIGHT)) { //Move sprite right
<br/>
  spr-&gt;screen_pos_x++;
<br/>
  spr-&gt;pixels_moved_x++;
<br/>
 }
<br/>
 
<br/>
 if(spr-&gt;pixels_moved_x &amp; 7) spr-&gt;map_x++;
<br/>
 if(spr-&gt;pixels_moved_y &amp; 7) spr-&gt;map_y++;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Although this would work for movements that are power of 2's, it wouldn't work for other numbers. This would be the same script re-written 'correctly':
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//I supose this is your current script
<br/>
u8 CheckCollision(sprite* spr) {
<br/>
 return map_col_table[spr-&gt;map_y * map_size_x + spr-&gt;map_x];
<br/>
}
<br/>
<br/>
void UpdateObjects() {
<br/>
 spr* Obj0, Obj1;
<br/>
 if(IS_PRESSED(KEY_UP)) { //Move sprite up
<br/>
  spr-&gt;screen_pos_y--;
<br/>
  spr-&gt;pixels_moved++; //Do this just incase you want to change p/f
<br/>
 }
<br/>
 if(IS_PRESSED(KEY_DOWN)) { //Move sprite down
<br/>
  spr-&gt;screen_pos_y++;
<br/>
  spr-&gt;pixels_moved++;
<br/>
 }
<br/>
 if(IS_PRESSED(KEY_LEFT)) { //Move sprite left
<br/>
  spr-&gt;screen_pos_x--;
<br/>
  spr-&gt;pixels_moved++;
<br/>
 }
<br/>
 if(IS_PRESSED(KEY_RIGHT)) { //Move sprite right
<br/>
  spr-&gt;screen_pos_x++;
<br/>
  spr-&gt;pixels_moved++;
<br/>
 }
<br/>
 spr-&gt;map_x = spr-&gt;screen_pos_x &gt;&gt; 3; //&gt;&gt; 3 = /8
<br/>
 spr-&gt;map_y = spr-&gt;screen_pos_y &gt;&gt; 3;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
That would be the way to detect tile-based collisions. I'm sure there's tutorials on how to be able to detect round/circle collisions... actually, I think someone already mentioned one but i can't be f*cked to read it lol...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148170 - Ruben - Thu Jan 03, 2008 8:00 am</h4>
    <div class="postbody"><span class="postbody">Oops... forgot a part:
<br/>
<br/>
To detect if your sprite went outside a collision area, you'd just retract it's current X/Y position by doing this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void CorrectCollision(sprite* spr) {
<br/>
 int amount;
<br/>
 amount = 8 - (spr-&gt;x &amp; 7);
<br/>
 spr-&gt;x -= amount;
<br/>
 amount = 8 - (spr-&gt;y &amp; 7);
<br/>
 spr-&gt;y -= amount;
<br/>
}
<br/>
<br/>
void UpdateObjects() { 
<br/>
 spr* Obj0, Obj1; 
<br/>
 if(IS_PRESSED(KEY_UP)) {
<br/>
  spr-&gt;screen_pos_y -= spr-&gt;speed;
<br/>
  spr-&gt;pixels_moved++;
<br/>
 } 
<br/>
 if(IS_PRESSED(KEY_DOWN)) {
<br/>
  spr-&gt;screen_pos_y += spr-&gt;speed;
<br/>
  spr-&gt;pixels_moved++; 
<br/>
 } 
<br/>
 if(IS_PRESSED(KEY_LEFT)) {
<br/>
  spr-&gt;screen_pos_x -= spr-&gt;speed;
<br/>
  spr-&gt;pixels_moved++; 
<br/>
 } 
<br/>
 if(IS_PRESSED(KEY_RIGHT)) {
<br/>
  spr-&gt;screen_pos_x += spr-&gt;speed;
<br/>
  spr-&gt;pixels_moved++; 
<br/>
 } 
<br/>
 spr-&gt;map_x = spr-&gt;screen_pos_x &gt;&gt; 3; //&gt;&gt; 3 = /8 
<br/>
 spr-&gt;map_y = spr-&gt;screen_pos_y &gt;&gt; 3;
<br/>
 
<br/>
 if(CheckCollision(spr)) CorrectCollision(spr);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
OK. Lame way to do it but I REALLY can't be f*cked typing up the other one 'cause I already typed up a formula and it's hot as hell here...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148174 - Peter - Thu Jan 03, 2008 9:54 am</h4>
    <div class="postbody"><span class="postbody">And this does work? I don't see code to handle movements from right to left, or down to up. To perform collision resolving correctly, you also need more than the current position, you need a vector that describes the travelled way.
<br/>
<br/>
Also for a player object for example, usually it's not enough to just test one point of the object for collision. If you test only the feet, the player might ran into a wall with his head.
<br/>
<br/>
Plus, what most people don't think about is when an object gets pushed out through the collision resolving process, it might be pushed into another collision. 
<br/>
<br/>
BTW, personally I would also throw away the screenpos concept, it overcomplicates the whole thing imo. Just use worldcoordinates for everything and right before rendering convert them to screencoords. But that's probably just a personal taste.<br/>_________________<br/>Kind Regards,
<br/>
Peter</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
