<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Movements of sprite and blur - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Movements of sprite and blur</h2>
<div id="posts">
<div class="post">
    <h4>#5592 - Link - Fri May 02, 2003 2:54 pm</h4>
    <div class="postbody"><span class="postbody">I'm proving the .bin file of tutorial33.zip of pernproject...
<br/>
(i'm learning how show sprite on GBA and move)
<br/>
<br/>
But moving the sprite in that .bin example i can see a bad blur of image:
<br/>
<br/>
When i move the image it became blurry, in the movement i see it not correctly (like bleary)...
<br/>
Instead if i try commercial game it don't happen..
<br/>
<br/>
What does depend it by?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5610 - pollier - Sat May 03, 2003 4:10 am</h4>
    <div class="postbody"><span class="postbody">Make sure your emulator is running at full speed, and maybe turn on V-Sync if you're using, say, VBA. Or does this problem occur on hardware? If so, the code isn't waiting for the V-Blank to update the position. Be sure to update your OAM after scanlines have finished to avoid shearing.<br/>_________________<br/>(Works for me!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5612 - Link - Sat May 03, 2003 8:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Make sure your emulator is running at full speed, and maybe turn on V-Sync if you're using, say, VBA.</td> </tr></table><span class="postbody">
<br/>
i don't think it depend by that, because i have the some configuration of emu with commercial rom, and blurry don't happen with them.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"> V-Blank </td> </tr></table><span class="postbody">
<br/>
can u explain? What is V-blank?
<br/>
<br/>
Update? i do see you the code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/********************************************************
<br/>
*   
<br/>
*
<br/>
*            by devoto
<br/>
*
<br/>
*   
<br/>
********************************************************/
<br/>
#include&lt;math.h&gt;
<br/>
#include"gba.h"
<br/>
#include"screenmode.h"
<br/>
#include"keypad.h"
<br/>
#include"sprite.h"
<br/>
<br/>
#include"sprite1.h"
<br/>
<br/>
<br/>
<br/>
#define FIXED s32
<br/>
#define PI 3.14159
<br/>
#define RADIAN(n)       (((float)n)/(float)180*PI)
<br/>
<br/>
///declare our functions so the c compiler knows what we are talking about
<br/>
<br/>
void InitializeSprites(void);
<br/>
void WaitForVsync(void);
<br/>
void CopyOAM(void);
<br/>
void GetInput(void);
<br/>
void MoveSprite(OAMEntry* sp, int x, int y);
<br/>
void RotateSprite(int rotDataIndex, int angle, FIXED x_scale,FIXED y_scale);
<br/>
<br/>
///these are global so i do not have to pass them to GetInput
<br/>
s16 x = 10;
<br/>
s16 y = 10;
<br/>
u16 char_number = 0;
<br/>
<br/>
FIXED angle = 0;
<br/>
FIXED zoom = 1&lt;&lt;8;
<br/>
<br/>
FIXED SIN[360];
<br/>
FIXED COS[360];
<br/>
<br/>
<br/>
<br/>
///main entry point from the boot.asm startup file
<br/>
int main(void)
<br/>
<br/>
{
<br/>
   int index = 0;  //some looping variables for loops :)
<br/>
   u16 loop;
<br/>
   
<br/>
   for(loop = 0; loop &lt; 360; loop++)
<br/>
   {
<br/>
      SIN[loop] = (FIXED)(sin(RADIAN(loop)) * 256);  //sin and cos are computed and cast to                      //fixed
<br/>
      COS[loop] = (FIXED)(cos(RADIAN(loop)) * 256);
<br/>
   }
<br/>
   
<br/>
   SetMode(MODE_2 | OBJ_ENABLE | OBJ_MAP_1D); //set mode 2 and enable sprites and 2d mapping 
<br/>
<br/>
   for(loop = 0; loop &lt; 256; loop++)
<br/>
      OBJPaletteMem[loop] = sprite1Palette[loop];   //loop through and store the palette from your pict 
<br/>
                           //palette into obj palette mem OBJPaletteMem is 
<br/>
                           //defined in gba.h.  sprite1Palette is from
<br/>
                           //pcx2gba tool sprite1.h.
<br/>
   
<br/>
   InitializeSprites();  //set all 128 sprites to offscreen
<br/>
<br/>
   //this is were we define our sprite atributes for the first sprite
<br/>
   //256 color 64x64 sprite that starts at character 0.  Character 0 is
<br/>
   //the first sprite data memory location.
<br/>
<br/>
   sprites[0].attribute0 = COLOR_256 | SQUARE| ROTATION_FLAG | y;  
<br/>
   sprites[0].attribute1 = SIZE_64 |ROTDATA(0)|x;
<br/>
   sprites[0].attribute2 = char_number;
<br/>
<br/>
   
<br/>
//allright now to copy in the sprites bitmap.  The data in sprite1Data is allready striped 
<br/>
//so we just copy it in one row of tiles at a time.  The only difference between this and a 
<br/>
//2D sprite is that we would need to keep in mind the fact that the tiles are not all in a row.
<br/>
//We could just use one big for loop.  There are 8 rows (64x64 = 8x8 tiles) so we loop through
<br/>
//all 8.  There is 512 bytes per row (8 tiles * 8x8 = 512) but since we copy 2 bytes at a 
<br/>
//time that equals 256.  The width of char memory is 32 * 8x8 = 1024 (512 double bytes).
<br/>
//   
<br/>
      for(index = 0; index &lt; 256*8; index++)
<br/>
      {
<br/>
         OAMData[index] = sprite1Data[index];  
<br/>
         
<br/>
      }//end index loop
<br/>
<br/>
///Main Game loop   
<br/>
   while(1)
<br/>
   {
<br/>
      GetInput();    //get input changes the x and y based on input
<br/>
      MoveSprite(&amp;sprites[0],x,y); //changes sprite atributes based on new x,y
<br/>
      
<br/>
      RotateSprite(0,angle,zoom,zoom);
<br/>
<br/>
      WaitForVsync();         //waits for the screen to stop drawing
<br/>
      CopyOAM();            //Copies our sprite array into OAM.
<br/>
   }
<br/>
}
<br/>
<br/>
////Set sprites to off screen
<br/>
<br/>
void InitializeSprites(void)
<br/>
{
<br/>
   int loop;
<br/>
   for(loop = 0; loop &lt; 128; loop++)
<br/>
   {
<br/>
      sprites[loop].attribute0 = 160;  //y to &gt; 159
<br/>
      sprites[loop].attribute1 = 240;  //x to &gt; 239
<br/>
   }
<br/>
}
<br/>
<br/>
//wait for the screen to stop drawing
<br/>
void WaitForVsync(void)
<br/>
{
<br/>
   
<br/>
<br/>
//lets get rid of htat inline asm we used in arm
<br/>
<br/>
/*
<br/>
   __asm 
<br/>
   {
<br/>
      mov    r0, #0x4000006   //0x4000006 is vertical trace counter; when it hits 160                //160 the vblanc starts
<br/>
      scanline_wait:             //the vertical blank period has begun. done in asm just 
<br/>
                        //because:)
<br/>
      ldrh   r1, [r0]
<br/>
      cmp   r1, #160
<br/>
      bne    scanline_wait
<br/>
   }         
<br/>
*/
<br/>
<br/>
while(REG_VCOUNT&lt;160);
<br/>
<br/>
}
<br/>
<br/>
///Copy our sprite array to OAM
<br/>
void CopyOAM(void)
<br/>
{
<br/>
   u16 loop;
<br/>
   u16* temp;
<br/>
   temp = (u16*)sprites;
<br/>
   for(loop = 0; loop &lt; 128*4; loop++)
<br/>
   {
<br/>
      OAM[loop] = temp[loop];
<br/>
   }
<br/>
}
<br/>
<br/>
///Test for key presses
<br/>
void GetInput(void)
<br/>
{
<br/>
   if(!(*KEYS &amp; KEY_UP))
<br/>
   {
<br/>
       y--;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_DOWN))
<br/>
   {
<br/>
       y++;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_LEFT))
<br/>
   {
<br/>
       x--;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_RIGHT))
<br/>
   {
<br/>
       x++;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_L))
<br/>
   {
<br/>
       angle--;
<br/>
      if(angle&lt;0)
<br/>
         angle = 359;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_R))
<br/>
   {
<br/>
       angle++;
<br/>
      if(angle &gt; 359)
<br/>
         angle = 0;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_A))
<br/>
   {
<br/>
       zoom--;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_B))
<br/>
   {
<br/>
       zoom++;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_START))
<br/>
   {
<br/>
       if(!(sprites[0].attribute0 &amp; SIZE_DOUBLE))//set or clear size double 
<br/>
      {                                 //needs if to keep from holding down the start
<br/>
         sprites[0].attribute0 |= SIZE_DOUBLE;
<br/>
         x-=32;                        //size double shifts the sprite center by half the width and height this just 
<br/>
         y-=32;                        //adjusts for it.
<br/>
      }
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_SELECT))
<br/>
   {
<br/>
       if((sprites[0].attribute0 &amp; SIZE_DOUBLE))
<br/>
      {
<br/>
         sprites[0].attribute0 &amp;= ~SIZE_DOUBLE;
<br/>
         x+=32;
<br/>
         y+=32;
<br/>
      }
<br/>
   }
<br/>
}
<br/>
<br/>
//move the sprite
<br/>
void MoveSprite(OAMEntry* sp, int x, int y)
<br/>
{
<br/>
   if(x &lt; 0)         //if it is off the left corect
<br/>
      x = 512 + x;
<br/>
   if(y &lt; 0)         //if off the top corect
<br/>
      y = 256 + y;
<br/>
<br/>
   sp-&gt;attribute1 = sp-&gt;attribute1 &amp; 0xFE00;  //clear the old x value
<br/>
   sp-&gt;attribute1 = sp-&gt;attribute1 | x;
<br/>
   
<br/>
   sp-&gt;attribute0 = sp-&gt;attribute0 &amp; 0xFF00;  //clear the old y value
<br/>
   sp-&gt;attribute0 = sp-&gt;attribute0 | y;
<br/>
}   
<br/>
void RotateSprite(int rotDataIndex, int angle, FIXED x_scale,FIXED y_scale)
<br/>
{
<br/>
   
<br/>
   FIXED pa,pb,pc,pd;
<br/>
<br/>
   pa = ((x_scale) * COS[angle])&gt;&gt;8;    //(do my fixed point multiplies and shift back down)
<br/>
   pb = ((y_scale) * SIN[angle])&gt;&gt;8;
<br/>
   pc = ((x_scale) * -SIN[angle])&gt;&gt;8;
<br/>
   pd = ((y_scale) * COS[angle])&gt;&gt;8;
<br/>
<br/>
<br/>
   rotData[rotDataIndex].pa = pa;  //put them in my data struct
<br/>
   rotData[rotDataIndex].pb = pb;
<br/>
   rotData[rotDataIndex].pc = pc;
<br/>
   rotData[rotDataIndex].pd = pd;
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5617 - Malefactor - Sat May 03, 2003 3:02 pm</h4>
    <div class="postbody"><span class="postbody">if you are using VBA, make sure you have the motion blur filter turned off.<br/>_________________<br/><a class="postlink" href="http://lorrd.fearware.net" target="_blank"></a><a href="http://mysite.verizon.net/vzep3wth/sitebuildercontent/sitebuilderpictures/lorrdbanner.gif">[Images not permitted - Click here to view it]</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5620 - pollier - Sat May 03, 2003 9:17 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//wait for the screen to stop drawing
<br/>
void WaitForVsync(void)
<br/>
{
<br/>
   
<br/>
<br/>
//lets get rid of htat inline asm we used in arm
<br/>
<br/>
/*
<br/>
   __asm 
<br/>
   {
<br/>
      mov    r0, #0x4000006   //0x4000006 is vertical trace counter; when it hits 160                //160 the vblanc starts
<br/>
      scanline_wait:             //the vertical blank period has begun. done in asm just 
<br/>
                        //because:)
<br/>
      ldrh   r1, [r0]
<br/>
      cmp   r1, #160
<br/>
      bne    scanline_wait
<br/>
   }         
<br/>
*/
<br/>
<br/>
while(REG_VCOUNT&lt;160);
<br/>
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
This is interesting... It should work fine, but you might want to watch out for skipping frames. I don't think that would be the cause of the blurring, however. 
<br/>
<br/>
V-Blank is the period in which it's safe to do anything to the display registers/memory without getting things like shearing on the LCD because the GBA is finished drawing scanlines for this frame.
<br/>
<br/>
If we're talking about a real 'blur' then it's definitely your emulator, but if the image is choppy or sheared then it might be either the emulator or the code.<br/>_________________<br/>(Works for me!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5625 - Link - Sun May 04, 2003 1:06 am</h4>
    <div class="postbody"><span class="postbody">what exactly do this??: </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> //wait for the screen to stop drawing 
<br/>
void WaitForVsync(void) 
<br/>
{ 
<br/>
    
<br/>
<br/>
//lets get rid of htat inline asm we used in arm 
<br/>
<br/>
/* 
<br/>
   __asm 
<br/>
   { 
<br/>
      mov    r0, #0x4000006   //0x4000006 is vertical trace counter; when it hits 160                //160 the vblanc starts 
<br/>
      scanline_wait:             //the vertical blank period has begun. done in asm just 
<br/>
                        //because:) 
<br/>
      ldrh   r1, [r0] 
<br/>
      cmp   r1, #160 
<br/>
      bne    scanline_wait 
<br/>
   }          
<br/>
*/ 
<br/>
<br/>
while(REG_VCOUNT&lt;160); 
<br/>
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
however the motion blur is disabled, and i usa VBA with parameters default.
<br/>
In the game (commercials) the blur don't appear but in my test yes!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5632 - antysix - Sun May 04, 2003 2:19 pm</h4>
    <div class="postbody"><span class="postbody">It waits for the screen to finish drawing.<br/>_________________<br/>Currently playing: NGC: Metroid Prime
<br/>
GBA: Golden Sun: The Lost Age
<br/>
<br/>
Currently developping: Project ~ [ Phail ]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5633 - Link - Sun May 04, 2003 2:27 pm</h4>
    <div class="postbody"><span class="postbody">how do u do?
<br/>
<br/>
Thanx for help! ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5634 - Touchstone - Sun May 04, 2003 2:51 pm</h4>
    <div class="postbody"><span class="postbody">A more proper wait-vsync is this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void WaitForVsync(void) 
<br/>
{
<br/>
    while(REG_VCOUNT == 160);
<br/>
    while(REG_VCOUNT != 160); 
<br/>
}</td> </tr></table><span class="postbody">
<br/>
This is safer to use if your processing-time of a frame is shorter than the vblank period.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5635 - Link - Sun May 04, 2003 3:09 pm</h4>
    <div class="postbody"><span class="postbody">Tnx much</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
