<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Fast Collision detection in Shoot 'em ups - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Fast Collision detection in Shoot 'em ups</h2>
<div id="posts">
<div class="post">
    <h4>#7477 - GBA Coda - Wed Jun 18, 2003 3:07 pm</h4>
    <div class="postbody"><span class="postbody">Hi Guys,
<br/>
<br/>
Anyone here know any fast ways of doing collision detection in shoot 'em ups?
<br/>
<br/>
kinda experiencing slowdown in my demo...
<br/>
<br/>
currently i have the player shooting 12 shots at a time, But when i get about 20 enemies on screen -*the game dies*-
<br/>
<br/>
help!
<br/>
<br/>
GBA Coda ( kinda )<br/>_________________<br/>Expression has no effect in function Main()!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7496 - tepples - Wed Jun 18, 2003 6:30 pm</h4>
    <div class="postbody"><span class="postbody">You're running into the O(n^2) comparisons of collision detection. Guess what else has O(n^2) comparisons? I'm guessing that the structure of your current comparison loop looks like that of a bubble sort. Collision detection is a type of search, and in general, sorting the data allows for more powerful search methods. Thus, game engine developers have improvised uses of sorting to speed things up.
<br/>
<br/>
Step 1: 1D sorting.  Before doing collision detection, do a Shell sort[1] on the sprites, keyed by the top edge of the sprite's bounding box.  Compare each sprite only to the following sprites whose top is above the current sprite's bottom. The speedup comes from the fact that in a top-to-bottom scan, once you've seen one sprite that's too far away to overlap, you've seen all the sprites that could potentially overlap.
<br/>
<br/>
Step 2: 2D sorting, or the sector method. This is much more complicated but can pay off when you have a LOT of larger sprites. <a class="postlink" href="http://www.google.com/search?q=collision+detection+sector+method" target="_blank">Look it up on Google</a> if collision detection turns out to be too slow even after adding sorting.
<br/>
<br/>
[1] <a class="postlink" href="http://www.wikipedia.org/wiki/Shell%20sort" target="_blank">Shell sort</a> is better than <a class="postlink" href="http://www.wikipedia.org/wiki/Quicksort" target="_blank">quicksort</a> for some applications such as collision detection. From frame to frame, the sprites will usually be nearly sorted. Shell sort is based on the insertion sort, which has better performance on nearly-sorted data than most quicksort variations.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7505 - Daniel Andersen - Wed Jun 18, 2003 9:16 pm</h4>
    <div class="postbody"><span class="postbody">If you want to do pixel-based collision detection, i.e. for overlapping rectangles, save with each sprite-frame a table with a word (32bit) for each row in that frame; each word then contains the whole row interpreted as bits instead of bytes, that is, each non-zero pixel n has its corresponding n'th bit set.
<br/>
<br/>
In this way collision detection is easy; on each row, first do a logical shift on a row of one of the tables to make the X-coordinates match, then do a AND on the resulting words (e.g. the two rows from the tables). If the result is non-zero a collision has occured, if it is zero no collision has occured. And there you have it! This pixelwise collision detection algorithm is linear, O(n) that is!
<br/>
<br/>
Needless to say you also have to compare the right table rows if the two sprites' Y-coordinates do not match.
<br/>
<br/>
I have implemented this algorithm in my Basic + Golden Environment called GNES (which is to come soon). It is very powerfull.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7529 - GBA Coda - Thu Jun 19, 2003 11:44 am</h4>
    <div class="postbody"><span class="postbody">Thanks a lot Guys! 
<br/>
<br/>
i'm gonna try that stuff :)<br/>_________________<br/>Expression has no effect in function Main()!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13159 - shunyata - Sat Dec 06, 2003 5:51 pm</h4>
    <div class="postbody"><span class="postbody">i cant help but wonder if insertionsort (shellsort with only the 1- increment) would be slightly faster on such small sets of nearly sorted data...?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
