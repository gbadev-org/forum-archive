<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Style Question - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Style Question</h2>
<div id="posts">
<div class="post">
    <h4>#163298 - Talen - Mon Sep 29, 2008 1:42 am</h4>
    <div class="postbody"><span class="postbody">im having a bit of a style delima
<br/>
<br/>
im working on some NDS code involving 64x64 tile BG's
<br/>
and what im wondering is i have 2 ways to deal with my position 2 memory index converter.
<br/>
<br/>
its a bit of a delima for me just want to know what someone else thinks
<br/>
<br/>
first way is 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define POS2IDX(x, y)   ((((x/32)+((y/32)+(y/32)))*32*32) + ((x%32) + ((y%32)*32)))
<br/>
<br/>
memoryMap[POS2IDX(x,y)] = tileId;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
the second way is 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// Number of tiles in a `small' map (i. e. not the full 64x64 one)
<br/>
const int _TILE_W = 32;
<br/>
const int _TILE_H = 32;
<br/>
<br/>
// Sets a tile in 64x64 map
<br/>
// It takes care of the fact that the DS puts 4 32x32 maps after each other
<br/>
void setTile(u16* memoryMap, int x, int y, const u16 tileId)
<br/>
{
<br/>
   int n;
<br/>
<br/>
   
<br/>
   if(x &gt;= _TILE_W &amp;&amp; y &gt;= _TILE_H)
<br/>
   {
<br/>
      n = 3;
<br/>
      x -= _TILE_W;
<br/>
      y -= _TILE_H;
<br/>
   }
<br/>
   else if(x &gt;= _TILE_W)
<br/>
   {
<br/>
      n = 1;
<br/>
      x -= _TILE_W;
<br/>
   }
<br/>
   else if(y &gt;= _TILE_H)
<br/>
   {
<br/>
      n = 2;
<br/>
      y -= _TILE_H;
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
      n = 0;
<br/>
   }
<br/>
<br/>
   memoryMap[n * _TILE_W * _TILE_H + x + y*_TILE_W] = tileId;
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163301 - Dwedit - Mon Sep 29, 2008 3:16 am</h4>
    <div class="postbody"><span class="postbody">Compile both with -S and see which one executes fewer instructions.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163322 - Miked0801 - Mon Sep 29, 2008 4:33 pm</h4>
    <div class="postbody"><span class="postbody">My calcs show that if you change around the if check, they will both run roughly the same speed:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
(2 * y/32 + x/32) * 1024 + (y &amp; 0x1F) * 32 + x &amp; 0x1F
<br/>
<br/>
r0 add y,shift 5
<br/>
r1 add x, shift 5
<br/>
r0 add r1
<br/>
shift 10
<br/>
and Y shift 5
<br/>
and x 1f
<br/>
add x,y
<br/>
mem op
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
vs
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
n=0;
<br/>
<br/>
if(x &gt; W)
<br/>
{
<br/>
    x |= 1024;
<br/>
}
<br/>
<br/>
if(y &gt; H)
<br/>
{
<br/>
    y |= 2048;
<br/>
}
<br/>
memMap[n + x + y *W] = tileId;
<br/>
<br/>
mov reg,0
<br/>
cmp r1, W
<br/>
orrgt reg,#
<br/>
cmp r2,H
<br/>
orrgt reg,#
<br/>
add x,reg
<br/>
add reg,y,shift
<br/>
<br/>
memop
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
So both take around 7 cycles to setup in ARM and then the mem op.  If you can change your math a bit so that you aren't relying on integer math to shift away extra low bits, you can make the 1st version 1 or 2 cycles faster.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163340 - Talen - Tue Sep 30, 2008 1:13 am</h4>
    <div class="postbody"><span class="postbody">i managed to talk to my old professor today he recomened using the first option with shifts and xor   and if i can masks
<br/>
<br/>
its been real funn teaching myself bitwise operations........   since i just hadda take C++ classes instead of C lol
<br/>
<br/>
edit** 
<br/>
my final code ended up being
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define POS2IDX(x, y)   ((((x&gt;&gt;5)+((y&gt;&gt;5)+(y&gt;&gt;5)))&lt;&lt;10) + ((x&amp;31) + ((y&amp;31)&lt;&lt;5)))</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163544 - furrykef - Sat Oct 04, 2008 6:36 pm</h4>
    <div class="postbody"><span class="postbody">I think you should use an inline function instead of a macro, so it would look something like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">inline unsigned int Pos2Idx(unsigned int x, unsigned int y)
<br/>
{
<br/>
  return (((x/32)+((y/32)+(y/32)))*32*32) + ((x%32) + ((y%32)*32));
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I went with the version with multiplies, divisions, and mods because it's clearer and it should compile to the same code (as long as the variables are unsigned).
<br/>
<br/>
Functions tend to have more intuitive behavior than macros and you should prefer them whenever possible.
<br/>
<br/>
- Kef</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163606 - Cearn - Mon Oct 06, 2008 1:12 pm</h4>
    <div class="postbody"><span class="postbody">Two small notes on what furrykef said. First, GCC is somewhat odd in how it handles the `inline' keyword. With just `inline', a linkable symbol will still be created in each file the function is #included into, giving linker errors concerning multiple definitions. To avoid that, use `static inline'. Second, basic arithmetic (+-*/%) don't need so many parentheses and it's probably clearer with fewer them:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// NOTE: the *2 is required only for 64x64 BGs. 
<br/>
static inline unsigned int Pos2Idx(unsigned int x, unsigned int y)
<br/>
{
<br/>
    return (x/32 + y/32*2)*32*32 + x%32 + y%32*32;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Other than that, what he said.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163612 - furrykef - Mon Oct 06, 2008 4:03 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, I simply copied the line from the macro so I didn't bother removing all those extra parentheses. Mainly because I didn't want to do it wrong and screw the whole thing up, I guess.
<br/>
<br/>
Anyway, using "static inline" shouldn't be necessary if you're compiling C++ code, but it seems that it is if you're compiling C code. (Using "static inline" in C++ code probably wouldn't hurt, though.) Nice catch. Is it required when you compile in C99 mode as well? I think GCC still defaults to C89 mode.
<br/>
<br/>
- Kef</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163676 - ninjalj - Wed Oct 08, 2008 5:09 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">First, GCC is somewhat odd in how it handles the `inline' keyword. With just `inline', a linkable symbol will still be created in each file the function is #included into, giving linker errors concerning multiple definitions. To avoid that, use `static inline'. </td> </tr></table><span class="postbody">
<br/>
<br/>
Well, that's because in C static symbols have scope limited to the compilation unit (.c file), while non static symbols can be seen from any compilation unit. 
<br/>
<br/>
Thus, an inline function is compiled inline when called from the current compilation unit, but also has a non inline expansion for external (to the current compilation unit) calls. static inline functions don't need the non inline expansion.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
