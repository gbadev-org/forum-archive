<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>gba.h modification suggestions anyone? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > gba.h modification suggestions anyone?</h2>
<div id="posts">
<div class="post">
    <h4>#49322 - jarobi - Thu Jul 28, 2005 5:36 pm</h4>
    <div class="postbody"><span class="postbody">Hi all!  I have an old copy of gba.h that I can't stand to part with because I have made various modifications and corrections; most of which I can't remember.  There are a few issues with this version I am concerned about though.  Some registers are not defined as volatile when they should be and some of the type definitions are shady (e.g. u16's are shorts as expected, but u32's are longs... why is that?).  Also, at the time this file was made, the purpose of some of the registers was unknown, like windowing for example.  I could scour all of the the CowBite specs and correct all this information, but given the amount of documentation and the very little time I have in between school, it is not very practical to do so.  That's why I'm asking anyone who has a little bit of time to correct at least one thing or suggest something that would help me make this file as accurate as possible.  Thanks in advance!
<br/>
<br/>
FYI: I renamed gba.h to gbareg.h
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*****************************\
<br/>
*    gbareg.h
<br/>
*   Original by eloist
<br/>
*   Modified by staringmonkey
<br/>
*  Modified by Uze
<br/>
*   Last modified on 29/11/2001
<br/>
\*****************************/
<br/>
<br/>
//////////////////////////////////////////////////////////////////////////////
<br/>
// GBAREG.h                                                                    //
<br/>
//////////////////////////////////////////////////////////////////////////////
<br/>
#ifndef   _GBAREG_H_
<br/>
#define   _GBAREG_H_
<br/>
<br/>
<br/>
<br/>
//#ifdef __cplusplus
<br/>
//extern "C" {
<br/>
//#endif
<br/>
<br/>
/////////////Type Definitions/////////////
<br/>
typedef unsigned char u8;
<br/>
typedef unsigned short u16;
<br/>
typedef unsigned long u32;
<br/>
<br/>
typedef volatile unsigned char vu8;
<br/>
typedef volatile unsigned short vu16;
<br/>
typedef volatile unsigned long vu32;
<br/>
<br/>
typedef const unsigned char const_u8;
<br/>
typedef const unsigned short const_u16;
<br/>
typedef const unsigned long const_u32;
<br/>
<br/>
typedef signed char s8;
<br/>
typedef signed short s16;
<br/>
typedef signed long s32;
<br/>
<br/>
typedef unsigned char byte;
<br/>
typedef unsigned short hword;
<br/>
typedef unsigned long word;
<br/>
typedef void (*fp)(void);   //this is the definition you will find in gba.h.  It is just delaring fp to represent a pointer to a function
<br/>
<br/>
#define TMR_PRESCALER_1CK       0x0000  // Prescaler 1 Clock
<br/>
#define TMR_PRESCALER_64CK      0x0001  //            64 clocks
<br/>
#define TMR_PRESCALER_256CK     0x0002  //          256 clocks
<br/>
#define TMR_PRESCALER_1024CK    0x0003  //        1024 clocks
<br/>
#define TMR_IF_ENABLE           0x0040  // Interrupt Request Enable
<br/>
#define TMR_ENABLE              0x0080  // Run Timer
<br/>
<br/>
///////////////Interrupts/////////////////////////////
<br/>
#define INT_VBLANK 0x0001
<br/>
#define INT_HBLANK 0x0002
<br/>
#define INT_VCOUNT 0x0004 //you can set the display to generate an interrupt when it reaches a particular line on the screen
<br/>
#define INT_TIMER0 0x0008
<br/>
#define INT_TIMER1 0x0010
<br/>
#define INT_TIMER2 0x0020
<br/>
#define INT_TIMER3 0x0040
<br/>
#define INT_COMUNICATION 0x0080 //serial communication interupt
<br/>
#define INT_DMA0 0x0100
<br/>
#define INT_DMA1 0x0200
<br/>
#define INT_DMA2 0x0400
<br/>
#define INT_DMA3 0x0800
<br/>
#define INT_KEYBOARD 0x1000
<br/>
#define INT_CART 0x2000 //the cart can actually generate an interupt
<br/>
#define INT_ALL 0x4000 //this is just a flag we can set to allow the my function to enable or disable all interrupts. Doesn't actually correspond to a bit in REG_IE
<br/>
<br/>
////////////////sound channels/////////////
<br/>
#define SOUNDINIT         0x8000   // makes the sound restart
<br/>
#define SOUNDDUTY87         0x0000   //87.5% wave duty
<br/>
#define SOUNDDUTY75         0x0040   //75% wave duty
<br/>
#define SOUNDDUTY50         0x0080   //50% wave duty
<br/>
#define SOUNDDUTY25         0x00C0   //25% wave duty
<br/>
<br/>
#define SOUND1PLAYONCE      0x4000   // play sound once
<br/>
#define SOUND1PLAYLOOP      0x0000   // play sound looped
<br/>
#define SOUND1INIT         0x8000   // makes the sound restart
<br/>
#define SOUND1SWEEPSHIFTS(n)   n   // number of sweep shifts (0-7)
<br/>
#define SOUND1SWEEPINC      0x0000   // sweep add (freq increase)
<br/>
#define SOUND1SWEEPDEC      0x0008   // sweep dec (freq decrese)
<br/>
#define SOUND1SWEEPTIME(n)   (n&lt;&lt;4)   // time of sweep (0-7)
<br/>
#define SOUND1ENVSTEPS(n)   (n&lt;&lt;8)   // envelope steps (0-7)
<br/>
#define SOUND1ENVINC      0x0800   // envellope increase
<br/>
#define SOUND1ENVDEC      0x0000   // envellope decrease
<br/>
#define SOUND1ENVINIT(n)   (n&lt;&lt;12) // initial envelope volume (0-15)
<br/>
<br/>
<br/>
#define SOUND2PLAYONCE      0x4000   // play sound once
<br/>
#define SOUND2PLAYLOOP      0x0000   // play sound looped
<br/>
#define SOUND2INIT         0x8000   // makes the sound restart
<br/>
#define SOUND2ENVSTEPS(n)   (n&lt;&lt;8)   // envelope steps (0-7)
<br/>
#define SOUND2ENVINC      0x0800   // envellope increase
<br/>
#define SOUND2ENVDEC      0x0000   // envellope decrease
<br/>
#define SOUND2ENVINIT(n)   (n&lt;&lt;12) // initial envelope volume (0-15)
<br/>
<br/>
<br/>
<br/>
#define SOUND3BANK32      0x0000   // Use two banks of 32 steps each
<br/>
#define SOUND3BANK64      0x0020   // Use one bank of 64 steps
<br/>
#define SOUND3SETBANK0      0x0000   // Bank to play 0 or 1 (non set bank is written to)
<br/>
#define SOUND3SETBANK1      0x0040
<br/>
#define SOUND3PLAY         0x0080   // Output sound
<br/>
<br/>
#define SOUND3OUTPUT0      0x0000   // Mute output
<br/>
#define SOUND3OUTPUT1      0x2000   // Output unmodified
<br/>
#define SOUND3OUTPUT12      0x4000   // Output 1/2
<br/>
#define SOUND3OUTPUT14      0x6000   // Output 1/4
<br/>
#define SOUND3OUTPUT34      0x8000  // Output 3/4
<br/>
<br/>
#define SOUND3PLAYONCE      0x4000   // Play sound once
<br/>
#define SOUND3PLAYLOOP      0x0000   // Play sound looped
<br/>
#define SOUND3INIT         0x8000   // Makes the sound restart
<br/>
<br/>
<br/>
#define SOUND4PLAYONCE      0x4000   // play sound once
<br/>
#define SOUND4PLAYLOOP      0x0000   // play sound looped
<br/>
#define SOUND4INIT         0x8000   // makes the sound restart
<br/>
#define SOUND4ENVSTEPS(n)   (n&lt;&lt;8)   // envelope steps (0-7)
<br/>
#define SOUND4ENVINC      0x0800   // envellope increase
<br/>
#define SOUND4ENVDEC      0x0000   // envellope decrease
<br/>
#define SOUND4ENVINIT(n)   (n&lt;&lt;12) // initial envelope volume (0-15)
<br/>
<br/>
<br/>
#define SOUND4STEPS7      0x0004
<br/>
#define SOUND4STEPS15      0x0000
<br/>
#define SOUND4PLAYONCE      0x4000
<br/>
#define SOUND4PLAYLOOP      0x0000
<br/>
#define SOUND4INIT         0x8000
<br/>
<br/>
/////////////////Registers/////////////////
<br/>
#define REG_INTERUPT   *(u32*)0x3007FFC      //Interrupt Register
<br/>
#define REG_IRQ_HAND   *(fp)0x3007FFC      //Interrupt Request Handler Location
<br/>
#define REG_DISPCNT    *(u32*)0x4000000      //Display Control (Mode)
<br/>
#define REG_DISPCNT_L  *(u16*)0x4000000      //???
<br/>
#define REG_DISPCNT_H  *(u16*)0x4000002      //???
<br/>
#define REG_DISPSTAT   *(vu16*)0x4000004   //VBlank, HBlank, VTrigger Status
<br/>
#define REG_VCOUNT     *(vu16*)0x4000006   //Vertical Control (Sync)
<br/>
#define REG_BG0CNT     *(u16*)0x4000008      //Background 0
<br/>
#define REG_BG1CNT     *(u16*)0x400000A      //Background 1
<br/>
#define REG_BG2CNT     *(u16*)0x400000C      //Background 2
<br/>
#define REG_BG3CNT     *(u16*)0x400000E      //Background 3
<br/>
#define REG_BG0HOFS    *(u16*)0x4000010      //Background 0 Horizontal Offset
<br/>
#define REG_BG0VOFS    *(u16*)0x4000012      //Background 0 Vertical Offset
<br/>
#define REG_BG1HOFS    *(u16*)0x4000014      //Background 1 Horizontal Offset
<br/>
#define REG_BG1VOFS    *(u16*)0x4000016      //Background 1 Vertical Offset
<br/>
#define REG_BG2HOFS    *(u16*)0x4000018      //Background 2 Horizontal Offset
<br/>
#define REG_BG2VOFS    *(u16*)0x400001A      //Background 2 Vertical Offset
<br/>
#define REG_BG3HOFS    *(u16*)0x400001C      //Background 3 Horizontal Offset
<br/>
#define REG_BG3VOFS    *(u16*)0x400001E      //Background 3 Vertical Offset
<br/>
#define REG_BG2PA      *(u16*)0x4000020      //Background 2 PA Rotation (pa = x_scale * cos(angle);)
<br/>
#define REG_BG2PB      *(u16*)0x4000022      //Background 2 PB Rotation (pb = y_scale * sin(angle);)
<br/>
#define REG_BG2PC      *(u16*)0x4000024      //Background 2 PC Rotation (pc = x_scale * -sin(angle);)
<br/>
#define REG_BG2PD      *(u16*)0x4000026      //Background 2 PD Rotation (pd = y_scale * cos(angle);)
<br/>
#define REG_BG2X       *(u32*)0x4000028      //Background 2 X Location
<br/>
#define REG_BG2X_L     *(u16*)0x4000028      //???
<br/>
#define REG_BG2X_H     *(u16*)0x400002A      //???
<br/>
#define REG_BG2Y       *(u32*)0x400002C      //Background 2 Y Location
<br/>
#define REG_BG2Y_L     *(u16*)0x400002C      //???
<br/>
#define REG_BG2Y_H     *(u16*)0x400002E      //???
<br/>
#define REG_BG3PA      *(u16*)0x4000030      //Background 3 PA Rotation (pa = x_scale * cos(angle);)
<br/>
#define REG_BG3PB      *(u16*)0x4000032      //Background 3 PB Rotation (pb = y_scale * sin(angle);)
<br/>
#define REG_BG3PC      *(u16*)0x4000034      //Background 3 PC Rotation (pc = x_scale * -sin(angle);)
<br/>
#define REG_BG3PD      *(u16*)0x4000036      //Background 3 PD Rotation (pd = y_scale * cos(angle);)
<br/>
#define REG_BG3X       *(u32*)0x4000038      //Background 3 X Location
<br/>
#define REG_BG3X_L     *(u16*)0x4000038      //???
<br/>
#define REG_BG3X_H     *(u16*)0x400003A      //???
<br/>
#define REG_BG3Y       *(u32*)0x400003C      //Background 3 Y Location
<br/>
#define REG_BG3Y_L     *(u16*)0x400003C      //???
<br/>
#define REG_BG3Y_H     *(u16*)0x400003E      //???
<br/>
#define REG_WIN0H      *(u16*)0x4000040      //Window 0 X coords (bits 0-7 right, bits 8-16 left)
<br/>
#define REG_WIN1H      *(u16*)0x4000042      //Window 1 X coords (bits 0-7 right, bits 8-16 left)
<br/>
#define REG_WIN0V      *(u16*)0x4000044      //Window 0 Y coords (bits 0-7 bottom, bits 8-16 top)
<br/>
#define REG_WIN1V      *(u16*)0x4000046      //Window 1 Y coords (bits 0-7 bottom, bits 8-16 top)
<br/>
#define REG_WININ      *(u16*)0x4000048      //Inside Window Settings
<br/>
#define REG_WINOUT     *(u16*)0x400004A      //Outside Window Settings
<br/>
#define REG_MOSAIC     *(u32*)0x400004C      //Mosaic Mode
<br/>
#define REG_MOSAIC_L   *(u32*)0x400004C      //???
<br/>
#define REG_MOSAIC_H   *(u32*)0x400004E      //???
<br/>
#define REG_BLDMOD     *(u16*)0x4000050      //Blend Mode
<br/>
#define REG_BLDCNT     *(u16*)0x4000050      //Blend Mode under updated name
<br/>
#define REG_COLEV      *(u16*)0x4000052      //Alpha blending coefficients
<br/>
#define REG_BLDALPHA   *(u16*)0x4000052      //Alpha blending coefficients under updated name
<br/>
#define REG_COLEY      *(u16*)0x4000054      //Brightness
<br/>
#define REG_BLDY       *(u16*)0x4000054      //Brightness under updated name
<br/>
<br/>
#define REG_SOUND1CNT   *(vu32*)0x4000060      //sound 1
<br/>
#define REG_SOUND1CNT_L *(vu16*)0x4000060      //
<br/>
#define REG_SOUND1CNT_H *(vu16*)0x4000062      //
<br/>
#define REG_SOUND1CNT_X *(vu16*)0x4000064      //
<br/>
<br/>
#define REG_SOUND2CNT_L *(vu16*)0x4000068      //sound 2 lenght &amp; wave duty
<br/>
#define REG_SOUND2CNT_H *(vu16*)0x400006C      //sound 2 frequency+loop+reset
<br/>
<br/>
#define REG_SG30       *(vu32*)0x4000070      //???
<br/>
#define REG_SOUND3CNT  *(vu32*)0x4000070      //???
<br/>
#define REG_SG30_L     *(vu16*)0x4000070      //???
<br/>
#define REG_SOUND3CNT_L *(vu16*)0x4000070      //???
<br/>
#define REG_SG30_H     *(vu16*)0x4000072      //???
<br/>
#define REG_SOUND3CNT_H *(vu16*)0x4000072      //???
<br/>
#define REG_SG31       *(vu16*)0x4000074      //???
<br/>
#define REG_SOUND3CNT_X *(vu16*)0x4000074      //???
<br/>
<br/>
#define REG_SOUND4CNT_L *(vu16*)0x4000078      //???
<br/>
#define REG_SOUND4CNT_H *(vu16*)0x400007C      //???
<br/>
<br/>
#define REG_SGCNT0     *(vu32*)0x4000080
<br/>
#define REG_SGCNT0_L   *(vu16*)0x4000080
<br/>
#define REG_SOUNDCNT   *(vu32*)0x4000080
<br/>
#define REG_SOUNDCNT_L *(vu16*)0x4000080      //DMG sound control
<br/>
<br/>
#define REG_SGCNT0_H   *(vu16*)0x4000082
<br/>
#define REG_SOUNDCNT_H *(vu16*)0x4000082      //Direct sound control
<br/>
<br/>
#define REG_SGCNT1     *(vu16*)0x4000084
<br/>
#define REG_SOUNDCNT_X *(vu16*)0x4000084       //Extended sound control
<br/>
<br/>
#define REG_SGBIAS     *(vu16*)0x4000088
<br/>
#define REG_SOUNDBIAS  *(vu16*)0x4000088      //bit rate+sound bias
<br/>
<br/>
#define REG_WAVE_RAM0  *(vu32*)0x4000090      //???
<br/>
#define REG_SGWR0_L    *(vu16*)0x4000090      //???
<br/>
#define REG_SGWR0_H    *(vu16*)0x4000092      //???
<br/>
#define REG_WAVE_RAM1  *(vu32*)0x4000094      //???
<br/>
#define REG_SGWR1_L    *(vu16*)0x4000094      //???
<br/>
#define REG_SGWR1_H    *(vu16*)0x4000096      //???
<br/>
#define REG_WAVE_RAM2  *(vu32*)0x4000098      //???
<br/>
#define REG_SGWR2_L    *(vu16*)0x4000098      //???
<br/>
#define REG_SGWR2_H    *(vu16*)0x400009A      //???
<br/>
#define REG_WAVE_RAM3  *(vu32*)0x400009C      //???
<br/>
#define REG_SGWR3_L    *(vu16*)0x400009C      //???
<br/>
#define REG_SGWR3_H    *(vu16*)0x400009E      //???
<br/>
<br/>
#define REG_SGFIFOA    *(vu32*)0x40000A0      //???
<br/>
#define REG_SGFIFOA_L  *(vu16*)0x40000A0      //???
<br/>
#define REG_SGFIFOA_H  *(vu16*)0x40000A2      //???
<br/>
#define REG_SGFIFOB    *(vu32*)0x40000A4      //???
<br/>
#define REG_SGFIFOB_L  *(vu16*)0x40000A4      //???
<br/>
#define REG_SGFIFOB_H  *(vu16*)0x40000A6      //???
<br/>
#define REG_DMA0SAD     *(u32*)0x40000B0      //DMA0 Source Address
<br/>
#define REG_DMA0SAD_L   *(u16*)0x40000B0      //DMA0 Source Address Low Value
<br/>
#define REG_DMA0SAD_H   *(u16*)0x40000B2      //DMA0 Source Address High Value
<br/>
#define REG_DMA0DAD     *(u32*)0x40000B4      //DMA0 Destination Address
<br/>
#define REG_DMA0DAD_L   *(u16*)0x40000B4      //DMA0 Destination Address Low Value
<br/>
#define REG_DMA0DAD_H   *(u16*)0x40000B6      //DMA0 Destination Address High Value
<br/>
#define REG_DMA0CNT     *(u32*)0x40000B8      //DMA0 Control (Amount)
<br/>
#define REG_DMA0CNT_L   *(u16*)0x40000B8      //DMA0 Control Low Value
<br/>
#define REG_DMA0CNT_H   *(u16*)0x40000BA      //DMA0 Control High Value
<br/>
<br/>
#define REG_DMA1SAD     *(u32*)0x40000BC      //DMA1 Source Address
<br/>
#define REG_DMA1SAD_L   *(u16*)0x40000BC      //DMA1 Source Address Low Value
<br/>
#define REG_DMA1SAD_H   *(u16*)0x40000BE      //DMA1 Source Address High Value
<br/>
#define REG_DMA1DAD     *(u32*)0x40000C0      //DMA1 Desination Address
<br/>
#define REG_DMA1DAD_L   *(u16*)0x40000C0      //DMA1 Destination Address Low Value
<br/>
#define REG_DMA1DAD_H   *(u16*)0x40000C2      //DMA1 Destination Address High Value
<br/>
#define REG_DMA1CNT     *(u32*)0x40000C4      //DMA1 Control (Amount)
<br/>
#define REG_DMA1CNT_L   *(u16*)0x40000C4      //DMA1 Control Low Value
<br/>
#define REG_DMA1CNT_H   *(u16*)0x40000C6      //DMA1 Control High Value
<br/>
<br/>
#define REG_DMA2SAD     *(u32*)0x40000C8      //DMA2 Source Address
<br/>
#define REG_DMA2SAD_L   *(u16*)0x40000C8      //DMA2 Source Address Low Value
<br/>
#define REG_DMA2SAD_H   *(u16*)0x40000CA      //DMA2 Source Address High Value
<br/>
#define REG_DMA2DAD     *(u32*)0x40000CC      //DMA2 Destination Address
<br/>
#define REG_DMA2DAD_L   *(u16*)0x40000CC      //DMA2 Destination Address Low Value
<br/>
#define REG_DMA2DAD_H   *(u16*)0x40000CE      //DMA2 Destination Address High Value
<br/>
#define REG_DMA2CNT     *(u32*)0x40000D0      //DMA2 Control (Amount)
<br/>
#define REG_DMA2CNT_L   *(u16*)0x40000D0      //DMA2 Control Low Value
<br/>
#define REG_DMA2CNT_H   *(u16*)0x40000D2      //DMA2 Control High Value
<br/>
<br/>
#define REG_DMA3SAD     *(u32*)0x40000D4      //DMA3 Source Address
<br/>
#define REG_DMA3SAD_L   *(u16*)0x40000D4      //DMA3 Source Address Low Value
<br/>
#define REG_DMA3SAD_H   *(u16*)0x40000D6      //DMA3 Source Address High Value
<br/>
#define REG_DMA3DAD     *(u32*)0x40000D8      //DMA3 Destination Address
<br/>
#define REG_DMA3DAD_L   *(u16*)0x40000D8      //DMA3 Destination Address Low Value
<br/>
#define REG_DMA3DAD_H   *(u16*)0x40000DA      //DMA3 Destination Address High Value
<br/>
#define REG_DMA3CNT     *(u32*)0x40000DC      //DMA3 Control (Amount)
<br/>
#define REG_DMA3CNT_L   *(u16*)0x40000DC      //DMA3 Control Low Value
<br/>
#define REG_DMA3CNT_H   *(u16*)0x40000DE      //DMA3 Control High Value
<br/>
<br/>
#define REG_TM0D        *(vu16*)0x4000100      //Timer 0 counter
<br/>
#define REG_TM0CNT      *(u16*)0x4000102      //Timer 0 control
<br/>
#define REG_TM1D        *(vu16*)0x4000104      //Timer 1 counter
<br/>
#define REG_TM1CNT      *(u16*)0x4000106      //Timer 1 control
<br/>
#define REG_TM2D        *(vu16*)0x4000108      //Timer 2 counter
<br/>
#define REG_TM2CNT      *(u16*)0x400010A      //Timer 2 control
<br/>
#define REG_TM3D        *(vu16*)0x400010C      //Timer 3 counter
<br/>
#define REG_TM3CNT      *(u16*)0x400010E      //Timer 3 control
<br/>
<br/>
#define REG_SCD0       *(u16*)0x4000120      //32-bit Normal Serial Communication Data 0 / Multi-play
<br/>
#define REG_SCD1       *(u16*)0x4000122      //32-bit Normal Serial Communication Data 1 /Multi-play
<br/>
#define REG_SCD2       *(u16*)0x4000124      //Multi-play Communication Data 2
<br/>
#define REG_SCD3       *(u16*)0x4000126      //Multi-play Communication Data 3
<br/>
#define REG_SCCNT      *(u32*)0x4000128      //???
<br/>
#define REG_SCCNT_L    *(u16*)0x4000128      //???
<br/>
#define REG_SCCNT_H    *(u16*)0x400012A      //???
<br/>
#define REG_P1         *(vu16*)0x4000130      //Player 1 Input
<br/>
#define REG_KEYPAD     *(vu16*)0x4000130      //Player 1 Input
<br/>
#define REG_P1CNT      *(vu16*)0x4000132      //Player 1 Input Interrupt Status
<br/>
#define REG_KEYCNT     *(vu16*)0x4000132      //REG_P1CNT alias
<br/>
#define REG_R          *(u16*)0x4000134      //???
<br/>
#define REG_HS_CTRL    *(u16*)0x4000140      //???
<br/>
#define REG_JOYRE      *(u32*)0x4000150      //???
<br/>
#define REG_JOYRE_L    *(u16*)0x4000150      //???
<br/>
#define REG_JOYRE_H    *(u16*)0x4000152      //???
<br/>
#define REG_JOYTR      *(u32*)0x4000154      //???
<br/>
#define REG_JOYTR_L    *(u16*)0x4000154      //???
<br/>
#define REG_JOYTR_H    *(u16*)0x4000156      //???
<br/>
#define REG_JSTAT      *(u32*)0x4000158      //???
<br/>
#define REG_JSTAT_L    *(u16*)0x4000158      //???
<br/>
#define REG_JSTAT_H    *(u16*)0x400015A      //???
<br/>
#define REG_IE         *(u16*)0x4000200      //Interrupt Enable
<br/>
#define REG_IF         *(vu16*)0x4000202      //Interrupt Flags
<br/>
#define REG_WSCNT      *(u16*)0x4000204      //Wait State Control
<br/>
#define REG_IME        *(u16*)0x4000208      //Interrupt Master Enable
<br/>
#define REG_PAUSE      *(u16*)0x4000300      //Pause
<br/>
<br/>
<br/>
//#ifdef __cplusplus
<br/>
//}      /* extern "C" */
<br/>
//#endif
<br/>
<br/>
<br/>
#endif   // _GBAREG_H_
<br/>
<br/>
</td> </tr></table><span class="postbody">[/code]<br/>_________________<br/>Nihongo o hanasemasen!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49323 - tepples - Thu Jul 28, 2005 5:49 pm</h4>
    <div class="postbody"><span class="postbody">The slickest trick is making the DMA, timers, and other array-like registers into macros that act like arrays. This lets a single function work on multiple background layers.
<br/>
<br/>
First off, BG0CNT through BG3CNT become this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/* From pin8gba.h */
<br/>
#define BGCTRL ((volatile u16 *)0x04000008)
<br/>
</td> </tr></table><span class="postbody">
<br/>
For example, BG0CNT through BG3CNT turn into BGCTRL[0] through BGCTRL[3] or even BGCTRL[x] if x is a variable.
<br/>
<br/>
Similarly with the scrolling registers:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/* From pin8gba.h */
<br/>
struct BGPOINT
<br/>
{
<br/>
  u16 x, y;
<br/>
};
<br/>
<br/>
#define BGSCROLL ((volatile struct BGPOINT *)0x04000010)</td> </tr></table><span class="postbody">
<br/>
Then BG0HOFS becomes BGSCROLL[0].x, BG2VOFS becomes BGSCROLL[2].y, etc.
<br/>
<br/>
Continuing with the affine registers, the DMA registers, the timer registers, and even the text-mode background maps in VRAM:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/* From pin8gba.h */
<br/>
struct BGAFFINEREC
<br/>
{
<br/>
  s16 pa;  /* map_x increment per pixel */
<br/>
  s16 pb;  /* map_x increment per scanline */
<br/>
  s16 pc;  /* map_y increment per pixel */
<br/>
  s16 pd;  /* map_y increment per scanline */
<br/>
  u32 x_origin, y_origin;
<br/>
};
<br/>
<br/>
#define BGAFFINE ((volatile struct BGAFFINEREC *)0x04000000)
<br/>
<br/>
struct DMACHN
<br/>
{
<br/>
  const void *src;
<br/>
  void *dst;
<br/>
  u16 count;
<br/>
  u16 control;
<br/>
};
<br/>
<br/>
#define DMA ((volatile struct DMACHN *)0x040000b0)
<br/>
<br/>
typedef struct TIMER_REC
<br/>
{
<br/>
  unsigned short count;
<br/>
  unsigned short control;
<br/>
} TIMER_REC;
<br/>
<br/>
#define TIMER ((volatile TIMER_REC *)0x04000100)
<br/>
<br/>
typedef u16 NAMETABLE[32][32];
<br/>
<br/>
#define MAP ((NAMETABLE *)0x06000000)</td> </tr></table><span class="postbody">
<br/>
Access a single element at (x, y) of map n using MAP[n][y][x].
<br/>
<br/>
And here's where it gets tricky. I use actual macros rather than fake arrays for computation of addresses of tile pattern data in VRAM.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/* From pin8gba.h */
<br/>
#define PATRAM(x) ((u32 *)(0x06000000 | ((x) &lt;&lt; 14)))
<br/>
#define PATRAM4(x, tn) ((u32 *)(0x06000000 | (((x) &lt;&lt; 14) + ((tn) &lt;&lt; 5)) ))
<br/>
#define PATRAM8(x, tn) ((u32 *)(0x06000000 | (((x) &lt;&lt; 14) + ((tn) &lt;&lt; 6)) ))
<br/>
#define SPR_VRAM(tn) ((u32 *)(0x06010000 | ((tn) &lt;&lt; 5)))
<br/>
</td> </tr></table><span class="postbody">
<br/>
where x is the ID of the pattern table (from 0 to 3) and tn is the tile number.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49325 - jarobi - Thu Jul 28, 2005 6:02 pm</h4>
    <div class="postbody"><span class="postbody">That is some neat stuff! Thanks tepples! Anyone else have a suggestion?<br/>_________________<br/>Nihongo o hanasemasen!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49394 - Cearn - Fri Jul 29, 2005 10:11 am</h4>
    <div class="postbody"><span class="postbody">You can use fake arrays for tiles/pattern data too:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// tile 8x8@4bpp: 32bytes; 8 ints
<br/>
typedef struct { u32 data[8];  } TILE, TILE4;
<br/>
<br/>
// tile block: 32x16 tiles
<br/>
typedef TILE CHARBLOCK[512];
<br/>
<br/>
#define tile_mem ((CHARBLOCK*)0x06000000)
<br/>
</td> </tr></table><span class="postbody">
<br/>
Then use it like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//In code somewhere
<br/>
TILE *ptr= &amp;tile_mem[4][12];   // point to block 4 (== lower object block), tile 12
<br/>
<br/>
// Copy a tile from attached data to sprite-VRAM, tile 12
<br/>
tile_mem[4][12] = *(TILE*)spriteData;
<br/>
</td> </tr></table><span class="postbody">
<br/>
It may take a little used to but it's actually pretty easy. Good deal faster than u16/u32 array copies too. It does rely on the source data to be 4-byte aligned, though. If you feel like it, you can do something similar for palettes. 
<br/>
<br/>
Also, as to the 'long' type. In ancient history, CPUs were 16bit and the types were <span style="font-weight: bold">char</span> (8bit), <span style="font-weight: bold">short</span> (16bit) and <span style="font-weight: bold">long</span> (32bit). The <span style="font-weight: bold">int</span> type was usually set to the CPU size: then 16bit and synomynous with short. Then came 32bit chips and the int-size became 32bit, an alias for long. By the way, does anyone know what this is for 64bit chips, and beyond?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49400 - NighTiger - Fri Jul 29, 2005 1:31 pm</h4>
    <div class="postbody"><span class="postbody">something like that:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define RGB(r,g,b,) ((u16) (r | (g&lt;&lt;5) | (b&lt;&lt;10)))
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49421 - poslundc - Fri Jul 29, 2005 5:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">Also, as to the 'long' type. In ancient history, CPUs were 16bit and the types were <span style="font-weight: bold">char</span> (8bit), <span style="font-weight: bold">short</span> (16bit) and <span style="font-weight: bold">long</span> (32bit). The <span style="font-weight: bold">int</span> type was usually set to the CPU size: then 16bit and synomynous with short. Then came 32bit chips and the int-size became 32bit, an alias for long. By the way, does anyone know what this is for 64bit chips, and beyond?</td> </tr></table><span class="postbody">
<br/>
<br/>
Do 64-bit chips actually have 64-bit register width for their general-purpose registers? (Asks the guy with a 6-year-old computer.) That seems so wasteful, if true.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49422 - strager - Fri Jul 29, 2005 6:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">Do 64-bit chips actually have 64-bit register width for their general-purpose registers? (Asks the guy with a 6-year-old computer.) That seems so wasteful, if true.
<br/>
<br/>
Dan.</td> </tr></table><span class="postbody">
<br/>
<br/>
Chars are 8-bit, shorts are 16-bit, ints are 32-bit, and longs are 64-bit.  (I think...)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
