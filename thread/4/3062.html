<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>BG wave effect (Mode 0) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > BG wave effect (Mode 0)</h2>
<div id="posts">
<div class="post">
    <h4>#17896 - RaBBi - Tue Mar 16, 2004 9:09 pm</h4>
    <div class="postbody"><span class="postbody">Hi all,
<br/>
<br/>
I've searched yet on the board but didn't find anything but a snippet from headspin about this subject.
<br/>
<br/>
this subject is about wave effect with BGs in tile mode (0 in my case).
<br/>
<br/>
I use HBlank interrupt and a sinetable (generated by SinusLab), and VBlank interrupt too.
<br/>
<br/>
The wave is good from the start but then, after some "turns", the bottom of the screen is fixed, and a group of scanlines seems to move up then disappear (it's hard to describe a visual effect...)
<br/>
And that, in loop.
<br/>
<br/>
So can someone have an explanation about modus operandi for this, or perhaps a code snippet to show.
<br/>
<br/>
Thanks ^^<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17901 - dagamer34 - Tue Mar 16, 2004 10:35 pm</h4>
    <div class="postbody"><span class="postbody">A picture is worth 1000 words...<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17902 - RaBBi - Tue Mar 16, 2004 10:41 pm</h4>
    <div class="postbody"><span class="postbody">oki sorry, I'll post two pictures and a link to the *bad* result.
<br/>
<br/>
<a href="http://yumeteam.free.fr/gbadev/CoS.gba" target="_blank">http://yumeteam.free.fr/gbadev/CoS.gba</a>
<br/>
<br/>
EDIT: here the pics :
<br/>
<br/>
<a class="postlink" href="http://yumeteam.free.fr/gbadev/CoS_wave_ok.png" target="_blank">http://yumeteam.free.fr/gbadev/CoS_wave_ok.png</a>
<br/>
<br/>
<a class="postlink" href="http://yumeteam.free.fr/gbadev/CoS_parasite.png" target="_blank">http://yumeteam.free.fr/gbadev/CoS_parasite.png</a><br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17907 - Miked0801 - Wed Mar 17, 2004 2:03 am</h4>
    <div class="postbody"><span class="postbody">2 ways:
<br/>
1. Setup and HDMA every scanline that's dest is the BG scroll reg and source is a table of scroll offsets that are created and updated during vblank.  The table is a magnitude * sin (theta) per scanline to give you the wave.
<br/>
<br/>
2. Every Scanline, interrupts and do the sine calc yourself depending on the LY.  Slower, but easier to do at first.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17910 - RaBBi - Wed Mar 17, 2004 2:34 am</h4>
    <div class="postbody"><span class="postbody">Thanks Miked'
<br/>
<br/>
I did the second way apparently.
<br/>
<br/>
I use a sinus_counter variable that increment every vblank and I use it to calculate my index in the sintable (I use LCD_Y too).
<br/>
<br/>
But it seems that the problem comes after the 100th vblank...don't know why this particular value.
<br/>
<br/>
here my code :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
struct BGPOINT
<br/>
{
<br/>
  u16 x, y;
<br/>
};
<br/>
<br/>
#define BGSCROLL ((volatile struct BGPOINT *)0x04000010)
<br/>
<br/>
const s8 g_SinTab1[128*2]=
<br/>
{ 2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ,
<br/>
 14 , 15 , 16 , 18 , 19 , 20 , 21 , 23 ,
<br/>
 24 , 25 , 26 , 27 , 27 , 28 , 29 , 30 ,
<br/>
 30 , 31 , 31 , 31 , 32 , 32 , 32 , 32 ,
<br/>
 32 , 32 , 32 , 31 , 31 , 31 , 30 , 30 ,
<br/>
 29 , 28 , 27 , 27 , 26 , 25 , 24 , 23 ,
<br/>
 21 , 20 , 19 , 18 , 16 , 15 , 14 , 12 ,
<br/>
 11 , 9 , 8 , 6 , 5 , 3 , 2 , 0 ,
<br/>
-2 ,-3 ,-5 ,-6 ,-8 ,-9 ,-11 ,-12 ,
<br/>
-14 ,-15 ,-16 ,-18 ,-19 ,-20 ,-21 ,-23 ,
<br/>
-24 ,-25 ,-26 ,-27 ,-27 ,-28 ,-29 ,-30 ,
<br/>
-30 ,-31 ,-31 ,-31 ,-32 ,-32 ,-32 ,-32 ,
<br/>
-32 ,-32 ,-32 ,-31 ,-31 ,-31 ,-30 ,-30 ,
<br/>
-29 ,-28 ,-27 ,-27 ,-26 ,-25 ,-24 ,-23 ,
<br/>
-21 ,-20 ,-19 ,-18 ,-16 ,-15 ,-14 ,-12 ,
<br/>
-11 ,-9 ,-8 ,-6 ,-5 ,-3 ,-2 , 0,
<br/>
 2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ,
<br/>
 14 , 15 , 16 , 18 , 19 , 20 , 21 , 23 ,
<br/>
 24 , 25 , 26 , 27 , 27 , 28 , 29 , 30 ,
<br/>
 30 , 31 , 31 , 31 , 32 , 32 , 32 , 32 ,
<br/>
 32 , 32 , 32 , 31 , 31 , 31 , 30 , 30 ,
<br/>
 29 , 28 , 27 , 27 , 26 , 25 , 24 , 23 ,
<br/>
 21 , 20 , 19 , 18 , 16 , 15 , 14 , 12 ,
<br/>
 11 , 9 , 8 , 6 , 5 , 3 , 2 , 0 ,
<br/>
-2 ,-3 ,-5 ,-6 ,-8 ,-9 ,-11 ,-12 ,
<br/>
-14 ,-15 ,-16 ,-18 ,-19 ,-20 ,-21 ,-23 ,
<br/>
-24 ,-25 ,-26 ,-27 ,-27 ,-28 ,-29 ,-30 ,
<br/>
-30 ,-31 ,-31 ,-31 ,-32 ,-32 ,-32 ,-32 ,
<br/>
-32 ,-32 ,-32 ,-31 ,-31 ,-31 ,-30 ,-30 ,
<br/>
-29 ,-28 ,-27 ,-27 ,-26 ,-25 ,-24 ,-23 ,
<br/>
-21 ,-20 ,-19 ,-18 ,-16 ,-15 ,-14 ,-12 ,
<br/>
-11 ,-9 ,-8 ,-6 ,-5 ,-3 ,-2 , 0 };
<br/>
<br/>
<br/>
void hblfunc(void)
<br/>
{
<br/>
  
<br/>
  //if(LCD_Y&lt;160)
<br/>
  //{
<br/>
    BGSCROLL[1].x = (g_SinTab1[LCD_Y+sinus_count+(sinus_offset)]);
<br/>
    
<br/>
    BGSCROLL[2].x = (g_SinTab1[LCD_Y+sinus_count+(sinus_offset)]);
<br/>
    
<br/>
    //sinus_offset++;
<br/>
  //}
<br/>
<br/>
}
<br/>
<br/>
void vblfunc(void)
<br/>
{
<br/>
   sinus_count++;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Interrupts are correctly handled in IWRAM.
<br/>
And I use tepples'gba header.<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17911 - RaBBi - Wed Mar 17, 2004 3:21 am</h4>
    <div class="postbody"><span class="postbody">I solved my problem using an array of 128*4 entries instead of 128*2.
<br/>
<br/>
I tried to figure out why but didn't find the reason for the moment.
<br/>
<br/>
Could someone explain me this?
<br/>
<br/>
Thanks ^^<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17912 - Miked0801 - Wed Mar 17, 2004 3:25 am</h4>
    <div class="postbody"><span class="postbody">I'd do this
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   u8 theta =  LCD_Y + sinus_count + sinus_offset;
<br/>
<br/>
   BGSCROLL[1].x = (g_SinTab1[theta]); 
<br/>
   BGSCROLL[2].x = (g_SinTab1[theta]); 
<br/>
 </td> </tr></table><span class="postbody">
<br/>
<br/>
This makes sure you don't overflow your table - which is my guess at what your problem is.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17919 - RaBBi - Wed Mar 17, 2004 12:50 pm</h4>
    <div class="postbody"><span class="postbody">Yeah you're right Miked' ^^
<br/>
<br/>
It was an overflow problem, cause sinus_count+LCD_Y was over &gt; 256 (number of entries from the precedent sintable).
<br/>
<br/>
But, now that it works, I have a little question about your first way.
<br/>
<br/>
Why use HDMA for a small operation like put a value in a scroll register?
<br/>
<br/>
Thanks ^^<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17920 - headspin - Wed Mar 17, 2004 1:06 pm</h4>
    <div class="postbody"><span class="postbody">hehe you found the same problem I was having in my code ;)
<br/>
<br/>
I posted what I had at the time, but I never did get around to fixing the sine table looping/overflow problem...
<br/>
<br/>
Perhaps you could post your code Rabbi or send it to me via e-mail.. I am going to add the sine wave effect to my tutorial one of these days. Would save me the hasstle of re-writing it and I'll credit your help.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17924 - RaBBi - Wed Mar 17, 2004 4:46 pm</h4>
    <div class="postbody"><span class="postbody">There's no problem headspin ^^
<br/>
<br/>
I'll be glad to contribute to your tutorial I enjoy reading ;)
<br/>
<br/>
I'll post my code below, but I must say that I'm not an experimented developer and it certainly needs to be optimised.
<br/>
<br/>
I didn't get deeper in this effect, that was just to have a vision about the global way to realize it.
<br/>
If you can mix your approach and mine, it would be a nice demonstration I think ^^
<br/>
<br/>
Here's the code for <span style="font-weight: bold">main.c</span> :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void vblfunc(void);
<br/>
void hblfunc(void);
<br/>
<br/>
u16 scrollx = 0; // used to update BG scroll when using pad
<br/>
u16 scrolly = 0; // same
<br/>
u8 sinus_offset=0; // for next use
<br/>
u8 sinus_count=0;
<br/>
ISR saved_isr;
<br/>
<br/>
const s8 g_SinTab1[128*4]=
<br/>
{ 2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ,
<br/>
 14 , 15 , 16 , 18 , 19 , 20 , 21 , 23 ,
<br/>
 24 , 25 , 26 , 27 , 27 , 28 , 29 , 30 ,
<br/>
 30 , 31 , 31 , 31 , 32 , 32 , 32 , 32 ,
<br/>
 32 , 32 , 32 , 31 , 31 , 31 , 30 , 30 ,
<br/>
 29 , 28 , 27 , 27 , 26 , 25 , 24 , 23 ,
<br/>
 21 , 20 , 19 , 18 , 16 , 15 , 14 , 12 ,
<br/>
 11 , 9 , 8 , 6 , 5 , 3 , 2 , 0 ,
<br/>
-2 ,-3 ,-5 ,-6 ,-8 ,-9 ,-11 ,-12 ,
<br/>
-14 ,-15 ,-16 ,-18 ,-19 ,-20 ,-21 ,-23 ,
<br/>
-24 ,-25 ,-26 ,-27 ,-27 ,-28 ,-29 ,-30 ,
<br/>
-30 ,-31 ,-31 ,-31 ,-32 ,-32 ,-32 ,-32 ,
<br/>
-32 ,-32 ,-32 ,-31 ,-31 ,-31 ,-30 ,-30 ,
<br/>
-29 ,-28 ,-27 ,-27 ,-26 ,-25 ,-24 ,-23 ,
<br/>
-21 ,-20 ,-19 ,-18 ,-16 ,-15 ,-14 ,-12 ,
<br/>
-11 ,-9 ,-8 ,-6 ,-5 ,-3 ,-2 , 0,
<br/>
2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ,
<br/>
 14 , 15 , 16 , 18 , 19 , 20 , 21 , 23 ,
<br/>
 24 , 25 , 26 , 27 , 27 , 28 , 29 , 30 ,
<br/>
 30 , 31 , 31 , 31 , 32 , 32 , 32 , 32 ,
<br/>
 32 , 32 , 32 , 31 , 31 , 31 , 30 , 30 ,
<br/>
 29 , 28 , 27 , 27 , 26 , 25 , 24 , 23 ,
<br/>
 21 , 20 , 19 , 18 , 16 , 15 , 14 , 12 ,
<br/>
 11 , 9 , 8 , 6 , 5 , 3 , 2 , 0 ,
<br/>
-2 ,-3 ,-5 ,-6 ,-8 ,-9 ,-11 ,-12 ,
<br/>
-14 ,-15 ,-16 ,-18 ,-19 ,-20 ,-21 ,-23 ,
<br/>
-24 ,-25 ,-26 ,-27 ,-27 ,-28 ,-29 ,-30 ,
<br/>
-30 ,-31 ,-31 ,-31 ,-32 ,-32 ,-32 ,-32 ,
<br/>
-32 ,-32 ,-32 ,-31 ,-31 ,-31 ,-30 ,-30 ,
<br/>
-29 ,-28 ,-27 ,-27 ,-26 ,-25 ,-24 ,-23 ,
<br/>
-21 ,-20 ,-19 ,-18 ,-16 ,-15 ,-14 ,-12 ,
<br/>
-11 ,-9 ,-8 ,-6 ,-5 ,-3 ,-2 , 0,
<br/>
2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ,
<br/>
 14 , 15 , 16 , 18 , 19 , 20 , 21 , 23 ,
<br/>
 24 , 25 , 26 , 27 , 27 , 28 , 29 , 30 ,
<br/>
 30 , 31 , 31 , 31 , 32 , 32 , 32 , 32 ,
<br/>
 32 , 32 , 32 , 31 , 31 , 31 , 30 , 30 ,
<br/>
 29 , 28 , 27 , 27 , 26 , 25 , 24 , 23 ,
<br/>
 21 , 20 , 19 , 18 , 16 , 15 , 14 , 12 ,
<br/>
 11 , 9 , 8 , 6 , 5 , 3 , 2 , 0 ,
<br/>
-2 ,-3 ,-5 ,-6 ,-8 ,-9 ,-11 ,-12 ,
<br/>
-14 ,-15 ,-16 ,-18 ,-19 ,-20 ,-21 ,-23 ,
<br/>
-24 ,-25 ,-26 ,-27 ,-27 ,-28 ,-29 ,-30 ,
<br/>
-30 ,-31 ,-31 ,-31 ,-32 ,-32 ,-32 ,-32 ,
<br/>
-32 ,-32 ,-32 ,-31 ,-31 ,-31 ,-30 ,-30 ,
<br/>
-29 ,-28 ,-27 ,-27 ,-26 ,-25 ,-24 ,-23 ,
<br/>
-21 ,-20 ,-19 ,-18 ,-16 ,-15 ,-14 ,-12 ,
<br/>
-11 ,-9 ,-8 ,-6 ,-5 ,-3 ,-2 , 0,
<br/>
2 , 3 , 5 , 6 , 8 , 9 , 11 , 12 ,
<br/>
 14 , 15 , 16 , 18 , 19 , 20 , 21 , 23 ,
<br/>
 24 , 25 , 26 , 27 , 27 , 28 , 29 , 30 ,
<br/>
 30 , 31 , 31 , 31 , 32 , 32 , 32 , 32 ,
<br/>
 32 , 32 , 32 , 31 , 31 , 31 , 30 , 30 ,
<br/>
 29 , 28 , 27 , 27 , 26 , 25 , 24 , 23 ,
<br/>
 21 , 20 , 19 , 18 , 16 , 15 , 14 , 12 ,
<br/>
 11 , 9 , 8 , 6 , 5 , 3 , 2 , 0 ,
<br/>
-2 ,-3 ,-5 ,-6 ,-8 ,-9 ,-11 ,-12 ,
<br/>
-14 ,-15 ,-16 ,-18 ,-19 ,-20 ,-21 ,-23 ,
<br/>
-24 ,-25 ,-26 ,-27 ,-27 ,-28 ,-29 ,-30 ,
<br/>
-30 ,-31 ,-31 ,-31 ,-32 ,-32 ,-32 ,-32 ,
<br/>
-32 ,-32 ,-32 ,-31 ,-31 ,-31 ,-30 ,-30 ,
<br/>
-29 ,-28 ,-27 ,-27 ,-26 ,-25 ,-24 ,-23 ,
<br/>
-21 ,-20 ,-19 ,-18 ,-16 ,-15 ,-14 ,-12 ,
<br/>
-11 ,-9 ,-8 ,-6 ,-5 ,-3 ,-2 , 0 };
<br/>
<br/>
<br/>
void AgbMain(void)
<br/>
{
<br/>
<br/>
  /* Init interuption handler */
<br/>
  INTENABLE = 0;
<br/>
  saved_isr = GET_MASTER_ISR();
<br/>
  SET_MASTER_ISR(isr);
<br/>
  LCDSTAT |= LCDSTAT_VBLINT;
<br/>
  INTMASK |= INT_VBLANK;
<br/>
  LCDSTAT |= LCDSTAT_HBLINT;
<br/>
  INTMASK |= INT_HBLANK;
<br/>
  INTENABLE = 1;
<br/>
<br/>
  ...
<br/>
<br/>
  while(1)
<br/>
  {
<br/>
      // in the main loop, scrollx and scrolly are updated when pad is pressed
<br/>
      // not relative to the wave effect
<br/>
  }
<br/>
<br/>
}
<br/>
<br/>
void hblfunc(void)
<br/>
{
<br/>
<br/>
    // I tested Y wave effect, it was really fun to see ! ^^
<br/>
    // I commented these lines
<br/>
<br/>
    // sinus_offset is not used for the moment, always 0
<br/>
<br/>
    BGSCROLL[1].x = scrollx+(g_SinTab1[LCD_Y+sinus_count+(sinus_offset)]);
<br/>
    //BGSCROLL[1].y = scrolly+(g_SinTab1[LCD_Y+sinus_count+(sinus_offset)]);
<br/>
<br/>
    BGSCROLL[2].x = scrollx+(g_SinTab1[LCD_Y+sinus_count+(sinus_offset)]);
<br/>
    //BGSCROLL[2].y = scrolly+(g_SinTab1[LCD_Y+sinus_count+(sinus_offset)]);
<br/>
<br/>
}
<br/>
<br/>
void vblfunc(void)
<br/>
{
<br/>
   sinus_count++;
<br/>
<br/>
   // not relative to the wave effect
<br/>
   // it's just for scrolling BG with pad
<br/>
   BGSCROLL[1].x = scrollx;
<br/>
   BGSCROLL[1].y = scrolly;
<br/>
   BGSCROLL[2].x = scrollx;
<br/>
   BGSCROLL[2].y = scrolly;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
And here the code for the ISR (in <span style="font-weight: bold">isr.iwram.c</span>) :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void isr(void)
<br/>
{
<br/>
  u16 ack;
<br/>
<br/>
  INTENABLE = 0;
<br/>
  ack = INTACK;
<br/>
  if (ack &amp; INT_HBLANK)
<br/>
  {
<br/>
    hblfunc();
<br/>
  }
<br/>
  if (ack &amp; INT_VBLANK)
<br/>
  {
<br/>
    vblfunc();
<br/>
  }
<br/>
<br/>
  BIOS_INTACK = ack;
<br/>
  INTACK = ack;
<br/>
<br/>
  INTENABLE = 1;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
And that's all! 
<br/>
The GBA hardware is really fantastic ;)
<br/>
<br/>
NOTE: I used tepples'pineight's GBA header, so please refer to this for used defines and macros ;)
<br/>
<br/>
Hope it helps ^^
<br/>
And I repeat : it's was just a test !
<br/>
If someone want to enhance this, please let us know ;)<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17960 - Miked0801 - Wed Mar 17, 2004 11:07 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
But, now that it works, I have a little question about your first way. 
<br/>
<br/>
Why use HDMA for a small operation like put a value in a scroll register? 
<br/>
<br/>
Thanks ^^
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Because of all the overhead required to get into your interrupt, do the processing, and exit back to the main game.  You wouldn't be able to do something like this in real-time as you're talking roughly 80+% of your CPU time in interrupt management doing this per line.  This is why Mode7 stuff is done with HDMAs (and that stuff doesn't right more than a few bytes per line either).  This is why this should be done that way too.  It removes almost all the overhead by having the system do the assigning for you.  Doing with HDMAs will also fix any screen tearing/glitching I bet you're seeing right now as you aren't waiting for an HBlank period before writing your scroll register changes.
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17970 - poslundc - Thu Mar 18, 2004 12:32 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Because of all the overhead required to get into your interrupt, do the processing, and exit back to the main game.  You wouldn't be able to do something like this in real-time as you're talking roughly 80+% of your CPU time in interrupt management doing this per line.  This is why Mode7 stuff is done with HDMAs (and that stuff doesn't right more than a few bytes per line either).  This is why this should be done that way too.  It removes almost all the overhead by having the system do the assigning for you.  Doing with HDMAs will also fix any screen tearing/glitching I bet you're seeing right now as you aren't waiting for an HBlank period before writing your scroll register changes.</td> </tr></table><span class="postbody">
<br/>
<br/>
Now, now, Mike, you know perfectly well that a small, well-optimized ISR is perfectly manageable in HBlank despite the overhead.
<br/>
<br/>
My Mode7 stuff is done through ISRs and there's no problem with it, and it enables me to combine the Mode7 with other raster effects (like gradient fog and sky, and switching from displaying horizon to terrain on the same BG without using a VCOUNT interrupt).
<br/>
<br/>
HDMA is great if you have a single raster effect you're creating. Otherwise, interrupts are the way to go. And yes, when it comes to doing stuff in HBlank you will probably want to write your own ISR (instead of using the one in DKA) and you will probably want to code it in assembly.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17975 - Miked0801 - Thu Mar 18, 2004 12:50 am</h4>
    <div class="postbody"><span class="postbody">:)
<br/>
<br/>
Just trying to keep it easy(er).  But of course you are correct.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18009 - ScottLininger - Thu Mar 18, 2004 5:20 pm</h4>
    <div class="postbody"><span class="postbody">Hey guys,
<br/>
<br/>
I'm just trying to follow this thread and I realize that I have no idea what ISR means... I figured out HDMA from the cowbite spec, but ISR eludes me. (Probably belongs in the beginners forum, but while you're talking about it anyway...)
<br/>
<br/>
Anyone feel like filling me in?
<br/>
<br/>
Thanks!
<br/>
<br/>
Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18010 - poslundc - Thu Mar 18, 2004 5:32 pm</h4>
    <div class="postbody"><span class="postbody">Interrupt Service Routine
<br/>
<br/>
(Can apply both to the general interrupt subroutine the GBA branches to whenever an interrupt occurs, or to a more specific subroutine designed to handle a specific type of interrupt.)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18672 - LOst? - Wed Mar 31, 2004 2:57 pm</h4>
    <div class="postbody"><span class="postbody">This wave effect is one of the coolest effects you can do on a 2-d console. I wish it was possible to do it on the PC but it isn't.
<br/>
<br/>
I must really learn how to set up the HDMA so I can do these effects without loosing cycles like when calling ISR
<br/>
<br/>
How would the HDMA react if you have a HBlank interrupt running as well?
<br/>
<br/>
Is this the order of the interrupt calls:
<br/>
VBlank scanline 0
<br/>
HBlank scanline 1
<br/>
HBlank scanline 2
<br/>
HBlank scanline 3, etc?
<br/>
<br/>
How would the order of the HDMA be?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18674 - poslundc - Wed Mar 31, 2004 3:17 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">This wave effect is one of the coolest effects you can do on a 2-d console. I wish it was possible to do it on the PC but it isn't.</td> </tr></table><span class="postbody">
<br/>
<br/>
...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I must really learn how to set up the HDMA so I can do these effects without loosing cycles like when calling ISR</td> </tr></table><span class="postbody">
<br/>
<br/>
Have a look at any number of tutorials, the Cowbite spec, or search the forum. You should find everything you need.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">How would the HDMA react if you have a HBlank interrupt running as well?</td> </tr></table><span class="postbody">
<br/>
<br/>
HDMA should preempt the interrupt. I'm sure someone will correct me if I am wrong on this.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Is this the order of the interrupt calls:
<br/>
VBlank scanline 0
<br/>
HBlank scanline 1
<br/>
HBlank scanline 2
<br/>
HBlank scanline 3, etc?</td> </tr></table><span class="postbody">
<br/>
<br/>
You don't have to use interrupts for VBlank. But in general for raster effects you follow that pattern insofar as you set up scanline 0 in VBlank, then when REG_VCOUNT is 0 you set up scanline 1 in an HBlank interrupt, then scanline 2 when REG_VCOUNT is 1 in the next HBlank interrupt, etc.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">How would the order of the HDMA be?</td> </tr></table><span class="postbody">
<br/>
<br/>
No different, you just activate the DMA during VBlank.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
