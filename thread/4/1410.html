<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Real time/Consecutive programming - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Real time/Consecutive programming</h2>
<div id="posts">
<div class="post">
    <h4>#7067 - cooky - Sat Jun 07, 2003 9:04 pm</h4>
    <div class="postbody"><span class="postbody">I would just like to know how you acheive real time and/or consecutive programming (round robin). I have being running through the many programming tutorials around and now have a good idea of how to program the gba but still no idea how to do this.
<br/>
<br/>
I have a feeling it is done like this.
<br/>
Set up a timer that interupts the program every few times a second.
<br/>
Every time this happens the place where it leaves the program saved in memory and I load in to the program counter place that I want to load up the next process for the GBAs memory(as it was saved the last time that process had a time slice).
<br/>
The program goes through the list of processes befor starting at the beginning.
<br/>
<br/>
this way i can constantly skip between the sprites backgrounds etc of the program. It is all well and good having the theory, I just don't know how to implement it.
<br/>
<br/>
Any other ideas of how people have acheived this type of thing feel free to post as i'm not too bothered how i do this more that it works in a flexible way.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7070 - DekuTree64 - Sat Jun 07, 2003 10:57 pm</h4>
    <div class="postbody"><span class="postbody">You mean like an operating system, where it gives chunks of time to seprate programs, or just splitting up the work of a single game engine over several fames kind of thing? Cause if it can do a full game frame in one HW frame, then there's no need for jumping between processes. Otherwise, I'd try to make it where it does everything that doesn't display immediately on one frame (so you don't see a half-finished frame), and then everything that will display on the VBlank of the second. 
<br/>
And that doesn't involve any process jumping either. Generally there's no need for it in a console game. You either do everything at once, or split it up very organized-ly.
<br/>
<br/>
For an operating system-type thing, (I have no experience or knowledge about them, so this is just an idea) I'd have a while(time &lt; timePerProcess) loop for each program's main section, where it processes all the messages it's recieved since last frame, or as many as it can get done before it runs out of time, and then move onto the next program. timePerProcess would probably just be the number of cycles between the start of the frame and VBlank divided by the number of programs running. 
<br/>
You'd need to adjust timePerProcess after each program finishes its thing, since it would probably either finish way early, or go over the time limit if it happened to be doing something time-consuming.
<br/>
Then have another loop through the programs on VBlank for them to update their display stuff.
<br/>
<br/>
That's how I'd do it anyway, but like I said, I've never read a thing about OS programmnig, I just made all that up^_^ 
<br/>
I think it would work though.
<br/>
<br/>
<br/>
...or did you mean something else entirely?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7090 - pbmtp - Mon Jun 09, 2003 10:49 am</h4>
    <div class="postbody"><span class="postbody">first make a procedure that allow you to save the CPU context of a fonction (by context i mean the registers and everything that is needed to start/stop/restart this procedure)
<br/>
<br/>
next make a timer routine (under interruption) that wake up every 10ms or something like that
<br/>
<br/>
next do a schedule() function that manage a list of function that should be run and which choose the one which we need to give the next cpu slice
<br/>
(do a simple round robin policy or random policy at first for testing.
<br/>
round robin is simple to code you have a task list and you choose the i+1 one if i was the last one which was run)
<br/>
<br/>
once you have all this working glue everything together
<br/>
you initialise your task list with the context for each functions
<br/>
you launch the timer
<br/>
you launch the first task
<br/>
when the timer generate an iterruption you save the context for the task that was running you called schedule to find a new one you activate the context for this task, do not forget to re enable the timer and this will do the tricks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7119 - Vortex - Mon Jun 09, 2003 10:44 pm</h4>
    <div class="postbody"><span class="postbody">An old school way for switching tasks in C is to use setjump()/longjump() and have a separate stack space for each task. A little bit harder is to make sure the tasks access global variables in a nice manner.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7122 - torne - Mon Jun 09, 2003 11:11 pm</h4>
    <div class="postbody"><span class="postbody">pbtmp: sounds good, though the scheduler I'm writing is hard realtime and understands which tasks should be scheduled in vblank or vfill. Context switching on the ARM is a little confusing, though, and if anyone is trying to implement this I strongly recommend looking at the ARM ARM (Architectural Reference Manual) which is available to download from various places online (though not from ARM's site... I think my copy came from Altera). It has sample assembly code for doing a context switch on an ARMv3/4 chip.
<br/>
<br/>
Thread synchronisation is another more complex issue entirely; the ARM's swap instruction lets you implement simple boolean mutexes relatively easily, but semaphores and other structures are a little harder. Again, there are examples in the ARM ARM, but I don't like their mutex implementation; it's slow. =)
<br/>
<br/>
Running several threads is not likely to be worth the effort on the GBA for game or simple application development; the overheads involved are pretty huge, and it's a pain to allocate per-thread stacks in the tiny amount of waitless memory you have available.
<br/>
<br/>
Torne</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7142 - pbmtp - Tue Jun 10, 2003 3:52 pm</h4>
    <div class="postbody"><span class="postbody">torne: i know i have a similar hard RT scheduler (not yet 100% finished) in my operating system prototype, but i simplify the approach to have a more understable post. Round robin is a good implementation to start and its is quite easy to update to a more efficient RT policy like RM or EDF or anything else
<br/>
<br/>
thx for the ARM manual which i didnt know
<br/>
<br/>
=)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7170 - cooky - Wed Jun 11, 2003 12:08 pm</h4>
    <div class="postbody"><span class="postbody">That cleared things up a little.
<br/>
<br/>
The reason I want to do this is that I want to create a game where all you have to do is have one procedure with all the tests in and loops that are needed to control the sprites backgrounds etc. without he need to split what they do between loops with masses of variables to say which of those states they are in. This way I believe I can create better AI and more compact code because a single sprite is within one procedure.
<br/>
<br/>
This may in truth appear not to be the case but all my previous experience with games programming has included this feature and I like to be able to use it again.
<br/>
<br/>
Vortex by the way where can you find the functions setjump() and longjump() as they may be sufficient. Otherwise i'm going to try out the other aprouches.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7177 - torne - Wed Jun 11, 2003 3:12 pm</h4>
    <div class="postbody"><span class="postbody">cooky, it sounds like you want to be doing the same thing every frame, so why not just have your vblank bottom half trigger one cycle through each of your functions? That way you don't need a scheduler, or preemption.
<br/>
<br/>
T.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7202 - Cyberman - Thu Jun 12, 2003 3:34 am</h4>
    <div class="postbody"><span class="postbody">Perhaps as a suggestion for handling such things (having experienced such things as doing many things at once). 
<br/>
<br/>
In C you have single main program loop that has certain events that it branches off for.  Then a process loop (seperate) that is called while waiting for interrupts or other events.  Interrupts should have very little code in them. For example horizontal timer interrupt should set a flag that's polled in the process loop. If the process loop is too slow then increasing the code in the horizontal interrupt is needed.  However only events like serial data (what to do with Joypad data) etc. is actually handled by the process loop.  Waiting for a keypress for example or checking collisions or updating sprite positions every vertical interrupt.  All easily handled in the process loop.
<br/>
<br/>
The program then becomes event oriented and what happens to the display is a result of the process state.  It sounds overly simple, but it's not. I've done it so it's not hard.
<br/>
<br/>
This is a bit STACK messy though because you are constantly bipping between functions and checking states.  In otherwords the stack is in a constant state of being ON stack.
<br/>
<br/>
For example playing the game is actually a sub function of the main program (whose function is merely to start a new game continue a game run a demo or show the intro.  Each function from there is a sub routine of this. Anyhow I hope this makes sense.
<br/>
<br/>
I've used this technique on many projects, very few applications require intense program loops but it's often best to keep things simple and waste as little cpu power as possible. :) This does work I've noticed with this concept.
<br/>
<br/>
For C++ any event queue might be good, each object is sent messages such as "you've got the right key pressed" and it should move acordingly.  Obviously this is not 'super' efficient but it keeps things clean. And allows you to figure out where to look for problems.  I'm using this approach with my current little project.
<br/>
<br/>
Cyb</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7333 - cooky - Sun Jun 15, 2003 12:29 pm</h4>
    <div class="postbody"><span class="postbody">torne: actually one of the points of this is that i don't what to be doing the same thing every frame more that i could be doing any one of a number of things in a frame depening on what tasks i have called in that area this way a going through the functions approach isn't suitable as cyberman surgested(where each function represents a state of the process and the function is decided apon using global variables). Sorry but i will see what I can do with the ideas any way.<br/>_________________<br/>Rolling a six is unlikely but how do you know if you have never picked up the dice.
<br/>
<a href="http://www.ceorron.co.uk" target="_blank">www.ceorron.co.uk</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7334 - torne - Sun Jun 15, 2003 1:15 pm</h4>
    <div class="postbody"><span class="postbody">Yes, but the set of things you could be doing in a frame is presumably static, so enabling/disabling various sets of functions to be called would surely work? Doing boolean tests doesn't take much time. =)
<br/>
<br/>
T</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7335 - cooky - Sun Jun 15, 2003 1:19 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">Yes, but the set of things you could be doing in a frame is presumably static, so enabling/disabling various sets of functions to be called would surely work? Doing boolean tests doesn't take much time. =)
<br/>
<br/>
T</td> </tr></table><span class="postbody">
<br/>
<br/>
Your beginning to convice me now but it seems alot of useless tests to set up one area different from the last. Surley wont tha get slow after a while or do you surgest setting up a different loop for each area? (!)<br/>_________________<br/>Rolling a six is unlikely but how do you know if you have never picked up the dice.
<br/>
<a href="http://www.ceorron.co.uk" target="_blank">www.ceorron.co.uk</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7357 - torne - Mon Jun 16, 2003 11:14 am</h4>
    <div class="postbody"><span class="postbody">You could have more than one loop per area, yes; all you need to do is have them all as seperate functions, and have some variable that can be set which will cause the loop to exit and the right function called next.
<br/>
<br/>
Having a huge bunch of tests really isn't a problem, though; if they are all testing the same variable(s) and there are few enough variables that they can stay in registers, it'll only take two or three clock cycles to run each test, and since you have 83766 cycles in each vertical blank interval, it's not going to consume much time. =)
<br/>
<br/>
Example of the first:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void main()
<br/>
{
<br/>
   while ( true )
<br/>
   {
<br/>
       switch ( state )
<br/>
       {
<br/>
            case 1: state1(); break;
<br/>
            case 2: state2(); break;
<br/>
            case 3: state3(); break;
<br/>
        }
<br/>
    }
<br/>
}
<br/>
<br/>
void state1()
<br/>
{
<br/>
   while ( state == 1 )
<br/>
   {    do stuff for state 1   }
<br/>
}
<br/>
<br/>
void state2()
<br/>
{
<br/>
   while ( state == 2 )
<br/>
   {    do stuff for state 2    }
<br/>
}
<br/>
...
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm sure you can see how that would work. For the second:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if ( state == 1 )
<br/>
{
<br/>
    do state1 stuff
<br/>
}
<br/>
if ( state == 2 || state == 3 )
<br/>
{
<br/>
   blah blah
<br/>
}
<br/>
if ( state == 1 )
<br/>
{
<br/>
  more state 1 stuff
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
and so on. It doesn't look very 'tidy' but it's fast; skipping over an if statement only takes two cycles if the values tested are already in registers. Compare that to the scheduling overhead of a multithreading system; it takes at least fifty cycles to switch thread, and that's without considering any clever goings-on. =)
<br/>
<br/>
T.
<br/>
<br/>
[/code]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7362 - col - Mon Jun 16, 2003 12:05 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">...Example of the first:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void main()
<br/>
{
<br/>
   while ( true )
<br/>
   {
<br/>
       switch ( state )
<br/>
       {
<br/>
            case 1: state1(); break;
<br/>
            case 2: state2(); break;
<br/>
            case 3: state3(); break;
<br/>
        }
<br/>
    }
<br/>
}
<br/>
<br/>
void state1()
<br/>
{
<br/>
   while ( state == 1 )
<br/>
   {    do stuff for state 1   }
<br/>
}
<br/>
<br/>
void state2()
<br/>
{
<br/>
   while ( state == 2 )
<br/>
   {    do stuff for state 2    }
<br/>
}
<br/>
...
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
An even neater way of doing this is to use a function pointer.  That way you can save the overhead of the switch satement:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
//declare your state function pointer and initialise to state1
<br/>
<br/>
void(*state)() = state1;
<br/>
<br/>
//define some state functions 
<br/>
<br/>
void state1() {
<br/>
     
<br/>
   // do stuff for state 1
<br/>
    ...
<br/>
    if(foo){
<br/>
        state = state2;     //switch state
<br/>
    }
<br/>
}
<br/>
<br/>
void state2() {
<br/>
<br/>
   //do stuff for state 2
<br/>
   ....
<br/>
   if(bar){
<br/>
        state = state1;       //switch state
<br/>
   }
<br/>
}
<br/>
...
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
then in your main game loop, you can invoke the current states process by dereferencing the pointer - no conditional checks required!
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
....
<br/>
<br/>
//process the current state
<br/>
<br/>
(*(currentObject-&gt;state)) ();
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
hope this is some help
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7365 - torne - Mon Jun 16, 2003 1:26 pm</h4>
    <div class="postbody"><span class="postbody">The 'overhead' of a switch statement on integers is almost zero, and it saves messing about with function pointers, which if you don't know exactly how they work, are a bit odd sometimes, especially with ARM/Thumb interworking. If the values in the switch are small natural numbers (0,1,2,3 or something) it gets compiled into a jump table which takes exactly the same number of memory accesses as a function pointer to run. =)
<br/>
<br/>
T.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7372 - col - Mon Jun 16, 2003 2:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">The 'overhead' of a switch statement on integers is almost zero, and it saves messing about with function pointers, which if you don't know exactly how they work, are a bit odd sometimes, especially with ARM/Thumb interworking. If the values in the switch are small natural numbers (0,1,2,3 or something) it gets compiled into a jump table which takes exactly the same number of memory accesses as a function pointer to run. =)
<br/>
<br/>
T.</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
If the switch statement is compiled into a jump table surely there will still be an extra level of indirection:
<br/>
the jump to the correct case block + the state function call?
<br/>
<br/>
Or can gcc optimise out the jump to the case block, and call the state() directly? that would be cool :)
<br/>
<br/>
I guess even if the cpu efficiency is the same, I like the neatness/brevity of the pointer approach. So can the switch approach be faster than the pointer approach?
<br/>
<br/>
Also, in what way does calling a function normally with interworking differ from dereferencing a function pointer with interworking?
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7380 - torne - Mon Jun 16, 2003 3:52 pm</h4>
    <div class="postbody"><span class="postbody">It uses the same number of memory accesses, which is the real speed factor on the GBA. It'll take one more instruction than if you constructed your own jump table, as gcc doesn't have tree rewrites powerful enough to realise that the switch is made of single function calls. The 'fastest' way is to use a jump table made of pointers, but you'll have to make that yourself, and it won't be much different. =)
<br/>
<br/>
Calling a function through a pointer properly in interworking code is awkward because all pointers to Thumb code have to be coerced to have their low bit set to 1, so that the bx instruction will do the right thing. This can add extra code in some cases, depending on the way you call functions and the compiler options that you use. Calling functions directly doesn't have this problem because ARM-target linkers know how to construct shims which switch instruction sets.
<br/>
<br/>
Torne</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7391 - col - Mon Jun 16, 2003 10:17 pm</h4>
    <div class="postbody"><span class="postbody">Hi again,
<br/>
<br/>
I decided to forget about theory and do some profiling :)
<br/>
<br/>
the pointer approach is (only) ~2cycles faster than the switch approach, which isn't a big win, but as the code is also smaller and the source is neater, i'll stick with it for now.
<br/>
<br/>
EDIT
<br/>
<br/>
this is a load of codswallop!
<br/>
my stupidity allowed me to happily use visual boy advance for this test - of course i realised immediately after hitting submit that i should be testing on hardware doh!
<br/>
<br/>
so heres the real deal
<br/>
<br/>
on hardware the pointer approach is ~19 cycles slower than using a switch statement !!!
<br/>
<br/>
ouch I'm gonna have a look at the output as soon as i have time :)
<br/>
<br/>
cheers
<br/>
<br/>
EDIT2
<br/>
<br/>
ha after using some unreachable recursion to stop gcc from inlining the dummy functions into the switch statement, a different story transpires...
<br/>
<br/>
now on hardware i get pointers as ~12 cycles faster per iteration!
<br/>
the saga continues!!!
<br/>
<br/>
the code is thumb running from rom with interworking on optimisation set to -O3.
<br/>
<br/>
(btw gcc seems to gracefully handle the interworking bit in the pointer! if you take the address of a thumb function with interworking set, the lowest bit is a 1!)
<br/>
<br/>
heres the test i'm using - i am now less then sure that it is valid - so please rip it up :)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
static volatile u32 val = 0;
<br/>
static volatile u32 caseIdx = 2;
<br/>
static void (* volatile funcPtr)() = dummyState1;
<br/>
<br/>
void testCaseVsFuncPtr(){
<br/>
   
<br/>
   u32 timeTaken = 0;
<br/>
<br/>
   //test pointer approach
<br/>
   initTimer();   //reset timer   
<br/>
   for(u32 i = 0; i &lt; 10000; ++i){
<br/>
      (*funcPtr)();
<br/>
   }
<br/>
   timeTaken = readTimer();
<br/>
<br/>
   dprint("\ntime for funcPtr=");
<br/>
   dprint(timeTaken);
<br/>
<br/>
   //test switch approach
<br/>
   initTimer();
<br/>
   for(u32 i = 0; i &lt; 10000; ++i){
<br/>
      switch(caseIdx){
<br/>
      case(0): dummyState4(); break;
<br/>
      case(1): dummyState2(); break;
<br/>
      case(2): dummyState1(); break;
<br/>
      }
<br/>
   }
<br/>
   timeTaken = readTimer();
<br/>
<br/>
   dprint("\ntime for switch =");
<br/>
   dprint(timeTaken);
<br/>
}
<br/>
<br/>
void dummyState1() {
<br/>
   if(val &gt; 100000) {
<br/>
      dummyState1();
<br/>
   }
<br/>
   ++val;
<br/>
}
<br/>
void dummyState2(){ dummyState1(); }
<br/>
void dummyState3(){ dummyState1(); }
<br/>
void dummyState4(){ dummyState1(); }
<br/>
<br/>
<br/>
void initTimer() {
<br/>
   REG_TM3DAT = 0;
<br/>
   REG_TM3CNT = 0;
<br/>
   REG_TM2DAT = 0;
<br/>
   REG_TM2CNT = 0;
<br/>
   REG_TM3CNT = 0x84;
<br/>
   REG_TM2CNT = 0x80;
<br/>
}
<br/>
u32 readTimer() {
<br/>
   return( (u32)(REG_TM3DAT &lt;&lt; 16) | (u32)(REG_TM2DAT) );
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
(the profiling code is borrowed from Kevin Weatherman)
<br/>
<br/>
i guess the conclusion (so far) is - if your functions are small, gcc can inline them in the switch statements for a big win, otherwise the pointers are the way to go...
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7418 - col - Tue Jun 17, 2003 4:39 pm</h4>
    <div class="postbody"><span class="postbody">quick update :)
<br/>
<br/>
It seems that there gcc can cope with function pointers and interworking ONLY if the pointers are not to member functions - no great hardship really :)
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
