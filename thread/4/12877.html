<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Inserting and deleting nodes (objects) in a list? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Inserting and deleting nodes (objects) in a list?</h2>
<div id="posts">
<div class="post">
    <h4>#123836 - Piratero - Sat Mar 31, 2007 6:40 pm</h4>
    <div class="postbody"><span class="postbody">Hello everyone! While this may not be GBA specific, I hope that I can receive some help.
<br/>
<br/>
My problem is that I want to be able to create a system where I can easily insert and display a lot of sprites on the screen without having to actually specify where in memory they should be placed. For example,
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
sprite_mem[0].x = 1;
<br/>
sprite_mem[0].y = 1;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I want to be able to "spawn" hundreds of sprites and be able to individually move them.
<br/>
<br/>
So far, the following code works is able to create a lot of sprites on screen. The only problem is that I have no idea how to be able to move each sprite separately.
<br/>
<br/>
Here is the code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
unsigned short
<br/>
AddPolygonToList(struct vdp1_sort_node *db)
<br/>
{
<br/>
   unsigned short   n;
<br/>
<br/>
   for (n = 0; n &lt; max_size; n++) {
<br/>
      if (((index + 1) &lt; max_size) &amp;&amp; (db[index].id == 0)) {
<br/>
         index++;
<br/>
         db[index - 1].id = index - 1;
<br/>
<br/>
         if (removed_nodes &gt; 0)
<br/>
            removed_nodes--;
<br/>
         break;
<br/>
      }
<br/>
      /* Else, the size has exceeded the maximum amount of nodes. */
<br/>
   }
<br/>
<br/>
   return index - 1;
<br/>
}
<br/>
<br/>
void
<br/>
DrawPolygon(struct vdp1_sort_node *db, struct mth_vertex vert[4], unsigned short color, unsigned char mesh, unsigned long color_calc)
<br/>
{
<br/>
   struct vdp1_cmd_table  *table;
<br/>
   unsigned short      id;
<br/>
<br/>
        /*
<br/>
         * Get the "ID." This will simply set the address as to where this
<br/>
         * sprite will be placed in memory.
<br/>
         */
<br/>
<br/>
   id = AddPolygonToList(db);
<br/>
<br/>
   table = GetTableAddress(id);
<br/>
<br/>
   table-&gt;control = 0x4;
<br/>
   table-&gt;mode = 0xc0 | (mesh &lt;&lt; 8) | (color_calc &amp; 0x7);
<br/>
   table-&gt;link = 0;
<br/>
   table-&gt;color = color;
<br/>
   table-&gt;character_base = 0;
<br/>
   table-&gt;size = 0;
<br/>
   table-&gt;xa = vert[0].x;
<br/>
   table-&gt;ya = vert[0].y;
<br/>
   table-&gt;xb = vert[1].x;
<br/>
   table-&gt;yb = vert[1].y;
<br/>
   table-&gt;xc = vert[2].x;
<br/>
   table-&gt;yc = vert[2].y;
<br/>
   table-&gt;xd = vert[3].x;
<br/>
   table-&gt;yd = vert[3].y;
<br/>
   table-&gt;gouraud_base = color_calc &gt;&gt; 16;
<br/>
   table-&gt;dummy = id;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Here is an example as to how to display two sprites and move them both.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
        /* This function pretty much sets the max_size global variable. */
<br/>
        yl_vdp1_cmd_init_list(&amp;db, 10);
<br/>
<br/>
   while (1) {
<br/>
      Vblank();
<br/>
<br/>
      yl_vdp1_cmd_init_list(&amp;db, 10);
<br/>
<br/>
      vert[0].x++;
<br/>
      vert[1].x++;
<br/>
      vert[2].x++;
<br/>
      vert[3].x++;
<br/>
<br/>
      DrawPolygon(db, vert, yl_video_rgb_555( 0,  0, 31), 0, 0);
<br/>
      DrawPolygon(db, vert, yl_video_rgb_555( 0,  0, 31), 0, 0);
<br/>
<br/>
      DestroyList();
<br/>
   }
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"><br/><br/>Last edited by Piratero on Sat Mar 31, 2007 8:22 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#123842 - sajiimori - Sat Mar 31, 2007 7:56 pm</h4>
    <div class="postbody"><span class="postbody">Polygons?  Sort nodes?  yl_vdp1_cmd_polygon?  What?
<br/>
<br/>
Try a simpler example, written in a style that's meant for communication with other people.  If you have a function that adds a polygon to a list, how about naming it addPolygonToList?
<br/>
<br/>
BTW, a polygon is not a sprite.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123843 - Piratero - Sat Mar 31, 2007 8:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Polygons?  Sort nodes?  yl_vdp1_cmd_polygon?  What?
<br/>
<br/>
Try a simpler example, written in a style that's meant for communication with other people.  If you have a function that adds a polygon to a list, how about naming it addPolygonToList?
<br/>
<br/>
BTW, a polygon is not a sprite.</td> </tr></table><span class="postbody">
<br/>
<br/>
The VDP1 is a video processor for another console. The idea with "OAM" entries is the same.
<br/>
<br/>
The function "yl_vdp1_cmd_add_table" adds a value onto the "db" list. The Polygon function "yl_vdp1_cmd_polygon" pretty much sets up a function and receives the value from "yl_vdp1_cmd_add_table."
<br/>
<br/>
I can certainly rewrite the code for a different or better solution to my problem. Any ideas?
<br/>
<br/>
By the way, I said sprite because there are other types of "command tables." I chose to display polygons first because they're the easiest to set up and see on the screen.
<br/>
<br/>
Thanks!<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123844 - keldon - Sat Mar 31, 2007 8:07 pm</h4>
    <div class="postbody"><span class="postbody">He is just saying that you have an irregular naming scheme that makes it very difficult to be able to make sense of some lines without looking at the code of the function and figuring it out from there. That is never a good thing; if a method adds polygons, call it addPolygon.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123845 - Piratero - Sat Mar 31, 2007 8:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">He is just saying that you have an irregular naming scheme that makes it very difficult to be able to make sense of some lines without looking at the code of the function and figuring it out from there. That is never a good thing; if a method adds polygons, call it addPolygon.</td> </tr></table><span class="postbody">
<br/>
<br/>
Gotcha. I'll be renaming them.
<br/>
<br/>
Edit: Are there any alternatives to what I need to do?<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123855 - sajiimori - Sat Mar 31, 2007 10:22 pm</h4>
    <div class="postbody"><span class="postbody">It sounds like all you want is a container.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">std::vector&lt;Sprite&gt; spriteList;
<br/>
spriteList.push_back(oneSprite);
<br/>
spriteList.push_back(anotherSprite);</td> </tr></table><span class="postbody">
<br/>
...or a hand-written equivalent if you don't want to use C++.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123863 - Piratero - Sun Apr 01, 2007 12:17 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">It sounds like all you want is a container.
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">std::vector&lt;Sprite&gt; spriteList;
<br/>
spriteList.push_back(oneSprite);
<br/>
spriteList.push_back(anotherSprite);</td> </tr></table><span class="postbody">
<br/>
...or a hand-written equivalent if you don't want to use C++.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
I'll try to write myself a "container." What exactly do you mean by push_back?<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123864 - sajiimori - Sun Apr 01, 2007 12:26 am</h4>
    <div class="postbody"><span class="postbody"><a href="http://www.google.com/search?&amp;q=push%5fback" target="_blank">http://www.google.com/search?&amp;q=push%5fback</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123865 - Piratero - Sun Apr 01, 2007 12:38 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">http://www.google.com/search?&amp;q=push%5fback</td> </tr></table><span class="postbody">
<br/>
<br/>
I see, that makes sense.<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123867 - Piratero - Sun Apr 01, 2007 12:45 am</h4>
    <div class="postbody"><span class="postbody">Is there any information out on the web on the container algorithm? I haven't found much other than links explaining how to use a container...<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123869 - keldon - Sun Apr 01, 2007 1:14 am</h4>
    <div class="postbody"><span class="postbody">There are two types of containers; ordered and unordered. Lists, queues, arrays, and vectors are ordered whereas sets, bags and maps are not ordered. The container sajimori was talking about was a list type. Different methods are used depending on your choice of implementation. You could use arrays, linked lists or doubly linked lists to store your data; but I really think you should read up a little on this aswell. It is very late right now (over here) but someone should be able to give you some links if you need them.
<br/>
<br/>
In fact <a href="http://en.wikipedia.org/wiki/Standard_Template_Library#Containers" target="_blank">http://en.wikipedia.org/wiki/Standard_Template_Library#Containers</a>
<br/>
<br/>
You have different operations for different types of containers. For lists you would make use of:
<br/>
 - get( elementNumber )
<br/>
 - getSize ()
<br/>
 - add ( element )
<br/>
 - insert ( element, position )
<br/>
 - remove (position)
<br/>
 - remove ( element )
<br/>
 - addAll ( container )
<br/>
 - removeAll ( container )
<br/>
 - retainAll ( container ) // remove everything in this list apart from those in the passed container
<br/>
<br/>
<br/>
With sets you would generally have:
<br/>
 - add ( element )
<br/>
 - remove ( element )
<br/>
 - getIterator ()
<br/>
 - addAll ( container )
<br/>
 - removeAll ( container )
<br/>
 - retainAll ( container ) // remove everything in this list apart from those in the passed container</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123871 - Piratero - Sun Apr 01, 2007 1:23 am</h4>
    <div class="postbody"><span class="postbody">Thank You!! That list is very useful.
<br/>
<br/>
Edit: I forgot to mention that I don't plan on using malloc/free to allocate memory as the "container" will have a fixed size of 2,048 entries.<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123877 - sajiimori - Sun Apr 01, 2007 2:18 am</h4>
    <div class="postbody"><span class="postbody">When you have a fixed-size buffer, one easy solution is to run a linked list through it.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
struct Link
<br/>
{
<br/>
   Link* next;
<br/>
   Object object;
<br/>
};
<br/>
<br/>
Link pool[NUM_LINKS];
<br/>
Link* firstFree;
<br/>
<br/>
void init()
<br/>
{
<br/>
   for(int i = 0; i &lt; NUM_LINKS - 1; ++i)
<br/>
      pool[i].next = &amp;pool[i + 1];
<br/>
<br/>
   firstFree = &amp;pool[0];
<br/>
}
<br/>
<br/>
Object* alloc()
<br/>
{
<br/>
   assert(firstFree != 0);
<br/>
   Object* result = firstFree;
<br/>
   firstFree = firstFree-&gt;next;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
I'll leave the free() function as an exercise.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123879 - Piratero - Sun Apr 01, 2007 2:55 am</h4>
    <div class="postbody"><span class="postbody">So the "free" function from that snip of code you pasted should point have the previous node point to the next node? In this case, would setting the "freed" node to zero be good enough or just simply have it point to the next node?
<br/>
<br/>
A very different approach:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
#define MAX_ELEMENTS   2048
<br/>
<br/>
typedef struct cmd_table_t {
<br/>
   unsigned short   control;
<br/>
   unsigned short   link;
<br/>
   unsigned short   mode;
<br/>
   unsigned short   color;
<br/>
   unsigned short   character_base;
<br/>
   unsigned short   size;
<br/>
   signed short   xa;
<br/>
   signed short   ya;
<br/>
   signed short   xb;
<br/>
   signed short   yb;
<br/>
   signed short   xc;
<br/>
   signed short   yc;
<br/>
   signed short   xd;
<br/>
   signed short   yd;
<br/>
   unsigned short   gouraud_base;
<br/>
   unsigned short   dummy;
<br/>
} element_t;
<br/>
<br/>
typedef struct container_t {
<br/>
   element_t   elements[MAX_ELEMENTS];
<br/>
} container_t;
<br/>
<br/>
static int container_size = 0;
<br/>
<br/>
int
<br/>
empty(element_t element)
<br/>
{
<br/>
   if (element.control == 0xffff)
<br/>
      return 1;
<br/>
   else
<br/>
      return 0;
<br/>
}
<br/>
<br/>
element_t
<br/>
get(container_t container, int element_number)
<br/>
{
<br/>
<br/>
   return container.elements[element_number];
<br/>
}
<br/>
<br/>
int
<br/>
get_size(container_t container)
<br/>
{
<br/>
<br/>
   return (sizeof(container) &gt;&gt; 5) - container_size;
<br/>
}
<br/>
<br/>
void
<br/>
house_cleaning(container_t *container)
<br/>
{
<br/>
   int n;
<br/>
<br/>
   for (n = 0; n &lt; get_size(*container); n++) {
<br/>
      container-&gt;elements[n].control = 0xffff;
<br/>
      container-&gt;elements[n].link = 0xffff;
<br/>
      container-&gt;elements[n].mode = 0xffff;
<br/>
      container-&gt;elements[n].color = 0xffff;
<br/>
      container-&gt;elements[n].character_base = 0xffff;
<br/>
      container-&gt;elements[n].size = 0xffff;
<br/>
      container-&gt;elements[n].xa = 0xffff;
<br/>
      container-&gt;elements[n].ya = 0xffff;
<br/>
      container-&gt;elements[n].xb = 0xffff;
<br/>
      container-&gt;elements[n].yb = 0xffff;
<br/>
      container-&gt;elements[n].xc = 0xffff;
<br/>
      container-&gt;elements[n].yc = 0xffff;
<br/>
      container-&gt;elements[n].xd = 0xffff;
<br/>
      container-&gt;elements[n].yd = 0xffff;
<br/>
      container-&gt;elements[n].gouraud_base = 0xffff;
<br/>
      container-&gt;elements[n].dummy = 0xffff;
<br/>
   }
<br/>
}
<br/>
<br/>
void
<br/>
add(element_t element)
<br/>
{
<br/>
}
<br/>
<br/>
void
<br/>
insert(container_t *container, element_t element, int position)
<br/>
{
<br/>
   if (position &lt; get_size(*container)) {
<br/>
      if (empty(container-&gt;elements[position])) {
<br/>
         printf("inserting into position: %d\n", position);
<br/>
         container-&gt;elements[position] = element;
<br/>
         container_size++;
<br/>
      } else {
<br/>
         printf("position %d is used\n", position);
<br/>
      }
<br/>
   } else
<br/>
      printf("reached the total amount of elements, use remove_all()\n");
<br/>
}
<br/>
<br/>
void
<br/>
remove_pos(int position)
<br/>
{
<br/>
}
<br/>
<br/>
void
<br/>
remove_element(element_t element)
<br/>
{
<br/>
}
<br/>
<br/>
void
<br/>
add_all(container_t container)
<br/>
{
<br/>
}
<br/>
<br/>
void
<br/>
remove_all(container_t container)
<br/>
{
<br/>
}
<br/>
<br/>
element_t
<br/>
add_polygon(unsigned short color)
<br/>
{
<br/>
   element_t write;
<br/>
<br/>
   write.control = 0;
<br/>
   write.color = color;
<br/>
<br/>
   return write;
<br/>
}
<br/>
<br/>
int
<br/>
main(void)
<br/>
{
<br/>
   container_t   container;
<br/>
   element_t   element;
<br/>
<br/>
   /* Ignore this! */
<br/>
   house_cleaning(&amp;container);
<br/>
<br/>
   element = add_polygon(0x801f);
<br/>
<br/>
   insert(&amp;container, element, 0);
<br/>
   insert(&amp;container, element, 1);
<br/>
   insert(&amp;container, element, 2);
<br/>
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123941 - sajiimori - Sun Apr 01, 2007 9:25 pm</h4>
    <div class="postbody"><span class="postbody">Assorted exercises:
<br/>
<br/>
In my example, if you called alloc() exactly NUM_LINKS times, what would be the value of firstFree?
<br/>
<br/>
What would happen if you called alloc() one more time after that?
<br/>
<br/>
The goal of the free() function is to take an Object* that was previously returned by alloc() and make it available to alloc() again.
<br/>
<br/>
What are the advantages of your approach and my approach?  How would you decide which one to use?
<br/>
<br/>
Pass large structures (larger than an int) by reference, not by value.  Passing by value causes them to be copied.
<br/>
<br/>
Make a clearer definition of a container's "size".  You have two different concepts that are both named size: the container_size variable, and the get_size(container_t) function.
<br/>
<br/>
get_size is fairly magical.  How does shifting right by 5 have to do with the size of a container?
<br/>
<br/>
Why is 'container_size' global when 'container' is local?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#123962 - sgeos - Mon Apr 02, 2007 4:25 am</h4>
    <div class="postbody"><span class="postbody">Remember that you can use array indices instead of pointers:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define MAX_NODES 20 // whatever makes sense
<br/>
#define NO_FREE_NODE -1
<br/>
#define FREE_NODE 1
<br/>
#define USED_NODE 0
<br/>
<br/>
typedef struct node_t
<br/>
{
<br/>
   data_t data;   // This node's data.
<br/>
   int prev;      // The index of the previous node.
<br/>
   int next;      // The index of the next node.
<br/>
   int free;      // Is this node free, or in use?
<br/>
} node_t;
<br/>
<br/>
node_t myLinkedList[MAX_NODES];
<br/>
<br/>
int getFreeNode(node_t *pLinkedList, int pSize)
<br/>
{
<br/>
   int i;
<br/>
<br/>
   for (i = 0; i &lt; pSize; i++)
<br/>
      if (FREE_NODE == pLinkedList-&gt;free)
<br/>
         return i;
<br/>
   // else
<br/>
      return NO_FREE_NODE;
<br/>
}
<br/>
<br/>
node_t *getNode(node_t *pLinkedList, int pNodeId)
<br/>
{
<br/>
   return &amp;(pLinkedList[pNodeId]);
<br/>
}
<br/>
<br/>
void insertAfterNode(node_t *pLinkedList, int pSize, int pLocation, int pNodeId)
<br/>
{
<br/>
   node_t *prevNode   = getNode(pLinkedList, pLocation);
<br/>
   node_t *nextNode   = getNode(pLinkedList, prevNode-&gt;next);
<br/>
   node_t *insertNode = getNode(pLinkedList, pNodeId);
<br/>
<br/>
   // link the new node to old nodes
<br/>
   insertNode-&gt;prev = pLocation;
<br/>
   insertNode-&gt;next = prevNode-&gt;next;
<br/>
<br/>
   // mark new node as not free
<br/>
   insertNode-&gt;free = USED_NODE;
<br/>
<br/>
   // link old nodes to new node
<br/>
   prevNode-&gt;next = pNodeId;
<br/>
   nextNode-&gt;prev = pNodeId;
<br/>
}
<br/>
<br/>
void deleteNode(node_t *pLinkedList, int pSize, int pNodeId)
<br/>
{
<br/>
   node_t *targetNode = getNode(pLinkedList, pNodeId);
<br/>
   node_t *prevNode   = getNode(pLinkedList, targetNode-&gt;prev);
<br/>
   node_t *nextNode   = getNode(pLinkedList, targetNode-&gt;next);
<br/>
<br/>
   // link old nodes to new node
<br/>
   prevNode-&gt;next = targetNode-&gt;next;
<br/>
   nextNode-&gt;prev = targetNode-&gt;prev;
<br/>
<br/>
   // mark target node as free
<br/>
   targetNode-&gt;free = FREE_NODE;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
There is probably a clearer way to write all of this.
<br/>
<br/>
You could even pull the struct apart and have an array of data and an array of links.  This way the link struct could be used with any kind of data:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define MAX_DATA 32
<br/>
<br/>
typedef struct link_t
<br/>
{
<br/>
   int prev;
<br/>
   int next;
<br/>
   int free;
<br/>
} link_t;
<br/>
<br/>
data_t data[MAX_DATA];           // &lt;- data lives here
<br/>
link_t myLinkedList[MAX_DATA];   // same number of links, one for each data member</td> </tr></table><span class="postbody">
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124040 - Piratero - Mon Apr 02, 2007 6:35 pm</h4>
    <div class="postbody"><span class="postbody">sgeos, thanks for the code, I'm looking at it now.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Assorted exercises:
<br/>
<br/>
In my example, if you called alloc() exactly NUM_LINKS times, what would be the value of firstFree?
<br/>
</td> </tr></table><span class="postbody">
<br/>
0
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
What would happen if you called alloc() one more time after that?
<br/>
</td> </tr></table><span class="postbody">
<br/>
Segmentation Fault.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The goal of the free() function is to take an Object* that was previously returned by alloc() and make it available to alloc() again.
<br/>
<br/>
What are the advantages of your approach and my approach?  How would you decide which one to use?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Pass large structures (larger than an int) by reference, not by value.  Passing by value causes them to be copied.
<br/>
<br/>
Make a clearer definition of a container's "size".  You have two different concepts that are both named size: the container_size variable, and the get_size(container_t) function.
<br/>
<br/>
get_size is fairly magical.  How does shifting right by 5 have to do with the size of a container?
<br/>
</td> </tr></table><span class="postbody">
<br/>
I'll fix that, thanks. The code did change so I did fix that. The get_size() has changed. I'll post the new code.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Why is 'container_size' global when 'container' is local?
<br/>
</td> </tr></table><span class="postbody">
<br/>
Good question. I guess you can say that container is allocated and container_size keeps track of the amount of objects i have inserted.
<br/>
container_size will probably give me trouble when I want to remove anything.
<br/>
<br/>
Here is the new code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;vdp1.h&gt;
<br/>
<br/>
static unsigned short   container_size = 0, current_pos = 0, max_size = 0;
<br/>
<br/>
static __inline__ unsigned char
<br/>
element_empty(struct vdp1_cmd_table command_table)
<br/>
{
<br/>
<br/>
   return ((command_table.cmdctrl != 0xffff) ? 0 : 1);
<br/>
}
<br/>
<br/>
<br/>
void
<br/>
add_element(struct container *container, struct vdp1_cmd_table command_table)
<br/>
{
<br/>
   if (current_pos &lt; (max_size - get_size())) {
<br/>
      if (_container_element_empty(container[current_pos].command_table))
<br/>
         container_size++;
<br/>
<br/>
      container[current_pos].command_table = command_table;
<br/>
   }
<br/>
<br/>
   current_pos++;
<br/>
}
<br/>
<br/>
void
<br/>
draw_objects(struct container *container)
<br/>
{
<br/>
   struct vdp1_cmd_table  *table;
<br/>
   unsigned short      dma_mode;
<br/>
   unsigned short      n;
<br/>
<br/>
   dma_mode = (1 &lt;&lt; 14) | (1 &lt;&lt; 12) | (1 &lt;&lt; 11) | (1 &lt;&lt; 9) | (1 &lt;&lt; 3) | (1 &lt;&lt; 0);
<br/>
   table = (struct vdp1_cmd_table *)VDP1_CMD_TABLE_BASE;
<br/>
<br/>
   /* Copy the entire list. */
<br/>
   for (n = 0; n &lt; container_size; n++)
<br/>
      sh2_dmac_ch0(&amp;table[n], &amp;container[n].command_table, 8, dma_mode);
<br/>
}
<br/>
<br/>
struct vdp1_cmd_table
<br/>
get_element(struct container *container, unsigned short pos)
<br/>
{
<br/>
   if (pos &lt; (max_size - get_size()))
<br/>
      return container[pos].command_table;
<br/>
<br/>
   return container-&gt;command_table;
<br/>
}
<br/>
<br/>
unsigned short
<br/>
get_size(void)
<br/>
{
<br/>
   return ((container_size &lt; max_size) ? container_size : 0);
<br/>
}
<br/>
<br/>
void
<br/>
init_list(struct container **container, unsigned long max)
<br/>
{
<br/>
   unsigned short n;
<br/>
<br/>
   *container = (struct container *)0x2020000;
<br/>
   max_size = VDP1_MAX_CMD_TABLES;
<br/>
<br/>
   for (n = 0; n &lt; (max_size - get_size()); n++) {
<br/>
      container[n]-&gt;next = &amp;container[0][n + 1];
<br/>
<br/>
      yl_vdp1_cmd_disable(&amp;container[0][n].command_table);
<br/>
   }
<br/>
}
<br/>
<br/>
<br/>
void
<br/>
insert_element(struct container *container, struct vdp1_cmd_table command_table, unsigned short pos)
<br/>
{
<br/>
   if (pos &lt; (max_size - get_size())) {
<br/>
      if (element_empty(container[pos].command_table))
<br/>
         container_size++;
<br/>
<br/>
      container[pos].command_table = command_table;
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124048 - gmiller - Mon Apr 02, 2007 8:11 pm</h4>
    <div class="postbody"><span class="postbody">Depending on how you want to use the nodes you could have a link list of free nodes and the link list of "used" nodes so when you want a free node you just grad the first node in the list.  This just means when you "de-allocate" a node you need to insert it into the free list.  This is generally the approach I take for static or controlled allocation.  
<br/>
<br/>
You could also use the concept of an allocation table (like what FAT disks use) where you have one bit for each possible node and you turn the bit off if its free and turn the bit on if it is not.  
<br/>
<br/>
There are lots of approaches to you could use, you just have to find one that fits you knowledge and overall design the best.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124049 - Piratero - Mon Apr 02, 2007 8:25 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">Depending on how you want to use the nodes you could have a link list of free nodes and the link list of "used" nodes so when you want a free node you just grad the first node in the list.  This just means when you "de-allocate" a node you need to insert it into the free list.  This is generally the approach I take for static or controlled allocation.  
<br/>
<br/>
You could also use the concept of an allocation table (like what FAT disks use) where you have one bit for each possible node and you turn the bit off if its free and turn the bit on if it is not.  
<br/>
<br/>
There are lots of approaches to you could use, you just have to find one that fits you knowledge and overall design the best.</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks for the ideas. This seems like a good idea because if I were to want to insert a free node, I'd have to search for one. This way, I know that I can just simply fetch one and insert.<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124051 - gmiller - Mon Apr 02, 2007 8:27 pm</h4>
    <div class="postbody"><span class="postbody">here is an example of the FAT method without the list list code. I use this in the class I teach (Machine Architecture).
<br/>
<br/>
NOTE:: Of course this code is just testing the implementation of the function so the main code does not really do much other than test over allocation, under allocation, empty and fully allocated.  also this was implemented in C not C++ using malloc and free not new and delete.  I like the free and used link lists better for small sets.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
/*
<br/>
<br/>
test
<br/>
<br/>
Use bit map to track sprite allocation.  The sprite data is
<br/>
allocated in an array and tracked using a bit map.  A one
<br/>
on in the bit map shows that the sprite is in use.  A zero
<br/>
on indicates that the sprite data is free and not in use.
<br/>
<br/>
*/
<br/>
<br/>
<br/>
#include &lt;stdio.h&gt;
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
<br/>
<br/>
#define DEBUG 1
<br/>
#define TRACE 1
<br/>
<br/>
static char const ident[] =
<br/>
  "$Id: msprite.c,v 1.3 2005/09/27 20:28:57 gmiller Exp gmiller $";
<br/>
<br/>
#include "debug.h"
<br/>
<br/>
const int SHIFT_SIZE[17] =
<br/>
  { 0, 3, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 7 };
<br/>
<br/>
//  macros
<br/>
<br/>
#define ELEMENT_BITS ((sizeof(int)*8))
<br/>
#define ELEMENT_MASK (ELEMENT_BITS - 1)
<br/>
#define ELEMENT_SHIFT (SHIFT_SIZE[sizeof(int)])
<br/>
#define ALL_ELEMENTS_USED (~0)
<br/>
<br/>
//  
<br/>
/*
<br/>
sample line:
<br/>
  // increment variable. (WHAT not HOW)
<br/>
  fubar_variable = - (~fubar_valiable);
<br/>
<br/>
<br/>
<br/>
*/
<br/>
<br/>
typedef enum
<br/>
{ NO_ERROR = 0,
<br/>
  BAD_SPRITE_PTR = -1,
<br/>
  BAD_SPRITE_NO = -2,
<br/>
  BAD_SPRITE_IS_FREE = -3,
<br/>
  BAD_SPRITE_IS_USED = -4,
<br/>
  BAD_SPRITE_ALL_USED = -5,
<br/>
  BAD_ALL_SPRITES_FREE = -6
<br/>
} sprite_error;
<br/>
<br/>
typedef struct _sprites_
<br/>
{
<br/>
  int x;                        // Current Sprite location x,y
<br/>
  int y;
<br/>
  int rows, cols;               // Size of Sprite Row x Col
<br/>
  char *elements;               // Data to display (size is Row x Col)
<br/>
  int life_value;               // Life force
<br/>
  int sprite_number;            // Sprite number in set, zero based
<br/>
} sprite;
<br/>
<br/>
typedef struct _allocation_data_
<br/>
{
<br/>
  int number_of_elements;       // number of possible sprites
<br/>
  int first_free;               // first element with free bit
<br/>
  int shift_amt;                // shift for entry index
<br/>
  int bit_mask;                 // mask to isolate bit number
<br/>
  int max_entry;                // maximum entry in array of bits
<br/>
  int *bit_table;               // bits for each possible sprite
<br/>
  int free_cnt;                 // number of free sprites
<br/>
  int used_cnt;                 // number of used sprites
<br/>
} allocation_data;
<br/>
<br/>
typedef struct _sprite_tbl_
<br/>
{
<br/>
  allocation_data salloc;       // allocation data
<br/>
  sprite *sprites;              // sprite data
<br/>
} sprite_tbl;
<br/>
<br/>
/*
<br/>
<br/>
Allocate space to manage a group of "number_of_sprites"
<br/>
using the defined structures.  Allocate space, initalize
<br/>
memory and return pointer.  Return != NULL if no error otherwise
<br/>
return NULL
<br/>
<br/>
Sample usage:
<br/>
<br/>
  sprite_tbl tbl_ptr;
<br/>
<br/>
  tbl_ptr = allocate_sprite_table( 1024 );
<br/>
  if ( tbl_ptr == NULL ) {
<br/>
    printf("Table allocation failed.\n");
<br/>
    exit( -1 );
<br/>
  }
<br/>
<br/>
<br/>
*/
<br/>
sprite_tbl *
<br/>
allocate_sprite_table (int number_of_sprites)
<br/>
{
<br/>
  static char my_fn[] = "allocate_sprite_table";
<br/>
  sprite_tbl sample, *tmp_s;
<br/>
  int i;
<br/>
  int last_element_no = number_of_sprites - 1;
<br/>
<br/>
  enter (my_fn);
<br/>
<br/>
  // Check size of int on this platform
<br/>
  if ((sizeof (int) + 1) &gt; (sizeof (SHIFT_SIZE) / sizeof (int))) {
<br/>
    printf ("Shift table size exceeded, modify code for this machine.\n");
<br/>
    exit (-1);
<br/>
  }
<br/>
<br/>
  // Check for number of sprites
<br/>
  if (number_of_sprites &lt;= 0)
<br/>
    rtnval (NULL);
<br/>
<br/>
  // Allocate space for for table area
<br/>
  tmp_s = (sprite_tbl *) malloc (sizeof (sprite_tbl));
<br/>
  if (tmp_s == NULL)
<br/>
    rtnval (NULL);
<br/>
<br/>
  // Clear data area
<br/>
  memset (tmp_s, 0, sizeof (sprite_tbl));
<br/>
  // Allocate space for sprites
<br/>
  tmp_s-&gt;sprites = calloc (number_of_sprites, sizeof (sprite));
<br/>
  if (tmp_s-&gt;sprites == NULL) {
<br/>
    free (tmp_s);
<br/>
    rtnval (NULL);
<br/>
  }
<br/>
<br/>
  // Initalize sprite numbers
<br/>
  for (i = 0; i &lt; number_of_sprites; i++)
<br/>
    tmp_s-&gt;sprites[i].sprite_number = i;
<br/>
<br/>
  // Set table initial values 
<br/>
  tmp_s-&gt;salloc.number_of_elements = number_of_sprites;
<br/>
  tmp_s-&gt;salloc.shift_amt = ELEMENT_SHIFT;  // Shift amount for each "int"
<br/>
  tmp_s-&gt;salloc.bit_mask = ELEMENT_MASK;    // mask to clear unused bits
<br/>
  // Allocate bit table
<br/>
  //TODO::
<br/>
  tmp_s-&gt;salloc.bit_table = (int *) calloc (((number_of_sprites +
<br/>
                                              (ELEMENT_BITS -
<br/>
                                               1)) &gt;&gt; ELEMENT_SHIFT),
<br/>
                                            sizeof (int));
<br/>
  // Allocate the correct number of bits
<br/>
  if (tmp_s-&gt;salloc.bit_table == NULL) {
<br/>
    free (tmp_s);
<br/>
    rtnval (NULL);
<br/>
  }
<br/>
<br/>
<br/>
// Set count of free sprites to number of sprites
<br/>
  tmp_s-&gt;salloc.free_cnt = number_of_sprites;
<br/>
<br/>
  //
<br/>
  tmp_s-&gt;salloc.max_entry = (last_element_no &gt;&gt; ELEMENT_SHIFT);
<br/>
<br/>
  // Check bit usage in last element
<br/>
  //
<br/>
  if ((last_element_no &amp; ELEMENT_MASK) != (ELEMENT_BITS - 1)) {
<br/>
    int tmp_bit = ((~0) &lt;&lt; ((last_element_no &amp; ELEMENT_MASK) + 1));
<br/>
/*
<br/>
<br/>
  last bit used (zero based) and add one to get next power of 2, shift
<br/>
  an all one value to the left to clear the number of bit positions and
<br/>
  then use that to set the last position in the table.
<br/>
<br/>
*/
<br/>
<br/>
// Fix last element for bits allocated after last element
<br/>
    tmp_s-&gt;salloc.bit_table[tmp_s-&gt;salloc.max_entry] = (tmp_bit);
<br/>
<br/>
  }
<br/>
<br/>
  rtnval (tmp_s);
<br/>
<br/>
}
<br/>
<br/>
/*
<br/>
<br/>
Return a pointer to a free sprite in the passed table.  If no
<br/>
free sprites are found return a NULL, otherwise mark the sprite
<br/>
as "inuse" and return a pointer to the structure.
<br/>
<br/>
Sample usage:
<br/>
<br/>
  sprite * sp_ptr;
<br/>
<br/>
  sp_ptr = get_free_sprite( tbl_ptr, &amp;err_flag );
<br/>
  if ( err_flag !=  NO_ERROR ) {
<br/>
    printf("Get free sprite failed with error %d\n", err_flag);
<br/>
    exit( -1 );
<br/>
  }
<br/>
<br/>
*/
<br/>
sprite *
<br/>
get_free_sprite (sprite_tbl * stbl, sprite_error * err)
<br/>
{
<br/>
  static char my_fn[] = "get_free_sprite";
<br/>
  int i, *tmp, mask;
<br/>
<br/>
  enter (my_fn);
<br/>
<br/>
  if (stbl == NULL) {           // bad ptr
<br/>
    *err = BAD_SPRITE_PTR;
<br/>
    rtnval (NULL);
<br/>
  }
<br/>
<br/>
  if (stbl-&gt;salloc.free_cnt == 0) { // none free
<br/>
    *err = BAD_SPRITE_ALL_USED;
<br/>
    rtnval (NULL);
<br/>
  }
<br/>
<br/>
  //
<br/>
  tmp = stbl-&gt;salloc.bit_table + stbl-&gt;salloc.first_free;   // point a first bit mask
<br/>
  for (i = stbl-&gt;salloc.first_free; i &lt;= stbl-&gt;salloc.max_entry; i++, tmp++) {  // loop through bit masks
<br/>
    if (*tmp != (~0)) {         // All bits on, then all used, otherwise some free
<br/>
      //
<br/>
      int bit_array_index = (i &lt;&lt; stbl-&gt;salloc.shift_amt);  // get bit number of first bit
<br/>
      int bit_offset;           // count bits
<br/>
      int mask = 1;             // mask for first bit
<br/>
<br/>
/*
<br/>
  Loop through all possible bit positions, count bits and shifting mask.
<br/>
*/
<br/>
<br/>
      for (bit_offset = 0; bit_offset &lt; ELEMENT_BITS;   // loop through bits
<br/>
           //
<br/>
           bit_offset++, mask = mask &lt;&lt; 1) {    // looking for 0 bits
<br/>
        if (((*tmp) &amp; mask) == 0) { // bit off ??
<br/>
          bit_array_index += bit_offset;    // get bit number
<br/>
          *tmp = (*tmp) | mask; // mark bit used
<br/>
          stbl-&gt;salloc.used_cnt++;  // one more used
<br/>
          stbl-&gt;salloc.free_cnt--;  // one less free
<br/>
          *err = NO_ERROR;
<br/>
          rtnval (stbl-&gt;sprites + bit_array_index); // return pointer to bit data
<br/>
        }
<br/>
      }
<br/>
      *err = BAD_SPRITE_ALL_USED;
<br/>
      rtnval (NULL);            // all used .... this means free count is fubar.
<br/>
    }
<br/>
  }
<br/>
<br/>
  *err = BAD_SPRITE_ALL_USED;
<br/>
  rtnval (NULL);                // all used .... this means free count is fubar.
<br/>
}
<br/>
<br/>
/*
<br/>
<br/>
Mark a "inuse" sprite as free in the passed table.  If the sprite
<br/>
is not "inuse" or any other error return a nonzero value that
<br/>
indicates the error.
<br/>
<br/>
Sample usage:
<br/>
<br/>
  sprite_error sp_error;
<br/>
<br/>
  sp_error = free_sprite( tbl_ptr, 5 );
<br/>
  if ( sp_error != NO_ERROR ) {
<br/>
    printf("Free of sprite failed with error %d\n", sp_error );
<br/>
    exit( -1 );
<br/>
  }
<br/>
<br/>
*/
<br/>
sprite_error
<br/>
free_sprite (sprite_tbl * stbl, int sprite_number)
<br/>
{
<br/>
  static char my_fn[] = "free_sprite";
<br/>
  int bit_array_index;          // get bit array index
<br/>
  int bit_mask;                 // get bit mask
<br/>
<br/>
  enter (my_fn);
<br/>
<br/>
  if (stbl == NULL)             // bad ptr
<br/>
    rtnval (BAD_SPRITE_PTR);
<br/>
<br/>
  if (stbl-&gt;salloc.used_cnt == 0)   // none used
<br/>
    rtnval (BAD_ALL_SPRITES_FREE);
<br/>
<br/>
  if ((sprite_number &gt;= stbl-&gt;salloc.number_of_elements) || // out of range
<br/>
      (sprite_number &lt; 0))      // out of range
<br/>
    rtnval (BAD_SPRITE_NO);
<br/>
<br/>
  // Get mask to isolate correct bit
<br/>
  //
<br/>
  bit_array_index = (sprite_number &gt;&gt; stbl-&gt;salloc.shift_amt);
<br/>
  bit_mask = (1 &lt;&lt; (sprite_number &amp; (stbl-&gt;salloc.bit_mask)));
<br/>
<br/>
  // Check for bit on
<br/>
  //
<br/>
  if ((stbl-&gt;salloc.bit_table[bit_array_index] &amp; bit_mask) != 0) {
<br/>
    //
<br/>
    stbl-&gt;salloc.bit_table[bit_array_index] &amp;= ~bit_mask;   // turn bit off
<br/>
    stbl-&gt;salloc.used_cnt--;    // one less used
<br/>
    stbl-&gt;salloc.free_cnt++;    // one more free
<br/>
    if (bit_array_index &lt; stbl-&gt;salloc.first_free)  // reset first free if needed
<br/>
      stbl-&gt;salloc.first_free = bit_array_index;
<br/>
    rtnval (NO_ERROR);
<br/>
  }
<br/>
<br/>
  rtnval (BAD_SPRITE_IS_FREE);
<br/>
<br/>
}
<br/>
<br/>
/*
<br/>
<br/>
Get the pointer to an "inuse" sprite in the passed table.  If the
<br/>
sprite is not "inuse" or some other error return a NULL.
<br/>
<br/>
Sample usage:
<br/>
<br/>
  sprite * sp_ptr;
<br/>
  sprite_error err_flag;
<br/>
<br/>
  sp_ptr = get_used_sprite( tbl_ptr, 5, &amp;err_flag );
<br/>
  if ( err_flag != NO_ERROR ) {
<br/>
    printf("Get pointer to used sprite failed with error %d\n", err_flag );
<br/>
    exit( -1 );
<br/>
  }
<br/>
<br/>
*/
<br/>
sprite *
<br/>
get_used_sprite (sprite_tbl * stbl, int sprite_number, sprite_error * err)
<br/>
{
<br/>
  static char my_fn[] = "get_used_sprite";
<br/>
  int bit_array_index;          // get bit array index
<br/>
  int bit_mask;                 // get bit mask
<br/>
<br/>
  enter (my_fn);
<br/>
<br/>
  if (stbl == NULL) {           // bad ptr
<br/>
    *err = BAD_SPRITE_PTR;
<br/>
    rtnval (NULL);
<br/>
  }
<br/>
<br/>
  if (stbl-&gt;salloc.used_cnt == 0) { // none used
<br/>
    *err = BAD_ALL_SPRITES_FREE;
<br/>
    rtnval (NULL);
<br/>
  }
<br/>
<br/>
  if ((sprite_number &gt;= stbl-&gt;salloc.number_of_elements) || // out of range
<br/>
      (sprite_number &lt; 0)) {    // out of range
<br/>
    *err = BAD_SPRITE_NO;
<br/>
    rtnval (NULL);
<br/>
  }
<br/>
<br/>
  // Get mask to isolate correct bit
<br/>
  //
<br/>
  bit_array_index = (sprite_number &gt;&gt; stbl-&gt;salloc.shift_amt);
<br/>
  bit_mask = (1 &lt;&lt; (sprite_number &amp; (stbl-&gt;salloc.bit_mask)));
<br/>
<br/>
  // Check for bit on
<br/>
  //
<br/>
  if ((stbl-&gt;salloc.bit_table[bit_array_index] &amp; bit_mask) != 0) {  // bit on ??
<br/>
    *err = NO_ERROR;
<br/>
    rtnval (stbl-&gt;sprites + sprite_number);
<br/>
  }
<br/>
<br/>
  *err = BAD_SPRITE_IS_FREE;
<br/>
  rtnval (NULL);
<br/>
}
<br/>
<br/>
int
<br/>
main (int argc, char **argv)
<br/>
{
<br/>
<br/>
  static char my_fn[] = "msprite";
<br/>
  sprite_tbl *my_sprites;
<br/>
  sprite *tmp_s;
<br/>
  int i, number;
<br/>
  sprite_error err;
<br/>
  sprite_error *err_ptr = &amp;err;
<br/>
<br/>
<br/>
  enter (my_fn);
<br/>
  set_debug ();
<br/>
  Log_debug ("This is the start of the program");
<br/>
<br/>
  if (argc &lt; 2) {
<br/>
    printf ("%s n\n", argv[0]);
<br/>
    printf (" n - count of sprites\n");
<br/>
    exit (-1);
<br/>
  }
<br/>
<br/>
  number = atoi (argv[1]);
<br/>
<br/>
  my_sprites = allocate_sprite_table (number);
<br/>
  if (my_sprites == NULL) {
<br/>
    printf ("Unable to allocate sprite table\n");
<br/>
    exit (-1);
<br/>
  }
<br/>
<br/>
  for (i = 0; i &lt; (my_sprites-&gt;salloc.number_of_elements + 2); i++) {
<br/>
    if ((tmp_s = get_free_sprite (my_sprites, err_ptr)) == NULL)
<br/>
      printf ("Get free failed on try %d with error %d\n", i, err);
<br/>
  }
<br/>
<br/>
  printf ("After get_free, used = %d, free = %d\n",
<br/>
          my_sprites-&gt;salloc.used_cnt, my_sprites-&gt;salloc.free_cnt);
<br/>
<br/>
  for (i = 0; i &lt; (my_sprites-&gt;salloc.number_of_elements + 2); i++) {
<br/>
    if ((tmp_s = get_used_sprite (my_sprites, i, err_ptr)) == NULL)
<br/>
      printf ("Get used failed on try %d with error %d\n", i, err);
<br/>
  }
<br/>
<br/>
  printf ("After get_used, used = %d, free = %d\n",
<br/>
          my_sprites-&gt;salloc.used_cnt, my_sprites-&gt;salloc.free_cnt);
<br/>
<br/>
  for (i = 2; i &lt; (my_sprites-&gt;salloc.number_of_elements); i++) {
<br/>
    if ((err = free_sprite (my_sprites, i)) != 0)
<br/>
      printf ("Free for sprite %d failed with error %d\n", i, err);
<br/>
  }
<br/>
<br/>
  printf ("After free_sprite, used = %d, free = %d\n",
<br/>
          my_sprites-&gt;salloc.used_cnt, my_sprites-&gt;salloc.free_cnt);
<br/>
<br/>
  for (i = 0; i &lt; 2; i++) {
<br/>
    if ((tmp_s = get_used_sprite (my_sprites, i, err_ptr)) == NULL)
<br/>
      printf ("Get used failed on try %d with error %d\n", i, err);
<br/>
  }
<br/>
<br/>
  printf ("After 2nd get_free, used = %d, free = %d\n",
<br/>
          my_sprites-&gt;salloc.used_cnt, my_sprites-&gt;salloc.free_cnt);
<br/>
<br/>
<br/>
<br/>
  rtnval (0);
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124059 - Piratero - Mon Apr 02, 2007 9:45 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for all the help guys! I really appreciate it! It looks I'll try gmiller's ideas and see what I can come up with.
<br/>
<br/>
So far it looks like I'll be needing at least 32k of memory to pull this off.
<br/>
<br/>
gmiller, the way I see it is that I can pretty much set these two up like stacks.
<br/>
<br/>
For example, if I want to draw a sprite: "pop" from the "free list" and "push" into the "used list"
<br/>
<br/>
If I want to disable a sprite: "pop" from the "used list" and "push" into the "free list"
<br/>
<br/>
That sound good?<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124065 - gmiller - Mon Apr 02, 2007 11:57 pm</h4>
    <div class="postbody"><span class="postbody">Yes that is the idea.  I use this method to keep from reallocating buffers in systems that must run for a long time.  When I startup I allocate a configured number of buffers and use them poping off the free into link lists and then pushing them back when I free up the node.  This worked for static and heap allocated things as long as they are either the same size or the largest type is used to allocate the the initial free type.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124098 - sgeos - Tue Apr 03, 2007 2:52 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">you could have a link list of free nodes and the link list of "used" nodes</td> </tr></table><span class="postbody">
<br/>
Fantastic idea.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">you have one bit for each possible node and you turn the bit off if its free and turn the bit on if it is not.</td> </tr></table><span class="postbody">
<br/>
Same thing.  The memory just lives in a different place and it is packed.
<br/>
<br/>
Pushing and popping will work.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124113 - Piratero - Tue Apr 03, 2007 6:00 am</h4>
    <div class="postbody"><span class="postbody">So 32 bits would mean 32 possible nodes?<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124135 - gmiller - Tue Apr 03, 2007 1:38 pm</h4>
    <div class="postbody"><span class="postbody">Yes 32 bits is 32 possible nodes but I usually implement the "used/free" table as an arry of int's so I can make the number of nodes as big as I want.  If the size of an int is 32 bits then the number of possible nodes is 32 * (sizeof(array)/sizeof(array[0]).  Or the more size independent (sizeof(int)*8) * (sizeof(array)/sizeof(array[0]).  These calculation would be done at compile time not run time so the divide is not an ARM issue.  To find the subscript in the array you just right shift the node number by 5 (for 32 bit int) and the bit number is the node number 'and'ed (binary) with 31.
<br/>
<br/>
This is the way the FAT storage allocation table works with a bit for every "cluster" on the disk.  The bit is on if the cluster is allocated and off if it is free.  The table is size limited so this does not work for large disks but it does work.  The sample code I posted uses this to track a limited number of nodes that are not linked together so the used and free list concept does not completely apply.  You could link the free and not the used or whatever ...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124182 - Piratero - Tue Apr 03, 2007 10:22 pm</h4>
    <div class="postbody"><span class="postbody">It actually seems to work like a charm!
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">used stack: bit mask, 10 elements
<br/>
0x000003ff,0x00000000,0x00000000,0x00000000,
<br/>
0x00000000,0x00000000,0x00000000,0x00000000,
<br/>
0x00000000,0x00000000,0x00000000,0x00000000,
<br/>
0x00000000,0x00000000,0x00000000,0x00000000,
<br/>
0x00000000,0x00000000,0x00000000,0x00000000,
<br/>
0x00000000,0x00000000,0x00000000,0x00000000,
<br/>
0x00000000,0x00000000,0x00000000,0x00000000,
<br/>
0x00000000,0x00000000,0x00000000,0x00000000,
<br/>
 --------------------|-------------------
<br/>
 free stack          |         used stack
<br/>
 --------------------|-------------------
<br/>
 0x25c00140          |         0x25c00000
<br/>
 0x25c00160          |         0x25c00020
<br/>
 0x25c00180          |         0x25c00040
<br/>
 0x25c001a0          |         0x25c00060
<br/>
 0x25c001c0          |         0x25c00080
<br/>
 0x25c001e0          |         0x25c000a0
<br/>
 0x25c00200          |         0x25c000c0
<br/>
 0x25c00220          |         0x25c000e0
<br/>
 0x25c00240          |         0x25c00100
<br/>
 0x25c00260          |         0x25c00120
<br/>
 0x25c00280 &lt;--   10 |         0x00000000
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
0x25c00000 = sprite #1
<br/>
0x25c00020 = sprite #2
<br/>
0x25c00040 = sprite #3
<br/>
...
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124233 - Piratero - Wed Apr 04, 2007 7:53 am</h4>
    <div class="postbody"><span class="postbody">Looks like I have a problem removing an element from the "used" list. For every time I "push" an element into the "used" list, I send the "used" element in the "free" list at the bottom:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
 ----------------------------|-------------------
<br/>
 free stack                  |         used stack
<br/>
 ----------------------------|-------------------
<br/>
    0. 0x25c00040 &lt;- next up |         0x25c00000
<br/>
    1. 0x25c00060            |         0x25c00020
<br/>
    2. 0x25c00080            |         0x00000000
<br/>
    3. 0x25c000a0            |         0x00000000
<br/>
    4. 0x25c000c0            |         0x00000000
<br/>
    5. 0x25c000e0 &lt;- end     |         0x00000000
<br/>
    6. 0x25c00000 &lt;- used    |         0x00000000
<br/>
    7. 0x25c00020 &lt;- used    |         0x00000000
<br/>
    
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Not really sure how to resolve this. Should I just not touch anything in the "free" list and just set the element as "used" or "free?"<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124256 - gmiller - Wed Apr 04, 2007 2:29 pm</h4>
    <div class="postbody"><span class="postbody">If you have a used linked list and a free linked list then you just need to link the nodes into the appropriate list.  Of course either list could have no elements in it so you need to handle that.  If you implemented a stack for the free nodes (rather than a linked list) then you just need to unlink them from the used link list and then push them onto the free list.  Of course the pushing and popping should be pointers/indexes to the free nodes not the nodes themselves.
<br/>
<br/>
The following code snippets show what I do in a live application using my generic link list code in C.  The link list can be any type as long as the structure you are linking is declared like the following:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define dList_LINKS(a)  \
<br/>
    struct a *next; \
<br/>
    struct a *prior
<br/>
<br/>
<br/>
<br/>
typedef struct _OUT_QUEUE_
<br/>
{
<br/>
  dList_LINKS (_OUT_QUEUE_);
<br/>
  ...
<br/>
}
<br/>
out_queue_t;
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The sList_LINKS MUST be the first part of the structure so the generic routines can manipulate them with knowledge of the rest of the fields.
<br/>
<br/>
Using the free list concept then is what I do to allocate nodes:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  dList_INIT (resource_entry_free_list);
<br/>
<br/>
  for (i = 0; i &lt; (CALL_MAX * 100); i++) {
<br/>
    queued_resource_entry *qr;
<br/>
<br/>
    qr = (queued_resource_entry *) s_malloc (sizeof (queued_resource_entry));
<br/>
    if (qr == NULL) {
<br/>
      em_exit (RTC_FAIL, "Free resource queue entry allocation failure");
<br/>
    }
<br/>
    memset (qr, 0, sizeof (queued_resource_entry));
<br/>
    dList_INIT (qr);
<br/>
    if (dList_APPEND (resource_entry_free_list, qr) == NULL) {
<br/>
      em_exit (RTC_FAIL, "Free resource queue append failure");
<br/>
    }
<br/>
<br/>
  }
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Then when I need a node i do:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  // Get a resource queue entry
<br/>
  if (dList_IS_EMPTY (resource_entry_free_list)) {
<br/>
    qr = (queued_resource_entry *) s_malloc (sizeof (queued_resource_entry));
<br/>
    if (qr == NULL) {
<br/>
      Log_error ("");
<br/>
      rtnval (result);
<br/>
    }
<br/>
    memset (qr, 0, sizeof (queued_resource_entry));
<br/>
    dList_INIT (qr);
<br/>
    Log_debug ("Needed a new free entry for the resource queue %08o",
<br/>
               rq-&gt;resource_type);
<br/>
  }
<br/>
  else {
<br/>
    qr = resource_entry_free_list-&gt;next;
<br/>
    dList_DETACH (qr);
<br/>
    Log_debug ("Got a free entry for the resource queue");
<br/>
  }
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And when I am done with the node I put it back in the free list:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
            dList_DETACH (ttmp_qr);
<br/>
            if (dList_APPEND (resource_entry_free_list, ttmp_qr) == NULL) {
<br/>
              Log_error ("Unable to add free resource entry to free queue");
<br/>
              s_free (ttmp_qr);
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124265 - sgeos - Wed Apr 04, 2007 4:33 pm</h4>
    <div class="postbody"><span class="postbody">If you are using a stack with a fixed maximum size, why not just implement it as an array and counter that keeps track of the number of used members?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define MAX_SIZE 32
<br/>
<br/>
type_t gStack[MAX_SIZE];
<br/>
int    gUsedNodes;
<br/>
<br/>
int push(type_t *pData, int pSize)
<br/>
{
<br/>
   if (pSize &lt;= gUsedNodes)
<br/>
      return OVERFLOW_ERROR;
<br/>
   copyType_t( &amp;(gStack[gUsedNodes]), pData );
<br/>
   gUsedNodes++;
<br/>
   return OK;
<br/>
}
<br/>
<br/>
int pop(type_t *pData)
<br/>
{
<br/>
   if (gUsedNodes &lt;= 0)
<br/>
      return UNDERFLOW_ERROR;
<br/>
   gUsedNodes--;
<br/>
   copyType_t( pData, &amp;(gStack[gUsedNodes]) );
<br/>
   return OK;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124280 - Piratero - Wed Apr 04, 2007 9:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">If you are using a stack with a fixed maximum size, why not just implement it as an array and counter that keeps track of the number of used members?
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define MAX_SIZE 32
<br/>
<br/>
type_t gStack[MAX_SIZE];
<br/>
int    gUsedNodes;
<br/>
<br/>
int push(type_t *pData, int pSize)
<br/>
{
<br/>
   if (pSize &lt;= gUsedNodes)
<br/>
      return OVERFLOW_ERROR;
<br/>
   copyType_t( &amp;(gStack[gUsedNodes]), pData );
<br/>
   gUsedNodes++;
<br/>
   return OK;
<br/>
}
<br/>
<br/>
int pop(type_t *pData)
<br/>
{
<br/>
   if (gUsedNodes &lt;= 0)
<br/>
      return UNDERFLOW_ERROR;
<br/>
   gUsedNodes--;
<br/>
   copyType_t( pData, &amp;(gStack[gUsedNodes]) );
<br/>
   return OK;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
-Brendan</span></td> </tr></table><span class="postbody">
<br/>
<br/>
So, then copyType_t() pretty much does something like:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void
<br/>
copyType_t(type_t *from, type_t *to)
<br/>
{
<br/>
     to-&gt;element1 = from-&gt;element1;
<br/>
     to-&gt;element2 = from-&gt;element2;
<br/>
     /* And so on... */
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks for all your help guys! I really appreciate it. The code is starting to work :)<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124287 - sajiimori - Wed Apr 04, 2007 9:40 pm</h4>
    <div class="postbody"><span class="postbody">If it's a straight bitwise copy, you can just do *to = *from.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124288 - gmiller - Wed Apr 04, 2007 9:42 pm</h4>
    <div class="postbody"><span class="postbody">The way his code works (if your assumtion for copyType_t is correct) you have data movement that is not really needed if you implement push and pop correctly.  The push should just link the add the node pointer being pushed to the free pool/list and pop should remove the node pointer from the free pool/list.  If there are no free nodes left (free list is empty) then you should get a null pointer.  Once you have a node pointer you are free to do what you want with it (other than discard it).  When you are done with the node you just need to unlink the node from any link lists and then push the pointer back into the free list.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124321 - Piratero - Thu Apr 05, 2007 2:31 am</h4>
    <div class="postbody"><span class="postbody">Everything seems to work great! I can finally delete polygons from the list! It seems to work great so far. I'll try to implement other features that'll make life  easier.
<br/>
<br/>
Here is a little teaser:
<br/>
<a href="http://img181.imageshack.us/img181/3419/triangleshd2.png">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
512 single-colored triangles displayed.<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124323 - Piratero - Thu Apr 05, 2007 2:36 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">If it's a straight bitwise copy, you can just do *to = *from.</td> </tr></table><span class="postbody">
<br/>
<br/>
I tried that and it gave me an error.
<br/>
<br/>
gmiller, I see what you mean. I did have a hard time implementing something similar to that. Instead, I just set the free list as simply a list of address offset values and the actual "used" list as a stack where I push values in. I don't really move things around other than copying a value from the "free" list.<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124324 - gmiller - Thu Apr 05, 2007 2:42 am</h4>
    <div class="postbody"><span class="postbody">The movement is not "wrong" just uneeded if implemented different.  This movement take CPU cycles that you do not need to use so I would just consider it wasteful.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124331 - Piratero - Thu Apr 05, 2007 3:41 am</h4>
    <div class="postbody"><span class="postbody">I don't understand. You're saying that my method that I described sounds like I'm using up a lot of CPU cycles? Or are you talking about the method you've explained to me earlier.<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124336 - sgeos - Thu Apr 05, 2007 4:26 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">The movement is not "wrong" just uneeded if implemented different.  This movement take CPU cycles that you do not need to use so I would just consider it wasteful.</td> </tr></table><span class="postbody">
<br/>
I was trying to illustrate a stack that does not use pointers.  If you are using a memory pool as an array, indices work just well.
<br/>
<br/>
The copy in my example code can (and probably should be) be optimized out.  Instead of writing to a node in memory you could get a free node and then push it, or call push to get a free node.  There are a bunch of ways to handle this.
<br/>
<br/>
The copy does have an advantage.  You can do something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">type_t newItem;  // &lt;- local variable
<br/>
<br/>
initItem(BLUE_VERSION);  // &lt;- do funny stuff
<br/>
modifyItem(CHOCOLATE);   // &lt;- do funny stuff
<br/>
<br/>
pushItem(gItemStack, STACK_SIZE, newItem);  // &lt;- push item</td> </tr></table><span class="postbody">
<br/>
If push adds a node and then returns it, you would instead do this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">type_t newItem = pushItem(gItemStack, STACK_SIZE);  // &lt;- get item
<br/>
<br/>
initItem(BLUE_VERSION);  // &lt;- do funny stuff
<br/>
modifyItem(CHOCOLATE);   // &lt;- do funny stuff</td> </tr></table><span class="postbody">
<br/>
The copy method may be "correct" if you store stock nodes in ROM:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// itemlib.h
<br/>
#define BLUE_CHOCOLATE &amp;(gItemLibrary[0])
<br/>
<br/>
// itemlib.c
<br/>
type_t gItemLibrary[] =
<br/>
{
<br/>
   { /* BLUE_CHOCOLATE defined here */},
<br/>
   // other stock items
<br/>
}
<br/>
<br/>
// inside of some function
<br/>
pushItem(gItemStack, STACK_SIZE, BLUE_CHOCOLATE);</td> </tr></table><span class="postbody">
<br/>
You can make anything.  What you should make depends on what you need to do.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#124347 - Piratero - Thu Apr 05, 2007 7:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">The movement is not "wrong" just uneeded if implemented different.  This movement take CPU cycles that you do not need to use so I would just consider it wasteful.</td> </tr></table><span class="postbody">
<br/>
I was trying to illustrate a stack that does not use pointers.  If you are using a memory pool as an array, indices work just well.
<br/>
<br/>
The copy in my example code can (and probably should be) be optimized out.  Instead of writing to a node in memory you could get a free node and then push it, or call push to get a free node.  There are a bunch of ways to handle this.
<br/>
<br/>
The copy does have an advantage.  You can do something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">type_t newItem;  // &lt;- local variable
<br/>
<br/>
initItem(BLUE_VERSION);  // &lt;- do funny stuff
<br/>
modifyItem(CHOCOLATE);   // &lt;- do funny stuff
<br/>
<br/>
pushItem(gItemStack, STACK_SIZE, newItem);  // &lt;- push item</td> </tr></table><span class="postbody">
<br/>
If push adds a node and then returns it, you would instead do this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">type_t newItem = pushItem(gItemStack, STACK_SIZE);  // &lt;- get item
<br/>
<br/>
initItem(BLUE_VERSION);  // &lt;- do funny stuff
<br/>
modifyItem(CHOCOLATE);   // &lt;- do funny stuff</td> </tr></table><span class="postbody">
<br/>
The copy method may be "correct" if you store stock nodes in ROM:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// itemlib.h
<br/>
#define BLUE_CHOCOLATE &amp;(gItemLibrary[0])
<br/>
<br/>
// itemlib.c
<br/>
type_t gItemLibrary[] =
<br/>
{
<br/>
   { /* BLUE_CHOCOLATE defined here */},
<br/>
   // other stock items
<br/>
}
<br/>
<br/>
// inside of some function
<br/>
pushItem(gItemStack, STACK_SIZE, BLUE_CHOCOLATE);</td> </tr></table><span class="postbody">
<br/>
You can make anything.  What you should make depends on what you need to do.
<br/>
<br/>
-Brendan</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks. That clears things up a bit. I did in fact use indices for the stack.<br/>_________________<br/><a href="http://mrkotfw.ribrdb.com/" target="_blank">http://mrkotfw.ribrdb.com/</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
