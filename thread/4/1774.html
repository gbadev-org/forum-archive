<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>preemptive multitasking experiment - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > preemptive multitasking experiment</h2>
<div id="posts">
<div class="post">
    <h4>#9034 - sajiimori - Sat Jul 26, 2003 9:51 pm</h4>
    <div class="postbody"><span class="postbody">I don't know if anybody has done this before on GBA, but I'm attempting to construct a simple preemptive multitasking environment, and I wanted to see if I could get some feedback.
<br/>
<br/>
The basic idea is to set up TIMER0 to trigger interrupts upon overflow, and have the interrupt handler save the current CPU state and load the state for the next thread.
<br/>
<br/>
The problem is that the BIOS saves the CPU state upon entering an interrupt, and restores it upon exiting.  This behavior is incompatable with the idea of writing an interrupt handler whose purpose is to change the CPU state, such as a task switcher.
<br/>
<br/>
I can think of two possible solutions:
<br/>
<br/>
1)  Don't return to the BIOS.  Just re-enable interrupts and jump to the new thread.  I'm concerned that the BIOS does other cleanup work, besides restoring the CPU state, such as stack unwinding.  If so, triggering an interrupt multiple times without ever returning to the BIOS could result in a stack overflow or other bad things.
<br/>
<br/>
2)  Hijack the CPU state saved in the BIOS and replace it with the state of the new thread, so the BIOS will "return" to a location of my choice.  I'm biased toward this idea simply for its coolness factor, but I don't really know how to do it.  I would have to know the location and format of the saved state.
<br/>
<br/>
It's unfortunate that the BIOS is inflexible regarding this behavior.  Any ideas on working around it?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9048 - Geno - Sun Jul 27, 2003 3:07 am</h4>
    <div class="postbody"><span class="postbody">Read the CowBite and GBATek specifications on the GBA.<br/>_________________<br/>Out of Order.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9087 - torne - Mon Jul 28, 2003 10:41 am</h4>
    <div class="postbody"><span class="postbody">You don't need to return to the BIOS (though you will need to pop the things it pushed in order to avoid running out of IRQ stack). The GBATEK doc tells you what the BIOS interrupt handler does: after returning from the user interrupt handler, it only does
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldmfd  r13!,r0-r3,r12,r14
<br/>
subs   r15,r14,4h</td> </tr></table><span class="postbody">
<br/>
<br/>
So, you will need to pop those values (or increment SP to throw them away)., and then return into your next thread by writing to PC with S set.
<br/>
<br/>
Torne</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9231 - sajiimori - Thu Jul 31, 2003 3:04 am</h4>
    <div class="postbody"><span class="postbody">Great, thanks!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
