<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Division by multiples of 10... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Division by multiples of 10...</h2>
<div id="posts">
<div class="post">
    <h4>#28558 - isildur - Tue Nov 02, 2004 9:15 pm</h4>
    <div class="postbody"><span class="postbody">I am working on something where I need to keep only the first 2 digits of an unsigned decimal number. Here is what I mean:
<br/>
<br/>
99345 would become 99        (99345 / 1000)
<br/>
2389454 would become 23     (2389454  / 100000)
<br/>
1024 would become 10          (1024 / 100)
<br/>
<br/>
See what I mean?
<br/>
<br/>
Not really any multiple of ten but but you see the point...
<br/>
<br/>
Is there an algo (fast algo if possible) to do this? Right now, I use the reciprocal multiplication (converted to shifts) method to divide by multiples of ten to get the answer. But if there is a better method, I'd like to know. Thanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28561 - keldon - Tue Nov 02, 2004 9:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int firstDigits ( int i ) {
<br/>
   int j;
<br/>
   for ( j = 1; j &lt;= i / 100; j = j * 10 ) {}
<br/>
   return i / j;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-weight: bold">Statistics:</span>
<br/>
divides: 2
<br/>
multiplies: log10 ( i / 10 )</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28564 - poslundc - Tue Nov 02, 2004 9:43 pm</h4>
    <div class="postbody"><span class="postbody">My <a class="postlink" href="http://www.danposluns.com/gbadev/posprintf/" target="_blank">posprintf</a> routine converts from base-2 to base-10, so you could then take the first two characters of the output string and subtract '0' to get the actual digits. It takes a fairly significant speed hit at numbers larger than 65,535, though, which I notice was the case with your second example. Not so much that it gets unmanageably slow (it entails calling one BIOS divide), but enough that someone else's routine on this board might be faster.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28572 - isildur - Tue Nov 02, 2004 10:41 pm</h4>
    <div class="postbody"><span class="postbody">@keldon:
<br/>
<br/>
I need something fast with no divides nor multiplies :)
<br/>
<br/>
@poslundc
<br/>
<br/>
My method is still faster requiring just a few shifts and adds for multiplying by the reciprocal of the divider. It's just that I thought it was a bit ugly because I have to test the number to process to see in what decimal range it is to determine by what I have to divide it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28574 - poslundc - Tue Nov 02, 2004 10:55 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>isildur wrote:</b></span></td> </tr> <tr> <td class="quote">My method is still faster requiring just a few shifts and adds for multiplying by the reciprocal of the divider. It's just that I thought it was a bit ugly because I have to test the number to process to see in what decimal range it is to determine by what I have to divide it.</td> </tr></table><span class="postbody">
<br/>
<br/>
You're kind of right; I should've looked closer at what exactly you were doing. At the same time, I suspect your way might not be faster for precisely the reason you've specified: you still have to test to determine what range it's in.
<br/>
<br/>
If the numbers are uniformly distributed, you could speed the tests up somewhat by exploiting that distribution. Say your numbers range from 0 to 99,999: start your testing at the point of greatest density in the distribution (x &gt; 9,999) then work your elses down the line (x &gt; 999, x &gt; 99, x &gt; 9).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28575 - keldon - Tue Nov 02, 2004 11:03 pm</h4>
    <div class="postbody"><span class="postbody">Or you could do a binary range search aswell, which is also quicker than a linear search.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28579 - pyros - Tue Nov 02, 2004 11:31 pm</h4>
    <div class="postbody"><span class="postbody">[quote="poslundc"]</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>isildur wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
If the numbers are uniformly distributed, you could speed the tests up somewhat by exploiting that distribution. Say your numbers range from 0 to 99,999: start your testing at the point of greatest density in the distribution (x &gt; 9,999) then work your elses down the line (x &gt; 999, x &gt; 99, x &gt; 9).
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Your reason for this may depend on what you need. If you want the 'best-possible worst-case' then you would (also) check for x&gt;9,999 first as then only one comparison is required for the conversion that requires the most divides, and the conversion requiring many comparisons will require the least number of divides.
<br/>
<br/>
I'm not sure if this is interesting or not, and it probably isn't likely to be relevent to your problem. or perhaps it's just very obvious. :/</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28649 - ampz - Wed Nov 03, 2004 11:39 pm</h4>
    <div class="postbody"><span class="postbody">"unsigned decimal number"
<br/>
What's the range of this number?
<br/>
<br/>
And what do you need this function for?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28653 - nmcconnell - Thu Nov 04, 2004 1:58 am</h4>
    <div class="postbody"><span class="postbody">Here's my approach - I tested it with a variety of inputs and it seems okay.  I've written this in C for ease reading, and debugging, but I think it would be trivial to convert it to assembler if you felt so inclined.
<br/>
<br/>
By my count, this is 9 compares, and a maximum of 6 adds, and six shifted subtracts.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
/*************************************
<br/>
  function: first2 
<br/>
  purpose: to return the first two digits (decimal representation) of an unsigned int
<br/>
  IMPORTANT LIMITATION: only works with values up to 999,999,999
<br/>
<br/>
  Author: Neil McConnell
<br/>
  Date: Nov 3, 2004
<br/>
*************************************/
<br/>
<br/>
<br/>
<br/>
<br/>
#define tenPower0 1
<br/>
#define tenPower1 10
<br/>
#define tenPower2 100
<br/>
#define tenPower3 1000
<br/>
#define tenPower4 10000
<br/>
#define tenPower5 100000
<br/>
#define tenPower6 1000000
<br/>
#define tenPower7 10000000
<br/>
#define tenPower8 100000000
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
int  first2(u32 x){
<br/>
   int retval=0;
<br/>
   u32 base;
<br/>
   
<br/>
   if(x&gt;=(tenPower5)){
<br/>
      if(x&gt;=(tenPower7)){
<br/>
         if(x&gt;=(tenPower8)){
<br/>
            base=tenPower7;
<br/>
         }
<br/>
         else{
<br/>
            base=tenPower6;
<br/>
         }
<br/>
      }
<br/>
      else{ //!(x&gt;=(tenPower7)
<br/>
         if(x&gt;=(tenPower6)){
<br/>
            base=tenPower5;
<br/>
         }
<br/>
         else{
<br/>
            base=tenPower4;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
   else{ //!(x&gt;=(tenPower5)
<br/>
      if(x&gt;=(tenPower3)){
<br/>
         if(x&gt;=(tenPower4)){
<br/>
            base=tenPower3;
<br/>
         }
<br/>
         else{
<br/>
            base=tenPower2;
<br/>
         }
<br/>
      }
<br/>
      else{//(x&gt;tenPower3)
<br/>
         if(x&gt;=(tenPower2)){
<br/>
            base=tenPower1;
<br/>
         }
<br/>
         else{
<br/>
            base=tenPower0;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   //the base is the smallest integer power of 10 such that (base * 100 &gt; x)
<br/>
   
<br/>
   if(x&gt;= (base&lt;&lt;6)) {x-=base&lt;&lt;6; retval+=1&lt;&lt;6;}
<br/>
   if(x&gt;= (base&lt;&lt;5)) {x-=base&lt;&lt;5; retval+=1&lt;&lt;5;}
<br/>
   if(x&gt;= (base&lt;&lt;4)) {x-=base&lt;&lt;4; retval+=1&lt;&lt;4;}
<br/>
   if(x&gt;= (base&lt;&lt;3)) {x-=base&lt;&lt;3; retval+=1&lt;&lt;3;}
<br/>
   if(x&gt;= (base&lt;&lt;2)) {x-=base&lt;&lt;2; retval+=1&lt;&lt;2;}
<br/>
   if(x&gt;= (base&lt;&lt;1)) {x-=base&lt;&lt;1; retval+=1&lt;&lt;1;}
<br/>
   if(x&gt;= (base&lt;&lt;0)) {x-=base&lt;&lt;0; retval+=1&lt;&lt;0;}
<br/>
<br/>
   return retval;
<br/>
   
<br/>
}
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
anyway, let me know if that works out for you</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28692 - isildur - Thu Nov 04, 2004 4:43 pm</h4>
    <div class="postbody"><span class="postbody">@ampz:
<br/>
<br/>
I am working on a fast aproximate square root function. I use a LUT with only the first 100 square roots and I aproximate the square roots for numbers higher than 100. So I need to keep the first 2 digits of a value because it becomes an index in my LUT. So basically, I need to know the decimal range of any 32 bit unsigned value passed.
<br/>
<br/>
Ex: if I need the square root of 349877, then I keep the first 2 digits (34) and get the value in the LUT at index 34. Then using this value, I aproximate the square root of 349877. 
<br/>
<br/>
I get 3 times faster results than the asm square root code from Dooby which is available on my web site in the math section. I still have to convert it to arm assembly, so I guess it can still be a little faster.
<br/>
<br/>
Of course, I lose more precision with large numbers but I still get acceptable results (for my needs) with numbers under a million.
<br/>
<br/>
I use the square root function for 3d collision detection and vector length calculation. And since I need the fastest possible code for a square root, I realized that I could suffer a bit of precision loss without any impact.
<br/>
<br/>
<br/>
@nmcconnell:
<br/>
<br/>
Thanks for posting that, I will test it later today. I will use your technique if it proves to be faster for my needs. I will tell you after I test it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28693 - poslundc - Thu Nov 04, 2004 5:08 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>isildur wrote:</b></span></td> </tr> <tr> <td class="quote">@ampz:
<br/>
<br/>
I am working on a fast aproximate square root function. I use a LUT with only the first 100 square roots and I aproximate the square roots for numbers higher than 100. So I need to keep the first 2 digits of a value because it becomes an index in my LUT. So basically, I need to know the decimal range of any 32 bit unsigned value passed.</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not clear on the mathematics behind your approximation, but would it not be possible to make a LUT for the first 128 square roots, and then instead of using the first two digits use the top 7 bits of the number? Break your number up into four blocks of 8 bits to determine which chunk to use, eg:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u32 n;
<br/>
if (!(n = x &gt;&gt; 24))
<br/>
    if (!(n = ((x &gt;&gt; 16) &amp; 0xFF)))
<br/>
        if(!(n = ((x &gt;&gt; 8) &amp; 0xFF)))
<br/>
            n = x &amp; 0xFF;</td> </tr></table><span class="postbody">
<br/>
<br/>
This way you don't need to worry about the decimal conversion at all.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28694 - nmcconnell - Thu Nov 04, 2004 6:08 pm</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
<br/>
I definitely agree with Dan on using a table of 128 instead of 100.  If you're using a lookup table, then 128 will definitely be much simpler to accomplish.
<br/>
<br/>
<br/>
There's a lot of very bright square root code located here:
<br/>
<a href="http://www.azillionmonkeys.com/qed/sqroot.html" target="_blank">http://www.azillionmonkeys.com/qed/sqroot.html</a>
<br/>
Search for "Update! Mark Cowne pointed out that unrolling Jim Ulery's solution yields a substantial increase in performance" and the code right after that should probably do for you.  It's going to give you an integer square root very quickly.
<br/>
<br/>
If you are intent on using a lookup (which should be faster but less acurate than the prviously mentioned code) then I'd advocate doing a binary search to find magnitude, then do your lookup from there.  I think that you will get better results from this than what you would get from breaking the number into arbitrary chunks.
<br/>
<br/>
PS - I'm still pretty pleased with my code for finding the first two decimal digits.  However, while I suspect it's a fairly snappy solution to the originally stated problem, I don't think it will be remotely useful to your final square root code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28697 - isildur - Thu Nov 04, 2004 6:33 pm</h4>
    <div class="postbody"><span class="postbody">@poslundc:
<br/>
<br/>
I don't think I can do it that way. Here is my algo.
<br/>
<br/>
I noticed that square roots can be aproximated by multiplying a corresponding square root by a constant or, by multiplying by a corresponding square root by the decimal range of the value divided by 100, depending on the decimal range of the value. 
<br/>
<br/>
Whew! I'm sure it's not very clear so here is an example.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
PSEUDOCODE (not optimized, just the algo)
<br/>
<br/>
magicNumber = 3.162277
<br/>
LUT = {square roots of numbers 0-100}
<br/>
value = number for which we want the square root
<br/>
<br/>
if(value &lt;= 100) return LUT[value]
<br/>
<br/>
if(value &lt; 1000) return LUT[value / 10] * magicNumber
<br/>
<br/>
if(value &lt; 10000) return LUT[value / 100] * 10
<br/>
<br/>
if(value &lt; 100000) return LUT[value / 1000] * magicNumber * 10
<br/>
<br/>
if(value &lt; 1000000) return LUT[value / 10000] * 100
<br/>
<br/>
if(value &lt; 10000000) return LUT[value / 100000] * magicNumber * 100
<br/>
<br/>
if(value &lt; 100000000) return LUT[value / 1000000] * 1000
<br/>
<br/>
if(value &lt; 1000000000) return LUT[value / 10000000] * magicNumber * 1000
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
See what I mean?
<br/>
<br/>
This is just the base of the algo, I add a little precision by not using these constants exactly like that to average the precision loss within a given range. And of course, I convert the muls and divs to series of shifts and adds or subs. So it is quite fast. I will post the assembly version of it when it will be ready and fully tested.
<br/>
<br/>
I don't know if this square root aproximation method (or a similar) already exists but it looks like it works well for what I need it for.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28699 - isildur - Thu Nov 04, 2004 6:54 pm</h4>
    <div class="postbody"><span class="postbody">@nmcconnell:
<br/>
<br/>
Well thanks for the link. I found one very good and very fast square root function there. It is a little faster than mine, but what I like about it is that it's a lot more precise than mine. So I guess I will not use mine now :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28701 - poslundc - Thu Nov 04, 2004 7:24 pm</h4>
    <div class="postbody"><span class="postbody">I tried doing some random testing but I kept screwing up when inputting your formula on my calculator... :P
<br/>
<br/>
About what margin of error do you get with your formula?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28702 - isildur - Thu Nov 04, 2004 8:13 pm</h4>
    <div class="postbody"><span class="postbody">if you use my formula using floating point numbers, there isn't any significant loss of precision. In unsigned int form, the loss of precision ranges from 1 (when in 1000-9999 range) to 200 (when in 1000000-9999999 range). Loss increases when the decimal range increases, but I get perfect precision in the middle of each range. Worst precision is found at the start and end of the ranges.
<br/>
<br/>
Anyways, the implementation found on the link in nmcconnell's post above is far better. I had fun trying though :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28703 - nmcconnell - Thu Nov 04, 2004 8:35 pm</h4>
    <div class="postbody"><span class="postbody">You don't necesarily need to give up yet.  You could pretty certainly top the calculation code by using a lookup if you still want to try to squeeze out a little more speed.
<br/>
<br/>
Here's the real timesaver though:
<br/>
<br/>
<span style="font-weight: bold">For many 3D calculations, you don't need to use the square root function at all.</span>
<br/>
<br/>
For example, I notice that you are using square root for colision detection.  I'm assuming that you mean that you're checking the distance between two objects and then if the distance is small enough, you have a colision.  This is to say that you're checking to see if:
<br/>
sqrt(x*x+y*y+z*z) &lt; collisionCutOff
<br/>
<br/>
It is generally prefereable to check:
<br/>
x*x+y*y+z*z &lt; collisionCutOff*collisionCutOff
<br/>
<br/>
This saves you the square root altogether.  If you're getting overflow, you can shift both sides of the comparisson to the right.
<br/>
<br/>
------------------------------------------------
<br/>
<br/>
Anyway, with regard to your algorithm that uses all the 10s, base ten is very intuitive for humans because it is the number system we use most often.  However, any algorithm that is explicitly tied to base 10 is really only useful for humans - computers generally prefer base 2 for exactly the same reasons humans prefer base 10 - because you can replace a multiply or a divide with a shift operation.
<br/>
<br/>
For example, if you asked me to aproximate the square root of 5,000,000 in my head, I'd start by taking out the million, and I'll say that that's six zeros, so the square root should get three zeros.  Then I'd say that the sqaure root of 5 is 2 and spare change.  This would give me an aproximate square root of 2,000 although I'd know that this is low.  A good computer algorithm that uses a lookup will work almost exactly the same way, but in base 2 (binary) instead of base 10.
<br/>
<br/>
I hope this helps you out.  Seriously, though, the most important thing you should remember is that there are many cases when you don't need to use square root at all.  This is very important!
<br/>
<br/>
--Neil</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28704 - poslundc - Thu Nov 04, 2004 8:48 pm</h4>
    <div class="postbody"><span class="postbody">In addition to this, if what you want is the distance between two cartesian points (and it's not sufficient just to check the squared versions) there's an excellent approximation function:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// distApprox adds 8 to the precision of the result.
<br/>
// Therefore two integers will generate a 24.8 result.
<br/>
// Expected error around 7%.
<br/>
<br/>
#define DA_FOS(n)   (((n) &lt;&lt; 6) + ((n) &lt;&lt; 4))
<br/>
<br/>
inline s32 distApprox(s32 x, s32 y)
<br/>
{
<br/>
   if (x &lt; y)
<br/>
      return ((x &lt;&lt; 8) + DA_FOS(y));
<br/>
   else
<br/>
      return ((y &lt;&lt; 8) + DA_FOS(x));
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28705 - isildur - Thu Nov 04, 2004 9:00 pm</h4>
    <div class="postbody"><span class="postbody">@nmcconnell:
<br/>
<br/>
Thanks for your tip on not using the square root. I will use it. :)
<br/>
<br/>
And I will try to use a 256 LUT instead for my algo, just for the fun of it and for the sake of completing what I had started. I always like experimenting with algos. 
<br/>
<br/>
Also, I will convert the implementation from your link in arm assembly and post it on my site since it beats the square root algo from Dooby that I had posted.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28707 - nmcconnell - Thu Nov 04, 2004 9:09 pm</h4>
    <div class="postbody"><span class="postbody">Good call Dan.  I think I remember that one from graphics gems or something.
<br/>
<br/>
Has anyone ever extended that approximation into 3-space?  I'm just thinking about it now. . .  what if you were do write a 3d dist function as
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline s32 distApprox3(s32 x, s32 y, s32z){ 
<br/>
  return(distApprox(distApprox(x, y), z&lt;&lt;8));
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
This would create a cumulative error of more than the 7% from the 2D algorithm.  It should still be within 15% though, I think.
<br/>
<br/>
Anyone with more experience in this domain wanna comment?  Could the error be reduced by processing the two smaller distances first?
<br/>
<br/>
--Neil</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28708 - isildur - Thu Nov 04, 2004 9:30 pm</h4>
    <div class="postbody"><span class="postbody">I just tried Dan's suggestion with the distance aproximation but it doesn't have enough precision for what I need. So, I now use nmcconnell's trick for collision detection. Still need 3 muls but I had 2 muls before plus the sqrt().</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28711 - ampz - Thu Nov 04, 2004 10:23 pm</h4>
    <div class="postbody"><span class="postbody">If you want to check the distance between two points on the GBA screen, then there is a 2-3 instruction way to do it:
<br/>
<br/>
lookup[y][x]
<br/>
<br/>
Or more optimal:
<br/>
<br/>
lookup[(y&lt;&lt;8) | x]
<br/>
<br/>
The above table takes 80kByte of flash.
<br/>
Here is a version which trades one extra instruction in order to cut table size in half:
<br/>
<br/>
lookup[(y&lt;&lt;8) | x]+x</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28713 - isildur - Thu Nov 04, 2004 10:45 pm</h4>
    <div class="postbody"><span class="postbody">I am doing 3d object collision detection, though I need only to check in X and Z because the objects are sitting on the ground.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28715 - nmcconnell - Thu Nov 04, 2004 10:56 pm</h4>
    <div class="postbody"><span class="postbody">ahh.  detecting in 2 dimensions explains your comment:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I just tried Dan's suggestion with the distance aproximation but it doesn't have enough precision for what I need. So, I now use nmcconnell's trick for collision detection. Still need 3 muls but I had 2 muls before plus the sqrt().</td> </tr></table><span class="postbody">
<br/>
<br/>
However, don't forget that if your collision threshold distance is the same every time, then you only need to do that multiplication once and store it.  This means that you're almost back down to just two multiplications per collision check.
<br/>
<br/>
There are some other things you can do that can save you time in a collision detection system.  It sort of depends on how you've got things set up, but in general, you should not be looking at a scenario where you just iterate through each object and check its distance from every other object.  This is an O(n^2) algorithm, and can usually (always?) be improved upon.  
<br/>
<br/>
I think there must be extensive posting on the topic of optimal collision detection on this board and others.  I haven't actually checked, but it's worth looking in to.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28724 - isildur - Fri Nov 05, 2004 2:44 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>nmcconnell wrote:</b></span></td> </tr> <tr> <td class="quote">ahh.  detecting in 2 dimensions explains your comment:
<br/>
<br/>
However, don't forget that if your collision threshold distance is the same every time, then you only need to do that multiplication once and store it.  This means that you're almost back down to just two multiplications per collision check.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, I will store that value in the object's structure.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>nmcconnell wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
There are some other things you can do that can save you time in a collision detection system.  It sort of depends on how you've got things set up, but in general, you should not be looking at a scenario where you just iterate through each object and check its distance from every other object.  This is an O(n^2) algorithm, and can usually (always?) be improved upon.  
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
In my game, most of the objects are static, I only need to check on 4 moving objects.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28742 - ampz - Fri Nov 05, 2004 7:18 am</h4>
    <div class="postbody"><span class="postbody">Then why the big fuzz about speed?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28752 - isildur - Fri Nov 05, 2004 3:47 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Then why the big fuzz about speed?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Well, why not?
<br/>
<br/>
I am doing 3d in mode 4. I have only 4 moving objects but I have to check if they collide with all the static objects.
<br/>
<br/>
I am aiming for 60 fps and at least 30 fps when there's lots of stuff to render. So, I have to optimize every bit of code I can to keep this frame rate. This alone might not make a huge difference but add up all the unoptimized math code and then it make a difference. And I just hate jerky 3d.
<br/>
<br/>
And anyways, I like optimizing routines like that. I like having the fastest code for 3d and math stuff.
<br/>
[/quote]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28807 - phantom-inker - Sat Nov 06, 2004 8:13 pm</h4>
    <div class="postbody"><span class="postbody">Thought I'd chime in here, since square-root is a problem I've tackled before.  In the event that you really <span style="font-weight: bold"><span style="font-style: italic">do</span></span> need to compute square roots, such as you might require for normalizing vectors, there are a variety of efficient mathematical techniques that exist, ranging from the silly (such as odd-number sums) to the very sophisticated (bit-wise logarithmic tricks).  Paul Hseih has tracked these algorithms at his square-root web site:  <a href="http://www.azillionmonkeys.com/qed/sqroot.html" target="_blank">http://www.azillionmonkeys.com/qed/sqroot.html</a>
<br/>
<br/>
For what it's worth, I've been using Mark Cowne's unrolled version of Jim Ulery's fast square-root algorithm for fixed-point vector-normalization, and it's been quite serviceable for that.  No doubt it would work even better with a tightly-coded assembly version, but I haven't actually needed <span style="font-style: italic">that</span> much speed.
<br/>
<br/>
Of course, square root is a relatively easy problem...  now performing pow(x,y) in fixed-point --- efficiently --- now <span style="font-style: italic">that's</span> tough (see Knuth 1.2.2.25 for hints...).<br/>_________________<br/>Do you suppose if I put a signature here, anyone would read it?  No?  I didn't think so either.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28820 - isildur - Sun Nov 07, 2004 1:40 am</h4>
    <div class="postbody"><span class="postbody">The link you posted was already posted above, and that's the square root code I'm using now. Though, I don't need the square root anymore for collision detection.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29050 - phantom-inker - Wed Nov 10, 2004 8:18 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>isildur wrote:</b></span></td> </tr> <tr> <td class="quote">The link you posted was already posted above, and that's the square root code I'm using now. Though, I don't need the square root anymore for collision detection.</td> </tr></table><span class="postbody">
<br/>
Ah, indeed.  I missed that the first time reading through this thread.  Ah, well, better too much information than too little.  And you may still want to retain that link:  If you're doing heavy 3-D stuff, you're going to eventually want a routine for vector normalization, and that means square root.<br/>_________________<br/>Do you suppose if I put a signature here, anyone would read it?  No?  I didn't think so either.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29061 - MumblyJoe - Wed Nov 10, 2004 10:40 pm</h4>
    <div class="postbody"><span class="postbody">Well you can multiply by 10 by doing things like (x&lt;&lt;1)+(x&lt;&lt;3) so im sure there is some way to divide, but I can't see how immediately. I will have a think about it at work today.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29066 - isildur - Wed Nov 10, 2004 10:57 pm</h4>
    <div class="postbody"><span class="postbody">To divide by 10 you could do this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
Since we know that:
<br/>
x / 10 = 0.1 * 10
<br/>
<br/>
So you precompute 0.1 * 1024 = 102.4, but you round it to 103.
<br/>
<br/>
Then it makes (x * 103) &gt;&gt; 10 = x / 10
<br/>
<br/>
So you can finally do this:
<br/>
<br/>
Turn (x*103) in shifts: ((x &lt;&lt; 6) + (x &lt;&lt; 5) + (x &lt;&lt; 2) + (x &lt;&lt; 1) + x) &gt;&gt; 10 = x / 10
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29111 - Miked0801 - Thu Nov 11, 2004 7:07 pm</h4>
    <div class="postbody"><span class="postbody">Dear god, just do a multiply and be done with it!  It's only 2-5 cycles :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29112 - isildur - Thu Nov 11, 2004 7:18 pm</h4>
    <div class="postbody"><span class="postbody">Oh really? :-0 
<br/>
<br/>
LOL
<br/>
<br/>
I thought those multiplies took more cycles than that. Oh well...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29114 - poslundc - Thu Nov 11, 2004 7:32 pm</h4>
    <div class="postbody"><span class="postbody">If you're coding in assembler, the size of the third parameter dictates how long it takes. If there are 1-8 significant bits (positive or negative) then it's only two cycles, and as the number of significant bits increase (9-16, 17-24, 25-32) the cycle count increases to five.
<br/>
<br/>
In assembly you can often do some mega-optimizations if you know the domain restrictions on your inputs. I don't think GCC is smart enough to do those kinds of optimizations, though, even when obvious.
<br/>
<br/>
The fast multiply opcode does eliminate the need to do most complicated shift-multiplies. Simple ones may still be worthwhile, since you still need to load the multiplicand into a register and this is non-trivial if it can't be expressed as a shifted 8-bit constant.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29360 - AnthC - Fri Nov 19, 2004 1:04 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>isildur wrote:</b></span></td> </tr> <tr> <td class="quote">I am working on something where I need to keep only the first 2 digits of an unsigned decimal number. Here is what I mean:
<br/>
<br/>
99345 would become 99        (99345 / 1000)
<br/>
2389454 would become 23     (2389454  / 100000)
<br/>
1024 would become 10          (1024 / 100)
<br/>
<br/>
See what I mean?
<br/>
<br/>
Not really any multiple of ten but but you see the point...
<br/>
<br/>
Is there an algo (fast algo if possible) to do this? Right now, I use the reciprocal multiplication (converted to shifts) method to divide by multiples of ten to get the answer. But if there is a better method, I'd like to know. Thanks.</td> </tr></table><span class="postbody">
<br/>
<br/>
'A simple solution'
<br/>
First 'normalise' your number so multiply by 10 until it is greater or equal to 100000000UL (beware of the special case 0)
<br/>
(Which is the largest multiple of 10 that will fit into 32 bits)
<br/>
<br/>
U32 d0=0,d1=0;
<br/>
<br/>
U32 n=666; // your number to extrat the digits from (unsigned 32 bits)
<br/>
<br/>
while (n&lt;100000000UL &amp;&amp; n!=0) n*=10; // 'normalise' your number
<br/>
<br/>
Then your first digit is :-
<br/>
<br/>
if (n&gt;=500000000UL) {d0+=5;n-=500000000UL;}
<br/>
if (n&gt;=200000000UL) {d0+=2;n-=200000000UL;}
<br/>
if (n&gt;=100000000UL) {d0+=1;n-=100000000UL;}
<br/>
if (n&gt;=100000000UL) {d0+=1;n-=100000000UL;}
<br/>
<br/>
Now extract your next digit
<br/>
<br/>
n*=10; // next digit
<br/>
<br/>
if (n&gt;=500000000UL) {d1+=5;n-=500000000UL;}
<br/>
if (n&gt;=200000000UL) {d1+=2;n-=200000000UL;}
<br/>
if (n&gt;=100000000UL) {d1+=1;n-=100000000UL;}
<br/>
if (n&gt;=100000000UL) {d1+=1;n-=100000000UL;}
<br/>
<br/>
d0 &amp; d1 are your 2 leading digits 0..9.
<br/>
<br/>
Not the fastest way of doing it/doesn't involve tables/fixup etc.
<br/>
<br/>
(N.B. I've not tested this, so be it on your own head!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29361 - isildur - Fri Nov 19, 2004 1:40 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>AnthC wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<br/>
<br/>
while (n&lt;100000000UL &amp;&amp; n!=0) n*=10; // 'normalise' your number
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
That's just something I wanted to avoid :-)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29946 - AnthC - Sat Nov 27, 2004 1:33 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>isildur wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>AnthC wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<br/>
<br/>
while (n&lt;100000000UL &amp;&amp; n!=0) n*=10; // 'normalise' your number
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
That's just something I wanted to avoid :-)</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Well there's ways around that, you could split it into a binary search, although I don't see the while loop taking up _that_ much CPU.
<br/>
(Mul's tend to be cheap on the GBA's CPU)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
