<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>collisions - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > collisions</h2>
<div id="posts">
<div class="post">
    <h4>#30057 - wiz - Sun Nov 28, 2004 1:35 am</h4>
    <div class="postbody"><span class="postbody">This is probably the 100th post on collision questions?
<br/>
<br/>
I have ideas on how this is done, and actually made games in the past with detection using pixels.
<br/>
<br/>
For the most recent pixel / map detection method on the pc I used a 2d array which put all the pixels from the background layer where the player sprite was stood, then applied an outline to the array which set 0's of the outline border of the sprite.  A bit like a cookie cutter effect.
<br/>
<br/>
Anything that was not a 0 left in the array was a collision, not the best method but it worked, flawless too.
<br/>
<br/>
Now I tried something like this for the GBA except (obviously) it ran too slow and even at that I couldnt really get it working.
<br/>
<br/>
What really winds me up is the 2 pixel per 16bits, it drives me mad! :(
<br/>
<br/>
I can think of methods using a binary mask (?) checking bits with pixels but my code turns very ugly/confusing/useless within seconds because of this accessing 16bits at a time business.  Surely it cant be that hard to do pixel perfect collisions on the gba? =/
<br/>
<br/>
tile collisions wont cut it either, I already have that working as a tempoary measure..
<br/>
<br/>
Anyone have some advice on the subject?
<br/>
<br/>
Thanks kindly</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30063 - sajiimori - Sun Nov 28, 2004 1:59 am</h4>
    <div class="postbody"><span class="postbody">Code doesn't become ugly because of the kind of work being done.  It becomes ugly due to bad factoring.  Make sure you're writing short functions that do one thing well, rather than long ones that try to do everything.
<br/>
<br/>
I tend to write lots of small utility functions that have no side effects and only compute values based on their arguments.  It makes things easier to understand, because you don't have to hold many things in your head at once.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30117 - Lupin - Sun Nov 28, 2004 3:01 pm</h4>
    <div class="postbody"><span class="postbody">sajiimori i think this topic is about collision detection, not coding style :P
<br/>
<br/>
Well, i would not use pixel perfect collision detection on a GBA because it is just too slow, you have to abstract the object that you want to colide with...<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30134 - sajiimori - Sun Nov 28, 2004 7:27 pm</h4>
    <div class="postbody"><span class="postbody">If he is only avoiding fast techniques because they make his code ugly, then it is about coding style because the answer he seeks is to write better code.
<br/>
<br/>
Be careful claiming that the GBA is too slow for pixel-perfect collision.  Star Control II used it on 16MHz 80386 PCs.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30244 - wiz - Mon Nov 29, 2004 8:16 pm</h4>
    <div class="postbody"><span class="postbody">Hi guys,
<br/>
<br/>
I didnt mean to claim the GBA is slow for pixel perfect collisions, I was just commenting on the same technique I had used on the PC would be too slow to convert.
<br/>
<br/>
sajiimori thanks for the tips, I dont try to avoid fast techniques but its true I do need to write better code.  I was wondering if using functions (small utilities) would slow things down (if called heaps of times during a frame loop)?  Or do function calls not cost anything at all?
<br/>
<br/>
Lupin, cheers for writing - tile collisions are very easy to handle and usually the way to go but for a game like, lets say, pinball you would want non-square collision detection for the corners etc.
<br/>
<br/>
Is bitmask the way to go with pixel perfect collisions?
<br/>
<br/>
Thanks for your time :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30257 - R0d Longfella - Mon Nov 29, 2004 10:15 pm</h4>
    <div class="postbody"><span class="postbody">Perhaps it's dumb to mention this, but
<br/>
<br/>
You could test for collisions using a bounding box, and then if you find a collision you could test if the objects actually collide using the pixel perfect approach. This way you would save cycles by only using the expensive pixel perfect detection when two objects are in eachothers vicinity.
<br/>
<br/>
Goodluck!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30258 - R0d Longfella - Mon Nov 29, 2004 10:25 pm</h4>
    <div class="postbody"><span class="postbody">By the way, pixel perfect detection shouldn't be so expensive.
<br/>
<br/>
Using some optimization you only need (worst case) to use 32 checks for detecting a collision between 2 sprites which are 32 by 32 pixels.
<br/>
<br/>
Assuming that both sprites almost completely overlap, you'll need to check each row (32 times) and you can check every 32 pixels on each row by comparing two unsigned 32 bit masks (int). You'll need to create the masks using shifts and AND's, but that wouldn't take too much to calculate. And if you precisely wanted to know where both sprites collided, you could calculate the precise coordinates when two rows match.
<br/>
<br/>
Provided that each sprite comes with a bitmask for collision detection, it shouldn't be too hard.
<br/>
<br/>
Again, goodluck!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30263 - keldon - Mon Nov 29, 2004 10:51 pm</h4>
    <div class="postbody"><span class="postbody">I'm not sure how you do it but here's a basic algorithm that outlines the a process I would use for perfect pixel collision.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
struct Rect {
<br/>
   int x;
<br/>
   int y;
<br/>
   int width;
<br/>
   int height;
<br/>
}
<br/>
<br/>
<br/>
boolean collides ( map1, x1, x2, map2, x2, y2 ) {
<br/>
   Rect overlap;
<br/>
   int jointCollisionMap[maxMapSize];
<br/>
   bool overLapped = getOverlapRegion ( x1, y1, x2, y2, &amp;overlap );
<br/>
   if ( !overLapped ) return false;
<br/>
<br/>
   copy map1 to jointCollisionMap with overlap region
<br/>
   copy map2 to jointCollisionMap with overlap region returning true where there's a collision
<br/>
<br/>
   otherwise return false;
<br/>
}
<br/>
<br/>
// returns whether regions overlap, and copied data into &amp;overLap
<br/>
void boolean getOverlapRegion ( int x1, int y1, int x2, int y2, Rect *overlap ) {
<br/>
   if ( x1 &gt; x2 ) {
<br/>
      return getOverLaplegion ( x2, y2, x1, y1, &amp;overlap );
<br/>
   }
<br/>
<br/>
   Assert ( x1 &lt;= x2 );
<br/>
   if ( x1 &lt; x2 - spriteWidth ) return false;
<br/>
<br/>
   overlap.x = x2;
<br/>
   overlap.width = (x1+spriteWidth) - x2;
<br/>
   if ( overLap.width &lt;= 0 ) return false;
<br/>
<br/>
   if ( y1 &lt; y2 ) {
<br/>
      overlap.y = y2;
<br/>
      overlap.width = (y1+spriteHeight) - y2;
<br/>
   else {
<br/>
      overlap.y = y1;
<br/>
      overlap.width = (y2+spriteHeight) - y1;
<br/>
   }
<br/>
<br/>
   if ( overlap.width &lt;= 0 ) return false;
<br/>
<br/>
   return true;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This of course doesn't work if the two objects are going past each other too fast to catch them overlapping within one frame; but that's only important to worry about if that can happen.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30277 - sajiimori - Tue Nov 30, 2004 1:03 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I was wondering if using functions (small utilities) would slow things down (if called heaps of times during a frame loop)? Or do function calls not cost anything at all?</td> </tr></table><span class="postbody">If your utilities are in the same file (or a header), the compiler will inline them when appropriate.  Use the -O3 option on GCC to enable this behavior.
<br/>
<br/>
Non-inlinable (e.g. extern) function calls are costly in inner loops, so if you're having speed problems, check the compiler's output to make sure it's inlining everything it should.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30305 - tepples - Tue Nov 30, 2004 5:39 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>wiz wrote:</b></span></td> </tr> <tr> <td class="quote">tile collisions are very easy to handle and usually the way to go but for a game like, lets say, pinball you would want non-square collision detection for the corners etc.</td> </tr></table><span class="postbody">
<br/>
For pinball, you'd want exact-geometry collision: circles with line segments.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30311 - Marill - Tue Nov 30, 2004 6:14 am</h4>
    <div class="postbody"><span class="postbody">I wouldn't want to tie my collision data with my graphics data anyways, and abstract shaped (spheres, boxes, line) collision may be good enough for most uses.
<br/>
<br/>
I would see 2D pixel perfect collision solution something like a brute-force volume collision (testing every unit point in the volume) in 3D, which is pretty much overkill in most applications of it... if the you can do abstract shaped collisions in the game then go with it, unless the game really needs pixel perfect tests, or you're just coding one for the heck of it without any game in mind, then well, go for it :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30322 - keldon - Tue Nov 30, 2004 8:21 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>wiz wrote:</b></span></td> </tr> <tr> <td class="quote">tile collisions are very easy to handle and usually the way to go but for a game like, lets say, pinball you would want non-square collision detection for the corners etc.</td> </tr></table><span class="postbody">
<br/>
For pinball, you'd want exact-geometry collision: circles with line segments.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
=D I didn't know it was a pinball game. To be honest I hadn't completely read the post, it was formatted too badly so I skimmed it poorly.
<br/>
<br/>
Yeah, well if it's a geometric shape it's easier. You just calculate when the two paths will cross using line gradients. Because it's a circle you'll have to include a bit of sin/cos for alterations to the path's collision. This is based on the angle of the ball against the surface it is colliding with.
<br/>
<br/>
Also when you're doing it, instead of checking with every line filter out all lines clearly behind its path.
<br/>
<br/>
A little more on how you do collision detection from the ground up here.
<br/>
<br/>
<a href="http://forum.gbadev.org/viewtopic.php?p=30221#30221" target="_blank">http://forum.gbadev.org/viewtopic.php?p=30221#30221</a>
<br/>
<br/>
It's really simple when you think of 1d collision where two trains collide.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
