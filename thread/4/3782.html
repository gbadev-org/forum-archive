<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Copy to EWRAM - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Copy to EWRAM</h2>
<div id="posts">
<div class="post">
    <h4>#23988 - ProblemBaby - Mon Jul 26, 2004 2:03 am</h4>
    <div class="postbody"><span class="postbody">Hi
<br/>
<br/>
Now iam trying to copy code to EWRAM but no$gba give me fatal error
<br/>
the rom-image has crashed.
<br/>
<br/>
The thing iam trying to do is...
<br/>
Ive a Multiboot program (its really small)
<br/>
and I want to copy a function to a another place in ewram.
<br/>
(plz if you now how do it, dont just repost a: WHY?!?!?)
<br/>
<br/>
well my code goes like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u16 *EWRAM        = (u16 *)0x2000000;
<br/>
   void (*ewramcode)();
<br/>
   ewramcode = 0x2010000; // 0x10000 to be sure that i dont mess with the other data
<br/>
   u32 Address = 0;
<br/>
// Later I will check for the branch instead
<br/>
   while (Address &lt; 100) 
<br/>
// well, the function cant be bigger then 100 *sizeof(u16) bytes
<br/>
{
<br/>
      EWRAM[0x10000 + Address] = ((u16 *)MyFunction)[Address];
<br/>
      Address++;
<br/>
   }
<br/>
   ewramcode(); // when I do this i got error
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks in advance</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23994 - DekuTree64 - Mon Jul 26, 2004 2:48 am</h4>
    <div class="postbody"><span class="postbody">The copying looks fine. Is the function compiled as THUMB? If so, then the problem is that you're getting switched over to ARM mode without knowing it. Because you can only do a regular branch to a PC-relative location, and function pointers are loaded from memory into registers, the compiler has to use bx. 
<br/>
Normally, when you set a function pointer to the address of a function (as opposed to a direct value like 0x2010000), it can check wether that function is written in ARM or THUMB and set the THUMB flag accordingly. The lower bit of the address in the register you're bx'ing to is the THUMB flag, so the solution here is to set it by hand. Set the function pointer to 0x2010001 and see if it works.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23999 - ETkoala - Mon Jul 26, 2004 7:56 am</h4>
    <div class="postbody"><span class="postbody">you should try with other emu (for example: visualboy advance).
<br/>
i hear that no$gba look the header before run.
<br/>
be sure that the game isn't in a zip file (no$gba don't support zip)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24001 - torne - Mon Jul 26, 2004 11:30 am</h4>
    <div class="postbody"><span class="postbody">DekuTree64: No, you can branch to an absolute location just fine without using bx:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov lr, pc
<br/>
mov pc, register_with_address</td> </tr></table><span class="postbody">
<br/>
GCC should happily generate this code when neccecary. Try disassembling the copying/calling function to see how it's calling the copied function - if it's doing bx then you do need to add the low bit to the address, but complaining to the maintainers would be in order; it's *very* silly for a call of this form to switch modes if it doesn't know either way.
<br/>
<br/>
I would be more worried about the contents of the function; is it position-independant?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24005 - ProblemBaby - Mon Jul 26, 2004 1:01 pm</h4>
    <div class="postbody"><span class="postbody">Ive tried a lot of different things acoording to what you have replayed
<br/>
but I really cant get it to work either with no$gba, VBA or MappyVM.
<br/>
<br/>
Maybe someone can show me a working example?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24006 - ProblemBaby - Mon Jul 26, 2004 1:33 pm</h4>
    <div class="postbody"><span class="postbody">Maybe it is possible to make a function putted at 0x2010000
<br/>
and then overwrite it? but I dont know how but maybe that could be a solution</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24007 - poslundc - Mon Jul 26, 2004 1:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">DekuTree64: No, you can branch to an absolute location just fine without using bx:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov lr, pc
<br/>
mov pc, register_with_address</td> </tr></table><span class="postbody">
<br/>
GCC should happily generate this code when neccecary. Try disassembling the copying/calling function to see how it's calling the copied function - if it's doing bx then you do need to add the low bit to the address, but complaining to the maintainers would be in order; it's *very* silly for a call of this form to switch modes if it doesn't know either way.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
I can't access my copy of the ARM documentation from work. Does anyone know if this style of branching can switch processor modes using the LSB?
<br/>
<br/>
For that matter, do any of the other branching techniques (B and BL, LDR and LDM to the PC, and I suppose any other ALU ops to the PC) permit an instruction set exchange, or just BX?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24012 - torne - Mon Jul 26, 2004 4:18 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">I can't access my copy of the ARM documentation from work. Does anyone know if this style of branching can switch processor modes using the LSB?</td> </tr></table><span class="postbody">
<br/>
On the ARMv4 architecture, the LSB is processed when setting the program counter - mov, ldr and ldm will all set the CPU mode correctly. However, the ARM7 is an ARMv3 processor, and the ARMv3 only obeys the LSB during the BX instruction. This means that an interworking return on the GBA has to pop the link register value into a temporary register, then bx to that register, rather than being able to pop it directly into the program counter. Unless you write interworking-capable code in assembler, of course, this is done for you by the compiler. (I say a temporary register because in Thumb mode, the pop instruction cannot pop into LR, and another register must be used; in ARM mode, you can just pop into LR and then bx to LR - this actually makes a Thumb interworking return really, really unpleasant).
<br/>
<br/>
B and BL never generate an instruction set switch on either architecture; it is up to the linker to automatically insert shims between functions that call each other in this way that have differing instruction sets; GNU ld does this correctly in devkitarm/devkitgba, which is why this normally works. As it's done by the linker, you can even rely on this behaviour when coding in assembly.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24028 - ProblemBaby - Mon Jul 26, 2004 8:26 pm</h4>
    <div class="postbody"><span class="postbody">Here is my code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.align
<br/>
.section .text
<br/>
<br/>
.thumb_func
<br/>
.global DrawLine
<br/>
DrawLine:
<br/>
   @ St?ller in DISPCNT
<br/>
   LDR r0, =0x4000000
<br/>
   LDR r1, =0x403
<br/>
   STR r1, [r0]
<br/>
   
<br/>
   @ Ritar en r?d linje p? rad 5
<br/>
   LDR r0, =0x6000960
<br/>
   LDR r1, =0x1F
<br/>
   LDR r2, =240
<br/>
   label1:
<br/>
   STRH r1, [r0]
<br/>
   ADD r0, r0, #2
<br/>
   SUB r2, r2, #1
<br/>
   CMP r2, #0
<br/>
   BNE label1
<br/>
   hej:
<br/>
   B hej
<br/>
<br/>
.thumb_func
<br/>
.global CopyAndRun
<br/>
CopyAndRun:
<br/>
   @ Lagrar funktionen i EWRAM 0x2001000
<br/>
   LDR r0, =DrawLine
<br/>
   LDR r1, =0x2001000
<br/>
   LDR r2, =0x100
<br/>
   Copy:
<br/>
   LDRB r3, [r0]
<br/>
   STRB r3, [r1]
<br/>
   ADD r0, r0, #1
<br/>
   ADD r1, r1, #1
<br/>
   SUB r2, r2, #1
<br/>
   CMP r2, #0
<br/>
   BNE Copy
<br/>
   
<br/>
   @ K?r Funktionen
<br/>
   LDR r1, =0x2001000
<br/>
   MOV pc, r1
<br/>
   
<br/>
   BX lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Can someone see an error??</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24060 - DekuTree64 - Tue Jul 27, 2004 7:16 am</h4>
    <div class="postbody"><span class="postbody">Ah, found it. The .thumb_func directive tells the linker that whenever it sees that symbol name, to set the lower bit of it as the THUMB flag, so for example, that ldr r0, =DrawLine would have the flag set so if you bx to it, you will be switched into THUMB state. However in this case, you're copying one byte at a time, so having the lower bit set means that you're copying the second half of the first instruction, and then the first half of the second instruction, into the first halfword of the destination. Of course the instructions that you will end up with are then completely wrong, so it goes off into the great beyond never to return.
<br/>
<br/>
Solution: replace that .thumb_func with plain .thumb (might give you problems if you try to call the function from C code), or subtract one from r0 after the ldr (wastes a cycle, and 2 bytes for the instruction. I'd go with this way for general purpose reliability).<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24087 - ProblemBaby - Tue Jul 27, 2004 7:18 pm</h4>
    <div class="postbody"><span class="postbody">Thanks a lot man!!
<br/>
<br/>
by the way, is it somehow possible to force a function or/and data to be placed last in ewram (in my case). I mean that after that it should be only junk no data or code..</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
