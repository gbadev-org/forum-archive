<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Flood fill algorithm - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Flood fill algorithm</h2>
<div id="posts">
<div class="post">
    <h4>#4677 - sgeos - Sun Apr 06, 2003 9:24 pm</h4>
    <div class="postbody"><span class="postbody">Do you suppose the stack would survive a recursive flood fill algorithm on a 32 by 32 map under the worst conditions?  64 by 64?  I could always use an iterative approach:
<br/>
<br/>
unsigned short fill_map[0x1000];
<br/>
unsigned long  current_fill = 0;
<br/>
<br/>
I've actually never done a flood fill before.  I don't need to keep track of 64 * 64 points in an iterative solution.  Time to work on this.  At any rate, any thoughts on the recursive method?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4686 - ArnoldLayne - Mon Apr 07, 2003 2:18 am</h4>
    <div class="postbody"><span class="postbody">The simple but bad way of doing it recursively is to fill the starting pixel, then up down left and right.  It tends to blow the stack and it's slow.
<br/>
<br/>
A much better way is to work on a scan line at a time (also called "spans").  From the starting pixel, draw a horizontal line to the left and right until you hit a different color.  After the whole line is drawn, scan from left to right above it and recurse.  Then scan from left to right below and recurse.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
we want to fill over O and stop when we hit color Y
<br/>
X is the fill color
<br/>
<br/>
YYYYY
<br/>
YOYOY
<br/>
YOOOY
<br/>
YOOOY
<br/>
YYYYY
<br/>
<br/>
<br/>
YYYYY
<br/>
YOYOY
<br/>
YOXOY         start pixel
<br/>
YOOOY
<br/>
YYYYY
<br/>
<br/>
YYYYY
<br/>
YOYOY
<br/>
YXXXY         horizontal
<br/>
YOOOY
<br/>
YYYYY
<br/>
<br/>
YYYYY
<br/>
YXYXY     above ( 2 calls)
<br/>
YXXXY         
<br/>
YOOOY
<br/>
YYYYY
<br/>
<br/>
YYYYY
<br/>
YXYXY     
<br/>
YXXXY         
<br/>
YXXXY   below (1 call)
<br/>
YYYYY
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Does that make sense?   Sorry about my sucky diagrams.
<br/>
<br/>
The easiest way is to recurse for each pixel as you scan above and below.  This will result in a lot of calls that return right away.  I'd implement it that way first.  The variation is to scan longest spans and pass those offsets recursively.  Foley and Van Dam describe both and have a diagram but no pseudocode.   If I were coding this for GBA to be fast in bitmap modes I'd probably try to check and write 2 pixels at a time, then 1 pixel at the end if necessary.
<br/>
<br/>
-Kevin
<br/>
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">Do you suppose the stack would survive a recursive flood fill algorithm on a 32 by 32 map under the worst conditions?  64 by 64?  I could always use an iterative approach:
<br/>
<br/>
unsigned short fill_map[0x1000];
<br/>
unsigned long  current_fill = 0;
<br/>
<br/>
I've actually never done a flood fill before.  I don't need to keep track of 64 * 64 points in an iterative solution.  Time to work on this.  At any rate, any thoughts on the recursive method?
<br/>
<br/>
-Brendan</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4687 - tepples - Mon Apr 07, 2003 2:40 am</h4>
    <div class="postbody"><span class="postbody">If you want to see a implementation of span-based flood filling, look at tetanus.c in the source code for <a class="postlink" href="http://www.pineight.com/gba/#tod" target="_blank">TOD</a>, which uses flood filling to determine contiguous masses of blocks.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4694 - sgeos - Mon Apr 07, 2003 4:36 am</h4>
    <div class="postbody"><span class="postbody">[quote="tepples"]If you want to see a implementation of span-based flood filling, look at tetanus.c in the source code for [url=http://www.pineight.com/gba/#tod]TOD[/url], which uses flood filling to determine contiguous masses of blocks.[/quote]
<br/>
<br/>
What function or set of functions am I looking for?  I looked briefly, but when I saw "p.c.b[y][x]" I decided that I should probably just ask.  You have a thing for printed circuit boards I take it? =P  Hehehe...
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4697 - tepples - Mon Apr 07, 2003 5:42 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">to see a implementation of span-based flood filling, look at tetanus.c</td> </tr></table><span class="postbody">
<br/>
What function or set of functions am I looking for?</span></td> </tr></table><span class="postbody">
<br/>
TeFloodFill() and FloodFillLoop()
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I looked briefly, but when I saw "p.c.b[y][x]" I decided that I should probably just ask.  You have a thing for printed circuit boards I take it?</td> </tr></table><span class="postbody">
<br/>
The answer can be found in tod.h:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct Field
<br/>
{
<br/>
  unsigned char b[21][10];
<br/>
} Field;
<br/>
<br/>
typedef struct Player
<br/>
{
<br/>
  Field b, c;  /* block map and connection map */
<br/>
/* SNIP SNIP SNIP */
<br/>
} Player;
<br/>
<br/>
extern Player p;</td> </tr></table><span class="postbody">
<br/>
So "p.c.b[][]" is the <span style="font-weight: bold">p</span>layer's <span style="font-weight: bold">c</span>onnection map's array of <span style="font-weight: bold">b</span>locks. Nothing to do with a printed circuit board, although given a scanned PCB, a similar algorithm could possibly be used to find traces that lead from one part to another.
<br/>
<br/>
The falling algorithm I use in TOD (developed under the "Carbon" codename) is based on copying the block map to the connection map and then flood-filling contiguous areas.
<br/>
<br/>
Just consider p.c.b an array 21 high by 10 wide.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
