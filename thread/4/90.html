<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Fixed point math... how does it work? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Fixed point math... how does it work?</h2>
<div id="posts">
<div class="post">
    <h4>#511 - animension - Wed Jan 08, 2003 8:46 am</h4>
    <div class="postbody"><span class="postbody">Hey all,
<br/>
<br/>
I'm not a new programmer, but I am relatively new to the GBA platform. As I understand it, the ARM CPU does not have native hardware support for floating point mathamatics, but rather has an emulation of it and thus it should be avoided whenever possible since it will slow down performance. I also understand that fixed point math is the middle ground to this delima. What I wanted to know was how fixed point math works as opposed to floating point. How are floating point numbers stored in memory as opposed to fixed point?
<br/>
<br/>
I have read some of the ARM application notes on Advanced Risc Machines' web site but most of it consisted of mathamatical formulae to convert from one form to another but I am curious as to the inner workings of these formats. If I can grasp the technical difference, I think I would be more compentant in being able to correctly implement the fixed number format.
<br/>
<br/>
Thanks in advance!
<br/>
<br/>
M. Knittel</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#512 - Quirky - Wed Jan 08, 2003 9:11 am</h4>
    <div class="postbody"><span class="postbody">I'll try and explain my understanding of it with a couple of examples, having used fixed points a fair amount recently to do some 3D stuff. 
<br/>
<br/>
The decimal point in "fixed point" numbers is always in the same place, as the name suggests. You can place it anywhere in an integer, but the usual place is 8 bits in using signed long ints (which have 4 bytes = 32 bits) Though it may be usefull to shift it more or less depending on the data range.
<br/>
<br/>
What you do is shift any decimal point number by the number of bits. Instead of having say 0.1, you would have 0.1&lt;&lt;8 or 0.1 * 256... which is 25.6, though as we store it as an int, we lose that bit of decimal pointage to store 25. Then you use this value all the time instead of 0.1. Usually you multiply a fixed point by a big number at some point and want to find the result, or you use some comparisons to find angles, etc. 
<br/>
<br/>
In the first case you need to shift back down to find the "true" result. So for example 0.1 * 100 = 10. In the fixed notation... 100 * 25 = 2500 then shift down 8... 2500&gt;&gt;8 ~= 2500/256 = 9. More or less right, and for the sort of things fixed points are used for (3D rotations, etc) such rounding errors aren't usually as catastrophic as they appear. If you're careful with ranges,etc.
<br/>
<br/>
The second example, if you want to compare a "decimal point number" to a value... say you want something like:
<br/>
<br/>
if (x &gt; 0.95)
<br/>
<br/>
then if you use fixed point maths, x will be shifted up by 8.. so you would need:
<br/>
<br/>
if (x &gt; 243)
<br/>
<br/>
because if you simply shift x back down to compare, then it would lose all its data. (if x is less than 1&lt;&lt;8 then x&gt;&gt;8 will be zero)
<br/>
<br/>
I've probably missed out something fundamental, I've not mentioned the stuff like what happens when you divide or multiply fixeds because you've probably read that already. They aren't that difficult to grasp once you realise that all fixeds are, are smallish numbers multiplied by a bigish number so that the result can be stored in an int. When you want the smallish number back, you need to divide (i.e. shift down) by the bigish number.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#514 - animension - Wed Jan 08, 2003 9:41 am</h4>
    <div class="postbody"><span class="postbody">Thanks for informative reply! I understand the concept of shifting bits, so this makes perfect sense. What I also want to know is what goes on at a binary level. Say for instance:
<br/>
<br/>
You have an unsigned short int of 16 bits. The bits are represented as:
<br/>
<br/>
00000000 00011001 (25 in decimal)
<br/>
<br/>
I have heard that fixed point math is kind of like normal decimal point math in that you can put a "point" somewhere along the bits like so:
<br/>
<br/>
00000000 0001.1001
<br/>
<br/>
which would make it 1 and 1001 out of 1111 possible binary values, or 1 and 9/16, or 1.5625 in decimal notation. What I want to know is how floats are stored and therefore how converting from floats to fixed works. Such as how does one represent 1.975 in fixed point math at a binary level? Are floats stored in a similar way and thus able to be stored into fixed notation relatively easily? How do floats calculate decimal values? If I understood both I could easily manipulate one from the other.
<br/>
<br/>
M Knittel</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#524 - Quirky - Wed Jan 08, 2003 11:22 am</h4>
    <div class="postbody"><span class="postbody">It isn't that complicated. Fixed point really is just "multiply up and lob off what's left over". So 1.975 would just be...
<br/>
<br/>
1.975 &lt;&lt;8 = 505 -&gt; 111111001 
<br/>
<br/>
'course, you wouldn't have 1.975 in floating point format at any point on the GBA, just its fixed representation. 
<br/>
<br/>
I don't know 100% the binary representation of floats, I've only learned what I needed for GBA programming, but there's stacks of examples on the web.
<br/>
<br/>
<a class="postlink" href="http://www.google.com/search?q=how+are+floats+stored+in+binary&amp;btnG=Google+Search&amp;hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=utf-8" target="_blank">http://www.google.com/search?q=how+are+floats+stored+in+binary&amp;btnG=Google+Search&amp;hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=utf-8</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#554 - animension - Wed Jan 08, 2003 8:07 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for the link.  I read a couple of the articles and seem to understand things better. My final question is:
<br/>
<br/>
If the ARM processor doesn't natively process floating point units, and thus our need for using fixed point variables, would it impact the performance of the code to do something like:
<br/>
<br/>
typedef FIXED signed long int;
<br/>
<br/>
FIXED myFixedVariable = (int)(5.23723 &lt;&lt; 8)
<br/>
<br/>
Seeing that 5.23723 is a floating point number, would this code snippet require the ARM CPU to emulate floating point math and slow things down?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#560 - coelurus - Wed Jan 08, 2003 8:34 pm</h4>
    <div class="postbody"><span class="postbody">Most compilators calculate constants and store them directly. I hope the GBA-compiler does :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#578 - ampz - Wed Jan 08, 2003 9:43 pm</h4>
    <div class="postbody"><span class="postbody">I'am not sure floats can be shifted.... can they?
<br/>
<br/>
" *256.0 " is equivalent of " &lt;&lt;8 "</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#579 - Touchstone - Wed Jan 08, 2003 9:45 pm</h4>
    <div class="postbody"><span class="postbody">Floats cannot be shifted.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#590 - animension - Wed Jan 08, 2003 10:17 pm</h4>
    <div class="postbody"><span class="postbody">How then could one do the equivalent of storing a float constant into a fixed var?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#592 - Touchstone - Wed Jan 08, 2003 10:27 pm</h4>
    <div class="postbody"><span class="postbody">Well, multiplication of course. :) Shift a integer value left (assuming that the left most bit is the most significant bit) by eight steps will result in the value being 256 times bigger, so you could multiply the original value by 256 to get the same result as arithmetic shift left.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#597 - grumpycat - Wed Jan 08, 2003 10:35 pm</h4>
    <div class="postbody"><span class="postbody">I define a type for my fixed-point values:
<br/>
<br/>
typedef long sfxd32;  // signed, fixed-point 32-bit.
<br/>
<br/>
And then define:
<br/>
<br/>
#define I2F(x)     ((x) &gt;&gt; 16)
<br/>
#define F2I(x)     ((x) &lt;&lt; 16)
<br/>
<br/>
To convert between my fixed-point and integer variables.
<br/>
<br/>
Also, so I don't confuse myself, I tag all my fixed-points with 'F', e.g.:
<br/>
<br/>
     int x;
<br/>
     sfxd32 xF;
<br/>
<br/>
     x = F2I(xF);
<br/>
<br/>
To assign constants, you can:
<br/>
<br/>
     xF = (sfxd32)(543.125 * 256);
<br/>
<br/>
And this is all done at compile time.
<br/>
<br/>
<br/>
Addition of fixed-point values is simple.
<br/>
<br/>
    zF = xF + yF;
<br/>
<br/>
Multiplication needs to be corrected:
<br/>
<br/>
    zF = ((long long)xF * (long long)yF) &gt;&gt; 16;
<br/>
<br/>
You can use the ARM SMULL (I think) to do it better in asm.
<br/>
<br/>
The shift is required because you're multiplying values that have already been multiplied by 2^16:
<br/>
<br/>
   xF = (float)x * 2^16.
<br/>
   yF = (float)y * 2^16.
<br/>
so,
<br/>
   zF = x * y * 2^32.
<br/>
<br/>
You want to normalize that back to 2^16, so you &gt;&gt; 16.
<br/>
<br/>
Division works the same way, except you'll want to &lt;&lt; 16 before the division.
<br/>
<br/>
Grumpy.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#601 - animension - Wed Jan 08, 2003 10:45 pm</h4>
    <div class="postbody"><span class="postbody">I see what you mean. Essentially I need to do this?
<br/>
<br/>
(assuming myDoubleValue is a constant and not a variable)
<br/>
<br/>
typedef FIXED signed short int;
<br/>
FIXED myFixedVar = (FIXED)(myDoubleValue * (double)(1 &lt;&lt; myShiftAmount));
<br/>
<br/>
Which would:
<br/>
<br/>
1) evaluate 1 &lt;&lt; myShiftAmount to the multiplier (ex: myShiftAmount is 8, the multiplier would evaluate to 256)
<br/>
2) cast the multiplier as a double to make it compatible with myDoubleVar (ex: 256 becomes 256.0)
<br/>
3) multiply the constant myDoubleValue amount by the multiplier (ex: 256.0)  to yield a double constant representing this amount
<br/>
4) cast the multiplied double value into the FIXED type, truncating the decimal remainder and storing the value as an integer at a binary level.
<br/>
<br/>
Correct?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#603 - animension - Wed Jan 08, 2003 10:47 pm</h4>
    <div class="postbody"><span class="postbody">Ok I see the logic to having to compensate for operations on fixed number types... I still remember some grade-school math ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#604 - grumpycat - Wed Jan 08, 2003 10:48 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>animension wrote:</b></span></td> </tr> <tr> <td class="quote">I see what you mean. Essentially I need to do this?
<br/>
<br/>
(assuming myDoubleValue is a constant and not a variable)
<br/>
<br/>
typedef FIXED signed short int;
<br/>
FIXED myFixedVar = (FIXED)(myDoubleValue * (double)(1 &lt;&lt; myShiftAmount));
<br/>
<br/>
Which would:
<br/>
<br/>
1) evaluate 1 &lt;&lt; myShiftAmount to the multiplier (ex: myShiftAmount is 8, the multiplier would evaluate to 256)
<br/>
2) cast the multiplier as a double to make it compatible with myDoubleVar (ex: 256 becomes 256.0)
<br/>
3) multiply the constant myDoubleValue amount by the multiplier (ex: 256.0)  to yield a double constant representing this amount
<br/>
4) cast the multiplied double value into the FIXED type, truncating the decimal remainder and storing the value as an integer at a binary level.
<br/>
<br/>
Correct?</td> </tr></table><span class="postbody">
<br/>
<br/>
Right-on.  In fact you don't need step 2, as (1 &lt;&lt; myShiftAmount) will be promoted to a float automatically.
<br/>
<br/>
Grumpy.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#605 - animension - Wed Jan 08, 2003 10:50 pm</h4>
    <div class="postbody"><span class="postbody">[quote="grumpycat
<br/>
Right-on.  In fact you don't need step 2, as (1 &lt;&lt; myShiftAmount) will be promoted to a float automatically.
<br/>
<br/>
Grumpy.[/quote]
<br/>
<br/>
Sweetness! Thanks for all the help you guys! This is one of the reasons I have come to love developing for this platform: comraderie! :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
