<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ECG on GBA - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > ECG on GBA</h2>
<div id="posts">
<div class="post">
    <h4>#53930 - Tomik - Tue Sep 13, 2005 3:35 pm</h4>
    <div class="postbody"><span class="postbody">Hi, did someone a ECG on the GBA?
<br/>
I have some problems with that.
<br/>
<br/>
I did:
<br/>
- read in the ecg data
<br/>
- plot an scroll them
<br/>
- draw a line between all pixels
<br/>
<br/>
 ... and that is very slowly .... what can I do better for show like two or three heartbeats at a time on the display ??
<br/>
<br/>
Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54013 - Tomik - Wed Sep 14, 2005 4:02 pm</h4>
    <div class="postbody"><span class="postbody">nobody has an idea?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   while(1)
<br/>
   {   
<br/>
      Raster();
<br/>
      RighttoLeft(yArr);         
<br/>
      DrawLine(yArr);
<br/>
      WaitForVblank();
<br/>
      Flip();      
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
<br/>
I draw:
<br/>
- a Raster
<br/>
- draw the current and old shifted pixels
<br/>
- draw lines between the pixels
<br/>
- Flip to back buffer (or frontbuffer)
<br/>
<br/>
how can i make that faster.
<br/>
i think i dont need to draw my raster everytime new and dont need to draw all lines in every step new ? But I am a Noob and need help with that !!
<br/>
<br/>
Thanks, Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54016 - poslundc - Wed Sep 14, 2005 5:09 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Tomik wrote:</b></span></td> </tr> <tr> <td class="quote">i think i dont need to draw my raster everytime new and dont need to draw all lines in every step new ?</td> </tr></table><span class="postbody">
<br/>
<br/>
So why don't you try that, then? Just draw whatever columns have changed between the last frame and the current frame. If most of your data doesn't change, then don't update it.
<br/>
<br/>
You have an idea, so <span style="font-style: italic">try it.</span> Don't just ask "what can I do better".
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54045 - tepples - Thu Sep 15, 2005 4:29 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">Just draw whatever columns have changed between the last frame and the current frame.</td> </tr></table><span class="postbody">
<br/>
This technique does require your display to be arranged in a tiled (not linear) format, however, if you want a scrolling display and not a sweeping display like a radar or like Lumines.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54071 - Cearn - Thu Sep 15, 2005 9:36 am</h4>
    <div class="postbody"><span class="postbody">You probably don't need to draw the raster every time. You can, for example, use sprites for the raster, draw that at start-up and you'll never have to draw the raster again. It will always be in front of the background, though.
<br/>
<br/>
As for making things faster, there are a number of fairly simple ways of doing that. For example, a number of tutorials engage in some pretty serious pessimisation; if you can get rid of that you might be able to speed up the code by a few factors. For example:
<br/>
<ul><li><span style="font-weight: bold">Compiling options</span>. Generally, it's better to compile as thumb code (-mthumb) rather than arm code (-marm, which is the default). This may speed things up by 50% or more. The exception to this is when code goes into IWRAM, but I'm guessing that's not happening yet. Putting code into IWRAM is also a good idea of speeding things up, btw, but it can be a little tricky at times.
<br/>
If you don't have optimisations turned on yet (-O options), maybe it's a good time to start. By default, optimisations are off; adding -O2 or -O3 to your compiler flags can make a world of difference.
<br/>
</li><li><span style="font-weight: bold">Inline functions and macros</span>. For small functions, like plotting pixels, <span style="font-style: italic">DO NOT</span> use regular functions, use inline functions or macros instead.
<br/>
</li></ul></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// Normal function
<br/>
void m3_plot_std(int x, int y, u16 clr)
<br/>
{   vid_mem[y*240+x]= clr;   }
<br/>
<br/>
// inline function
<br/>
static inline void m3_plot_inl(int x, int y, u16 clr)
<br/>
{   vid_mem[y*240+x]= clr;   }
<br/>
<br/>
// macro
<br/>
#define M3_PLOT_MACRO(x, y, clr) vid_mem[(y)*240+(x)]= clr
<br/>
</td> </tr></table><span class="postbody">Using m3_plot_inl or M3_PLOT_MACRO instead of the normal function is about three times faster, and hardly more difficult to use.
<br/>
<li><span style="font-weight: bold">If possible, work in word-sized chunks</span>. The GBA is a 32bit machine, and prefers 32bits (words). Working in bytes (8bit) and halfwords (16bit) is often slower. 
<br/>
For example, if you need to fill blocks of memory (like drawing horizontal grid lines), you can fill in word chunks instead of halfword chunks and speed things up by roughly a factor 2.
<br/>
</li></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// filling a scanline in mode 3
<br/>
int ii;
<br/>
<br/>
// in halfwords
<br/>
u16 clr= 0x03E0;    // green
<br/>
u16 *dst= &amp;vid_mem[10*240]; // scanline 10;
<br/>
for(ii=0; ii&lt;240; ii++)
<br/>
    dst[ii] = clr;
<br/>
<br/>
// or in words (filling 2 pixels at once)
<br/>
u32 clr32= 0x03E003E0; // green times two
<br/>
u32 *dst32= (u32*)&amp;vid_mem[10*240];  // scanline 10
<br/>
for(ii=0; ii&lt;240/2; ii++)
<br/>
    dst32[ii]= clr32;</td> </tr></table><span class="postbody">
<br/>
Because there are half the iterations in the second loop, it's nearly twice as fast. There are plenty of methods faster still, though: DMA and CpuFastSet, for example, but those require a little more effort to get working that a few casts. Well worth it, though.
<br/>
Also, note that the loop variable <span style="font-style: italic">ii</span> is an int (also 32bit). <span style="font-weight: bold">DON'T</span> use non-words for local variables, <span style="font-weight: bold">especially</span> not for loop variables. If I had used u16 as a type, it'd have been 20% slower, which can run up to 50% or more if you use the variable often. Use of non-words require extra effort in the CPU's part, use those only if you have to.
<br/>
These things are still pretty easy to deal with and may speed things up by as much as 800%. More is certainly possible, but that depends on the current implementation, so it's difficult to see what we can do about that without seeing more of the code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54184 - Tomik - Fri Sep 16, 2005 8:10 am</h4>
    <div class="postbody"><span class="postbody">I think the fastest way is tp plot current ecg black and the last one white so its erased. then shift it. and that works nice an fast !
<br/>
but how can I draw the line betwenn the 120 pixels to get a real ecg?
<br/>
or better how can I shift it ?
<br/>
I have already the drawing function made and it works, but now i need to shift the y=mx+b function ! i do not have an idea. 
<br/>
the problem is that i draw a line between to pixels with this function. 
<br/>
i dont have an array where this value are in ! (would be tooooo big)
<br/>
<br/>
have an idea (!!!thats what i want poslundc!!!)
<br/>
<br/>
Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54185 - Cearn - Fri Sep 16, 2005 8:37 am</h4>
    <div class="postbody"><span class="postbody">How exactly is the data coming in? Some thing like: every frame you get a new y-value to add to the left or right of the screen? If so, do you store those values in an array somewhere? An array of 240 values is definitely not too big. Then you can use that array to erase the previous lines, and redraw it one pixel further along. 
<br/>
<br/>
Also, if you do have a horizontal resolution of 1 (successive x-values are 1 unit apart), then you don't really need a full line drawer. If you have, say coordinates (x,y0) and (x+1, y1), the line between them would just be two vertical lines at most. Something like
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
 #
<br/>
 #
<br/>
 #
<br/>
 #
<br/>
#
<br/>
#
<br/>
#
<br/>
#
<br/>
</td> </tr></table><span class="postbody">
<br/>
You can take the vertical average ya= (y0+y1)/2, and draw two vertical lines between (x,y0)-(x,ya) and (x+1,ya), (x+1, y1).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54186 - Tomik - Fri Sep 16, 2005 9:01 am</h4>
    <div class="postbody"><span class="postbody">It is a 120 Array because I use Mode 4 so I can only plot 2 Pixel at a time !
<br/>
<br/>
Here I readin the new value of the ecg :
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void RighttoLeft(int *yArr)                  // Plot current value and scroll right to left
<br/>
{
<br/>
   int i;
<br/>
   int xAXIS=0;
<br/>
<br/>
   for(i=21;i&lt;140;i++)
<br/>
   {
<br/>
      PlotPixel(1,i,0xFFFF);
<br/>
   }
<br/>
<br/>
   for(i=0; i&lt;120 ; i++)                  
<br/>
   {
<br/>
      PlotPixel(i,yArr[i],0x0000);      // draw current Pixels      
<br/>
      PlotPixel(i+2,yArr[i],0xFFFF);      // erase last pixel   
<br/>
<br/>
      yArr[i]=yArr[i+1];               // shift all Pixel one step to right (no drawing)   
<br/>
   }
<br/>
   
<br/>
   ADC_CNT(yArr);                     // if loop down to 0 then load new ADC value   
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
..and this is my drawing function:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void DrawLine(int *yArr)
<br/>
{
<br/>
   float m,b; 
<br/>
   int x,y,i;
<br/>
   
<br/>
   for(i=0;i&lt;119;i++)
<br/>
   {
<br/>
      if((abs(yArr[i]-yArr[i+1]))&gt;2)
<br/>
      {
<br/>
         int x0=i;
<br/>
         int y0=yArr[i];
<br/>
         int x1=i+1;
<br/>
         int y1=yArr[i+1];
<br/>
         
<br/>
         int dx=x1-x0;               
<br/>
         int dy=y1-y0;
<br/>
<br/>
         m=((float)abs(dy))/(float)dx;            // explains the function
<br/>
         b = y0-m*x0;
<br/>
<br/>
         if(y0&lt;=y1)                        // if falling line
<br/>
         {
<br/>
            for(y=y0;y&lt;y1;y++)
<br/>
            {
<br/>
               x=(int)(-(b-y)/m+0.5);
<br/>
               PlotPixel(x,y,0x0000);
<br/>
               PlotPixel(x,y,0xFFFF);
<br/>
            }
<br/>
         }
<br/>
         else                           // if rising line
<br/>
         {
<br/>
            for(y=y1;y&lt;y0;y++)
<br/>
            {
<br/>
               x=(int)(-(b-y)/m+0.5);
<br/>
               PlotPixel(x,y,0x0000);
<br/>
               PlotPixel(x,y,0xFFFF);
<br/>
            }
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
..and if I use this drawing function every step and draw all lines new .. very slowly ;)
<br/>
<br/>
Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54187 - Cearn - Fri Sep 16, 2005 9:03 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">m=((float)abs(dy))/(float)dx;            // explains the function </td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
*cough*
<br/>
Well there's your slowdown.
<br/>
<br/>
No floats on GBA please, and preferably no division too. I'll see about the rest later.
<br/>
<br/>
ETA:
<br/>
<br/>
The GBA has no floating point unit, so any floats or doubles have to be emulated (read: is slow). Just did a tiny little check and found that floating point division is roughly 7 times slower than the 'standard' integer division. The GBA also doesn't have a hardware integer division, so that's slow as well 17 times as slow as multiplication for example in this particular test (can vary a little bit, but it's a fair number). So right there you've lost yourself a factor 100. 
<br/>
<br/>
Instead of floating point, read up on fixed point arithmetic.
<br/>
Instead of division, use a reciprocal look up table.
<br/>
<br/>
In fact, for drawing lines, you don't need any division at all, look up Bresenham.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54190 - Tomik - Fri Sep 16, 2005 10:35 am</h4>
    <div class="postbody"><span class="postbody">the problem is the draw line function:
<br/>
I will change the float and division things!
<br/>
What about that idea:
<br/>
make the timesteps on the xAxis fixed and so I can plot more pixel (new ADC value) for every xAxis value ? 
<br/>
i think it sounds good, but dont know NOW how to realize it !!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54192 - Cearn - Fri Sep 16, 2005 10:56 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">...
<br/>
         int x0=i; 
<br/>
         int y0=yArr[i]; 
<br/>
         int x1=i+1;     // &lt;-- 
<br/>
         int y1=yArr[i+1]; 
<br/>
          
<br/>
         int dx=x1-x0;                
<br/>
         int dy=y1-y0; </td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
Hadn't noticed this yet. So yes, x0 and x1 are always 1 apart, and dx=1, by definition. That simplifies things enormously. Try this (untested) code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void DrawLine(int *yArr)
<br/>
{
<br/>
    int ix, iy;
<br/>
    u32 y0, y1, ya;
<br/>
    for(ix=0; ix&lt;119; ix++)     // draw each line segment
<br/>
    {
<br/>
        y0= yArr[ix];
<br/>
        y1= yArr[ix+1];
<br/>
        if(y0&gt;y1)       // swap so that y1 &gt; y0
<br/>
        {   int tmp= y0; y0= y1; y1= tmp; }
<br/>
<br/>
        ya= (y0+y1)/2;  // div by 2^n are optimised by GCC. This is fine.
<br/>
<br/>
        for(iy=y0; iy&lt;ya; iy++)
<br/>
            PlotPixel(ix, iy, 0xFF);
<br/>
<br/>
        for(iy=ya; iy&lt;y1; iy++)
<br/>
            PlotPixel(ix+1, iy, 0xFF);
<br/>
    }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
It's really not to difficult to use all 240 pixels in mode 4 btw, I gave you a function for that in another thread.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54193 - Tomik - Fri Sep 16, 2005 11:12 am</h4>
    <div class="postbody"><span class="postbody">really nice, works fine ! i have to change some little things ....
<br/>
thanks cearn !! it fast ;)
<br/>
<br/>
thomas / germany</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54199 - Cearn - Fri Sep 16, 2005 2:39 pm</h4>
    <div class="postbody"><span class="postbody">Messed up in the line drawer. For falling lines, the x values need to be swapped as well. Sorry :-]
<br/>
<br/>
Also added a color parameter for the function, so that you can change line colors more easily.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void DrawLine(int *yArr, u32 clr) 
<br/>
{ 
<br/>
    int ix, iy; 
<br/>
    int x0, x1, y0, y1, ya; 
<br/>
    for(ix=0; ix&lt;119; ix++)     // draw each line segment 
<br/>
    { 
<br/>
        y0= yArr[x0= ix]; 
<br/>
        y1= yArr[x1= ix+1]; 
<br/>
        if(y0&gt;y1)       // swap so that y1 &gt; y0 
<br/>
        {
<br/>
            int tmp= y0; y0= y1; y1= tmp;
<br/>
            x0= ix+1; x1= ix;
<br/>
        } 
<br/>
<br/>
        ya= (y0+y1)&gt;&gt;1;
<br/>
<br/>
        for(iy=y0; iy&lt;ya; iy++) 
<br/>
            PlotPixel(x0, iy, clr); 
<br/>
<br/>
        for(iy=ya; iy&lt;y1; iy++) 
<br/>
            PlotPixel(x1, iy, clr); 
<br/>
    } 
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Also tested a full scrolling thing in no$gba. Basic procedure works, but may be just a little too slow for one VBlank. At least when you use the all 240 columns. With page flipping it worked fine though.
<br/>
Of course, there are still ways of speeding up the drawing code, like putting it in IWRAM.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54204 - Tomik - Fri Sep 16, 2005 4:43 pm</h4>
    <div class="postbody"><span class="postbody">..and I have still the problem with draw only one pixel.
<br/>
In your function there between the steps one pixel missing if i plot in single pixel mode.
<br/>
<br/>
It works now fine, but I still plot two pixels in a row, they are still together and i dont know how to split them !
<br/>
<br/>
the problem wasnt the falling line, it was the rising one. because zero ist on the top ;) doesnt matter, i know what you ment.
<br/>
<br/>
Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54437 - Tomik - Mon Sep 19, 2005 1:42 pm</h4>
    <div class="postbody"><span class="postbody">It works very nice right now.
<br/>
I  want now a constant time for readin the adc ! therefore i think i have to use a interrupt.
<br/>
can someone give me information how to use and handle that?
<br/>
<br/>
Thanks, Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54490 - tepples - Mon Sep 19, 2005 11:38 pm</h4>
    <div class="postbody"><span class="postbody">(In order to decide whether to use one of the LCD controller's timers or one of the programmable timers)
<br/>
How often do you need to read the ADC?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54542 - Tomik - Tue Sep 20, 2005 7:52 am</h4>
    <div class="postbody"><span class="postbody">I would like to make 200, 400 or 800Hz readout !!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54543 - Cearn - Tue Sep 20, 2005 8:47 am</h4>
    <div class="postbody"><span class="postbody">You mean 200, 400, 800 new pixels/second? That's a whole lotta plotting. 
<br/>
Then again, maybe not: the screen itself refreshes every 60 Hz; why you could redraw the whole thing 200 times a second, you'd only be able to show it in 200/60 ~ 3 pixel increments anyway. And that'd go up to 13 for 800 Hz. It could be done with timer interrupts. There may be trouble with the fact that drawing the whole line takes a lot longer though (best case: around 450 Hz for a 120 horizontal resolution, all code in IWRAM), but it could be done.
<br/>
<br/>
But I have to wonder whether you'd want to go through all that, though. 200 Hz would mean 200 scrolls/second, and for 120 pixels that'd mean you'd have a completely new screen ever 0.6 seconds. While it won't exactly be a blur, it may still be a little too much for comfortable viewing. For 800, it probably <span style="font-style: italic">would</span> be a blur.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54545 - Tomik - Tue Sep 20, 2005 8:58 am</h4>
    <div class="postbody"><span class="postbody">i dont want to plot 800hz pixel after pixel (xAxis). the value might be at the "same" xaxis-value. means maybe more pixels on the y Axis, so i would get a better resolution and can forget the linedrawing !
<br/>
i want to get 3 sec on the display (40pxl/beat @ 60hz). 
<br/>
the problem is to get 3 seconds on display ... doesnt matter if hearbeat is 60 or 250BPM.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54552 - Tomik - Tue Sep 20, 2005 11:00 am</h4>
    <div class="postbody"><span class="postbody">i think i will make xAxis steps in 50Hz, that means every 0.02sek a new x axis value!! that DONT mean 50Hz new ADC values ! if i readout the adc data with 400-800Hz i could draw 8-16 yvalue on on x step !!!
<br/>
<br/>
so how can i realize the 50Hz xAxis Steps??
<br/>
<br/>
Like this <a class="postlink" href="http://user.chem.tue.nl/jakvijn/tonc/timers.htm#REG_TMxD" target="_blank">http://user.chem.tue.nl/jakvijn/tonc/timers.htm#REG_TMxD</a>:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">REG_TM2D= 0x147;                      // 0x147 (50Hz) ticks till overflow
<br/>
REG_TM2CNT= TM_ON | TM_FREQ_1024; // we're using the 1024 cycle timer   
<br/>
REG_TM3CNT= TM_ON | TM_CASCADE;   // cascade into tm3
<br/>
<br/>
main
<br/>
{
<br/>
  u16 count=REG_TM3D;
<br/>
  while(1)
<br/>
  {
<br/>
    if(REG_TM3D != count)
<br/>
    {
<br/>
       // [plotting code]
<br/>
       count= REG_TM3D;
<br/>
    }
<br/>
  } 
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54654 - Tomik - Wed Sep 21, 2005 7:59 am</h4>
    <div class="postbody"><span class="postbody">what do you think about this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void main(void)
<br/>
{
<br/>
   REG_TM2D   = 0xFFFF-0x147;         // 327 ticks is 20ms = 50 Hz for xValue shifting
<br/>
   REG_TM2CNT = 0x83;               // 1024 cycle timer - 61.04us / 16.384kHz
<br/>
   REG_TM3CNT = 0x87;
<br/>
<br/>
  u16 xAxisShifter = REG_TM2D;
<br/>
.
<br/>
.
<br/>
.
<br/>
  u16 xAxisShifter=REG_TM3D; 
<br/>
  while(1) 
<br/>
  { 
<br/>
    if(REG_TM3D != xAxisShifter) 
<br/>
    { 
<br/>
       // [plotting code] 
<br/>
       xAxisShifter= REG_TM3D; 
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54756 - Tomik - Thu Sep 22, 2005 10:45 am</h4>
    <div class="postbody"><span class="postbody">it runs very nice right now ... but the solution is still not so good.
<br/>
so how can i get this "two pixel in a row" drawing to a one pixel drawing.
<br/>
<br/>
Code is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void PlotPixel(int x,int y, u16 c)   
<br/>
{ 
<br/>
   videoBuffer[(y) *120 + (x)] = (c); 
<br/>
}
<br/>
<br/>
void RighttoLeft(int *yArr)                  // Plot current value and scroll right to left
<br/>
{
<br/>
   int i;
<br/>
   int xAXIS=0;
<br/>
<br/>
   for(i=0; i&lt;120 ; i++)                  
<br/>
   {
<br/>
      PlotPixel(i,yArr[i],0x0000);      // draw current Pixels   
<br/>
      PlotPixel(i+2,yArr[i],0xFFFF);      // erase last pixel
<br/>
      yArr[i]=yArr[i+1];               // shift all Pixel one step to right (no drawing)   
<br/>
   }
<br/>
   
<br/>
   ADC_CNT(yArr);                     // if loop is 119 then load new ADC value   
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
have an idea ??</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54778 - tepples - Thu Sep 22, 2005 3:29 pm</h4>
    <div class="postbody"><span class="postbody">Untested, but it should give you the idea of how to use a read-modify-write sequence to plot one pixel at a time:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void PlotPixel(unsigned int x, unsigned int y, unsigned int c)
<br/>
{
<br/>
  /* Find the address of a pair of pixels. */
<br/>
  unsigned short *pair = &amp;videoBuffer[y * 120 + (x &gt;&gt; 1)];
<br/>
<br/>
  /* Bounds checking is useful for debugging and optimizing. */
<br/>
  assert(x &lt; 240 &amp;&amp; y &lt; 160 &amp;&amp; c &lt; 256);
<br/>
<br/>
  /* 1: pixel on the right; 0: pixel on the left */
<br/>
  if(x &amp; 1)
<br/>
    /* High byte of pixels is on the right. Erase the high byte and replace it. */
<br/>
    *pair = (*pair &amp; 0x00ff) | (c &lt;&lt; 8);
<br/>
  else
<br/>
    /* Low byte of pixels is on the left. Erase the low byte and replace it. */
<br/>
    *pair = (*pair &amp; 0xff00) | c;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
EDIT: comments added<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"><br/><br/>Last edited by tepples on Tue Sep 27, 2005 4:20 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#55215 - Tomik - Mon Sep 26, 2005 1:52 pm</h4>
    <div class="postbody"><span class="postbody">What is the difference between assert() and if() ?
<br/>
assert: if zero then .... else stop programm !?!?
<br/>
if: could be the same !?!?!?!
<br/>
<br/>
can you comment that code a bit please .... thanks
<br/>
<br/>
Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#55221 - poslundc - Mon Sep 26, 2005 5:00 pm</h4>
    <div class="postbody"><span class="postbody">A thread about asserts: <a href="http://forum.gbadev.org/viewtopic.php?t=2999" target="_blank">http://forum.gbadev.org/viewtopic.php?t=2999</a>
<br/>
<br/>
One thing not mentioned in that thread is that you can easily define asserts to be automatically optimized out for a non-debug build, such as:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#if OPTION_ASSERT
<br/>
#define ASSERT(x) \
<br/>
    if (!(x)) \
<br/>
        AssertPrint("Assertion failed:\n\tFile: %s\n\tLine: %d\n", __FILE__, __LINE__);
<br/>
#else
<br/>
#define ASSERT(x) ;
<br/>
#endif</td> </tr></table><span class="postbody">
<br/>
<br/>
(Where AssertPrint is a custom-function that outputs a message to the debugger, then drops into an infinite loop, or perhaps waits for a button combination before proceeding.)
<br/>
<br/>
The advantages speak for themselves: they give you a simple way to put bounds-checking on the input to your various modules and test that the results of your algorithms behave as expected, and it can all automatically vanish when you want to create an optimized build.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57055 - Tomik - Thu Oct 13, 2005 11:04 am</h4>
    <div class="postbody"><span class="postbody">Hey, its me again.
<br/>
<br/>
I changed a lot. Specially I have 800Hz Sample Rate, with 40Hz scrolling.
<br/>
That means 20 ECG value in one of the 240 columns ....
<br/>
It doesnt work fine right now, because I have an Array which is 240*20 Pixel. I thought about changing the mode. I use Mode 4 right now.
<br/>
I think I need a Tile-Mode for that.
<br/>
What do you think? TILE or BITMAP-MODE ?
<br/>
Can I make all that with Tile-Mode 2?
<br/>
<br/>
I need help with that...
<br/>
<br/>
tahnks, Thomas /Germany</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57061 - Cearn - Thu Oct 13, 2005 12:31 pm</h4>
    <div class="postbody"><span class="postbody">Define "It doesnt work fine right now". It's too slow?
<br/>
<br/>
Anyway, in order to use tilemodes you'd have to edit individual tiles to get the right pixels. That could be a bit hairy. But as in your case scrolling is limited to constant speed, horizontally, and there wouldn't be too many other things on screen (right?), I have a feeling you can simplify a lot. 
<br/>
First of all, as scrolling in tile-moes wraps around, you only have to update the new column and the rest can be kept as was, meaning you don't need any array at all. In its stead, just use a single scroll counter, indicating the column you have to fill in. But please, do <span style="font-weight: bold">not</span> use something like REG_BGxHOFS++, because the scrolling registers are write only.
<br/>
<br/>
Here's what might work (depends on the complexity of your case, and basically pulled out of my a^Hhat as I'm writing this, so bare with me).
<br/>
<br/>
For the tile modes, you have a charblock (CBB) and a screenblock (SBB).  A full screenblock contains 32x32=1024 screen entries (SE), which is also the amount of tiles you can access in regular backgrounds (i.e., modes 0 and 1; mode 2 would only make things harder). Set up the map so that it's column-based to start with. That is, something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// tile-indices in the screenblock (in hex):
<br/>
000 020 040 060 ... 3C0
<br/>
001 021 041 061 ... 3C1
<br/>
...
<br/>
01F 03F 05F 07F ... 3FF      
<br/>
</td> </tr></table><span class="postbody">
<br/>
This means that each stretch of 32 tiles in the charblock signifies a column on the background. That right, each <span style="font-weight: bold">row</span> in the CBB is a <span style="font-weight: bold">column</span> in the screenblock. This is a win situation because if you use 4bpp tiles, there are 8 pixels/tile-row, == one u32 /tile-row, and so each column on screen is basically represented by a continuous array of words. Get the tile-column from the current offset (ofs&gt;&gt;3), and the nybble-offset in the word (which corresponds with the pixels ofset in the tile-column) by ofs&amp;7. plotting a vertical line then becomes something like
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int tx= ofs&gt;&gt;3, ix= ofs&amp;7, iy;
<br/>
<br/>
// nasty casting here because I don't know how you're defining your
<br/>
// charblocks, if you're using my tile_mem stuff, it'd be much easier.
<br/>
// u32 *col= &amp;tile_mem[cbb_id][tx*32];
<br/>
u32 *col= (u32*) &amp;( ((u8*)cbb_ptr)[tx*32*32] );
<br/>
<br/>
// clr_id: palette index in [0,15), shifted to the right nybble
<br/>
u32 pxl l= clrid&lt;&lt;(4*ix); 
<br/>
<br/>
// plotting new pixels as (ix,iy), for iy in [y0, y1) ; 0&lt;=y0&lt;=y1&lt;32
<br/>
for(iy=y0; iy&lt;y1; iy++)
<br/>
    col[iy] |= pxl;
<br/>
</td> </tr></table><span class="postbody">
<br/>
You will have to make sure that you erase tiles that you've scrolled past, but that shouldn't be too hard. And, again, because of the column-based map, it shouldn't take long either, as you can use a single DMA_FILL or CpuFastSet for it.
<br/>
<br/>
Hmm, hope that make any kind of sense to you :P. 
<br/>
<br/>
Just curious, how variable is an ECG? Do you have a representative screenshot somewhere?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57211 - Tomik - Fri Oct 14, 2005 10:24 am</h4>
    <div class="postbody"><span class="postbody">the ECG I use is not very hard. but forget the ECG, use a sinus ... its simple too !
<br/>
I have to trie a lot ...
<br/>
<br/>
i would like to use a 800Hz samplerate ... 40Hz scrolling !! that means
<br/>
20 value in column ..big array ..but now drawing line (interpolation)
<br/>
in mode 4 i have to have an array ... or how cxan i scroll the whole matrix ? that would make everything faster and easier ....
<br/>
<br/>
Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57212 - Cearn - Fri Oct 14, 2005 10:35 am</h4>
    <div class="postbody"><span class="postbody">20 values/column = 480 entries. That's not all that big actually. You could house a lot more in IWRAM.
<br/>
For scrolling the entire screen you can use the <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#lcdvideocontroller" target="_blank">scrolling registers</a>, see tutorial code to see how you can work with them. Technically they work for the bitmap modes too, but as those modes don't wrap around at the edges, you can't really use them there.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57232 - Tomik - Fri Oct 14, 2005 1:38 pm</h4>
    <div class="postbody"><span class="postbody">20values/column ... 240columns ..=4800values ! thats big ! ever step (40Hz=25ms) shifting 4800 values and draw 4799 lines between them ... make a detection algorithmus or something else ... thats much, too much !!
<br/>
I will check out the scrolling register !!
<br/>
do you have an example code for this ??</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57235 - Tomik - Fri Oct 14, 2005 2:03 pm</h4>
    <div class="postbody"><span class="postbody">My question is: how can I copy (in Mode 4) the current screen to the inactive on ... an refresh the old on with only one new value ? that means not calculating every step every value, every line ...aso !!
<br/>
know what i mean ??
<br/>
<br/>
Thomas</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57236 - Cearn - Fri Oct 14, 2005 2:17 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Tomik wrote:</b></span></td> </tr> <tr> <td class="quote">20values/column ... 240columns ..=4800values
<br/>
</td> </tr></table><span class="postbody">
<br/>
Heh. Oops :P 
<br/>
Would still fit though. 
<br/>
<br/>
I thought the point of having so many samples was that you wouldn't have to draw lines between them anymore? You probably wouldn't be able to see 20 pixels / column, so you wouldn't need to keep track of them all; just min/max or average might work just as well.
<br/>
<br/>
And you don't need to shift each and every one of the array entries either, you could use it as a ring buffer: keep an index <span style="font-style: italic">ix</span> for the 'current' column and work with offsets. Still, drawing 4800 lines would be too much, yeah.
<br/>
<br/>
Using tilemodes would probably be best if you need scrolling, just browse around in the gbadev demo section and tutorial text and code. Don't rush into applying it to the ECG graph, just muck around with charblocks and screenblock and registers to get a feel of what you're doing. It's not hard, it just takes some getting used to.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Tomik wrote:</b></span></td> </tr> <tr> <td class="quote">do you have an example code for this ??</td> </tr></table><span class="postbody">
<br/>
tonc code does have a few examples for working with tilemap, nothing fancy though.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57244 - Tomik - Fri Oct 14, 2005 2:48 pm</h4>
    <div class="postbody"><span class="postbody">does the shifting of the whole screen also work in Mode 4 ?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#57603 - Cearn - Mon Oct 17, 2005 8:56 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Tomik wrote:</b></span></td> </tr> <tr> <td class="quote">does the shifting of the whole screen also work in Mode 4 ?</td> </tr></table><span class="postbody">Yes. And no! Mostly no.
<br/>
You <span style="font-style: italic">can</span> move the screen around (with REG_BG2X and REG_BG2Y, as bg2 is an affine background in the bitmap modes), but because it doesn't wrap around at the edges, the whole background disappears from view after you've scrolled 240 pixels. 
<br/>
In tile-bgs do wrap around: if you move it by, say, 60 pixels to the left, the pixels that have disappeared on the left side wrap around the screen and are shown on the right side, so you have a repeating background. Note that the wrap is around 256 pixels, not 240, this gives you a 16 pixel window in which you can change either the screen entries or the tiles themselves in order to get a continuously scrolling background. That's pretty much how all the scrolling games work; you can see this in action in emulators with map/tile viewers.
<br/>
<br/>
Below is an example of what I was talking about. 
<br/>
<span style="font-style: italic">m0_ecg_init()</span> sets up a map of increasingtile indices in column format. 
<br/>
<span style="font-style: italic">m0_ecg_scroll()</span> adds a new column on the right of the screen; ecg_hofs is a global counter, indicating which (moved) column we're working on. Because the screenblock was column based, each consecutive block of 32 tiles represents an 8x256 block of pixels on screen: a tile-column. We have to find the column which is on the right side of the screen, (ecg_hofs&amp;255)&gt;&gt;3, and then the pixel in that tile-column,ecg_hofs&amp;7. Simply OR the pixel of choice in there. Because we re-use columns, we need to make sure old ones are erased before re-use,  that's done in the hofs&amp;7 if-block. I'm using memset there because it's easy, but if you really need to, there are faster methods. 
<br/>
<span style="font-style: italic">m0_ecg()</span> is basically the main function here, with the main loop and a retrieval for the y values using a sine function because I don't have an actual ECG using to hook it up to.
<br/>
<br/>
You will probably need to rename a few things for it to compile, but I hope you can manage.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;string.h&gt;     // for memset
<br/>
<br/>
// --- some extra types ---
<br/>
typedef struct { u32 data[8];  } TILE, TILE4;
<br/>
typedef TILE     CHARBLOCK[512];
<br/>
typedef u16      SCREENBLOCK[1024];
<br/>
<br/>
// --- memory areas ---
<br/>
// tile_mem[y] = TILE[]   (char block y)
<br/>
// tile_mem[y][x] = TILE (char block y, tile x)
<br/>
#define tile_mem      ( (CHARBLOCK*)0x06000000)
<br/>
<br/>
// se_mem[y] = SB_ENTRY[] (screen block y)
<br/>
// se_mem[y][x] = screen entry (screen block y, screen entry x)
<br/>
#define se_mem        ((SCREENBLOCK*)0x06000000)
<br/>
<br/>
// === the real stuff ===
<br/>
<br/>
#define ECG_CBB      0
<br/>
#define ECG_SBB     31
<br/>
#define ECG_CLRID    1
<br/>
#define ECG_HOFS0  240
<br/>
#define ECG_POINTS   2
<br/>
#define ECG_Y0      80
<br/>
<br/>
int ecg_hofs=0;
<br/>
int ecg_ys[ECG_POINTS];
<br/>
<br/>
void m0_ecg_init()
<br/>
{
<br/>
    int ix, iy;
<br/>
    u16 *se= (u16*)&amp;se_mem[ECG_SBB];
<br/>
<br/>
    for(ix=0; ix&lt;ECG_POINTS; ix++)
<br/>
        ecg_ys[ix]= ECG_Y0;
<br/>
<br/>
    for(ix=0; ix&lt;32; ix++)
<br/>
        for(iy=0; iy&lt;1024; iy += 32)
<br/>
            *se++= iy+ix;
<br/>
<br/>
    pal_bg_mem[ECG_CLRID]= CLR_CYAN;
<br/>
    REG_BG0CNT= (ECG_SBB&lt;&lt;BG_SBB_SHIFT) | ECG_CBB;
<br/>
<br/>
    REG_DISPCNT= _DCNT_MODE0 | DCNT_BG0_ON;
<br/>
}
<br/>
<br/>
void m0_ecg_scroll()
<br/>
{
<br/>
    // current pixel ofs; with wrapping
<br/>
    u32 hofs= ecg_hofs&amp;255;
<br/>
<br/>
    ecg_hofs++;
<br/>
<br/>
    u32 tx= hofs&gt;&gt;3;    // tile-column id
<br/>
<br/>
    // get pointer to the tile-column
<br/>
    // 4bpp: 8pixels/word 
<br/>
    u32 *col= (u32*)&amp;tile_mem[ECG_CBB][32*tx];
<br/>
<br/>
    // new tile-column: 
<br/>
    //   erase the one that'll be used next
<br/>
    if((hofs&amp;7)==0)
<br/>
    {
<br/>
        u32 otx= (tx+1)&amp;31;
<br/>
        u32 *oldcol= (u32*)&amp;tile_mem[ECG_CBB][32*otx];
<br/>
        // clears 32*8*4 bytes (32 tiles)
<br/>
        // (use memset32 or CpuFastSet if you know how)
<br/>
        memset(oldcol, 0, 32*8*4);
<br/>
    }
<br/>
<br/>
    u32 sh= (hofs&amp;7)*4; // pixel shift in tile-column
<br/>
<br/>
    // draw line at right side of screen
<br/>
    int iy, y0, y1;
<br/>
<br/>
    y0= ecg_ys[0];
<br/>
    y1= ecg_ys[1];
<br/>
    col[y1] |= ECG_CLRID&lt;&lt;sh;
<br/>
<br/>
    // swap if necessary
<br/>
    if(y0 &gt; y1)
<br/>
    {   int t= y0; y0= y1; y1= t;   }
<br/>
<br/>
    for(iy=y0; iy&lt;y1; iy++)
<br/>
        col[iy] |= ECG_CLRID&lt;&lt;sh;
<br/>
<br/>
    REG_BG0HOFS= hofs-ECG_HOFS0;
<br/>
}
<br/>
<br/>
void m0_ecg()
<br/>
{
<br/>
    m0_ecg_init();
<br/>
<br/>
    int x=0;
<br/>
    while(1)
<br/>
    {
<br/>
        // Get new pixels from a sine LUT (change for your own needs)
<br/>
        ecg_ys[0]= ecg_ys[1];
<br/>
        ecg_ys[1]= ECG_Y0-(60*SIN(x&gt;&gt;4)&gt;&gt;8);
<br/>
        x += 0x022;
<br/>
<br/>
        vid_vsync();    // vsync (60Hz updates)
<br/>
        m0_ecg_scroll();
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
