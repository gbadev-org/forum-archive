<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>A question about accuracy - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > A question about accuracy</h2>
<div id="posts">
<div class="post">
    <h4>#33982 - ProblemBaby - Tue Jan 11, 2005 10:51 pm</h4>
    <div class="postbody"><span class="postbody">Hi
<br/>
<br/>
for example if I want to find out the slope of a line and represent it with a fixed integer how can I find what format I should use if I always want exact results.
<br/>
<br/>
for example:
<br/>
I know that the difference in x never will  be greater then 256
<br/>
and I also know that the difference in y never will be greater then 64
<br/>
<br/>
how much accuracy do ? need for to always get exct results for y when I do (x*slope)&gt;&gt;acc .
<br/>
<br/>
And how do I find an accuracy that works for all possible numbers if I know the intervals.
<br/>
<br/>
Hope ou understand what I mean!
<br/>
thanks in adv</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#33985 - DekuTree64 - Tue Jan 11, 2005 11:32 pm</h4>
    <div class="postbody"><span class="postbody">There is no perfect accuracy. You can always get things like 1/3, which repeats infinitely. What is it you're trying to do? You may be able to run operations on your lines just storing the slope as a fraction, with two seperate variables (ala Bresenham line drawing)
<br/>
<br/>
EDIT: On second thought, I think there would be a certain range of accuracy that would work, as long as you round off your answers rather than truncating. 
<br/>
For example, if your line is 150 wide and 50 tall, you'll get a slope of 1/3. Anytime you truncate (or round) to binary, you'll get something slightly smaller. Going with 16-bit fixed-point, you'd get (65536*50)/150 = 21845. Then multiply that by 150 again and divide by 65536 and you get 49.9992... You'll never get at/above 50, but you can round it.
<br/>
<br/>
Nothing's coming to mind on how to figure the range though. My gut says the fraction will need to be either the sum of the bits in both, or maybe 1 more bit than the larger of the two (because of the rounding), but I have no evidence at all to back either one of those up.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34089 - AnthC - Thu Jan 13, 2005 1:41 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ProblemBaby wrote:</b></span></td> </tr> <tr> <td class="quote">Hi
<br/>
<br/>
for example if I want to find out the slope of a line and represent it with a fixed integer how can I find what format I should use if I always want exact results.
<br/>
<br/>
for example:
<br/>
I know that the difference in x never will  be greater then 256
<br/>
and I also know that the difference in y never will be greater then 64
<br/>
<br/>
how much accuracy do ? need for to always get exct results for y when I do (x*slope)&gt;&gt;acc .
<br/>
<br/>
And how do I find an accuracy that works for all possible numbers if I know the intervals.
<br/>
<br/>
Hope ou understand what I mean!
<br/>
thanks in adv</td> </tr></table><span class="postbody">
<br/>
<br/>
If we represent a 2d line in real format we get
<br/>
<br/>
A1+B1*t
<br/>
<br/>
(where t is an integer number of iterations A1 is start B1 is slope)
<br/>
<br/>
In similar way, if we represent a line in space in fixed point format we also get
<br/>
<br/>
A+B*t
<br/>
<br/>
Where A is floor(A1*FPM) and B is floor(B1*FPM)
<br/>
<br/>
FPM (fixed point multiplier) in your case would be 256 or if you are using 16:16 numbers it would be 65536
<br/>
<br/>
We can form an error term (e) and work out how the error behaves as we iterate
<br/>
<br/>
error= actual - approx (scaling A, B by 1/FPM so they are compatible)
<br/>
<br/>
e=A1+B1*t - (A+B*t)
<br/>
e=A1-A/FPM+(B1-B/FPM)*t
<br/>
<br/>
You can see that this is just a function like your straight line, so the error should get larger as we iterate.
<br/>
<br/>
Now you want to know when your error is &gt;=1
<br/>
<br/>
1=A1-A/FPM+(B1-B/FPM)*t
<br/>
<br/>
1-A1+A/FPM = (B1-B/FPM)*t
<br/>
t=(1-A1+A/FPM)/(B1-B/FPM)
<br/>
<br/>
t*FPM = (FPM-A1*FPM+A)/(B1*FPM-B)
<br/>
t=((FPM-A1*FPM+A)/(B1*FPM-B))/FPM
<br/>
<br/>
Hope this is correct + helps :)
<br/>
Anth</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34105 - ProblemBaby - Thu Jan 13, 2005 6:09 pm</h4>
    <div class="postbody"><span class="postbody">Thanks both of you</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
