<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>HDMA - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > HDMA</h2>
<div id="posts">
<div class="post">
    <h4>#26312 - ProblemBaby - Sun Sep 12, 2004 8:28 pm</h4>
    <div class="postbody"><span class="postbody">Ive never done that before so I dont really know how to do it!
<br/>
My idea is to use HDMA for my water effect instead of a HBlank Interrupt first off I want to ask if it will be faster?
<br/>
here is the code for my interrupt:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void interrupt()
<br/>
{
<br/>
   if (REG_VCOUNT &lt; 160)
<br/>
   {
<br/>
      REG_BG2HOFS = 8 + (SIN[((REG_VCOUNT + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8);
<br/>
      REG_BG2VOFS = 8 + (COS[((REG_VCOUNT + (Counter&gt;&gt;3) - 80) &amp; 0xF) &lt;&lt; 4] &gt;&gt; 8);
<br/>
<br/>
      REG_BG1HOFS = 8 + (SIN[((REG_VCOUNT + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8);
<br/>
   }
<br/>
   else if (REG_VCOUNT == 160)
<br/>
      Counter++;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Is it possible to do this with HDMA? And how is it done hints would be great!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26314 - poslundc - Sun Sep 12, 2004 8:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ProblemBaby wrote:</b></span></td> </tr> <tr> <td class="quote">My idea is to use HDMA for my water effect instead of a HBlank Interrupt first off I want to ask if it will be faster?</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, it will, so long as it is the only raster effect you are doing. If you want to do more than one, you pretty much need an interrupt.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Is it possible to do this with HDMA? And how is it done hints would be great!</td> </tr></table><span class="postbody">
<br/>
<br/>
Precalculate your values for each scanline during VBlank and store them in an array. Load the value for the first scanline during VBlank; point the DMA to the second row and turn it on during VBlank with the correct settings, and watch the magic happen.
<br/>
<br/>
Note that the interrupt handler you wrote is about the worst way to do it in the first place. For HBlank stuff, you always want to precalculate and then just load the values in using HDMA or during your interrupt.
<br/>
<br/>
Also note: although HDMA will technically be faster, overall speed doesn't matter much on an HBlank interrupt. What matters is whether or not it's fast <span style="font-style: italic">enough</span> to get the job done before the HBlank period ends. For this reason, I wouldn't switch away from using an interrupt unless you are positive you won't want to do any other raster effects.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26315 - Lord Graga - Sun Sep 12, 2004 8:38 pm</h4>
    <div class="postbody"><span class="postbody">well, with some quick'n'dirty code, you should set up a table like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for(i=0;i&lt;160;i++){
<br/>
   bg2h[i] = 8 + (SIN[((i + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8);
<br/>
   bg2v[i] = 8 + (COS[((i + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8);
<br/>
   bg1h[i] = bg2h[i];
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Then you could just HDMA this into the memory at the locations it was meant for. Too bad that you need to use 3 DMA channels for it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26319 - poslundc - Sun Sep 12, 2004 8:48 pm</h4>
    <div class="postbody"><span class="postbody">Ouch, I didn't notice that you were changing three things in it.
<br/>
<br/>
Anyway, would it not be possible to make an array with each entry 16 bytes long (four bytes for each of BG1HOFS, BG1VOFS, BG2HOFS, BG2VOFS) and have the HDMA copy all 16 bytes each scanline?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26320 - ProblemBaby - Sun Sep 12, 2004 8:51 pm</h4>
    <div class="postbody"><span class="postbody">Ok so it maybe it is better to have an interrupt because I ve sound stuff too! 
<br/>
Just two questions:
<br/>
<br/>
1.
<br/>
With this line
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if (REG_VCOUNT &lt; 160)
<br/>
</td> </tr></table><span class="postbody">
<br/>
nothing happens if I use sound stuff.
<br/>
Ive no idea of why!
<br/>
<br/>
2.
<br/>
So the way I should do this is that I make 2 LUTs
<br/>
that I just update each HBLANK and dont increment Counter in the interrupt code. Right?
<br/>
Maybe I can do something like REG_VCOUNT &amp; 0x7/0xF because it just 8 or 16 different cases.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26321 - DekuTree64 - Sun Sep 12, 2004 9:08 pm</h4>
    <div class="postbody"><span class="postbody">You can pretty much recycle your existing code there to do it with HDMA, except instead of writing to the registers, write to a table with an entry for each line of the screen. 
<br/>
<br/>
Normally you can't write to several registers at once with HDMA, but since these are all bunched together, you can. BG1VOFS is right in the middle of them though, which means it will get overwritten by the DMA too. To combat this problem, just include it in the table and set all the values for it to the same thing.
<br/>
<br/>
The table will need to have entries for BG1HOFS, BG1VOFS, BG2HOFS and BG2VOFS in that order, followed by another set of values in that order for the next line, on to 160 lines. To make it a little more readable, I'll move BG1HOFS up to the top.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void MakeTable(u16 *regTable, bg1VofsVal) 
<br/>
{ 
<br/>
   s32 vCount;
<br/>
<br/>
   // Disable the DMA from last frame
<br/>
   REG_DM0CNT_H = 0;
<br/>
<br/>
   // Fill the table for next frame
<br/>
   for(vCount = 0; vCount &lt; 160; vCount++) 
<br/>
   { 
<br/>
      // 4 regs per line
<br/>
      regTable[vCount*4 + 0] = 8 + (SIN[((vCount + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8); 
<br/>
      regTable[vCount*4 + 1] = bg1VofsVal;   // Same every time
<br/>
<br/>
      regTable[vCount*4 + 2] = 8 + (SIN[((vCount + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8); 
<br/>
      regTable[vCount*4 + 3] = 8 + (COS[((vCount + (Counter&gt;&gt;3) - 80) &amp; 0xF) &lt;&lt; 4] &gt;&gt; 8); 
<br/>
   } 
<br/>
<br/>
   // We just did all 160 lines for this frame, so always increment Counter
<br/>
   Counter++; 
<br/>
<br/>
   Dma0(&amp;REG_BG1HOFS, regTable, 4, DMA_ENABLE|DMA_DEST_INC_RELOAD|DMA_MODE_HBL|DMA_REPEAT);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
That should look just like your HBlank effect. Make sure you call this function in VBlank though, otherwise you could overwrite values in the table that haven't been used yet.
<br/>
<br/>
Incase you haven't seen it before, DMA_DEST_INC_RELOAD is bits 5 and 6 set. It means to increment after each hword/word transferred, but to go back to the original dest after the whole DMA is finished. That means it will copy into BG1HOFS, BG1VOFS, BG2HOFS, and BG2VOFS, and then set back to &amp;BG1HOFS (if you just set dest fixed, it will just copy into BG1HOFS 4 times).
<br/>
<br/>
Also, for a completely correct effect, you'll want to manually set the regs to the first set of values in the table, and start the DMA from the second set. Because HBlank occurrs at the END of each line, the top line of the screen will show whatever was copied by the HBlank that occurred last frame on line 159. Your IRQ effect had this problem already though, so the DMA one will look exactly the same without the correction, just wanted to let you know incase it ever gets noticable enough to be worth fixing.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26325 - LOst? - Mon Sep 13, 2004 12:38 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">You can pretty much recycle your existing code there to do it with HDMA, except instead of writing to the registers, write to a table with an entry for each line of the screen. 
<br/>
<br/>
Normally you can't write to several registers at once with HDMA, but since these are all bunched together, you can. BG1VOFS is right in the middle of them though, which means it will get overwritten by the DMA too. To combat this problem, just include it in the table and set all the values for it to the same thing.
<br/>
<br/>
The table will need to have entries for BG1HOFS, BG1VOFS, BG2HOFS and BG2VOFS in that order, followed by another set of values in that order for the next line, on to 160 lines. To make it a little more readable, I'll move BG1HOFS up to the top.
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void MakeTable(u16 *regTable, bg1VofsVal) 
<br/>
{ 
<br/>
   s32 vCount;
<br/>
<br/>
   // Disable the DMA from last frame
<br/>
   REG_DM0CNT_H = 0;
<br/>
<br/>
   // Fill the table for next frame
<br/>
   for(vCount = 0; vCount &lt; 160; vCount++) 
<br/>
   { 
<br/>
      // 4 regs per line
<br/>
      regTable[vCount*4 + 0] = 8 + (SIN[((vCount + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8); 
<br/>
      regTable[vCount*4 + 1] = bg1VofsVal;   // Same every time
<br/>
<br/>
      regTable[vCount*4 + 2] = 8 + (SIN[((vCount + (Counter&gt;&gt;3) - 80) &amp; 0x7) &lt;&lt; 5] &gt;&gt; 8); 
<br/>
      regTable[vCount*4 + 3] = 8 + (COS[((vCount + (Counter&gt;&gt;3) - 80) &amp; 0xF) &lt;&lt; 4] &gt;&gt; 8); 
<br/>
   } 
<br/>
<br/>
   // We just did all 160 lines for this frame, so always increment Counter
<br/>
   Counter++; 
<br/>
<br/>
   Dma0(&amp;REG_BG1HOFS, regTable, 4, DMA_ENABLE|DMA_DEST_INC_RELOAD|DMA_MODE_HBL|DMA_REPEAT);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
That should look just like your HBlank effect. Make sure you call this function in VBlank though, otherwise you could overwrite values in the table that haven't been used yet.
<br/>
<br/>
Incase you haven't seen it before, DMA_DEST_INC_RELOAD is bits 5 and 6 set. It means to increment after each hword/word transferred, but to go back to the original dest after the whole DMA is finished. That means it will copy into BG1HOFS, BG1VOFS, BG2HOFS, and BG2VOFS, and then set back to &amp;BG1HOFS (if you just set dest fixed, it will just copy into BG1HOFS 4 times).
<br/>
<br/>
Also, for a completely correct effect, you'll want to manually set the regs to the first set of values in the table, and start the DMA from the second set. Because HBlank occurrs at the END of each line, the top line of the screen will show whatever was copied by the HBlank that occurred last frame on line 159. Your IRQ effect had this problem already though, so the DMA one will look exactly the same without the correction, just wanted to let you know incase it ever gets noticable enough to be worth fixing.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
This is what I wanted as a reply in my thread:
<br/>
<a href="http://forum.gbadev.org/viewtopic.php?t=4013" target="_blank">http://forum.gbadev.org/viewtopic.php?t=4013</a>
<br/>
<br/>
I wanted to do the same effect. Oh well...
<br/>
<br/>
<br/>
<br/>
EDIT: Thanks DekuTree64! Your code works perfectly in my game!
<br/>
<br/>
AND TO HELP OTHERS:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
      /* Background 0 */
<br/>
      for (i = 0; i &lt; 160; i++)
<br/>
      {
<br/>
         VTable [(i * 2) + 0] = (s16) bg0.x_scroll;
<br/>
         VTable [(i * 2) + 1] = (s16) bg0.y_scroll;
<br/>
      }
<br/>
<br/>
      /* Scanline 0 */
<br/>
      REG_BG0HOFS = VTable [0];
<br/>
      REG_BG0VOFS = VTable [1];
<br/>
      
<br/>
      /* Scanline 1 to 160 */
<br/>
      DMA0(&amp;REG_BG0HOFS, &amp;VTable [2], 0x2, DMA_TIMEING_HBLANK | DMA_ENABLE | DMA_REPEATE | DMA_DEST_RELOAD);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
VTable is a s16 type with 160 * 2 entries:
<br/>
<span style="font-weight: bold">s16 VTable [160*2];</span>
<br/>
<br/>
And I didn't forget to turn off the HDMA at the beginning of my VBlank routine:
<br/>
<span style="font-weight: bold">REG_DMA0CNT_H = 0;</span>
<br/>
<br/>
This is just to see if it works. There are no effects associated with this code! Only updating REG_BG0HOFS and REG_BG0VOFS each scanline!
<br/>
<br/>
EDIT2:
<br/>
TOO BAD
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
      REG_BG0HOFS = VTable [0];
<br/>
      REG_BG0VOFS = VTable [1];
<br/>
</td> </tr></table><span class="postbody">
<br/>
This didn't work. It's still showing the top scanline from the last frame :(
<br/>
<br/>
<br/>
EDIT3:
<br/>
Yay it works:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
      /* Scanline 0 */
<br/>
      DMA0(&amp;REG_BG0HOFS, &amp;VTable [0], 0x2, DMA_ENABLE);
<br/>
<br/>
      /* Scanline 1 to 160 */
<br/>
      DMA0(&amp;REG_BG0HOFS, &amp;VTable [2], 0x2, DMA_TIMEING_HBLANK | DMA_ENABLE | DMA_REPEATE | DMA_DEST_RELOAD);
<br/>
</td> </tr></table><span class="postbody">
<br/>
The first scanline needed to be DMA's with channel 0.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
