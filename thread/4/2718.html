<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Windows XP on GBA - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Windows XP on GBA</h2>
<div id="posts">
<div class="post">
    <h4>#15361 - LOst? - Wed Jan 21, 2004 12:51 pm</h4>
    <div class="postbody"><span class="postbody">I'm learning much from programming a window manager in C++. I've come very far with the GDI engine. Well, I'm calling it Windows XP mostly because I'm porting the OS over to the GBA.
<br/>
<br/>
Now to the problem. My first GDI was programmed to work with mode 3, but I couldn't stand the low memory that was left. When making Windows, I need to have Device Contexts in memory, and that took all the memory that was left.
<br/>
So my new GDI is using mode 4, and now I have enough with space to run at least 3 windows's without any problems.
<br/>
But mode 4 must write two pixels at the same time! That makes it damn hard. I can't use put pixel routines because they're too slow for Windows. I'm using DMA to copy DC's to the screen, and I can only copy them at a 2 pixel boundary. Do you have any solutions for copying images with DMA at any horizontal position in mode 4?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15369 - tepples - Wed Jan 21, 2004 3:32 pm</h4>
    <div class="postbody"><span class="postbody">Windows 3.1's VGA driver managed to draw graphics on a screen with four bitplanes. If you're really inside Microsoft, and you're really trying to port some limited version of Windows to the GBA, why don't you go check out the Windows 3.1 source code to see how it handled blitting to graphics devices with pixels smaller than the smallest addressable memory unit?
<br/>
<br/>
Seriously: 1. you shouldn't call it "Windows XP" because that's a trademark, and 2. you should borrow ideas from drivers for 4-bit packed-pixel displays. This might take a few shifts and or's.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15370 - LOst? - Wed Jan 21, 2004 3:39 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Windows 3.1's VGA driver managed to draw graphics on a screen with four bitplanes. If you're really inside Microsoft, and you're really trying to port some limited version of Windows to the GBA, why don't you go check out the Windows 3.1 source code to see how it handled blitting to graphics devices with pixels smaller than the smallest addressable memory unit?
<br/>
<br/>
Seriously: 1. you shouldn't call it "Windows XP" because that's a trademark, and 2. you should borrow ideas from drivers for 4-bit packed-pixel displays. This might take a few shifts and or's.</td> </tr></table><span class="postbody">
<br/>
<br/>
There is a difference between the slow VGA 640x480x16 and the slow mode 4 :P
<br/>
I'm not calling it Windows XP really, Microsoft are.
<br/>
<br/>
Is there anyone here who uses mode 4 at all? Even if you got a backbuffer, you still have to vrte two pixels at a time because of the memory. Why did they create mode 4 for?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15374 - tepples - Wed Jan 21, 2004 4:38 pm</h4>
    <div class="postbody"><span class="postbody">Writing two or four pixels at a time is not difficult 1. if you're displaying a static bitmap, or 2. if you're writing a flat-filler or a texture mapper that goes across as opposed to down. If you're blitting 2D images into mode 4, you can use shifts to get them to line up right.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15381 - LOst? - Wed Jan 21, 2004 7:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Writing two or four pixels at a time is not difficult 1. if you're displaying a static bitmap, or 2. if you're writing a flat-filler or a texture mapper that goes across as opposed to down. If you're blitting 2D images into mode 4, you can use shifts to get them to line up right.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yea, shift, but with DMA, that isn't possible, right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15383 - tepples - Wed Jan 21, 2004 8:14 pm</h4>
    <div class="postbody"><span class="postbody">Not everything can be done with DMA.  Here's what your blitter's inner loop might look like, in pseudo assembly:
<br/>
<br/>
LDMIA source data
<br/>
Shift
<br/>
Or
<br/>
Shift
<br/>
Or
<br/>
Shift
<br/>
Or
<br/>
Shift
<br/>
Or
<br/>
STMIA destination data<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15384 - tom - Wed Jan 21, 2004 8:16 pm</h4>
    <div class="postbody"><span class="postbody">what about drawing the misaligned borders of your dc's using the cpu, and copying the middle strips using dma ?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15430 - LOst? - Thu Jan 22, 2004 2:34 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tom wrote:</b></span></td> </tr> <tr> <td class="quote">what about drawing the misaligned borders of your dc's using the cpu, and copying the middle strips using dma ?</td> </tr></table><span class="postbody">
<br/>
<br/>
Too slow!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15431 - tom - Thu Jan 22, 2004 2:56 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Too slow!</td> </tr></table><span class="postbody">
<br/>
<br/>
why, you have to copy at most two pixels manually per scanline/dc, if your window starts/ends at odd x coordinates. the remaining pixels can be copied using dma. shouldn't be that slow. 
<br/>
anyway, there is no dma-only solution to your problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15432 - poslundc - Thu Jan 22, 2004 3:09 pm</h4>
    <div class="postbody"><span class="postbody">To use a strategy like this, however, it also means maintaining two versions of your images: one where it's shifted over by a single pixel.
<br/>
<br/>
This is one of the optimizations I did on one of my font engines.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
