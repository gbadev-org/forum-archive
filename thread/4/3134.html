<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>insane bouncing box - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > insane bouncing box</h2>
<div id="posts">
<div class="post">
    <h4>#18502 - Darmstadium - Sun Mar 28, 2004 2:05 am</h4>
    <div class="postbody"><span class="postbody">Before I share my troubles with you, I would just like to thank everbody who puts up with my endless questions. You're all really great. I could never thank you enough for your help.
<br/>
<br/>
Now, I'm working on this physics dealy for handling how sprites move around on the screen. So I have this struct called object. It hold the mass, height, width, x, y and another struct that stores the force of a sprite. The struct that stores the force has 4 variables to keep track of the movement in each direction. It also stores the "speed". The speed is how many vertical blanks are waited for until the sprite is moved. This is usually always 1 since anything else looks choppy. Ok, I think I have blabbed quite enough, here's the code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include "gba.h"
<br/>
#include "dispcnt.h"
<br/>
#include "keypad.h"
<br/>
#include "sprite.h"
<br/>
#include "dma.h"
<br/>
<br/>
#include "box.raw.c"
<br/>
#include "box.pal.c"
<br/>
<br/>
struct force
<br/>
{
<br/>
   u8 speed;
<br/>
   s16 up, down, right, left;
<br/>
};
<br/>
<br/>
struct object
<br/>
{
<br/>
   u8 x, y, h, w, m;
<br/>
   force v;
<br/>
};
<br/>
<br/>
inline void WaitForVsync()
<br/>
{
<br/>
   while((volatile u16)REG_VCOUNT != 160){}
<br/>
}
<br/>
<br/>
inline void CopyOAM()
<br/>
{
<br/>
   REG_DM3SAD = (u32)sprites;
<br/>
   REG_DM3DAD = (u32)OAM;
<br/>
   REG_DM3CNT = 256 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
}
<br/>
<br/>
void apply(force * v, object * obj)
<br/>
{
<br/>
   obj-&gt;v.speed += v-&gt;speed;
<br/>
   obj-&gt;v.up += v-&gt;up;
<br/>
   obj-&gt;v.down += v-&gt;down;
<br/>
   obj-&gt;v.left += v-&gt;left;
<br/>
   obj-&gt;v.right += v-&gt;right;
<br/>
}
<br/>
<br/>
void hitback(force * v, object * obj)
<br/>
{
<br/>
   obj-&gt;v.speed -= v-&gt;speed;
<br/>
   obj-&gt;v.up -= v-&gt;up;
<br/>
   obj-&gt;v.down -= v-&gt;down;
<br/>
   obj-&gt;v.left -= v-&gt;left;
<br/>
   obj-&gt;v.right -= v-&gt;right;
<br/>
}
<br/>
<br/>
#define OBJSLEN   1
<br/>
object * objs[OBJSLEN];
<br/>
<br/>
int main()
<br/>
{
<br/>
   u16 loop;
<br/>
   
<br/>
   for(loop = 0; loop &lt; 128; loop++)
<br/>
   {
<br/>
      sprites[loop].attribute0 = 160;
<br/>
      sprites[loop].attribute1 = 240;
<br/>
   }
<br/>
   
<br/>
   REG_DISPCNT = MODE_1 | OBJ_ENABLE | OBJ_MAP_1D;
<br/>
   
<br/>
   REG_DM3SAD = (u32)box_Palette;
<br/>
   REG_DM3DAD = (u32)OBJPaletteMem;
<br/>
   REG_DM3CNT = 64 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
   
<br/>
   REG_DM3SAD = (u32)box_Bitmap;
<br/>
   REG_DM3DAD = (u32)&amp;OAMData[0];
<br/>
   REG_DM3CNT = 64 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
   
<br/>
   object box;
<br/>
   
<br/>
   objs[0] = &amp;box;
<br/>
   box.x = 20;
<br/>
   box.y = 140;
<br/>
   box.h = 16;
<br/>
   box.w = 16;
<br/>
   box.m = 3;
<br/>
   box.v.speed = 5;
<br/>
   box.v.up = 0;
<br/>
   box.v.down = 0;
<br/>
   box.v.left = 0;
<br/>
   box.v.right = 0;
<br/>
   
<br/>
   sprites[0].attribute0 = COLOR_256 | SQUARE | box.y;
<br/>
   sprites[0].attribute1 = SIZE_16 | box.x;
<br/>
   sprites[0].attribute2 = 0;
<br/>
   
<br/>
   u32 vsyncs;
<br/>
   
<br/>
   force gravity;
<br/>
   gravity.speed = 0;
<br/>
   gravity.up = 0;
<br/>
   gravity.down = 8;
<br/>
   gravity.left = 0;
<br/>
   gravity.right = 0;
<br/>
   
<br/>
   force jump;
<br/>
   jump.speed = 0;
<br/>
   jump.up = 5;
<br/>
   jump.down = 0;
<br/>
   jump.left = 0;
<br/>
   jump.right = 0;
<br/>
   
<br/>
   u16 holdcount = 0;
<br/>
   
<br/>
   while (1)
<br/>
   {
<br/>
      sprites[0].attribute0 = COLOR_256 | SQUARE | box.y;
<br/>
      sprites[0].attribute1 = SIZE_16 | box.x;
<br/>
      
<br/>
      if ((volatile u16)REG_VCOUNT == 160)
<br/>
         vsyncs++;
<br/>
      
<br/>
      if ((!(*KEYS &amp; KEY_A)) &amp;&amp; (box.y + box.h == 159))
<br/>
         apply(&amp;jump, &amp;box);
<br/>
      
<br/>
      if (!(*KEYS &amp; KEY_LEFT))
<br/>
         box.v.left += 1;
<br/>
      
<br/>
      if (!(*KEYS &amp; KEY_RIGHT))
<br/>
         box.v.right += 1;
<br/>
      
<br/>
      for (loop = 0; loop &lt; OBJSLEN; loop++)
<br/>
      {
<br/>
         if (vsyncs % objs[loop]-&gt;v.speed == 0)
<br/>
         {
<br/>
            apply(&amp;gravity, objs[loop]);
<br/>
            if (objs[loop]-&gt;y == 159 - objs[loop]-&gt;h)
<br/>
               hitback(&amp;gravity, objs[loop]);
<br/>
            
<br/>
            objs[loop]-&gt;x -= objs[loop]-&gt;v.left;
<br/>
            objs[loop]-&gt;x += objs[loop]-&gt;v.right;
<br/>
            objs[loop]-&gt;y -= objs[loop]-&gt;v.up;
<br/>
            objs[loop]-&gt;y += objs[loop]-&gt;v.down;
<br/>
            
<br/>
            if (objs[loop]-&gt;y &gt; 159 - objs[loop]-&gt;h)
<br/>
               objs[loop]-&gt;y = 159 - objs[loop]-&gt;h;
<br/>
            if (objs[loop]-&gt;y &lt; 1)
<br/>
               objs[loop]-&gt;y = 1;
<br/>
            if (objs[loop]-&gt;x &gt; 239 - objs[loop]-&gt;w)
<br/>
               objs[loop]-&gt;x = 239 - objs[loop]-&gt;w;
<br/>
            if (objs[loop]-&gt;x &lt; 1)
<br/>
               objs[loop]-&gt;x = 1;
<br/>
            
<br/>
            if (objs[loop]-&gt;y &gt; 140)
<br/>
            {
<br/>
               objs[loop]-&gt;v.left = 0;
<br/>
               objs[loop]-&gt;v.right = 0;
<br/>
            }
<br/>
         }
<br/>
      }
<br/>
      
<br/>
      WaitForVsync();
<br/>
      CopyOAM();
<br/>
      
<br/>
      if (vsyncs &gt; 200)
<br/>
         vsyncs = 0;
<br/>
   }
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Now when I press A, my sprite jumps and is pulled back down with no problem. The problem is that it seems to jump different amounts depending on how long you hold A. The game only cares if you press A when the sprite is on the ground, and the force struct jump never changes, so I see no reason for the inconsistency. I would really, really appreciate your help for this problem and comments on my system. Thanks in advance.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18503 - dagamer34 - Sun Mar 28, 2004 2:16 am</h4>
    <div class="postbody"><span class="postbody">I never get tired of your endless questions, in fact, you've just helped me with how to design my game mechanics by posting your code.
<br/>
<br/>
Now, for me to help you. The problem isn't the physics code but the way you check for input. You are basically asking to see if a key is pressed once and act on that input. So, just check and see if a key was pressed this frame, but wasn't pressed last frame.
<br/>
<br/>
There is also a topic somewhere around here that explains what I am talking about. I will search around for it and give you a link.
<br/>
<br/>
And there has to be a way to take out that modulus operator. There are so many problems with that one line right there that could mess you up completely. Using the modulus operate requires a divide, AND you are using GCC for the division which is even slower. It takes ~50 cycles using the BIOS function but assuming you do this for all 128 sprites, you have wasted a lot of VBlank time that should be focused on something else. Change it.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18504 - dagamer34 - Sun Mar 28, 2004 2:21 am</h4>
    <div class="postbody"><span class="postbody">Here's the link I promised:
<br/>
<a href="http://forum.gbadev.org/viewtopic.php?t=3002&amp;highlight=keys" target="_blank">http://forum.gbadev.org/viewtopic.php?t=3002&amp;highlight=keys</a><br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18505 - Miked0801 - Sun Mar 28, 2004 2:54 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
It takes ~50 cycles using the BIOS function...
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Add an extra 100 cycles or so on top of that.  Check the other thread for specifics on the BIOS Div().  
<br/>
<br/>
Why a limit of 200 on the VSyncs?  Make vsyncs a U8 and it will wrap automatically at 256 for you - on top of that since 256 is a base 2 number, you'll be able to get rid of that icky % operator.
<br/>
<br/>
Also, you may want to look up some of the thread on fixed point math to allow your system to handle sub-pixel movement/velocity/force.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18512 - Darmstadium - Sun Mar 28, 2004 5:17 am</h4>
    <div class="postbody"><span class="postbody">dagamer - could I ask you to modify my code and show me what you mean? I do not understand how to do this.
<br/>
<br/>
I'm going to try to find another way to see if it's time to move sprites. I;m not sure how I'm going to do it yet though.
<br/>
<br/>
Thanks a lot for your help guys</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18517 - sajiimori - Sun Mar 28, 2004 8:17 am</h4>
    <div class="postbody"><span class="postbody">Did you want to apply the jumping force continuously while the A button is being pressed?  It sounds like you only want it to be applied once, when A is first pressed.  If A was not being pressed on the previous frame, and it's being pressed now, then apply the force.
<br/>
<br/>
What do you need in order to tell if it was being pressed on the previous frame?  You need to save the contents of the keypad register every frame in order to refer back to on the next frame.
<br/>
<br/>
For forces, try using just 2 directions: x and y.  I mean, a force can't be both upward and downward, so why have seperate variables?  Use a negative y for upward and a positive y for downward, unless you have some other rationale for doing it the way it is now.
<br/>
<br/>
BTW, I like your coding style.  Seems like you'll be a great programmer if you stick to it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18543 - tepples - Sun Mar 28, 2004 7:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Did you want to apply the jumping force continuously while the A button is being pressed?</td> </tr></table><span class="postbody">
<br/>
Two considerations:<ul><li>Some game characters have a jetpack.</li><li>Many games cut off the peak of a character's jump parabola when the player releases A.</li></ul>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">What do you need in order to tell if it was being pressed on the previous frame?  You need to save the contents of the keypad register every frame in order to refer back to on the next frame.</td> </tr></table><span class="postbody">
<br/>
This is a rather common question, and it isn't search-friendly (keys vs. joypad vs. buttons vs. controller). I'll have to think of how to word it for the FAQ.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18559 - sajiimori - Sun Mar 28, 2004 10:47 pm</h4>
    <div class="postbody"><span class="postbody">tepp, I wasn't claiming that his code was wrong, but his posts seemed to suggest that he didn't want the force applied continuously.
<br/>
<br/>
As a FAQ question, I think a common way people ask is:
<br/>
<br/>
"How do I detect single button taps instead of continuous presses?"
<br/>
<br/>
It's an awkward way to phrase the question, but if they knew how to phrase it better they'd probably answer their own question:
<br/>
<br/>
"How do I know if a button is pressed on the current frame, but wasn't pressed on the previous frame?"
<br/>
<br/>
So, the awkward question is better in that sense.  It more accurately reflects the thoughts of the asker.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18570 - Darmstadium - Mon Mar 29, 2004 1:20 am</h4>
    <div class="postbody"><span class="postbody">I'm still trying to figure out how I can get rid of that modulus operator, but I did what sajiimori suggested. I'm still having trouble checking if a button wasn't pressed last frame. I ask you to tell me what I am doing wrong with that. Here's the code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include "gba.h"
<br/>
#include "dispcnt.h"
<br/>
#include "keypad.h"
<br/>
#include "sprite.h"
<br/>
#include "dma.h"
<br/>
<br/>
#include "box.raw.c"
<br/>
#include "box.pal.c"
<br/>
<br/>
<br/>
struct force
<br/>
{
<br/>
   u8 speed;
<br/>
   s16 x, y;
<br/>
};
<br/>
<br/>
struct object
<br/>
{
<br/>
   u8 x, y, h, w, m;
<br/>
   force v;
<br/>
};
<br/>
<br/>
inline void WaitForVsync()
<br/>
{
<br/>
   while((volatile u16)REG_VCOUNT != 160){}
<br/>
}
<br/>
<br/>
inline void CopyOAM()
<br/>
{
<br/>
   REG_DM3SAD = (u32)sprites;
<br/>
   REG_DM3DAD = (u32)OAM;
<br/>
   REG_DM3CNT = 256 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
}
<br/>
<br/>
void apply(force * v, object * obj)
<br/>
{
<br/>
   obj-&gt;v.x += v-&gt;x;
<br/>
   obj-&gt;v.y += v-&gt;y;
<br/>
}
<br/>
<br/>
void hitback(force * v, object * obj)
<br/>
{
<br/>
   obj-&gt;v.x -= v-&gt;x;
<br/>
   obj-&gt;v.y -= v-&gt;y;
<br/>
}
<br/>
<br/>
#define OBJSLEN   1
<br/>
object * objs[OBJSLEN];
<br/>
<br/>
int main()
<br/>
{
<br/>
   u16 loop;
<br/>
   
<br/>
   for(loop = 0; loop &lt; 128; loop++)
<br/>
   {
<br/>
      sprites[loop].attribute0 = 160;
<br/>
      sprites[loop].attribute1 = 240;
<br/>
   }
<br/>
   
<br/>
   REG_DISPCNT = MODE_1 | OBJ_ENABLE | OBJ_MAP_1D;
<br/>
   
<br/>
   REG_DM3SAD = (u32)box_Palette;
<br/>
   REG_DM3DAD = (u32)OBJPaletteMem;
<br/>
   REG_DM3CNT = 64 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
   
<br/>
   REG_DM3SAD = (u32)box_Bitmap;
<br/>
   REG_DM3DAD = (u32)&amp;OAMData[0];
<br/>
   REG_DM3CNT = 64 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
   
<br/>
   object box;
<br/>
   
<br/>
   objs[0] = &amp;box;
<br/>
   box.x = 20;
<br/>
   box.y = 140;
<br/>
   box.h = 16;
<br/>
   box.w = 16;
<br/>
   box.m = 3;
<br/>
   box.v.speed = 4;
<br/>
   box.v.x = 0;
<br/>
   box.v.y = 0;
<br/>
   
<br/>
   sprites[0].attribute0 = COLOR_256 | SQUARE | box.y;
<br/>
   sprites[0].attribute1 = SIZE_16 | box.x;
<br/>
   sprites[0].attribute2 = 0;
<br/>
   
<br/>
   u8 vsyncs = 0;
<br/>
   
<br/>
   force gravity;
<br/>
   gravity.speed = 0;
<br/>
   gravity.x = 0;
<br/>
   gravity.y = 8;
<br/>
   
<br/>
   force jump;
<br/>
   jump.speed = 0;
<br/>
   jump.x = 0;
<br/>
   jump.y = -30;
<br/>
   
<br/>
   u8 a_vcount = 0;
<br/>
   
<br/>
   u16 keys_lastframe = 0x3FF;
<br/>
   
<br/>
   while (1)
<br/>
   {
<br/>
      sprites[0].attribute0 = COLOR_256 | SQUARE | box.y;
<br/>
      sprites[0].attribute1 = SIZE_16 | box.x;
<br/>
      
<br/>
      keys_lastframe = *KEYS;
<br/>
      
<br/>
      WaitForVsync();
<br/>
      CopyOAM();
<br/>
      vsyncs++;
<br/>
      
<br/>
      if ((!(*KEYS &amp; KEY_A)) &amp;&amp; (keys_lastframe &amp; KEY_A) &amp;&amp; (box.y + box.h == 159))
<br/>
         apply(&amp;jump, &amp;box);
<br/>
      
<br/>
      if (!(*KEYS &amp; KEY_LEFT))
<br/>
         box.v.x -= 1;
<br/>
      
<br/>
      if (!(*KEYS &amp; KEY_RIGHT))
<br/>
         box.v.x += 1;
<br/>
      
<br/>
      for (loop = 0; loop &lt; OBJSLEN; loop++)
<br/>
      {
<br/>
         if (vsyncs % objs[loop]-&gt;v.speed == 0)
<br/>
         {
<br/>
            apply(&amp;gravity, objs[loop]);
<br/>
            
<br/>
            if (objs[loop]-&gt;y + objs[loop]-&gt;h == 159)
<br/>
               hitback(&amp;gravity, objs[loop]);
<br/>
            
<br/>
            objs[loop]-&gt;x += objs[loop]-&gt;v.x;
<br/>
            objs[loop]-&gt;y += objs[loop]-&gt;v.y;
<br/>
            
<br/>
            //crude collision detection
<br/>
            if (objs[loop]-&gt;y &gt; 159 - objs[loop]-&gt;h)
<br/>
               objs[loop]-&gt;y = 159 - objs[loop]-&gt;h;
<br/>
            if (objs[loop]-&gt;y &lt; 1)
<br/>
               objs[loop]-&gt;y = 1;
<br/>
            if (objs[loop]-&gt;x &gt; 239 - objs[loop]-&gt;w)
<br/>
               objs[loop]-&gt;x = 239 - objs[loop]-&gt;w;
<br/>
            if (objs[loop]-&gt;x &lt; 1)
<br/>
               objs[loop]-&gt;x = 1;
<br/>
            
<br/>
            //ground friction
<br/>
            if (objs[loop]-&gt;y + objs[loop]-&gt;h == 159)
<br/>
               objs[loop]-&gt;v.x = 0;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks a lot for your help</span><span class="gensmall"><br/><br/>Last edited by Darmstadium on Mon Mar 29, 2004 10:55 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#18581 - sajiimori - Mon Mar 29, 2004 4:57 am</h4>
    <div class="postbody"><span class="postbody">I'm not sure I understand the logic of your keystate variables.  The current frame's keystate is in the GBA's keystate register, so you don't need a special variable for that (unless you're worried about sub-frame keypress accuracy).
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define REG_KEYS (*(volatile u16*)0x4000130)
<br/>
<br/>
while(1)
<br/>
{
<br/>
  if (A is pressed in REG_KEYS and A is not pressed in old_keys)
<br/>
    jump();
<br/>
<br/>
  old_keys = REG_KEYS;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Note that old_keys has to be declared before the while loop, or else it's effectively destroyed on each iteration.  The whole point is that the information is retained between iterations -- you want a memory of the previous frame.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18582 - tepples - Mon Mar 29, 2004 4:57 am</h4>
    <div class="postbody"><span class="postbody">Darmstadium: Your code looks way too contorted for me to explain, let alone maintain. I'd do it a different way. If you don't understand my way, look up a bit of set theory.
<br/>
<br/>
First set keys_thisframe to the set of pressed buttons. (In your framework, this set is called <span style="font-weight: bold">~*KEYS</span>.) Then the key to computing the set of newly pressed buttons is the <a class="postlink" href="http://mathworld.wolfram.com/SetDifference.html" target="_blank">set-difference operator</a>, made of an intersection with a complement, called <span style="font-weight: bold">&amp; ~</span> in C. For example, <span style="font-weight: bold">A &amp; ~B</span> computes the set of bits that are 1 in A and 0 in B.
<br/>
<br/>
In context, such computation would look like the following:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/* SNIP */
<br/>
<br/>
int main()
<br/>
{
<br/>
/* SNIP */
<br/>
   
<br/>
  u16 keys_lastframe = 0x3FF;
<br/>
<br/>
  while (1)
<br/>
  {
<br/>
/* SNIP */
<br/>
    u16 keys_thisframe = ~*KEYS;
<br/>
    u16 keys_taps = keys_thisframe &amp; ~keys_lastframe;
<br/>
    keys_lastframe = keys_thisframe;
<br/>
/* SNIP: act on keys_thisframe and keys_taps */
<br/>
  }
<br/>
  return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18613 - Darmstadium - Mon Mar 29, 2004 10:51 pm</h4>
    <div class="postbody"><span class="postbody">Thanks a lot for your help and patience, but I still need a little but more help.
<br/>
<br/>
Instead of posting all my code again, I have edited the code of my previous post.
<br/>
<br/>
I fixed the game so you can't hold the A button and make the box jump quite as insanely as it did before, but after you make it jump, you have to press A twice to make it jump again. It also jumps at two different heights. It seems to alternate between these two different heights every time you make it jump. I'm beginning to suspect that the varying jump heights before were not entirely the work of my poor controls. Perhaps the gravity influece is not going quite right, or maybe it is the influence from when the ground returns gravity's force. hmm...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18631 - sajiimori - Tue Mar 30, 2004 7:00 am</h4>
    <div class="postbody"><span class="postbody">Your input code looks fine now, but your code is getting too messy for me to help anymore.  Seperate the tasks into functions, and abstract over the repetitive calculations like finding the bottom of an object.  It should be obvious what a function does at a glance.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int obj_bottom(object* o)
<br/>
{
<br/>
  return o-&gt;y + o-&gt;h;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Also, isn't the hitback function redundant if you're simultaneously doing simple collision detection?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18647 - dagamer34 - Tue Mar 30, 2004 11:07 pm</h4>
    <div class="postbody"><span class="postbody">You could make that loop a lot faster if you first check to see that you are going to be within your boundaries before calling apply (), that way, you don't have to call hitback whenever it hits your lower boundary since you do that calculation anyway.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    
<br/>
// Untested, but should be faster
<br/>
if (objs[loop]-&gt;y + objs[loop]-&gt;h + gravity.y == 159) 
<br/>
      apply(&amp;gravity, objs[loop]); 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
EDIT: Shouldn't you be checking to see if it is actually lower than 159 on the screen? I think it would be better to use &gt;= instead of ==.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18657 - Darmstadium - Wed Mar 31, 2004 2:00 am</h4>
    <div class="postbody"><span class="postbody">Well, I've tried to make my code a bit cleaner. I also tried to add in my collision detection system. It doesn't seem to work since the box goes right through the ground. I really hate to ask for so much help, but I have no idea why this isn't working! Here is my newest code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include "gba.h"
<br/>
#include "dispcnt.h"
<br/>
#include "keypad.h"
<br/>
#include "sprite.h"
<br/>
#include "dma.h"
<br/>
<br/>
#include "box.raw.c"
<br/>
#include "box.pal.c"
<br/>
<br/>
<br/>
struct force
<br/>
{
<br/>
   s16 x, y;
<br/>
};
<br/>
<br/>
struct object
<br/>
{
<br/>
   u8 n, x, y, h, w, m, speed;
<br/>
   force v;
<br/>
   void move();
<br/>
};
<br/>
<br/>
<br/>
inline void WaitForVsync();
<br/>
inline void CopyOAM();
<br/>
bool MoveOK(object *,s16,s16);
<br/>
inline void apply_force(force *,object *);
<br/>
inline void return_force(force *,object *);
<br/>
void TakeBoxInput();
<br/>
void ApplyAllForce();
<br/>
<br/>
<br/>
u8 vsyncs = 0;
<br/>
u16 keys_lastframe;
<br/>
#define OBJSLEN   5
<br/>
object objs[OBJSLEN];
<br/>
force gravity;
<br/>
force jump;
<br/>
<br/>
<br/>
void object::move()
<br/>
{
<br/>
   if (MoveOK(this, v.x, v.y))
<br/>
   {
<br/>
      x += v.x;
<br/>
      y += v.y;
<br/>
   }
<br/>
}
<br/>
<br/>
inline void WaitForVsync()
<br/>
{
<br/>
   while((volatile u16)REG_VCOUNT != 160){}
<br/>
}
<br/>
<br/>
inline void CopyOAM()
<br/>
{
<br/>
   REG_DM3SAD = (u32)sprites;
<br/>
   REG_DM3DAD = (u32)OAM;
<br/>
   REG_DM3CNT = 256 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
}
<br/>
<br/>
bool MoveOK(object * client, s16 xmove, s16 ymove)
<br/>
{
<br/>
   u16 loop;
<br/>
   for (loop = 0; loop &lt; OBJSLEN; loop++)
<br/>
   {
<br/>
      if (objs[loop].n != client-&gt;n)
<br/>
      {
<br/>
         if (client-&gt;x + xmove + client-&gt;w &lt;= objs[loop].x)
<br/>
            continue;
<br/>
         if (client-&gt;x + xmove &gt;= objs[loop].x + objs[loop].w)
<br/>
            continue;
<br/>
         if (client-&gt;y + ymove + client-&gt;h &lt;= objs[loop].y)
<br/>
            continue;
<br/>
         if (client-&gt;y + ymove &gt;= objs[loop].y + objs[loop].h)
<br/>
            continue;
<br/>
         
<br/>
         return false;
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   return true;
<br/>
}
<br/>
<br/>
inline void apply_force(force * v, object * obj)
<br/>
{
<br/>
   obj-&gt;v.x += v-&gt;x;
<br/>
   obj-&gt;v.y += v-&gt;y;
<br/>
}
<br/>
<br/>
inline void return_force(force * v, object * obj)
<br/>
{
<br/>
   obj-&gt;v.x -= v-&gt;x;
<br/>
   obj-&gt;v.y -= v-&gt;y;
<br/>
}
<br/>
<br/>
void TakeBoxInput()
<br/>
{
<br/>
   if ((!(*KEYS &amp; KEY_A)) &amp;&amp; (keys_lastframe &amp; KEY_A) &amp;&amp; (objs[0].y + objs[0].h == 159))
<br/>
      apply_force(&amp;jump, &amp;objs[0]);
<br/>
   if (!(*KEYS &amp; KEY_LEFT))
<br/>
      objs[0].v.x -= 1;
<br/>
   if (!(*KEYS &amp; KEY_RIGHT))
<br/>
      objs[0].v.x += 1;
<br/>
}
<br/>
<br/>
void ApplyAllForce()
<br/>
{   
<br/>
   u16 loop;
<br/>
   for (loop = 0; loop &lt; OBJSLEN; loop++)
<br/>
   {
<br/>
      if (vsyncs % objs[loop].speed == 0)
<br/>
      {
<br/>
         apply_force(&amp;gravity, &amp;objs[loop]);
<br/>
         
<br/>
         if (objs[loop].y + objs[loop].h == 159)
<br/>
            return_force(&amp;gravity, &amp;objs[loop]);
<br/>
         
<br/>
         objs[loop].move();
<br/>
      }
<br/>
   }
<br/>
}
<br/>
<br/>
int main()
<br/>
{
<br/>
   gravity.x = 0;
<br/>
   gravity.y = 8;
<br/>
   jump.x = 0;
<br/>
   jump.y = -30;
<br/>
   
<br/>
   u16 loop;
<br/>
   
<br/>
   for(loop = 0; loop &lt; 128; loop++)
<br/>
   {
<br/>
      sprites[loop].attribute0 = 160;
<br/>
      sprites[loop].attribute1 = 240;
<br/>
   }
<br/>
   
<br/>
   REG_DISPCNT = MODE_1 | OBJ_ENABLE | OBJ_MAP_1D;
<br/>
   
<br/>
   REG_DM3SAD = (u32)box_Palette;
<br/>
   REG_DM3DAD = (u32)OBJPaletteMem;
<br/>
   REG_DM3CNT = 64 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
   
<br/>
   REG_DM3SAD = (u32)box_Bitmap;
<br/>
   REG_DM3DAD = (u32)&amp;OAMData[0];
<br/>
   REG_DM3CNT = 64 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE | DMA_32;
<br/>
   
<br/>
   //box
<br/>
   objs[0].x = 20;
<br/>
   objs[0].y = 140;
<br/>
   objs[0].h = 16;
<br/>
   objs[0].w = 16;
<br/>
   objs[0].m = 3;
<br/>
   objs[0].speed = 4;
<br/>
   objs[0].v.x = 0;
<br/>
   objs[0].v.y = 0;
<br/>
   sprites[0].attribute0 = COLOR_256 | SQUARE | objs[0].y;
<br/>
   sprites[0].attribute1 = SIZE_16 | objs[0].x;
<br/>
   sprites[0].attribute2 = 0;
<br/>
   
<br/>
   //ground
<br/>
   objs[1].n = 5;
<br/>
   objs[1].x = 0;
<br/>
   objs[1].y = 160;
<br/>
   objs[1].h = 0;
<br/>
   objs[1].w = 240;
<br/>
   
<br/>
   //ceiling
<br/>
   objs[2].n = 6;
<br/>
   objs[2].x = 0;
<br/>
   objs[2].y = 0;
<br/>
   objs[2].h = 0;
<br/>
   objs[2].w = 240;
<br/>
   
<br/>
   //left barrier
<br/>
   objs[3].n = 7;
<br/>
   objs[3].x = 0;
<br/>
   objs[3].y = 0;
<br/>
   objs[3].h = 160;
<br/>
   objs[3].w = 0;
<br/>
   
<br/>
   //right barrier
<br/>
   objs[4].n = 8;
<br/>
   objs[4].x = 240;
<br/>
   objs[4].y = 0;
<br/>
   objs[4].h = 160;
<br/>
   objs[4].w = 0;
<br/>
   
<br/>
   while (1)
<br/>
   {
<br/>
      sprites[0].attribute0 = COLOR_256 | SQUARE | objs[0].y;
<br/>
      sprites[0].attribute1 = SIZE_16 | objs[0].x;
<br/>
      
<br/>
      keys_lastframe = *KEYS;
<br/>
      WaitForVsync();
<br/>
      CopyOAM();
<br/>
      vsyncs++;
<br/>
      TakeBoxInput();
<br/>
      ApplyAllForce();
<br/>
   }
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Thank you for your help!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18663 - sajiimori - Wed Mar 31, 2004 5:24 am</h4>
    <div class="postbody"><span class="postbody">Pretty weird code.  The edges of the screen are being pulled by gravity, and the velocity of objects isn't affected when they collide -- they simply refuse to move, so the velocity added by gravity just keeps piling up.  It could make for a good Salvador Dali painting.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18686 - dagamer34 - Wed Mar 31, 2004 11:43 pm</h4>
    <div class="postbody"><span class="postbody">You code is beginning to be very hard to read. This is why I decided to create a library first and then start dealing with other stuff like collision detection because with all this code around, you are bound to make mistakes.
<br/>
<br/>
It would be best to make a library of functions that you would commonly use. For instance:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if (!(*KEYS &amp; KEY_LEFT)) 
<br/>
</td> </tr></table><span class="postbody">
<br/>
isn't the cleanest way to check for input. Put stuff like this in a function and you will make your life a lot easier. DMA should also be put into a macro, and more things like that.
<br/>
<br/>
And if you don't feel like writing your own library, I have one ready for use, I need someone to test it out.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18697 - LOst? - Thu Apr 01, 2004 5:38 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>dagamer34 wrote:</b></span></td> </tr> <tr> <td class="quote">You code is beginning to be very hard to read. This is why I decided to create a library first and then start dealing with other stuff like collision detection because with all this code around, you are bound to make mistakes.
<br/>
<br/>
It would be best to make a library of functions that you would commonly use. For instance:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if (!(*KEYS &amp; KEY_LEFT)) 
<br/>
</td> </tr></table><span class="postbody">
<br/>
isn't the cleanest way to check for input. Put stuff like this in a function and you will make your life a lot easier. DMA should also be put into a macro, and more things like that.
<br/>
<br/>
And if you don't feel like writing your own library, I have one ready for use, I need someone to test it out.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Is your library good? Does it have better name than the standard GBA_H file you can get all over the place? Does it have a better way to manage sprites and background on each frame?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18728 - dagamer34 - Fri Apr 02, 2004 2:15 am</h4>
    <div class="postbody"><span class="postbody">I wouldn't really say better, but just easier. Now that I think about it, it's just better to write your own because you learn more that way instead of depending on others.
<br/>
<br/>
But, if you want to take a look at mine and see how mine is set up to get a few ideas, just e-mail me and I'll send it to you.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
