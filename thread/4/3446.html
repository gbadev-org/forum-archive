<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Building my own compiler..... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Building my own compiler.....</h2>
<div id="posts">
<div class="post">
    <h4>#21076 - MumblyJoe - Sun May 23, 2004 10:03 am</h4>
    <div class="postbody"><span class="postbody">I have been studying compiler design recently with the hope that it could give me an insight on how to write more efficient code, and I am suprised at how simple compiler design can be for a limited language.
<br/>
<br/>
So what I am thinking of doing is writing a compiler for a language with C style syntax, but pretty cut down to start off with. I have a general plan of how it will all be put together in my head to make it as simple as possible.
<br/>
<br/>
Basically the language would be custom built for the GBA, I would ditch alot of things that are either unneccessary (or truthfully just too hard for me to implement) and it would only output thumb .S files to begin with (I am striving to make to output compatible with gcc because I really can't be bothered writing my own assembler and linker).
<br/>
<br/>
In general my scribblings of ideas include (mostly with the basis of making it incredibly simple):
<br/>
*Only 6 types of variables: s8,s16,s32,u8,u16,u32. No floats EVER.
<br/>
*No typedefs (makes my job marginally easier).
<br/>
*No volatile keyword - I wont be optimising enough for it to be needed.
<br/>
*Built in optimising for constants (too many compilers dont seem to care, example a constant pointer or reference still bieng dereferenced in the output code even though its always the same after its declaration and is initialised at the declaration).
<br/>
*Optimise things like vram[7] to an actual constant address in the output (but not with a variable as the index like vram[i]).
<br/>
*Proper bios calls for divide etc.
<br/>
*Perhaps built in structures for sprites etc.
<br/>
*No dynamic memory.
<br/>
*Simple dma/memcpy use built into language and easily selectable.(example: palette = dmacpy(0) mypalette; palette = memcpy palette;) Sounds odd but think of the new and delete operators in c++, that sort of thing. Just something to save on work for the user.
<br/>
<br/>
Anyway, I am just throwing around ideas and playing with flex and bison so far, I still have a bit to go and a bit of research on the target CPU etc. Throw me some other optimisations you wish gcc had etc...
<br/>
<br/>
Oh, and don't tell me it's a stuipid idea because I am mostly only doing it as a project to learn some new things, if I can create a compiler that takes a VERY simplified language as input and output highly optimised thumb/arm code that can be linked to gcc projects then I will be happy if some people find it usefull.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21078 - torne - Sun May 23, 2004 3:50 pm</h4>
    <div class="postbody"><span class="postbody">You will need to output ELF files in order to be able to link against normal binaries. Here's some advice: don't try to implement ELF yourself. You will go hopelessly mad. The standard is missing, presumed gone. Use libbfd from GNU binutils. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21087 - tepples - Sun May 23, 2004 8:07 pm</h4>
    <div class="postbody"><span class="postbody">You don't want to use libbfd directly. Instead, emit ARM7TDMI assembly language and pass it to as, the same way GCC does.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21099 - sgeos - Sun May 23, 2004 9:36 pm</h4>
    <div class="postbody"><span class="postbody">Support for coroutines would be great.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21112 - MumblyJoe - Mon May 24, 2004 1:03 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">You will need to output ELF files in order to be able to link against normal binaries. Here's some advice: don't try to implement ELF yourself. You will go hopelessly mad. The standard is missing, presumed gone. Use libbfd from GNU binutils. =)</td> </tr></table><span class="postbody">
<br/>
<br/>
Trust me, the last thing I wanna do is get anymore complex with this than really necessary. Basically I wanna concentrate more on optimisation and output .S files that gcc/as can worry about.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">Support for coroutines would be great.</td> </tr></table><span class="postbody">
<br/>
<br/>
True, but based on my limited understanding of coroutines I would have to totally redesign how the stack etc works right?
<br/>
<br/>
<br/>
<br/>
Can anyone give me any hints on how gcc-arm handles parameter passing. I am considering using my own method to give me maximum control and more chances to optimise code, and allow an extern keyword that makes a function use gcc's standard method. Or maybe I should always use gcc's method and allow a fastcall modifier like borland does. What should be the default in your opinion?<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21117 - tepples - Mon May 24, 2004 4:59 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">based on my limited understanding of coroutines I would have to totally redesign how the stack etc works right?</td> </tr></table><span class="postbody">
<br/>
Given that coroutines can be implemented in C, which uses a common stack model, <a class="postlink" href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank">this page</a> may give you some implementation hints.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Can anyone give me any hints on how gcc-arm handles parameter passing.</td> </tr></table><span class="postbody">
<br/>
First four args in r0-r3; remainder on the stack; return value in r0. See also the <a class="postlink" href="http://www.cs.cornell.edu/courses/cs414/2004sp/resources/armcallconvention.pdf" target="_blank">ARM-Thumb Procedure Call Standard</a>. Function may trash only r0-r3 and r12.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Or maybe I should always use gcc's method and allow a fastcall modifier like borland does.</td> </tr></table><span class="postbody">
<br/>
That might be the best option. Perhaps make all 'static' functions fastcall by default. What improvements do you think you can make over ATPCS?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21119 - MumblyJoe - Mon May 24, 2004 6:40 am</h4>
    <div class="postbody"><span class="postbody">Thanks for those links tepples, the ATPCS pdf will make my life alot easier when I get to that stage. Truthfully I really dont know how I can improve on it, maybe a fastcall modifier which uses more registers and forbids the taking of parameter addresses so nothing "escapes" to the stack. Of course that would mean any function that was extern and can link to other languages would have to have code inserted by the compiler to clean up the registers to conform to the ATPCS. Still I think that if I come up with some good optimisations and its totally optional to use them in cases where they can be dodgy....
<br/>
<br/>
As for coroutines (which I have no experience with btw) I would basically use a pointer to call the function and when it returns I set that pointer to the address where it needs to reenter next, and next time it calls it continues from there. All local variables would have to be static of course. I assume that if the function body ends the next time it is called it begins from the start again... Am I right about this? Also is there any reason this would be useful for gba coding...<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21120 - sajiimori - Mon May 24, 2004 6:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
*Only 6 types of variables: s8,s16,s32,u8,u16,u32. No floats EVER.
<br/>
</td> </tr></table><span class="postbody">
<br/>
How about arrays, pointers, and structs?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
*No typedefs (makes my job marginally easier). 
<br/>
</td> </tr></table><span class="postbody">
<br/>
After you have the basic types working, you'll probably find that typedefs are trivial.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
*Optimise things like vram[7] to an actual constant address in the output (but not with a variable as the index like vram[i]). 
<br/>
</td> </tr></table><span class="postbody">
<br/>
Since <span style="font-weight: bold">array[index]</span> is the same as <span style="font-weight: bold">*(array+index)</span>, what you'll really be doing is optimizing arithmetic that involves constants.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
*Perhaps built in structures for sprites etc.
<br/>
</td> </tr></table><span class="postbody">
<br/>
If you have structs, there's no real reason to build a special struct into the language.  I guess you could have a certain header file that's always included or something... at least that wouldn't dirty up the language.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
*No dynamic memory.
<br/>
</td> </tr></table><span class="postbody">
<br/>
You don't have to do anything to support malloc, except allow external functions to be called in the standard C manner.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
*Simple dma/memcpy use built into language and easily selectable.(example: palette = dmacpy(0) mypalette; palette = memcpy palette;) Sounds odd but think of the new and delete operators in c++, that sort of thing. Just something to save on work for the user.
<br/>
</td> </tr></table><span class="postbody">
<br/>
It's tempting to add lots of special syntax and neat tricks to your language, but do you really want another perl?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
*No volatile keyword - I wont be optimising enough for it to be needed. 
<br/>
...
<br/>
if I can create a compiler that takes a VERY simplified language as input and output highly optimised thumb/arm code...
<br/>
</td> </tr></table><span class="postbody">
<br/>
Your code will definitely not be highly optimized if you don't do the sorts of optimizations that require the 'volatile' keyword.
<br/>
<br/>
Writing optimizers is not a walk in the park.  It's taken GCC many years to get where it is, and people still complain about it (though it's the most retargetable compiler around).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21130 - Daniel Andersen - Mon May 24, 2004 3:41 pm</h4>
    <div class="postbody"><span class="postbody">As I did in my custom-written Basic for the GBA, you could make a language construct to implement something like co-routines (or more like just interrupts :). In my language you could write
<br/>
<br/>
Run &lt;proc&gt; As &lt;number&gt;
<br/>
Stop &lt;number&gt;
<br/>
Stop All
<br/>
<br/>
A call to Run would "start the procedure" in every V-Blank; in that way you don't have to worry about monsters, effects etc. You could have a main game loop like:
<br/>
<br/>
Repeat
<br/>
Until Player.state = psDead
<br/>
<br/>
Good for beginners to programming, unnecessary for the rest of us and implementable in a flexible language! ;)<br/>_________________<br/>In a world without fences and walls you will never need gates and windows.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21131 - Daniel Andersen - Mon May 24, 2004 3:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Writing optimizers is not a walk in the park.  It's taken GCC many years to get where it is, and people still complain about it (though it's the most retargetable compiler around).</td> </tr></table><span class="postbody">
<br/>
<br/>
C is a language pretty hard to optimize but a custom-built could most likely easily be optimized on; in fact, in my custom-made Basic language (yet again) I made some quite good optimizations that resulted in very good code indeed.
<br/>
<br/>
But actually, haha, you *can* get lost in the park sometimes; first I did a *genius* optimization that resulted in skipping pre-evaluated expressions... just to realize that I had forgetten all about side-effects! :)<br/>_________________<br/>In a world without fences and walls you will never need gates and windows.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21160 - MumblyJoe - Tue May 25, 2004 3:28 am</h4>
    <div class="postbody"><span class="postbody">Well in response to a couple of good points, I am very very early in the development stage and hopefully anything I produce eventually will be useful.
<br/>
<br/>
I am ditching the volatile keyword because it seems like the sort of thing that I dont need yet. For now I'm actually tweaking together something that outputs a .c file with variables for all the registers and functions for all of the instructions, only because this makes it very easy for me to look at the output and test it without worrying about compiler directives etc yet. When I get something I'm proud of enough together I will post it and show you. Maybe I will add volatile when I get to optimisations, but once again I doubt that I will create a compiler that a whole game/program could be done with, just hope I can make something useful to link in.
<br/>
<br/>
I should have said that I meant to include pointers and structs, I should have been clearer on that. Wouldn't be much good for a memory mapped system like the gba if all you had was local variables :P
<br/>
<br/>
As for defending my idea of built in systems like sprite structs and dma modifiers: I want sprites etc built in because I am using a fairly modular method anyway so I can always remove it later if I wanna change to the DS or something, and I think my chances for optimising struct dereferencing will be high, but even higher if the struct is designed into the language. Its the difference between optimising s[i].x=160; when someone else has defined the struct and only general optimisations I will implement for all structs will be applied, and any special shit I can come up with on my own.
<br/>
<br/>
As for the DMA, I intend to have at least a couple of modifier keywords which can be overloaded. Example, the code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">memarea1 = copy(1) memarea2;</td> </tr></table><span class="postbody">
<br/>
And you can overload the copy keyword by defining a function roughly like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">T* copy(T*to, T*from, T n=0);</td> </tr></table><span class="postbody">
<br/>
so the end user can save on some effort by overloading copy for thier own preferences to work with dma or whatever they want. The n argument would be up to them to fill so they can use a switch or something to decide how to copy. If a switch seems like a bad idea dont give an argument to copy.
<br/>
<br/>
I don't expect to replace gcc, but I have read alot of compiler comparisons and gcc really doesnt do a great job. Check out <a class="postlink" href="http://www.ddj.com/documents/s=9132/ddj0405a/0405a.htm" target="_blank">http://www.ddj.com/documents/s=9132/ddj0405a/0405a.htm</a> if you wanna see what i mean.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21169 - sgeos - Tue May 25, 2004 7:09 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">As for coroutines (which I have no experience with btw) I would basically use a pointer to call the function and when it returns I set that pointer to the address where it needs to reenter next, and next time it calls it continues from there.</td> </tr></table><span class="postbody">
<br/>
That is more or less how coroutines are implemented.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">All local variables would have to be static of course.</td> </tr></table><span class="postbody">
<br/>
Local variables do not have to be static.  Subroutines are always called by and return to a 'parent function' of sorts.  They always have a 'parent-child' relationship. Coroutines don't.  I have only seen coroutines packaged as sets.  Coroutines are chunks of executable code that call each other.
<br/>
<br/>
Lets say we have a couple of parent functions, mama() and papa().  Lets say we also have three coroutines, a_ko(), b_ko(), and c_ko().  (Seen <a class="postlink" href="http://www.google.ca/search?hl=en&amp;ie=UTF-8&amp;q=project+a-ko&amp;meta=" target="_blank">Project A-Ko</a>?)
<br/>
<br/>
Lets say that mama() calls a_ko().  a_ko() works with b_ko() and c_ko() to get the job done.  When they are done, b_ko() may well end up returning to mama(), even though mama() told a_ko() to do the job in the first place.  When papa() calls a_ko(), b_ko(), or c_ko(), they work as a group to get the job done.
<br/>
<br/>
Local variables want to be considered local to the set of coroutines.  When one of the routines returns to the caller of the coroutine set, the local variables are no longer needed and can be clobbered.  I'm not overly fond of static data.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">I assume that if the function body ends the next time it is called it begins from the start again...</td> </tr></table><span class="postbody">
<br/>
<br/>
That depends on how it is set up.  As the compiler writer you get to decide if that function restarts, or if the coroutine set returns to mama() or papa().  =)  (I think the second option makes a little more sense.)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">Am I right about this? Also is there any reason this would be useful for gba coding...</td> </tr></table><span class="postbody">
<br/>
*Yes!* If the coroutines include an initialization section that gets called every time, it makes changing the game mode very easy:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void load_game(void)
<br/>
{
<br/>
   int file;
<br/>
<br/>
   init {
<br/>
      load_gfx(LOAD_GAME);
<br/>
      show_gfx(LOAD_GAME);
<br/>
      load_music(LOAD_GAME);
<br/>
      play_music();
<br/>
   }
<br/>
<br/>
   file = get_file_from_sram();
<br/>
   while (1) {
<br/>
      update_keypress();
<br/>
      if (release(UP))
<br/>
         file--;
<br/>
      if (release(DOWN))
<br/>
         file++;
<br/>
      fix_file_number(file);
<br/>
      if (release(A))
<br/>
         start_game(file);  // Coroutine
<br/>
      if (release(B))
<br/>
         title();  // Coroutine
<br/>
      vsync();
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I may want a coroutine in my set for each major game state:
<br/>
splash_screen()
<br/>
title_screen()
<br/>
save_game()
<br/>
load_game()
<br/>
walk_about()
<br/>
battle()
<br/>
menu()
<br/>
credits()
<br/>
game_over()
<br/>
<br/>
I'm not sure how other non-assembler languages handle coroutines, but I think that the biggest difficulty will be defining how members of a coroutine set are allowed to communicate, share data and return to the calling function.  If it would interest anyone, I would be happy to write an article on how to implement coroutines in C using a controller function.  It will assume that the reader has read <a class="postlink" href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank">Simon Tatham's article</a>, mentioned above.  Coroutines are also detailed in section 1.4.2 of <a class="postlink" href="http://www.amazon.com/exec/obidos/tg/detail/-/0201896834/qid=1085464014/sr=1-2/ref=sr_1_2/102-7525462-0456125?v=glance&amp;s=books" target="_blank">volume 1</a> of <a class="postlink" href="http://www-cs-faculty.stanford.edu/~knuth/" target="_blank">Donald Knuth's</a> <a class="postlink" href="http://www-cs-faculty.stanford.edu/~knuth/taocp.html" target="_blank">The Art of Computer Programming</a>.  (I highly recommend the <a class="postlink" href="http://www.amazon.com/exec/obidos/tg/detail/-/0201485419/qid=1085464014/sr=1-1/ref=sr_1_1/102-7525462-0456125?v=glance&amp;s=books" target="_blank">boxed set</a>.)
<br/>
<br/>
I'll note that if your compiler provides language level support for coroutines I will use it and probably become reluctant to touch other compilers.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21232 - MumblyJoe - Wed May 26, 2004 8:11 am</h4>
    <div class="postbody"><span class="postbody">hmmmm sgeos, you raise some interesting ideas. I still dont <span style="font-style: italic">really</span> understand coroutines but I will do some research now while I may be able to squeeze into my notes and test run grammer.
<br/>
<br/>
What I really need to know at this stage is if there is any good reason c/c++ dont natively support them?
<br/>
<br/>
<a class="postlink" href="http://www.sidhe.org/~dan/blog/archives/000178.html" target="_blank">http://www.sidhe.org/~dan/blog/archives/000178.html</a> describes them pretty well, and i think i will use the yield keyword if i do implement them. Which method that he describes on that page should I attempt: The ignoring of paremeters on subsequent calls, creating new instances, altering the variable, some other way... Which way is most useful for most people?
<br/>
<br/>
I am pretty sure I get the whole yielding idea, but having more than one coroutine that shares data with another or something.... I dunno yet.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21280 - sajiimori - Wed May 26, 2004 5:28 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
What I really need to know at this stage is if there is any good reason c/c++ dont natively support them?
<br/>
</td> </tr></table><span class="postbody">
<br/>
Mainly because C was designed with a single hardware stack in mind, and real coroutines each need their own stack.  The compiler could emulate additional stacks, but that would be a higher-order feature and C was also designed with low-level programming in mind.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21303 - MumblyJoe - Thu May 27, 2004 3:44 am</h4>
    <div class="postbody"><span class="postbody">Hmmm, I might just get on with some of the other work that I badly need to do for the compiler and have the yield and coroutine keywords reserved just in case (just in case I cant figure out a grammer where I can tell if a couroutine is what is wanted through use of the yield keyword). If anyone can give me an example of how other languages use it that would be cool.
<br/>
<br/>
Anyway, I have this new optimisation in my head and I want to know if it has been done before or not...
<br/>
<br/>
First step, <span style="font-weight: bold">__superconst</span> or something gay like is a language extension in my compiler (I can change the word in a second if anyone has a better one). A superconst cannot have it's constness casted away or have it's address taken or anay of the other things that c/c++ can allow to un-const something. This allows me some assumptions.
<br/>
<br/>
A function that takes a superconst can have the modifier <span style="font-weight: bold">__multiple</span>. Then amagine this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
void __multiple SomeFunction(__superconst u32 in);
<br/>
<br/>
int main()
<br/>
{
<br/>
    __superconst u32 somenum = 90;
<br/>
<br/>
    SomeFunction(somenum);
<br/>
    SomeFunction(56);
<br/>
<br/>
    return 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Now the assembler expands this into two SomeFunction's, both of which are built with the constant passed to them tied into the end asm as much as possible. If this sounds odd to you, imagine why people prefer to use a #define sometimes when an inline function could be used, its better in the end result some times.
<br/>
<br/>
When the compiler is done it will output some data to a file or to stdout or whatever that gives information on what optimisations have been taken, how much larger they have caused the end result to be, an estimate on if it has made it a lot or a little faster (or even slower).
<br/>
<br/>
Obviously __multiple functions are static etc. Anyway, I can see it as a useful optional extension that could allow some cool things done for really time critical code.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21310 - bats - Thu May 27, 2004 1:00 pm</h4>
    <div class="postbody"><span class="postbody">It sounds like you're idea is to mimic inlining, without actually inlining. It might help fight code bloat (only if a function is called multiple times with the same const), but it also removes some of the benefits of inlining: removing the function call, and allowing the inlined function to optimize "into" the calling function.
<br/>
<br/>
If you do decide to implement this feature, you shouldn't need a superconst to do it. If you calculate reaching definitions (a more useful optimization I would guess) your compiler will be able to determine constant expressions without the user's help.
<br/>
<br/>
If you're interested in writing an optimizing compiler, I'd suggest reading the "Dragon" Book. It's a nice starting point for the aspiring compiler writer.
<br/>
<br/>
Ben</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21319 - sajiimori - Thu May 27, 2004 7:49 pm</h4>
    <div class="postbody"><span class="postbody">Instead of speculating about optimizations that C compilers don't do, you might start by doing the usual optimizations -- they are far more important.  When you have a working compiler, then you can experiment with these other ideas and find out if they're worthwhile.
<br/>
<br/>
BTW, look at the assembler g++ generates for this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const int x=100;
<br/>
<br/>
int main()
<br/>
{
<br/>
  *(int*)&amp;x=123;
<br/>
  return x*2;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
I don't know what kind of assumptions you wanted to be able to make with your superconst idea, but it appears g++ makes a lot of them anyway, even when it's wrong.
<br/>
<br/>
Casting away const is just stupid. :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21338 - keldon - Fri May 28, 2004 1:26 am</h4>
    <div class="postbody"><span class="postbody">Forget about optimisations at first, in most cases you are just correcting a coders poor algorithm. The only optmisation you need ever do is with the assembler, not co-routines etc.
<br/>
<br/>
If you want to know how to optmise you need to create code tracing AI, or at least create a few finite rules to optmise. Code tracing AI is easily tackled with graph theory - and the higher level your language is, the easier this is.
<br/>
<br/>
Now where graph theory comes into place is when you, for example have poor code that asks a function twice for the same data, or the function need not be called twice with different data as a calculation could be made from the first call. An example of this is x = a^6 and y=a^7, but y=x*a.
<br/>
<br/>
Also variables could be replaced by registers completely, that is quite simple to tackle in some instances. But focus on getting it working, and by hand find optmisations and then apply an model and algorithm for finding it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21342 - sgeos - Fri May 28, 2004 2:28 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">Forget about optimisations at first, in most cases you are just correcting a coders poor algorithm. The only optmisation you need ever do is with the assembler, not co-routines etc.</td> </tr></table><span class="postbody">
<br/>
Coroutines are not an optimisation.  They are something that I wish was easier to implement in C.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">hmmmm sgeos, you raise some interesting ideas. I still dont <span style="font-style: italic">really</span> understand coroutines but I will do some research now while I may be able to squeeze into my notes and test run grammer.</td> </tr></table><span class="postbody">
<br/>
Naturally, I have some suggestions (later in the post).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">What I really need to know at this stage is if there is any good reason c/c++ dont natively support them?</td> </tr></table><span class="postbody">
<br/>
C is not the divine language.  It is lacking in some areas.  Depending on who you ask, C++ is better or worse.  At any rate, C++ is far from divine.
<br/>
<br/>
sajiimori suggested the stack.  Coroutines can be implemented in ANSI C, which uses "a common stack model", as tepples pointed out.  It's a bit of a pain, but in vanilla C, I can set up coroutines with the following features:
<br/>
<br/>
shared variables (I pass a struct in from my controller function)
<br/>
persistant variables (in the passed in struct)
<br/>
the ability to resume state (switch on __LINE__ trick)
<br/>
an initialization section (anything before the switch statement)
<br/>
<br/>
The goal is to have the language facilitate the programmer.  I can do everything now, I just want it to be easier to implement and easier to read.  These go hand in hand.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote"><a class="postlink" href="http://www.sidhe.org/~dan/blog/archives/000178.html" target="_blank">http://www.sidhe.org/~dan/blog/archives/000178.html</a> describes them pretty welli think i will use the yield keyword if i do implement them.</td> </tr></table><span class="postbody">
<br/>
Neat article.  I do not like the way he opens the article though:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Squawks of the Parrot wrote:</b></span></td> </tr> <tr> <td class="quote">Anyway, what is a coroutine? Well, a coroutine is a subroutine or function that can pause in the middle and return a value.</td> </tr></table><span class="postbody">
<br/>
Subroutines may or may not return values.  The same is true of coroutines.
<br/>
<br/>
Knuth does a much better job of describing them:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Donald E. Knuth wrote:</b></span></td> </tr> <tr> <td class="quote">Subroutines are special cases of more general program components, called <span style="font-style: italic">coroutines</span>.  In contrast to the unsymmetric relationship between a main routine and a subroutine, there is complete symmetry between coroutines, which <span style="font-style: italic">call on eachother</span>.
<br/>
<br/>
To understand the coroutine concept, let us consider another way of thinking about subroutines.  The viewpoint adopted in the previous section was that a subroutine merely was an extension of the computer hardware, introduced to save lines of coding.  This may be true, but another point of view is possible: We may consider the main program and the subroutine as a <span style="font-style: italic">team</span> of programs, each member of the team having a certain job to do.  The main program, in the course of doing its job, will activate the subprogram; the subprogram will perform its own function and then activate the main program.  We might stretch out imagination to believe that, from the subroutine's point of view, when it exits <span style="font-style: italic">it</span> is calling the <span style="font-style: italic">main</span> routine; the main routine continues to perform its duty, then "exits" to the subroutine.  The subroutine acts, then calls the main routine again.
<br/>
<br/>
This somewhat far-fetched philosophy actually takes place with coroutines, for which it is impossible to distinguish which is a subroutine of the other.  Suppose we have coroutines A and B; when programming A, we may think of B as our subroutine, but when programming B, we may think of A as our subroutine.  That is, in coroutine A, the instruction "JMP B" is used to activate coroutine B.  In coroutine B the instruction "JMP A" is used to activate coroutine A again.  Whenever a coroutine is activated, it resumes execution of its program at the point where the action was last suspended.
<br/>
<br/>
The coroutines A and B might, for example, be two programs that play chess.  We can combine them so that they will play against each other. (193-194)</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">i think i will use the yield keyword if i do implement them.</td> </tr></table><span class="postbody">
<br/>
"yield" sounds good.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">Which method that he describes on that page should I attempt: The ignoring of paremeters on subsequent calls,</td> </tr></table><span class="postbody">
<br/>
When dealing with two coroutines that work together, they can essentially return to eachother.  I do not think that using two coroutines is the best way to illustrate the concept.  A lot of assumptions can be made that cease to exist as soon as a third coroutine enters the picture.
<br/>
<br/>
My opinion is that coroutines, in general, should not return values to eachother.  Values should either be passed using parameters, or coroutines should use shared data to communicate.  Consider the following scenario:
<br/>
<br/>
mama() "There is some work that needs to get done.  a_ko(), I'll leave it up to you to make sure that this gets started."
<br/>
<br/>
a_ko()  *works for a while*  "Hey, b_ko(), I really need you to do your part before I can continue."
<br/>
<br/>
b_ko()  *finishes quickly*  "Ok c_ko()!  Your turn."
<br/>
<br/>
c_ko()  *works for a while*  "b_ko(), I need you work on this some more."
<br/>
<br/>
b_ko()  *finishes quickly*  "Ok c_ko()!  Your turn again."
<br/>
<br/>
c_ko()  *works for a while*  "a_ko(), you need to have a look at this..."
<br/>
<br/>
(Continues from there)
<br/>
<br/>
The problem is that a_ko() gives control to b_ko(), but has control returned from c_ko().  I think that passing control from one coroutine to another should always be done in a forward fashion.  If one ever wants a coroutine to return to it's calling coroutine, I suspect that that individual really wants a subroutine setup.  (Chances may also be that that individual has not figured out what he or she is doing.)
<br/>
<br/>
To be clear, I think that parameter values should be changed when we yield to another coroutine.  This essentially allows more than one value to be returned to each coroutine in an input only fashion.  "Returning" values is bad because we do not know who is returning the value.  a_ko() has no way of knowing if b_ko() or c_ko() is going to get back to her.
<br/>
<br/>
Assuming a structure model for shared variables, the parameters could be part of the structure, or they could be passed like subroutine parameters.
<br/>
<br/>
Input only is limiting because it allows only one set of data passed, with the types predefined.  If a given type is needed that is not part of the parameter list, that can be done with shared data.
<br/>
<br/>
To the extent that coroutine can communicate using nothing but shared data, I could see an arguement that the parameter list and return type should *only* be used to communicate with the "outside world".  Using that approach, the parameter "variables" should not change on subsequent calls.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">creating new instances,</td> </tr></table><span class="postbody">
<br/>
If parameters are used as a way for coroutines to communicate with eachother, then new instances are not useful.  Regardless of how I think about it, I don't see any merit in new instances, actually.  Discarding on a parameter change is also not useful.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>MumblyJoe wrote:</b></span></td> </tr> <tr> <td class="quote">altering the variable, some other way... Which way is most useful for most people?</td> </tr></table><span class="postbody">
<br/>
I think that altering the variable is the way to go, if parameters used as a means for coroutine communication.  Otherwise I'd ignore parameters on subsequent calls.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int a_ko(char x, char y, char z)
<br/>
{
<br/>
}</td> </tr></table><span class="postbody">
<br/>
If mama() calls a_ko() and later, c_ko() yields to a_ko() with different values, I think that a_ko() should pick up where she left off and run with the new parameter "variable" values.  I say this because I do not think that coroutines should return values to one another as such.  Again, all of this could be done with shared variables.  Regardless, int a_ko() indicates that a_ko() returns int to mama().  b_ko() and c_ko() should also return int to mama().
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I am pretty sure I get the whole yielding idea, but having more than one coroutine that shares data with another or something.... I dunno yet.</td> </tr></table><span class="postbody">
<br/>
I do not think that having more than one coroutine with shared data is an especially difficult concept.  "<span style="font-weight: bold">More than one coroutine</span>" and "<span style="font-weight: bold">shared data</span>" are different concepts.  I'll start with the "more than one coroutine" concept.
<br/>
<br/>
Coroutines work as teams.  a_ko(), b_ko() and c_ko() may work together, while d_ko() and e_ko() also work together.  (d_ko() and e_ko() are not part of a_ko()'s team.)  There has to be a way of telling who is on which team.  The compiler should not lump all coroutines together, nor should it allow coroutines on different teams to yield to one another any more than it allows subroutines to yield to one another.
<br/>
<br/>
This works well for subroutines:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">type_t subroutine(arg_t args);</td> </tr></table><span class="postbody">
<br/>
Subroutines work on teams of one.  (These loners are often enslaved by supreme calling functions.)  Coroutines band together, so how about something like this?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">coroutine {
<br/>
   u16 a_ko(int);
<br/>
   u16 b_ko(char);
<br/>
   u16 c_ko(void);
<br/>
}
<br/>
<br/>
coroutine {
<br/>
   void d_ko(u16);
<br/>
   void e_ko(u16);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
My main objection to this setup is that if another routine wants to join a team, the programmer has to hunt down the teams declarations.  These may be at the top of the file, or in a header.  In other words, far, far away.  The advantage to this is that once we find the team declaration, we know exactly who is on the team.
<br/>
<br/>
I much prefer team_name delimiter member_name.  Something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 abc@a_ko(int);
<br/>
u16 abc@b_ko(char);
<br/>
u16 abc@c_ko(void);
<br/>
void de @ d_ko(u16);
<br/>
void de @ e_ko(u16);</td> </tr></table><span class="postbody">
<br/>
<br/>
That should make things easy for the compiler.  Of more importance, is that somebody reading the code knows that these functions are coroutines.  Not only that, the reader knows what team the coroutines are on.  The reader may not know who all the team members are.
<br/>
<br/>
I could see mandatory declaration of all coroutines on a team within a file.  Something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 abc@a_ko(int);
<br/>
extern u16 abc@b_ko(char);
<br/>
extern u16 abc@c_ko(void);
<br/>
</td> </tr></table><span class="postbody">
<br/>
Then there is the question of moving from one routine to the next.  I think that the easiest way would be for yield b_ko(); (from a_ko()) to expand to the following psuedo code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">save_a_ko_state(resume_here);
<br/>
branch(b_ko, parameters);
<br/>
resume_here:</td> </tr></table><span class="postbody">
<br/>
The other way is for a_ko() to branch to something like __a_ko2b_ko:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__a_ko2b_ko:
<br/>
   save_a_ko_state(resume_here);
<br/>
   branch(b_ko_starts_here);
<br/>
__c_ko2b_ko:
<br/>
   save_c_ko_state(other_resume_here);
<br/>
   /* No branch needed */
<br/>
b_ko_starts_here:</td> </tr></table><span class="postbody">
<br/>
This would have to be set up for every function.  All in all, I suspect that the first way would be easier to implement.  The second way is how Knuth does things in the main text of TAOCP.
<br/>
<br/>
Naturally, trying to <span style="font-weight: bold">yield to</span> d_ko() from a_ko() or mama() should result in a compiler error.
<br/>
<br/>
Also, I'd like to point out the while:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void a_ko(void) {
<br/>
   yield b_ko();
<br/>
}</td> </tr></table><span class="postbody">
<br/>
passes control to b_ko(),
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void a_ko(void) {
<br/>
   b_ko();
<br/>
}</td> </tr></table><span class="postbody">
<br/>
creates a new instance of the abc team, and control starts there with b_ko().
<br/>
<br/>
Next is the issue of shared memory.  When I write coroutines in C, I have my controller function direct control from one routine to the next.  It also passes the same structure to every routine.  This is bad because the structure is defined at the top of the file or in a header.  It is a pain to add shared variables.  Somebody reading my code has to hunt the structure down.  It would be nice if the compiler put the struct together so that the data could be declared in the functions- where it really belongs!
<br/>
<br/>
If I were doing things, this code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 abc @ a_ko(int a)
<br/>
{
<br/>
   shared data_t data;
<br/>
<br/>
   while (1) { /* ... */ }
<br/>
}
<br/>
<br/>
u16 abc @ b_ko(char b)
<br/>
{
<br/>
   shared data_t data;
<br/>
   int i;
<br/>
<br/>
   init { /* ... */ }
<br/>
   { /* ... */ }
<br/>
}
<br/>
<br/>
u16 abc @ c_ko(void)
<br/>
{
<br/>
   int i;
<br/>
   int j;
<br/>
   int k;
<br/>
<br/>
   init { /* ... */ }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Would be compiled into the rough moral equivalent of:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">struct __abc {
<br/>
   data_t   __shared_data;
<br/>
   int   __b_ko_i;   
<br/>
   int   __c_ko_i;   
<br/>
   int   __c_ko_j;   
<br/>
   int   __c_ko_k;   
<br/>
   void *   __a_ko_state;
<br/>
   void *   __b_ko_state;
<br/>
};
<br/>
<br/>
u16 __abc__a_ko(int a, struct __abc *__abc)
<br/>
{
<br/>
   /* No init */
<br/>
   branch(__abc-&gt;__a_ko_state);
<br/>
   while (1) { /* ... */ }
<br/>
}
<br/>
<br/>
u16 __abc__b_ko(char b, struct __abc *__abc)
<br/>
{
<br/>
   init { /* ... */ }
<br/>
   branch(__abc-&gt;__b_ko_state);
<br/>
   { /* ... */ }
<br/>
}
<br/>
<br/>
<br/>
u16 __abc__c_ko(struct __abc *__abc)
<br/>
{
<br/>
   init { /* ... */ }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Everything starts with __ because that is the compiler's name space.  c_ko() does not have a state because everything is in the initialization section.  data is not shared with c_ko().  Trying to access data from within c_ko() should result in a compiler error.  b_ko() and c_ko() both have variables named i.  These are not shared- they are different variables.  In theory, c_ko() should be able to have a non shared variable named data.
<br/>
<br/>
I think that initializing the function state pointers properly is something to look out for.  I'm not sure how tricky the (shared) variables would be to implement.
<br/>
<br/>
In closing, I'd love to see coroutines included.  I think that the keywords yield, shared, and init (or their moral equivalents) and a team delimiter would be a good way of doing things.  I'd also like to hear what other people have to say on the topic.
<br/>
<br/>
I do think that your first priority should be to get a basic compiler up and running.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21343 - MumblyJoe - Fri May 28, 2004 2:32 am</h4>
    <div class="postbody"><span class="postbody">Don't worry, I have a table of textbooks on the subject that I am studying and I have every intention of performing any standard optimisations too, but I need to throw ideas around before they get stagnant in my head :P<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21346 - MumblyJoe - Fri May 28, 2004 2:59 am</h4>
    <div class="postbody"><span class="postbody">Thanks again sgeos, thats given me some good insights on how to allow for coroutines at a later stage. This is important for me to do at this stage because I am toying with namespaces etc in theory etc, and until I get that done I cant really even start register allocations etc.
<br/>
<br/>
From what I can tell they shouldn't get me in any trouble with grammar, the coroutine {} method would get through my parser as ok with a minimum of fuss because its so similar to things like extern "C" {} or static {} groupings. Of course your idea of using a delimeter like @ wouldn't take long to add in either. Also thanks for the examples, I am pretty sure I get the shared data now. Adding support for the shared keyword is obviously gonna be as easy as it looks.
<br/>
<br/>
Back to the books...<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21377 - keldon - Fri May 28, 2004 10:32 am</h4>
    <div class="postbody"><span class="postbody"><span style="font-weight: bold">Brendan</span> I think you've hit the nail. Whenever yield is used to call the co-routine the instance variables created, if any are global to this level of co-routine calls just like when a function is called it has its own instance variables.
<br/>
<br/>
This is no difficult task, nor is co-routine implementation - it is merely a jump. To pass parameters to a new instance when yield is not declared could be handled like so:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">coRoutineJump ( *(void *) function, param 1, param2 etc.... ) {
<br/>
 jmp function
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
So for example you can have recursive co-routines, etc.
<br/>
<br/>
I also agree with them being grouped together, that way the concept shown above works with ease, so that you always pass x amount of instance variables to the function.
<br/>
<br/>
With the co-routines, you may not implement them now, but make sure that your compiler is structured to be able to insert its functionality later.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21414 - sajiimori - Fri May 28, 2004 10:12 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Forget about optimisations at first, in most cases you are just correcting a coders poor algorithm.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I strongly disagree with the above.  When given the choice between a highly optimized and hard-to-read solution and an easy-to-read solution that the compiler will optimize to be as fast as the first solution, a good programmer will always choose the latter.
<br/>
<br/>
Consider:  Why does anybody write inline functions?  To be faster, right?  Wrong.  They could have inlined the function by hand, and they wouldn't have needed an optimizing compiler to do it.  Using an inline function makes the code easier to write, read, and maintain.  The inlining compiler allows the coder to write code that is fast <span style="font-style: italic">and</span> good.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The only optmisation you need ever do is with the assembler...
<br/>
</td> </tr></table><span class="postbody">
<br/>
I've never heard of an "optimizing assembler".  That wouldn't really make any sense.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21421 - keldon - Fri May 28, 2004 11:22 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Forget about optimisations at first, in most cases you are just correcting a coders poor algorithm.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I strongly disagree with the above.  When given the choice between a highly optimized and hard-to-read solution and an easy-to-read solution that the compiler will optimize to be as fast as the first solution, a good programmer will always choose the latter.
<br/>
<br/>
Consider:  Why does anybody write inline functions?  To be faster, right?  Wrong.  They could have inlined the function by hand, and they wouldn't have needed an optimizing compiler to do it.  Using an inline function makes the code easier to write, read, and maintain.  The inlining compiler allows the coder to write code that is fast <span style="font-style: italic">and</span> good.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The only optmisation you need ever do is with the assembler...
<br/>
</td> </tr></table><span class="postbody">
<br/>
I've never heard of an "optimizing assembler".  That wouldn't really make any sense.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
You didn't understand what I meant. When I said optmizing assembler, I meant that optimise the output using variations of methods in assembler. E.g.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">function ( int f ) {
<br/>
   int a = 3;
<br/>
   return f * 3 mod diff ( f );
<br/>
}</td> </tr></table><span class="postbody">
<br/>
would be outputted as say
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   ;; f = r1
<br/>
   sub r1 3
<br/>
   ldr r2 0
<br/>
   cmp r1 r2
<br/>
   sub lt r2 r1
<br/>
   mul r2 r1</td> </tr></table><span class="postbody">
<br/>
...returning in r1. Excuse my assembler mistakes, such as how the stack is handled here; I have no idea how it is done in the GBA as I haven't looked through it yet.
<br/>
<br/>
And what I meant by the programmer writing better code, I meant in the case that they have created a poor algorithm, not an algorithm that doesn't use loads of optmisations such as, for example, directly accessing registers. A good algorithm doesn't necessarily have to be unreadable, which any good programmer knows.
<br/>
<br/>
As a note, there are numerous optmisations that a compiler can choose by examining the path of data and processing. That means that it can even examine the processes of the functions being called and calculating what portion of the process could be extracted, etc.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21424 - torne - Sat May 29, 2004 12:05 am</h4>
    <div class="postbody"><span class="postbody">Actually, I've been writing an optimising assembler for my final-year project. Some time in the next few months I will hopefully have it in a condition that someone else could use it. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21432 - sajiimori - Sat May 29, 2004 2:29 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Actually, I've been writing an optimising assembler for my final-year project.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Hmm... maybe it ceases to be an assembler then, and becomes a compiler for a language that strongly resembles assembly. =)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
When I said optmizing assembler, I meant that optimise the output using variations of methods in assembler.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Oh, alright then.  I guess you were distinguishing between optimizations in output versus optimizations in lines of source or programmer effort.  Normally, the phrase "optimizing compiler" only refers to optimizations that affect the output.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
And what I meant by the programmer writing better code, I meant in the case that they have created a poor algorithm, not an algorithm that doesn't use loads of optmisations such as, for example, directly accessing registers. A good algorithm doesn't necessarily have to be unreadable, which any good programmer knows. 
<br/>
</td> </tr></table><span class="postbody">
<br/>
Ok.  I still think you're wrong to say that optimizing compilers are usually only useful for correcting bad algorithms.  Optimizers allow me to write code that is clearer and more modular, without sacrificing speed.
<br/>
<br/>
Or are you going to argue that there is no such thing as a trade-off between speed and clarity/modularity?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21446 - keldon - Sat May 29, 2004 11:47 am</h4>
    <div class="postbody"><span class="postbody">I can write code that is fast, optmised, modular without being unreadable. You are simply not a programmer in the poor category, so this does not apply to your code.
<br/>
<br/>
Consider this code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   b = 0; m = 4; x = 1;
<br/>
   for ( int i = 0; i &lt; 25; i++ ) {
<br/>
      b = b + (m ^ x) ;
<br/>
      x = x + 1;
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
<br/>
Now a smarter algorithm is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   b = 0; m = 4;
<br/>
   for ( int i = 0; i &lt; 25; i++ ) {
<br/>
      b = b + m;
<br/>
      m = m * m;
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
<br/>
A compiler may wish to change the first algorithm to create the second, however that takes time for some to design. Both are readable, but the first would take ages to compute, simply because of what's behind the exponental functions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21471 - sajiimori - Sat May 29, 2004 7:12 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I can write code that is fast, optmised, modular without being unreadable. You are simply not a programmer in the poor category, so this does not apply to your code.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Are you saying there is such a thing as a trade-off between speed and clarity/modularity, but only for bad programmers?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   b = 0; m = 4; 
<br/>
   for ( int i = 0; i &lt; 25; i++ ) { 
<br/>
      b = b + m; 
<br/>
      m = m * m; 
<br/>
   }
<br/>
</td> </tr></table><span class="postbody">
<br/>
Oops, I think the compiler had to correct your bad algorithm!  Here's the x86 output with -O0:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   movl   $0, -4(%ebp)
<br/>
   movl   $4, -8(%ebp)
<br/>
   movl   $0, -12(%ebp)
<br/>
L2:
<br/>
   cmpl   $24, -12(%ebp)
<br/>
   jle   L5
<br/>
   jmp   L3
<br/>
L5:
<br/>
   movl   -8(%ebp), %edx
<br/>
   leal   -4(%ebp), %eax
<br/>
   addl   %edx, (%eax)
<br/>
   movl   -8(%ebp), %eax
<br/>
   imull   -8(%ebp), %eax
<br/>
   movl   %eax, -8(%ebp)
<br/>
   leal   -12(%ebp), %eax
<br/>
   incl   (%eax)
<br/>
   jmp   L2
<br/>
L3:
<br/>
</td> </tr></table><span class="postbody">
<br/>
And here's the output with -O3:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   movl   $24, %eax
<br/>
   xorl   %ecx, %ecx
<br/>
   movl   $4, %edx
<br/>
L6:
<br/>
   addl   %edx, %ecx
<br/>
   imull   %edx, %edx
<br/>
   decl   %eax
<br/>
   jns   L6
<br/>
</td> </tr></table><span class="postbody">
<br/>
Does that mean you're a poor programmer after all?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
A compiler may wish to change the first algorithm to create the second, however that takes time for some to design.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Yes, it's hard to write optimizing compilers, but I don't see how that applies to your argument that optimizers are only useful for bad programmers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21492 - keldon - Sun May 30, 2004 12:42 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Are you saying there is such a thing as a trade-off between speed and clarity/modularity, but only for bad programmers? </td> </tr></table><span class="postbody">
<br/>
Well a poor programmer would mostly write code in the hope that it works. You don't need to know ways around a compiler to be a good programmer, just have knowledge and understanding of algorithms. Many people don't, and some methods of software optmisation only exist for their benifit.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Does that mean you're a poor programmer after all? </td> </tr></table><span class="postbody">
<br/>
<br/>
And this may be slightly off topic, but you have illustrated a great level of stupidity, ignorance, and poor understanding of algorithms and assembler.
<br/>
<br/>
The first output is the compiler using stack variables for every variable; the second is the compiler realising that it only needs to use registers. If you were clever you might have tried to input the first algorithm, or even realised how fundamentally wrong it was - which many poor programmers may do; which the second is a faster version of.
<br/>
<br/>
Also being an assembler programmer at heart, the second output is how I would have written it anyway. Also you failed to realise (/understand) that I meant that a compiler may wish to optmise the first code I gave you (you know, the one that called the exponent function multiple times) to give the same code you've given there.
<br/>
<br/>
In fact I am surprised that the first output came out like that, but I wouldn't consider the second one an optmisation on the code; simply better code than the first one given - but then again I mostly program in assembler so all my code would come out pretty much like that anyway :-). So I guess however good a programmer you are, or may be, you're not a bright spark.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21494 - torne - Sun May 30, 2004 12:55 am</h4>
    <div class="postbody"><span class="postbody">sajimori is completely right, you know. Don't be so pompous. There are many compiler optimisations which cannot be done at C source level at all, however illegibly you write your code. Allocating local variables to registers *is* an optimisation; the standard 'model' of the compiler states that local variables are on the stack, so doing anything different for performance reasons is optimising.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21495 - keldon - Sun May 30, 2004 1:06 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Oops, I think the compiler had to correct your bad algorithm! Here's the x86 output with -O0: </td> </tr></table><span class="postbody">
<br/>
Just thought I'd add to your stupidity, but both of the outputs you've given me are the same algorithm, represented with different code - but the same algorithm.
<br/>
<br/>
<br/>
<br/>
---
<br/>
Now in regards to the compiler it just goes to show the difficulties of converting a high level expression into a low level expression.
<br/>
<br/>
But even that is not a true display of optmisation; the biggest optmisation is when operations are arranged so that as as many instructions are carried out at the same time, sometimes up to 4 or 5, which is simply not an issue with the gameboy advance.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21496 - keldon - Sun May 30, 2004 1:15 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">sajimori is completely right, you know. Don't be so pompous. There are many compiler optimisations which cannot be done at C source level at all, however illegibly you write your code. Allocating local variables to registers *is* an optimisation; the standard 'model' of the compiler states that local variables are on the stack, so doing anything different for performance reasons is optimising.</td> </tr></table><span class="postbody">
<br/>
<br/>
Well like I said, I write in assembler - and to suggest that as being pompous is quite farfetched, although I did give quite a stately display, and I hate stupid comments like that when people attempt to cover up their own mistake.
<br/>
<br/>
But I am mostly pointing out his attempt to insult me by suggesting I created a poor algorithm by my own definition; however no change was made to the algorithm - and he completely ignored the the original code, also I was expressing the difference between good and bad code and why writing an optmiser that focuses on fixing bad code to good code (which can be done) should be dismissed.
<br/>
<br/>
Also this is over the discussion of focussing on optmisation. There are various methods to optmise code - and if using a register instead of a variable on a stack is seen as an optmisation then I will accept that, and that is an optmisation that should not be missed. Just remember that I code in assembler, so this is a quite humourous joke to assemblers given the arguments against writing in assembler - a little too off topic so I'll stop here.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21499 - sajiimori - Sun May 30, 2004 1:45 am</h4>
    <div class="postbody"><span class="postbody">I'm done talking to you, keldon.  Let me know when you grow up.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21502 - keldon - Sun May 30, 2004 2:18 am</h4>
    <div class="postbody"><span class="postbody">Me grow up?!? Whether I spoke out of turn, or was a little <span style="font-style: italic">'pompous'</span> - the fact remains that you tried to be facetious and  <span style="font-weight: bold">incorrectly</span> attempted to point out a fault,   which was in fact no fault. So is it me who should grow up and stop overreacting to <span style="font-weight: bold">your mistakes</span>, or you who should grow up and <span style="font-weight: bold">accept your mistakes</span> - as I have accepted mine.
<br/>
<br/>
Also this little squabble is taking up considerable space in MumblyJoe's topic.
<br/>
<br/>
I would also add that I was not attempting to squabble with you or argue with you until you attempted to show me up with your output therefore you initiated the bad response and now attempt to cover it by calling me childish, bearing in mind who wanted to insult who first. <span style="font-weight: bold">It would be far more intelligent</span> to admit you misunderstood what I said and that <span style="font-weight: bold">I, also misunderstood what you said and did not explain myself fully</span>; that is the wise and ADULT way of doing things in this case.
<br/>
<br/>
<span style="font-weight: bold">Also</span> don't take my comments on me being an assembler programmer as a declaration of importance and priority - it is a choice because I learned more doing assembly and found working with it a lot easier.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
