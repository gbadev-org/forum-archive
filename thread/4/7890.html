<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>tetris problem - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > tetris problem</h2>
<div id="posts">
<div class="post">
    <h4>#64778 - vexon - Mon Dec 26, 2005 6:45 pm</h4>
    <div class="postbody"><span class="postbody">hello, I've been working on my first GBA game today which I'm planning to complete :p.
<br/>
I'm currently having some issues with the movement of the cluster which contains the blocks which are moved individual and are also represented by an array. Could someone please help me out by saying what should be changed in my code to get the blocks moving properly? 
<br/>
the link to the GBA file <a class="postlink" href="http://download.sigma-interactions.com/Tetrix.gba" target="_blank">here</a>
<br/>
here's the code.. I'm using the HAMlib:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;mygba.h&gt;
<br/>
<br/>
//GFX INCLUDES - START//
<br/>
    #include "GFX\master.pal.c";
<br/>
    //titlescreen
<br/>
    #include "GFX\title_screen.raw.c";
<br/>
    #include "GFX\title_screen.map.c";
<br/>
    //logo screen (credits)
<br/>
    //game bg
<br/>
    #include "GFX\game_bg.raw.c";
<br/>
    #include "GFX\game_bg.map.c";
<br/>
    //block
<br/>
    #include "GFX\block.raw.c";
<br/>
//GFX INCLUDES - END//
<br/>
<br/>
//GLOBAL VARIABLES - START//
<br/>
    bool bAddcluster = true;
<br/>
    char* keypressed;
<br/>
    int speed = 1;
<br/>
    int speedmultiplier = 0;
<br/>
    int controlspeed = 0;
<br/>
    int score = 0;
<br/>
    int time = 0;
<br/>
    u8 tickcount=0;
<br/>
    u8 block[16];
<br/>
    u8 staticblock[120];
<br/>
    u8 currentstaticblock=0;
<br/>
    u8 block_y[16];
<br/>
    u8 block_x[16];
<br/>
    char* clustertype;
<br/>
    u8 clusterpos_x;
<br/>
    u8 clusterpos_y;
<br/>
    int completerow;
<br/>
    char field[13][10]; //rows, colls
<br/>
//GLOBAL VARIABLES - END//
<br/>
<br/>
//FUNCTION PROTOTYPES - START//
<br/>
    void tick(); //every frame (60 a second)
<br/>
    void update(); //updates movement
<br/>
    void proces_input(); //looks for input and what to do then
<br/>
    void addcluster(); //adds a another block combination to fall from the sky
<br/>
    void clusterfall(); //let's  a cluster drop
<br/>
    void rotatecluster(); //rotate that cluster 90 degrees
<br/>
    void createcluster(char* type); //create a new cluster
<br/>
    int movecluster(); //move cluster
<br/>
    int checkrow(); //check if there's a full row
<br/>
    void makestatic(); //deactivate the cluster if it's grounded
<br/>
    void checkcollision(); //check for collision to see it can be made static.
<br/>
//FUNCTION PROTOTYPES - END//
<br/>
<br/>
//FUNCTION DECLARATIONS - START//
<br/>
int main(void)
<br/>
{
<br/>
    for(int fillfield = 0; fillfield &lt;= 10; fillfield++){
<br/>
        field[fillfield][13] = 1;
<br/>
    }
<br/>
    map_fragment_info_ptr bg_game;
<br/>
    
<br/>
    map_fragment_info_ptr bg_title_screen;
<br/>
    ham_Init();
<br/>
    ham_SetBgMode(1);
<br/>
    ham_LoadBGPal((void*)master_Palette,256);
<br/>
    ham_LoadObjPal((void*)master_Palette,256);    
<br/>
    ham_bg[0].ti = ham_InitTileSet((void*)title_screen_Tiles, SIZEOF_16BIT(title_screen_Tiles),1,1);
<br/>
    ham_bg[0].mi = ham_InitMapEmptySet(3,0);
<br/>
    bg_title_screen = ham_InitMapFragment((void*)title_screen_Map, 30,20,0,0,30,20,0);
<br/>
    ham_InsertMapFragment(bg_title_screen,0,0,0);
<br/>
    
<br/>
    ham_InitBg(0,1,1,0);
<br/>
<br/>
    while(!F_CTRLINPUT_A_PRESSED)
<br/>
    {
<br/>
           //show logo :)
<br/>
    }
<br/>
    ham_ResetBg();
<br/>
    //ham_InitText(1);
<br/>
    ham_SetBgMode(1);
<br/>
    
<br/>
    ///ham_SetTextCol(000, 000);
<br/>
    // Setup the tileset for our image
<br/>
    ham_bg[1].ti = ham_InitTileSet((void*)game_bg_Tiles, SIZEOF_16BIT(game_bg_Tiles),1,1);
<br/>
    // Setup the map for our image
<br/>
    ham_bg[1].mi = ham_InitMapEmptySet(3,0);
<br/>
    bg_game = ham_InitMapFragment((void*)game_bg_Map, 30,20,0,0,30,20,0);
<br/>
    ham_InsertMapFragment(bg_game,1,0,0);
<br/>
    // Display the background
<br/>
<br/>
    ham_InitBg(1,1,0,0);
<br/>
    
<br/>
    ham_StartIntHandler(INT_TYPE_VBL,(void*)&amp;tick);
<br/>
    while(1)
<br/>
    {
<br/>
           //keep in eternal looopy
<br/>
    }
<br/>
    ham_ResetAll();
<br/>
    return 0;
<br/>
}
<br/>
<br/>
void tick(){
<br/>
    if(speedmultiplier &gt;= 20){
<br/>
        //DEBUG START
<br/>
        ham_VBAText("crap");
<br/>
        //DEBUG END
<br/>
        addcluster();
<br/>
        clusterfall();
<br/>
        speedmultiplier = 0;
<br/>
    }
<br/>
    checkcollision();
<br/>
    proces_input();
<br/>
    speedmultiplier += speed;
<br/>
    update();
<br/>
    completerow = checkrow();
<br/>
    ham_CopyObjToOAM();
<br/>
}
<br/>
<br/>
void update(){
<br/>
    for(int blockN = 0; blockN &lt;= 16; blockN++){
<br/>
        ham_SetObjX(block[blockN],block_x[blockN]);
<br/>
        ham_SetObjY(block[blockN],block_y[blockN]);
<br/>
    }
<br/>
    ham_DrawText(50,180,"00:01");
<br/>
}
<br/>
<br/>
void proces_input(){
<br/>
    if(controlspeed &gt; 5){
<br/>
            if(F_CTRLINPUT_UP_PRESSED)
<br/>
            {
<br/>
                //if (block_y[blockN] &gt; 0) block_y[blockN]-=12;
<br/>
                rotatecluster();
<br/>
            }
<br/>
<br/>
            if(F_CTRLINPUT_DOWN_PRESSED)
<br/>
            {
<br/>
                for(int blockN = 0; blockN &lt;= 16; blockN++){
<br/>
                    if (block_y[blockN] &lt; 140){
<br/>
                        block_y[blockN]+=12;
<br/>
                    }
<br/>
                }
<br/>
            }
<br/>
<br/>
            if(F_CTRLINPUT_LEFT_PRESSED)
<br/>
            {
<br/>
                for(int blockN = 0; blockN &lt;= 16; blockN++){
<br/>
                    if (block_x[blockN] &gt; 60){
<br/>
                        block_x[blockN]-=12;
<br/>
                    }
<br/>
                }
<br/>
            }
<br/>
<br/>
            if(F_CTRLINPUT_RIGHT_PRESSED)
<br/>
            {
<br/>
                for(int blockN = 0; blockN &lt;= 16; blockN++){
<br/>
                    if (block_x[blockN] &lt; 168){
<br/>
                        block_x[blockN]+=12;
<br/>
                    }
<br/>
                }
<br/>
            }
<br/>
        controlspeed = 0;
<br/>
    }
<br/>
    controlspeed++;
<br/>
}
<br/>
<br/>
void addcluster(){
<br/>
    if(bAddcluster == true){
<br/>
        createcluster("L");
<br/>
        bAddcluster = false;
<br/>
    }
<br/>
}
<br/>
<br/>
void rotatecluster(){
<br/>
    //NU DOEN!!
<br/>
    for(int blockN = 0; blockN &lt;= 16; blockN++){
<br/>
        block_y[blockN]-=12;
<br/>
        block_y[blockN]+=12;
<br/>
        block_x[blockN]-=12;
<br/>
        block_x[blockN]+=12;
<br/>
    }
<br/>
}
<br/>
<br/>
void clusterfall(){
<br/>
    for(int blockN = 0; blockN &lt;= 16; blockN++){
<br/>
        block_y[blockN]+=12;
<br/>
    }
<br/>
    for(int row = 0; row &lt;= 12; row++){
<br/>
        //check each row
<br/>
        for(int column = 0; column &lt;= 10; column++){
<br/>
            //check each column
<br/>
            if(field[row][column] == 2){
<br/>
                field[row][column-1] = 2;
<br/>
                field[row][column] = 0;
<br/>
                break;
<br/>
            }
<br/>
        }
<br/>
    }
<br/>
}
<br/>
<br/>
void createcluster(char* type){
<br/>
    clustertype = type;
<br/>
    if(type == "L"){
<br/>
        char Lclustershape[4][4] = {{0,2,0,0},{0,2,0,0},{0,2,2,0},{0,0,0,0}};
<br/>
        int Crow = 0;
<br/>
        int Ccol = 0;
<br/>
        for(int row = 13; row &gt;= 8; row--){
<br/>
            //check each row
<br/>
                for(int column = 2; column &lt; 7; column++){
<br/>
                    //check each column
<br/>
                    field[row][column] = Lclustershape[Crow][Ccol];
<br/>
                    Ccol++;
<br/>
                }
<br/>
            Crow++;
<br/>
        }
<br/>
        clusterpos_x = 120;
<br/>
        clusterpos_y = 0;
<br/>
        block_x[1] = clusterpos_x;
<br/>
        block_y[1] = clusterpos_y;
<br/>
        block_x[2] = clusterpos_x;
<br/>
        block_y[2] = clusterpos_y+12;
<br/>
        block_x[3] = clusterpos_x;
<br/>
        block_y[3] = clusterpos_y+24;
<br/>
        block_x[4] = clusterpos_x+12;
<br/>
        block_y[4] = clusterpos_y+24;
<br/>
        block[1] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[1],block_y[1]);
<br/>
        block[2] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[2],block_y[2]);
<br/>
        block[3] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[3],block_y[3]);
<br/>
        block[4] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[4],block_y[4]);
<br/>
    }
<br/>
}
<br/>
<br/>
int checkrow(){
<br/>
    int fullrow;
<br/>
    for(int row = 0; row &lt;= 12; row++){
<br/>
        //check each row
<br/>
        if(fullrow == -1){
<br/>
            for(int column = 0; column &lt;= 10; column++){
<br/>
                //check each column
<br/>
                if(field[row][column] == 0){
<br/>
                    fullrow = -1;
<br/>
                    break;
<br/>
                }else{
<br/>
                    fullrow = row;
<br/>
                }
<br/>
            }
<br/>
        }else{
<br/>
            break;
<br/>
        }
<br/>
    }
<br/>
    return fullrow;
<br/>
}
<br/>
<br/>
void makestatic(){
<br/>
    for(int blockN = 0; blockN &lt;= 16; blockN++){
<br/>
        staticblock[currentstaticblock] = block[blockN];
<br/>
        block[blockN] = 0;
<br/>
        currentstaticblock++;
<br/>
    }
<br/>
    for(int row = 0; row &lt;= 12; row++){
<br/>
        //check each row
<br/>
        for(int column = 0; column &lt;= 10; column++){
<br/>
            //check each column
<br/>
            if(field[row][column] == 2){
<br/>
                field[row][column] = 1;
<br/>
            }
<br/>
        }
<br/>
    }
<br/>
    bAddcluster=true;
<br/>
}
<br/>
<br/>
void checkcollision(){
<br/>
    for(int row = 0; row &lt; 13; row++){
<br/>
        //check each row
<br/>
        for(int column = 0; column &lt;= 10; column++){
<br/>
            //check each column
<br/>
            if(field[row][column] == 2){
<br/>
                if(field[row][column+1] == 1){
<br/>
                makestatic();
<br/>
                break;
<br/>
            }
<br/>
            }else{
<br/>
<br/>
            }
<br/>
        }
<br/>
    }
<br/>
}
<br/>
//FUNCTION DECLARATIONS - END//</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks in advance :)[/url]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#64787 - zazery - Mon Dec 26, 2005 7:58 pm</h4>
    <div class="postbody"><span class="postbody">It looks like the first sprite isn't initialized properly. The block_x and block_y arrays are initialized starting at index one, yet whenever you loop through all the blocks you start at index zero. Also many loops go from 0-16, when the array is 0-15 (including 0 makes the entire size 16), for example in the process_input() function. Since you didn't use index zero for the sprite, it is being drawn. I could be wrong, but I think that's your problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#64790 - vexon - Mon Dec 26, 2005 8:18 pm</h4>
    <div class="postbody"><span class="postbody">I think I see your point I have changed a lot of code in the meanwhile. Though I might have screwed up the arrays so I'm changing those now.
<br/>
I'll let you know if it works when done. If anybody has any suggestions to my code design please tell :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#64802 - tepples - Mon Dec 26, 2005 10:32 pm</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://everything2.com/?node=Tetris%20pseudocode" target="_blank">How to develop a tetris clone</a><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#64806 - vexon - Mon Dec 26, 2005 11:13 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Ya'll hehe my game finally works. I need to get the text to work though should be some pallet isue or something.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#64843 - vexon - Tue Dec 27, 2005 12:10 pm</h4>
    <div class="postbody"><span class="postbody">heh well I've just changed an array and now my graphics are screwed up while that array has nothing to do with graphics.
<br/>
for those who are interested here's my current gba file: <a class="postlink" href="http://download.sigma-interactions.com/Tetrix.gba" target="_blank">here it isss</a>
<br/>
<br/>
Here's the bit of code that seems to screw it up:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">char Lclustershape[3][2] = {{2,0},{2,0},{2,2}};
<br/>
        char Lclustershape[3][2] = {{2,0},{2,0},{2,2}};
<br/>
        int Crow = 0;
<br/>
        int Ccol = 0;
<br/>
        for(int row = 0; row &lt; 3; row++){
<br/>
            //check each row
<br/>
                for(int column = 5; column &lt; 7; column++){
<br/>
                    //check each column
<br/>
                    field[row][column] = Lclustershape[Crow][Ccol];
<br/>
                    Ccol++;
<br/>
                }
<br/>
            Ccol = 0;
<br/>
            Crow++;
<br/>
        }
<br/>
        Crow=0;
<br/>
        }</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
And here's the actual code I have now the collision detection is not fully working yet and neither optimized.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;mygba.h&gt;
<br/>
<br/>
//GFX INCLUDES - START//
<br/>
    #include "GFX\master.pal.c";
<br/>
    //titlescreen
<br/>
    #include "GFX\title_screen.raw.c";
<br/>
    #include "GFX\title_screen.map.c";
<br/>
    //logo screen (credits)
<br/>
    //game bg
<br/>
    #include "GFX\game_bg.raw.c";
<br/>
    #include "GFX\game_bg.map.c";
<br/>
    //block
<br/>
    #include "GFX\block.raw.c";
<br/>
//GFX INCLUDES - END//
<br/>
<br/>
//GLOBAL VARIABLES - START//
<br/>
    bool bAddcluster = true;
<br/>
    char* keypressed;
<br/>
    int speed = 1;
<br/>
    int speedmultiplier = 0;
<br/>
    int controlspeed = 0;
<br/>
    int score = 0;
<br/>
    int time = 0;
<br/>
    u8 tickcount=0;
<br/>
    u8 block[4];
<br/>
    u8 u8nextcluster[4];
<br/>
    char* upcomingcluster ="L";
<br/>
    u8 staticblock[120];
<br/>
    u8 currentstaticblock=0;
<br/>
    u8 block_y[4];
<br/>
    u8 block_x[4];
<br/>
    char* clustertype;
<br/>
    u8 clusterpos_x;
<br/>
    u8 clusterpos_y;
<br/>
    u8 clusterorientation=0;
<br/>
    int completerow;
<br/>
    char field[10][12]; //rows, colls
<br/>
    bool moveleft;
<br/>
    bool moveright;
<br/>
//GLOBAL VARIABLES - END//
<br/>
<br/>
//FUNCTION PROTOTYPES - START//
<br/>
    void tick(); //every frame (60 a second)
<br/>
    void nextcluster();
<br/>
    void update(); //updates movement
<br/>
    void proces_input(); //looks for input and what to do then
<br/>
    void addcluster(); //adds a another block combination to fall from the sky
<br/>
    void clusterfall(); //let's  a cluster drop
<br/>
    void rotatecluster(); //rotate that cluster 90 degrees
<br/>
    void createcluster(char* type); //create a new cluster
<br/>
    int movecluster(); //move cluster
<br/>
    int checkrow(); //check if there's a full row
<br/>
    void makestatic(); //deactivate the cluster if it's grounded
<br/>
    void checkcollision(); //check for collision to see it can be made static.
<br/>
//FUNCTION PROTOTYPES - END//
<br/>
<br/>
//FUNCTION DECLARATIONS - START//
<br/>
int main(void)
<br/>
{
<br/>
    ham_InitText(1);
<br/>
    map_fragment_info_ptr bg_game;
<br/>
    
<br/>
    map_fragment_info_ptr bg_title_screen;
<br/>
    ham_Init();
<br/>
    ham_SetBgMode(1);
<br/>
    ham_LoadBGPal((void*)master_Palette,256);
<br/>
    ham_LoadObjPal((void*)master_Palette,256);    
<br/>
    ham_bg[0].ti = ham_InitTileSet((void*)title_screen_Tiles, SIZEOF_16BIT(title_screen_Tiles),1,1);
<br/>
    ham_bg[0].mi = ham_InitMapEmptySet(3,0);
<br/>
    bg_title_screen = ham_InitMapFragment((void*)title_screen_Map, 30,20,0,0,30,20,0);
<br/>
    ham_InsertMapFragment(bg_title_screen,0,0,0);
<br/>
    
<br/>
    ham_InitBg(0,1,1,0);
<br/>
<br/>
    while(!F_CTRLINPUT_A_PRESSED)
<br/>
    {
<br/>
           //show logo :)
<br/>
    }
<br/>
    ham_ResetBg();
<br/>
    
<br/>
    ham_SetBgMode(1);
<br/>
    
<br/>
    //ham_SetTextCol(666, 666);
<br/>
    // Setup the tileset for our image
<br/>
    ham_bg[1].ti = ham_InitTileSet((void*)game_bg_Tiles, SIZEOF_16BIT(game_bg_Tiles),1,1);
<br/>
    // Setup the map for our image
<br/>
    ham_bg[1].mi = ham_InitMapEmptySet(3,0);
<br/>
    bg_game = ham_InitMapFragment((void*)game_bg_Map, 30,20,0,0,30,20,0);
<br/>
    ham_InsertMapFragment(bg_game,1,0,0);
<br/>
    // Display the background
<br/>
<br/>
    ham_InitBg(1,1,0,0);
<br/>
    
<br/>
    ham_StartIntHandler(INT_TYPE_VBL,(void*)&amp;tick);
<br/>
<br/>
    while(1)
<br/>
    {
<br/>
           //keep in eternal looopy
<br/>
    }
<br/>
    ham_ResetAll();
<br/>
    return 0;
<br/>
}
<br/>
<br/>
void tick(){
<br/>
    if(speedmultiplier &gt; 20){
<br/>
        //DEBUG START
<br/>
       // ham_VBAText("crap");
<br/>
        //DEBUG END
<br/>
        addcluster();
<br/>
        clusterfall();
<br/>
        speedmultiplier = 0;
<br/>
    }
<br/>
    checkcollision();
<br/>
    proces_input();
<br/>
    speedmultiplier += speed;
<br/>
    completerow = checkrow();
<br/>
    update();
<br/>
    ham_CopyObjToOAM();
<br/>
}
<br/>
<br/>
void update(){
<br/>
    for(int blockN = 0; blockN &lt; 4; blockN++){
<br/>
        ham_SetObjX(block[blockN],block_x[blockN]);
<br/>
        ham_SetObjY(block[blockN],block_y[blockN]);
<br/>
    }
<br/>
    ham_DrawText(50,180,"00:01");
<br/>
}
<br/>
<br/>
void proces_input(){
<br/>
    if(controlspeed &gt; 5){
<br/>
            if(F_CTRLINPUT_UP_PRESSED)
<br/>
            {
<br/>
                rotatecluster();
<br/>
            }
<br/>
<br/>
            if(F_CTRLINPUT_DOWN_PRESSED)
<br/>
            {
<br/>
                for(int blockN = 0; blockN &lt; 4; blockN++){
<br/>
                        block_y[blockN]+=12;
<br/>
                }
<br/>
            }
<br/>
<br/>
            if(F_CTRLINPUT_LEFT_PRESSED)
<br/>
            {
<br/>
                for(int row = 0; row &lt; 12; row++){
<br/>
                        //check each row
<br/>
                        for(int column = 0; column &lt; 10; column++){
<br/>
                            //check each column
<br/>
                            if(field[row][column] == 2){
<br/>
                                if(field[row][column-1] == 1 || column == 0){
<br/>
                                    moveleft = false;
<br/>
                                }else{
<br/>
                                    moveleft = true;
<br/>
                                }
<br/>
                            }
<br/>
                        }
<br/>
                }
<br/>
                if(moveleft == true){
<br/>
                    for(int blockN = 0; blockN &lt; 4; blockN++){
<br/>
                        block_x[blockN]-=12;
<br/>
                    }
<br/>
                    for(int row = 0; row &lt; 12; row++){
<br/>
                        //check each row
<br/>
                        for(int column = 0; column &lt; 10; column++){
<br/>
                            //check each column
<br/>
                            if(field[row][column] == 2){
<br/>
                                field[row][column-1] = 2;
<br/>
                                field[row][column] = 0;
<br/>
                                break;
<br/>
                            }
<br/>
                        }
<br/>
                    }
<br/>
                }
<br/>
            }
<br/>
<br/>
            if(F_CTRLINPUT_RIGHT_PRESSED)
<br/>
            {
<br/>
                for(int row = 0; row &lt; 12; row++){
<br/>
                        //check each row
<br/>
                        for(int column = 0; column &lt; 10; column++){
<br/>
                            //check each column
<br/>
                            if(field[row][column] == 2){
<br/>
                                if(field[row][column+1] == 1 || column == 9){
<br/>
                                    moveright = false;
<br/>
                                }else{
<br/>
                                    moveright = true;
<br/>
                                }
<br/>
                            }
<br/>
                        }
<br/>
                }
<br/>
                if(moveright == true){
<br/>
                    for(int blockN = 0; blockN &lt; 4; blockN++){
<br/>
                                block_x[blockN]+=12;
<br/>
                    }
<br/>
                    for(int row = 0; row &lt; 12; row++){
<br/>
                        //check each row
<br/>
                        for(int column = 0; column &lt; 10; column++){
<br/>
                            //check each column
<br/>
                            if(field[row][column] == 2){
<br/>
                                field[row][column+1] = 2;
<br/>
                                field[row][column] = 0;
<br/>
                                break;
<br/>
                            }
<br/>
                        }
<br/>
                    }
<br/>
                }
<br/>
            }
<br/>
        controlspeed = 0;
<br/>
    }
<br/>
    controlspeed++;
<br/>
}
<br/>
<br/>
void addcluster(){
<br/>
    if(bAddcluster == true){
<br/>
        createcluster(upcomingcluster);
<br/>
        nextcluster();
<br/>
        bAddcluster = false;
<br/>
    }
<br/>
}
<br/>
<br/>
void rotatecluster(){
<br/>
    //NU DOEN!!
<br/>
    /*switch(clusterorientation){
<br/>
        case 0:
<br/>
        block_y[1]+=24;
<br/>
        block_x[1]-=12;
<br/>
        block_x[2]+=12;
<br/>
        clusterorientation+=90;
<br/>
        break;
<br/>
        case 90:
<br/>
        block_y[1]-=24;
<br/>
        block_x[1]+=12;
<br/>
        block_x[3]+=12;
<br/>
        block_y[3]-=36;
<br/>
        block_x[2]+=12;
<br/>
        clusterorientation+=90;
<br/>
        break;
<br/>
        case 180:
<br/>
        block_y[1]+=24;
<br/>
        clusterorientation+=90;
<br/>
        break;
<br/>
        case 270:
<br/>
        block_y[1]+=24;
<br/>
        clusterorientation=0;
<br/>
        break;
<br/>
    }*/
<br/>
    //}
<br/>
}
<br/>
<br/>
void clusterfall(){
<br/>
    for(int blockN = 0; blockN &lt; 4; blockN++){
<br/>
        block_y[blockN]+=12;
<br/>
    }
<br/>
    for(int row = 11; row &gt;= 0; row--){
<br/>
        //check each row
<br/>
        for(int column = 0; column &lt; 10; column++){
<br/>
            //check each column
<br/>
            if(field[row][column] == 2){
<br/>
                field[row+1][column] = 2;
<br/>
                field[row][column] = 0;
<br/>
                break;
<br/>
            }
<br/>
        }
<br/>
    }
<br/>
}
<br/>
<br/>
void createcluster(char* type){
<br/>
    clustertype = type;
<br/>
    if(type == "L"){
<br/>
        char Lclustershape[3][2] = {{2,0},{2,0},{2,2}};
<br/>
        int Crow = 0;
<br/>
        int Ccol = 0;
<br/>
        for(int row = 0; row &lt; 3; row++){
<br/>
            //check each row
<br/>
                for(int column = 5; column &lt; 7; column++){
<br/>
                    //check each column
<br/>
                    field[row][column] = Lclustershape[Crow][Ccol];
<br/>
                    Ccol++;
<br/>
                }
<br/>
            Ccol = 0;
<br/>
            Crow++;
<br/>
        }
<br/>
        Crow=0;
<br/>
        clusterpos_x = 107;
<br/>
        clusterpos_y = 11;
<br/>
        block_x[0] = clusterpos_x;
<br/>
        block_y[0] = clusterpos_y;
<br/>
        block_x[1] = clusterpos_x;
<br/>
        block_y[1] = clusterpos_y+12;
<br/>
        block_x[2] = clusterpos_x;
<br/>
        block_y[2] = clusterpos_y+24;
<br/>
        block_x[3] = clusterpos_x+12;
<br/>
        block_y[3] = clusterpos_y+24;
<br/>
        block[0] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[0],block_y[0]);
<br/>
        block[1] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[1],block_y[1]);
<br/>
        block[2] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[2],block_y[2]);
<br/>
        block[3] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, block_x[3],block_y[3]);
<br/>
    }
<br/>
}
<br/>
<br/>
int checkrow(){
<br/>
    int fullrow;
<br/>
    for(int row = 0; row &lt; 12; row++){
<br/>
        //check each row
<br/>
        if(fullrow == -1){
<br/>
            for(int column = 0; column &lt; 10; column++){
<br/>
                //check each column
<br/>
                if(field[row][column] == 0){
<br/>
                    fullrow = -1;
<br/>
                    break;
<br/>
                }else if(field[row][column] == 1){
<br/>
                    fullrow = row;
<br/>
                }
<br/>
            }
<br/>
        }else{
<br/>
            break;
<br/>
        }
<br/>
    }
<br/>
    return fullrow;
<br/>
}
<br/>
<br/>
void makestatic(){
<br/>
    for(int blockN = 0; blockN &lt; 4; blockN++){
<br/>
        staticblock[currentstaticblock] = block[blockN];
<br/>
        block[blockN] = 0;
<br/>
        currentstaticblock++;
<br/>
    }
<br/>
    for(int row = 0; row &lt; 12; row++){
<br/>
        //check each row
<br/>
        for(int column = 0; column &lt; 10; column++){
<br/>
            //check each column
<br/>
            if(field[row][column] == 2){
<br/>
                field[row][column] = 1;
<br/>
            }
<br/>
        }
<br/>
    }
<br/>
    bAddcluster=true;
<br/>
}
<br/>
<br/>
void checkcollision(){
<br/>
    for(int row = 0; row &lt; 12; row++){
<br/>
        //check each row
<br/>
        for(int column = 0; column &lt; 10; column++){
<br/>
            //check each column
<br/>
            if(field[row][column] == 2){
<br/>
                if(field[row+1][column] == 1 || row==11){
<br/>
                    makestatic();
<br/>
                }
<br/>
            }
<br/>
        }
<br/>
    }
<br/>
}
<br/>
<br/>
void nextcluster(){
<br/>
    upcomingcluster = "L";
<br/>
    if(upcomingcluster == "L"){
<br/>
        u8nextcluster[0] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, 200,15);
<br/>
        u8nextcluster[1] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, 200,27);
<br/>
        u8nextcluster[2] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, 200,39);
<br/>
        u8nextcluster[3] = ham_CreateObj((void*)block_Bitmap, 0, 1,OBJ_MODE_NORMAL,1,0,0,0,0,0,0, 212,39);
<br/>
    }
<br/>
}
<br/>
//FUNCTION DECLARATIONS - END//
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#64860 - zazery - Tue Dec 27, 2005 9:05 pm</h4>
    <div class="postbody"><span class="postbody">It looks like the graphics are messed up already in the title screen. Checking the vram in VBA it looks like you're not adding the tiles correctly, and since ham takes care of that I'm not sure how to suggest to fix that. Did you change any of the ham calls when you redid the array code? 
<br/>
<br/>
One small thing I noticed is that you call ham_InitText(1), before ham_Init(), but then again I've never used ham so that might not be the problem.
<br/>
<br/>
I strongly recommend is commenting out rotation, adding new pieces and everything else except having one piece being displayed and the ability to move it around (up included for debugging). You're trying to design the multiple shapes before actually getting one properly being displayed. It was one of the mistakes I made when designing my version of tetris.
<br/>
<br/>
Hope that helps.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#64881 - wintermute - Wed Dec 28, 2005 1:20 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vexon wrote:</b></span></td> </tr> <tr> <td class="quote">heh well I've just changed an array and now my graphics are screwed up while that array has nothing to do with graphics.
<br/>
for those who are interested here's my current gba file: <a class="postlink" href="http://download.sigma-interactions.com/Tetrix.gba" target="_blank">here it isss</a>
<br/>
<br/>
Here's the bit of code that seems to screw it up:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;mygba.h&gt;
<br/>
<br/>
//GFX INCLUDES - START//
<br/>
    #include "GFX\master.pal.c";
<br/>
    //titlescreen
<br/>
    #include "GFX\title_screen.raw.c";
<br/>
    #include "GFX\title_screen.map.c";
<br/>
    //logo screen (credits)
<br/>
    //game bg
<br/>
    #include "GFX\game_bg.raw.c";
<br/>
    #include "GFX\game_bg.map.c";
<br/>
    //block
<br/>
    #include "GFX\block.raw.c";
<br/>
//GFX INCLUDES - END//
<br/>
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
<br/>
#including c files is extremely bad practice for many reasons and entirely defeats the point of having separate files. The preprocessor includes these files verbatim in the file you're trying to build which effectively means your project is one very large file. Data arrays in particular use horrendous amounts of memory when compiling, slowing down the build process.
<br/>
<br/>
The problems you're seeing sound like your graphics data has not been explicitly aligned and other data is affecting the alignment.
<br/>
<br/>
When defining a char array which will be later copied to VRAM you need at least 16 bit alignment but 32 bit is more usual to allow for 32bit DMA copy or CPUFastSet. You may find an aligment macro like the one here somewhere in the HAM headers, it's fairly common and, imo, a necessity for most projects.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
// C file declaring data array
<br/>
<br/>
// macro to set alignment in bytes
<br/>
#define ALIGN(m)   __attribute__((aligned (m)))
<br/>
<br/>
// 32bit (4 byte) aligned char array
<br/>
const char data[] ALIGN(4) = { ... };
<br/>
<br/>
// declare the size of the array for other files
<br/>
const int data_size = sizeof(data);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
When using arrays as data it is much better to compile them individually rather than using #include to insert it in your main source file. You should use a header file like this ( using the above code as an example)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// H file included by files which need to access the data
<br/>
<br/>
#ifndef _data_h_
<br/>
#define _data_h_
<br/>
<br/>
extern const char data[];
<br/>
extern const int data_size;
<br/>
<br/>
#endif // _data_h_
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Then #include this header in the file and not the C file.
<br/>
<br/>
Visual HAM generates a makefile which should allow for compiling object files individually.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65564 - vexon - Tue Jan 03, 2006 11:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>zazery wrote:</b></span></td> </tr> <tr> <td class="quote">Did you change any of the ham calls when you redid the array code?</td> </tr></table><span class="postbody">
<br/>
<br/>
Nope, I can just comment out the array code and the game displays fine except that it's not working properly but that's because the shape isn't inserted into the field array.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65630 - Cearn - Wed Jan 04, 2006 3:05 pm</h4>
    <div class="postbody"><span class="postbody">Yup, that's a data-alignment problem. ham_InitTileSet uses a 32-bit DMA to copy the tiles and I'm thinking you're using either u8 or u16 arrays. Now, if you're compiling data separately that's usually not a problem because individual files are always aligned properly, but as you're #including them and have a whole slew of non-word variables, misalignment is almost guaranteed.
<br/>
<br/>
It look like you're using gfx2gba for your graphics conversion. I believe that has a switch to ensure word alignment ... -align, maybe? Or you can use u32 arrays, which are always properly aligned.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
