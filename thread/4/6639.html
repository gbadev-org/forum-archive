<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Mysterious interrupt issue - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Mysterious interrupt issue</h2>
<div id="posts">
<div class="post">
    <h4>#51563 - jarobi - Sun Aug 21, 2005 9:22 pm</h4>
    <div class="postbody"><span class="postbody">I have just started getting into interrupts and for some reason, they are not working for me.  I have looked at numerous threads regarding the issue, but I can't seem to find any info that helps me out.  Since I do not have the time to learn ARM assembly, I have used the IrqHandler routine from The PERN Project website (day 4 in tutorials).  I have also modified the interrupt.h from that same tutorial.  I have checked the assembler instructions at 0x3007ffc and the IrqHandler routine is there.  However, when I load my ISR into the IntrTable and enable interrupts, absolutely nothing happens.  Everything seems to be in the right place, which makes things very confusing for me now.  The code (partial) below should move a 32x32 px window one pixel down and one pixel right during vblank:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//
<br/>
// interrupt.h
<br/>
//
<br/>
#define INT_VBLANK      0x0001
<br/>
#define INT_HBLANK      0x0002
<br/>
#define INT_VCOUNT      0x0004
<br/>
#define INT_TIMER0      0x0008
<br/>
#define INT_TIMER1      0x0010
<br/>
#define INT_TIMER2      0x0020
<br/>
#define INT_TIMER3      0x0040
<br/>
#define INT_SERIALCOM   0x0080 //serial communication interupt
<br/>
#define INT_DMA0      0x0100
<br/>
#define INT_DMA1      0x0200
<br/>
#define INT_DMA2      0x0400
<br/>
#define INT_DMA3      0x0800
<br/>
#define INT_KEYPAD      0x1000
<br/>
#define INT_CART      0x2000
<br/>
<br/>
void interruptEnable(); //sets REG_IME to 1
<br/>
void interruptDisable(); //sets REG_IME to 0
<br/>
void irqEnable(int, fp); //enables an interrupt request for a given interrupt
<br/>
void irqDisable(int); //disables an interrupt request
<br/>
<br/>
//
<br/>
// interrupt.c
<br/>
//
<br/>
extern void IrqHandler();
<br/>
<br/>
fp IntrTable[14];
<br/>
<br/>
void interruptEnable()
<br/>
{
<br/>
   REG_IME = 1;
<br/>
}
<br/>
<br/>
void interruptDisable()
<br/>
{
<br/>
   REG_IME = 0;
<br/>
}
<br/>
<br/>
void irqEnable(int irqId, fp irq_funct)
<br/>
{
<br/>
   int i, j, prevIMEval;
<br/>
<br/>
   for (i = 0, j = 1; i &lt; 14; i++, j&lt;&lt;=1)
<br/>
   {
<br/>
      if ((j &amp; irqId) != 0)
<br/>
      {
<br/>
         IntrTable[i] = irq_funct;
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   REG_IRQHAND = IrqHandler;
<br/>
   prevIMEval = REG_IME;
<br/>
   REG_IME = 0;
<br/>
   REG_IE |= irqId;
<br/>
   REG_IME = prevIMEval;
<br/>
}
<br/>
<br/>
void irqDisable(int irqId)
<br/>
{
<br/>
   int prevIMEval;
<br/>
   prevIMEval = REG_IME;
<br/>
   REG_IME = 0;
<br/>
   REG_IE ^= irqId;
<br/>
   REG_IME = prevIMEval;
<br/>
}
<br/>
<br/>
//
<br/>
// irqh.s
<br/>
//
<br/>
@ Interrupt Request Handler taken from "The Pern Project"
<br/>
@ http://www.thepernproject.com/tutorials/GBA/day_4.html
<br/>
       .SECTION    .iwram,"ax",%progbits
<br/>
       .EXTERN     IntrTable
<br/>
       .GLOBAL     IrqHandler
<br/>
       .ALIGN
<br/>
         .ARM
<br/>
<br/>
IrqHandler:
<br/>
                                         @ Multiple interrupts support
<br/>
        mov     r2, #0x4000000           @ REG_BASE
<br/>
        ldr     r3, [r2,#0x200]!         @ r2 = IE : r3 = IF|IE
<br/>
        ldrh    r1, [r2, #0x8]           @ r1 = IME
<br/>
        mrs     r0, spsr
<br/>
        stmfd   sp!, {r0-r2,lr}          @ {spsr, IME, REG_IE, lr}
<br/>
        mov     r0, #1                   @ IME = 1 
<br/>
        strh    r0, [r2, #0x8]
<br/>
        and     r1, r3, r3, lsr #16      @ r1 = IE &amp; IF
<br/>
<br/>
        @BIOS uses 0x300:7FF8 to hold IRQ flags for certain functions
<br/>
        @such as IntrWait
<br/>
        
<br/>
        ldrh    r3, [r2, #-8]             @ r3 = [0x300:7FF8] 
<br/>
        orr     r3, r3, r1                @ r3 |= IF &amp; IE                    
<br/>
        strh    r3, [r2, #-8]             @ [0x300:7FF8] = r3 
<br/>
<br/>
        @Set r12 to point to our IRQ table
<br/>
        ldr     r12, =IntrTable
<br/>
<br/>
        @cycle through IF checking to see if the bits are set.
<br/>
        @if set we jump to the interrupt table
<br/>
        ands    r0, r1, #1               @ V-blank interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #2               @ H-blank interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #4               @ V-counter interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #8               @ Timer 0 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x10            @ Timer 1 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x20            @ Timer 2 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x40            @ Timer 3 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x80            @ Serial Comm Interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x100           @ DMA 0 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x200           @ DMA 1 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x400           @ DMA 2 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x800           @ DMA 3 interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x1000          @ Key interrupt
<br/>
        bne     jump_intr
<br/>
        add     r12,r12, #4
<br/>
        ands    r0, r1, #0x2000          @ Cart interrupt
<br/>
        strneb  r0, [r3, #0x84 - 0x200]  @ Stop sound if cart removed (REG_SOUNDCNT_X)
<br/>
<br/>
jump_intr:
<br/>
        strh    r0, [r2, #2]             @ Clear IF
<br/>
        mrs     r3, cpsr
<br/>
        bic     r3, r3, #0xdf            @ Stack stuff
<br/>
        orr     r3, r3, #0x1f            @ 
<br/>
        msr     cpsr, r3
<br/>
        ldr     r0, [r12]
<br/>
        stmfd   sp!, {lr}
<br/>
        adr     lr, IntrRet
<br/>
        bx      r0
<br/>
<br/>
IntrRet:
<br/>
        ldmfd   sp!, {lr}
<br/>
        mrs     r3, cpsr
<br/>
        bic     r3, r3, #0xdf            @ 
<br/>
        orr     r3, r3, #0x92            @ 
<br/>
        msr     cpsr, r3
<br/>
        ldmfd   sp!, {r0-r2,lr}          @ {spsr, IME, REG_IE, lr}
<br/>
        strh    r1,  [r2, #0x8]          @ restore REG_IME
<br/>
        msr     spsr, r0                 @ restore spsr
<br/>
        bx      lr
<br/>
<br/>
    .ALIGN
<br/>
    .POOL
<br/>
<br/>
//
<br/>
// main.c 
<br/>
//
<br/>
#define WIN_SIZE 32
<br/>
<br/>
int i = 0, j = 0;
<br/>
<br/>
void doSomething()
<br/>
{
<br/>
   setWin0Bounds(i++, i+32, j++, j+32);
<br/>
}
<br/>
<br/>
int main()
<br/>
{
<br/>
   Background demon_bk;
<br/>
   
<br/>
   irqEnable(INT_VBLANK, doSomething);
<br/>
   interruptEnable();
<br/>
   
<br/>
   demon_bk.bgNumber = 2;
<br/>
   demon_bk.attributes = BG_COLOR_256
<br/>
                  |ROTBG_SIZE_1
<br/>
                  |BG_PRIORITY(3)
<br/>
                  |CHAR_BASE_BLOCK(0)
<br/>
                  |SCREEN_BASE_BLOCK(24)
<br/>
                  |WRAP_AROUND;
<br/>
   
<br/>
   loadBGPalette(demonPal);
<br/>
   loadBGTiles((u16*)demonData, 0, 256, 0);
<br/>
   loadBGMap(demon_map, 24, 16, 16);
<br/>
   
<br/>
   REG_BG2CNT = demon_bk.attributes;
<br/>
   
<br/>
   setWin0Content(W0_BG2);
<br/>
   
<br/>
   setMode(MODE_2|BG2_ENABLE|WIN0_ENABLE);
<br/>
   while (1)
<br/>
   {
<br/>
      waitForVBlank();
<br/>
   }
<br/>
   
<br/>
   return 0;
<br/>
}
<br/>
<br/>
//
<br/>
// window.h
<br/>
//
<br/>
//Window 0 content flags (inside window)
<br/>
#define W0_BG0 0x1
<br/>
#define W0_BG1 0x2
<br/>
#define W0_BG2 0x4
<br/>
#define W0_BG3 0x8
<br/>
#define W0_SPRITE 0x10
<br/>
#define W0_BLEND 0x20
<br/>
<br/>
//Window 1 content flags (inside window)
<br/>
#define W1_BG0 0x100
<br/>
#define W1_BG1 0x200
<br/>
#define W1_BG2 0x400
<br/>
#define W1_BG3 0x800
<br/>
#define W1_SPRITE 0x1000
<br/>
#define W1_BLEND 0x2000
<br/>
<br/>
//Window Out content flags (outside window)
<br/>
#define WOUT_BG0 0x1
<br/>
#define WOUT_BG1 0x2
<br/>
#define WOUT_BG2 0x4
<br/>
#define WOUT_BG3 0x8
<br/>
#define WOUT_SPRITE 0x10
<br/>
#define WOUT_BLEND 0x20
<br/>
<br/>
//Object Window content flags (in object window)
<br/>
#define WOBJ_BG0 0x100
<br/>
#define WOBJ_BG1 0x200
<br/>
#define WOBJ_BG2 0x400
<br/>
#define WOBJ_BG3 0x800
<br/>
#define WOBJ_SPRITE 0x1000
<br/>
#define WOBJ_BLEND 0x2000
<br/>
<br/>
#define setWin0Content(n) (REG_WININ=(REG_WININ&amp;=0x3f00)|(n&amp;0x3f))
<br/>
#define setWin1Content(n) (REG_WININ=(REG_WININ&amp;=0x3f)|(n&amp;0x3f00))
<br/>
#define setWinOutContent(n) (REG_WINOUT=(REG_WINOUT&amp;=0x3f00)|(n&amp;0x3f))
<br/>
#define setWinObjContent(n) (REG_WINOUT=(REG_WINOUT&amp;=0x3f)|(n&amp;0x3f00))
<br/>
<br/>
#define setWin0Bounds(x1, x2, y1, y2) REG_WIN0H=((x1)&lt;&lt;8)|(x2);REG_WIN0V=((y1)&lt;&lt;8)|(y2);
<br/>
#define setWin1Bounds(x1, x2, y1, y2) REG_WIN1H=((x1)&lt;&lt;8)|(x2);REG_WIN1V=((y1)&lt;&lt;8)|(y2);
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>Nihongo o hanasemasen!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#51575 - DekuTree64 - Mon Aug 22, 2005 1:01 am</h4>
    <div class="postbody"><span class="postbody">You also need to set the VBlank interrupt bit in REG_DISPSTAT. 
<br/>
<br/>
The logic behind it is that each piece of hardware that can generate an interrupt has a bit to enable it (in DISPSTAT, the timer regs, DMA regs, etc), and then REG_IE is like a bunch of AND gates to block those signals if you want to.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#51579 - jarobi - Mon Aug 22, 2005 2:58 am</h4>
    <div class="postbody"><span class="postbody">Oh, geez. How could I have missed that?  Thank you very much, DekuTree64, your advice has helped my code work.  On another note, one thing I have noticed is that when my isr runs via an interrupt, it is much slower than when it is called directly in my main loop with a waitForVBlank routine.  Is there severe overhead in using interrupts?<br/>_________________<br/>Nihongo o hanasemasen!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
