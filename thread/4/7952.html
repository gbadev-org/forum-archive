<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Modify Program to use memcpy and memset - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Modify Program to use memcpy and memset</h2>
<div id="posts">
<div class="post">
    <h4>#65193 - jake2431 - Sat Dec 31, 2005 6:20 am</h4>
    <div class="postbody"><span class="postbody">Hi, I am reading Programming the "Nintendo Game Boy Advance" and one of the challenges is to modify the following code to use memset and memcopy(from string.h).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define MULTIBOOT int __gba_multiboot;
<br/>
MULTIBOOT
<br/>
<br/>
//add support for rand function
<br/>
#include &lt;stdlib.h&gt;
<br/>
<br/>
//declare the function prototype
<br/>
void DrawPixel3(int, int, unsigned short);
<br/>
void DrawBox3(int,int,int,int, unsigned short);
<br/>
<br/>
//declare some defines for the video mode
<br/>
#define REG_DISPCNT *(unsigned long*)0x4000000
<br/>
#define MODE_3 0x3
<br/>
#define BG2_ENABLE 0x400
<br/>
<br/>
//changes the video mode
<br/>
#define SetMode(mode) REG_DISPCNT = (mode)
<br/>
<br/>
//packs three values into a 15-bit color
<br/>
#define RGB(r,g,b) ((r) + (g&lt;&lt;5) + (b&lt;&lt;10))
<br/>
<br/>
//create a pointer to the video buffer
<br/>
unsigned short *videoBuffer = (unsigned short*)0x6000000;
<br/>
<br/>
int main(void)
<br/>
{
<br/>
    int x1;
<br/>
    int y1;
<br/>
    int x2;
<br/>
    int y2;
<br/>
    unsigned short color;
<br/>
    
<br/>
    SetMode(MODE_3 | BG2_ENABLE);
<br/>
    
<br/>
    while(1)
<br/>
    {
<br/>
        x1 = rand() % 240;
<br/>
        y1 = rand() % 160;
<br/>
        x2 = x1 + rand() % 60;
<br/>
        y2 = y1 + rand() % 60;
<br/>
        color = RGB(rand()%31, rand()%31, rand()%31);
<br/>
        
<br/>
        DrawBox3(x1,y1,x2,y2, color);
<br/>
    }
<br/>
    return 0;
<br/>
}
<br/>
<br/>
void DrawPixel3(int x, int y, unsigned short color)
<br/>
{
<br/>
    videoBuffer[y * 240 + x] = color;
<br/>
}
<br/>
<br/>
void DrawBox3(int left, int top, int right, int bottom, unsigned short color)
<br/>
{
<br/>
    int x;
<br/>
    int y;
<br/>
<br/>
    for(y = top; y&lt;bottom; y++)
<br/>
        for(x = left; x &lt; right; x++)
<br/>
            DrawPixel3(x,y,color);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I am having trouble seeing exactly how to do this. If you have the pdf version of this book it is challenge 2 on page 196. Could someone show me how this is done and maybe explain it a little bit?
<br/>
<br/>
Thanks
<br/>
-Jake</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65196 - Dwedit - Sat Dec 31, 2005 7:42 am</h4>
    <div class="postbody"><span class="postbody">This is a poor example, since you can't use memset on 16 bit data.  But here is a replacement of DrawBox3 that uses memcpy to copy the previous row drawn.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const int screen_width = 240; //hardcoded numbers = headaches when you change them, so make them constants
<br/>
<br/>
void DrawBox3(int left, int top, int right, int bottom, unsigned short color)
<br/>
{
<br/>
    unsigned short *on_video;
<br/>
    int x;
<br/>
    int y;
<br/>
    int width=right-left;
<br/>
    int height=top-bottom;
<br/>
<br/>
    if (height&lt;=0) return;
<br/>
    //address in video memory = base + y*screen_width + x
<br/>
    on_video = videobuffer + top * screen_width + left;
<br/>
    
<br/>
    //draw first row manually
<br/>
    for (x = 0; x &lt; width; x++)
<br/>
    {
<br/>
        on_video[x]=color;
<br/>
    }
<br/>
<br/>
    for (y = 1; y &lt; height; y++)
<br/>
    {
<br/>
        //copy previous rows
<br/>
        on_video+=screen_width;
<br/>
        memcpy(on_video,on_video-screen_width,width*sizeof(unsigned short));
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65208 - Cearn - Sat Dec 31, 2005 4:39 pm</h4>
    <div class="postbody"><span class="postbody">Unfortunately, that might not work either, partially for the same reasons.
<br/>
<br/>
The reason memset doesn't work is because the input is always in bytes, so it'd never work for 16 or 32 bit data anyway. In principle this wouldn't matter for memcpy because data is just data, except for that little problem concerning VRAM and byte copies. The exception to this is when the copy can be optimised, which is possible when a) then size is over 16 bytes (and possibly a multiple of 4, can't remember right now)  and b) the source and destination addresses are word aligned. Which for a general mode 3 plotter won't be the case.
<br/>
<br/>
Your best bet would be to create your own 16 and 32 bit versions of memset/memcpy, or nick <a class="postlink" href="http://user.chem.tue.nl/jakvijn/files/core_asm.s" target="_blank">someone elses</a>. Or use DMA.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65210 - jake2431 - Sat Dec 31, 2005 7:10 pm</h4>
    <div class="postbody"><span class="postbody">Oh, okay. Thanks guys for your help. I think I will just continue reading the book for now and maybe come back to it later since it is not something that is going to really help right now.
<br/>
<br/>
Also, though, in the book he taught me how to write a few functions that would display hard coded text of his design. This was interesting and will most definetly help in the development of games. However, the third challenge on the same page as mentioned above was to make this text count how many randomly placed objects were being displayed on the screen. Now, my first idea was to put a variable++ in the loop that displayed the random objects along with our Print function and use ("%d", variable++); to diplay the number of objects(like with the stdio.h heder file). But with the arguments "Print(int,int,char *,unsigned short) //unsigned short being the color" I don't see how to accomplish this. Any idea? If you need to see the entire DisplayText code just let me know.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65223 - tepples - Sun Jan 01, 2006 2:21 am</h4>
    <div class="postbody"><span class="postbody">Look up <a class="postlink" href="http://www.google.com/search?q=sprintf" target="_blank">sprintf</a> to see what it does.
<br/>
<br/>
[commercial break]
<br/>
<br/>
Now you know what sprintf(char *, const char *, ...) does. But on the GBA, it's called something different: s<span style="font-weight: bold">i</span>printf(). The 'i' means integer-only so that you don't bring in the large, slow floating-point arithmetic library.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
