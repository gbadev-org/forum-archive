<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Huffman Compression - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Huffman Compression</h2>
<div id="posts">
<div class="post">
    <h4>#83470 - ProblemBaby - Tue May 16, 2006 3:38 pm</h4>
    <div class="postbody"><span class="postbody">Hello
<br/>
Iam trying to write a huffman decompression routine.
<br/>
I dont exactly understand the layout of the data.
<br/>
<br/>
It would be nice if someone who understands it could write some easy psuedo code for me?
<br/>
<br/>
thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84209 - Ant6n - Sun May 21, 2006 6:38 am</h4>
    <div class="postbody"><span class="postbody">i dont know how well you understand the algorithm behind huffman compression, but as far as data structures i could suggest this, for the final storage of the huffmann tree:
<br/>
assuming you have a huffmann tree ...
<br/>
emmm
<br/>
...this is going to be long, are you sure you really want Huffmann tree and not attempt lempel ziv, its a little bit more straightforward (imho) and the data structres are simpler
<br/>
<br/>
anton</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84236 - tepples - Sun May 21, 2006 2:11 pm</h4>
    <div class="postbody"><span class="postbody">Another option to consider if you have a lot of small values in your data set is Rice coding or ternary coding, depending on the distribution.
<br/>
<br/>
ProblemBaby: What kind of data do you need Huffman coding for?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84267 - Ant6n - Sun May 21, 2006 6:39 pm</h4>
    <div class="postbody"><span class="postbody"><a href="http://nocash.emubase.de/gbatek.htm#biosdecompressionfunctions" target="_blank">http://nocash.emubase.de/gbatek.htm#biosdecompressionfunctions</a>
<br/>
gba has decompression</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84287 - ProblemBaby - Sun May 21, 2006 8:21 pm</h4>
    <div class="postbody"><span class="postbody">I know how it works, the idea. But I dont understand the tree.
<br/>
I'll use exactly the same layout of the file as the BIOS decompression routine does, I want to write my own to get some more decompression options.
<br/>
<br/>
I dont understand the tree, In which order the nodes are stored.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84293 - Ant6n - Sun May 21, 2006 8:48 pm</h4>
    <div class="postbody"><span class="postbody">ok, lets see. We'll just use the data structure of the huffman tree that the gba uses for decompression. then we have, from the specs (see above link):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">SWI 13h (GBA/NDS7/NDS9) - HuffUnComp (NDS: with Callback)
<br/>
Expands Huffman-compressed data and writes in units of 32bits.
<br/>
If the size of the compressed data is not a multiple of 4, please adjust it as much as possible by padding with 0.
<br/>
Align the source address to a 4Byte boundary.
<br/>
<br/>
  r0  Source Address, aligned by 4, pointing to:
<br/>
       Data Header (32bit)
<br/>
         Bit 0-3   Data size in bit units (normally 4 or 8)
<br/>
         Bit 4-7   Compressed type (must be 2 for Huffman)
<br/>
         Bit 8-31  24bit size of decompressed data in bytes
<br/>
       Tree Table
<br/>
        u8      tree table size/2-1
<br/>
        Each of the nodes below defined as:
<br/>
         u8
<br/>
          6bit  offset to next node -1 (2 byte units)
<br/>
          1bit  right node end flag (if set, data is in next node)
<br/>
          1bit  left node end flag
<br/>
        1 node  Root node
<br/>
        2 nodes Left, and Right node
<br/>
        4 nodes LeftLeft, LeftRight, RightLeft, and RightRight node
<br/>
        ...
<br/>
       Compressed data
<br/>
        ...
<br/>
  r1  Destination Address
<br/>
  r2  Callback parameter (NDS SWI 13h only, see Callback notes below)
<br/>
  r3  Callback structure (NDS SWI 13h only, see Callback notes below)
<br/>
<br/>
Return: No return value, Data written to destination address.</td> </tr></table><span class="postbody">
<br/>
<br/>
so the datastructre is like that
<br/>
-Header
<br/>
-Tree
<br/>
-compressed data
<br/>
<br/>
the tree is kind of like this (it is actually a trie), example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
              root
<br/>
           0/      \1
<br/>
         0/ \1    [a] 
<br/>
        [b] [c]
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This trie would encode a data set with the possible symbols a,b,c. so now when you have a string of bits you just always walk along a path until you hit a symbol. Notice that the edges in the tree represent the 0s and 1s of the compressed data, the leaves are the symbols. So now, if we had a bitstring, i.e.
<br/>
001011
<br/>
<br/>
it would decode it into the sequence of symbols
<br/>
b (00), a (1), c (01), a (1)
<br/>
<br/>
usually we would store the tree as nodes, saving internal nodes as
<br/>
- pointer to right child (1)
<br/>
- pointer to left child (0)
<br/>
and leaves as
<br/>
- symbol
<br/>
Of course we need a way to differentiate between internal nodes and leaves
<br/>
<br/>
Since we dont change the tree during runtime, it is convenient to store it as a an array.
<br/>
The specs indicate that every node has 8 bit. 
<br/>
- the first 6 bit indicate the offset to next nodes (instead of using pointers)
<br/>
 I would assume that they just sit next to each other (the left and right child)
<br/>
- the other two bit indicate whether the childeren are data nodes
<br/>
- it they are data nodes i would assume they are just data
<br/>
<br/>
so the above tree would look like this (correct me, if i am wrong)
<br/>
[0,0,1],[0,1,1],['a'],['b'],['c']
<br/>
<br/>
right?
<br/>
<br/>
anton</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
