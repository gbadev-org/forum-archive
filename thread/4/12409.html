<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Circle-Circle Collision and Reaction (Frame-Independent) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Circle-Circle Collision and Reaction (Frame-Independent)</h2>
<div id="posts">
<div class="post">
    <h4>#118003 - sgeos - Fri Feb 09, 2007 1:28 am</h4>
    <div class="postbody"><span class="postbody">I'm looking for a frame independent circle-circle collison/reaction routine.  So far as I can tell, this is expensive.  The basic flow goes something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">circle a;
<br/>
circle b;
<br/>
float t = timeToCollison(a, b);  // in frames
<br/>
<br/>
if (t &lt; 1.0)
<br/>
{
<br/>
   scaledMove(a, t);   // x += dx * scale; y += dy * scale;
<br/>
   scaledMove(b, t);
<br/>
   react(a, b);
<br/>
   scaledMove(a, 1.0 - t); // or not, if you want them to touch
<br/>
   scaledMove(b, 1.0 - t);
<br/>
}
<br/>
else
<br/>
{
<br/>
   scaledMove(a, 1.0);
<br/>
   scaledMove(b, 1.0);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
timeToCollison() seems to boild down to a quadratic equation:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// terms
<br/>
pA;                  // circle A
<br/>
pB;                  // circle B
<br/>
r  = pA.r  + pB.r;   // distance at collison
<br/>
x  = pA.x  - pB.x;   // x distance
<br/>
y  = pA.y  - pB.y;   // y distance
<br/>
dx = pA.dx - pB.dx;  // delta x distance
<br/>
dy = pA.dy - pB.dy;  // delta y distance
<br/>
t;                   // time
<br/>
SQ(v)   ((v) * (v))  // squared variable
<br/>
<br/>
// collide when distance equals sum of radii
<br/>
// SQ(a) + SQ(b) == SQ(c);
<br/>
SQ(t * dx + x) + SQ(t * dy + y) == SQ(r);
<br/>
// expanded
<br/>
SQ(t) * SQ(dx) + (t * 2 * dx * x) + SQ(x) + SQ(t) * SQ(dy) + (t * 2 * dy * y) + SQ(y) == SQ(r);
<br/>
// quadratic in terms of t
<br/>
SQ(t) * (SQ(dx) + SQ(dy)) + t * (2 * (dx * x + dy * y)) + (SQ(x) + SQ(y) - SQ(r)) == 0;
<br/>
<br/>
// quadratic terms
<br/>
a = (SQ(dx) + SQ(dy));
<br/>
b = (2 * (dx * x + dy * y));
<br/>
c = (SQ(x) + SQ(y) - SQ(r));
<br/>
<br/>
// solve using quadratic equation, return smaller value
<br/>
t0 = (-b + sqrt(SQ(b) - 4*a*c)) / 2a;
<br/>
t1 = (-b - sqrt(SQ(b) - 4*a*c)) / 2a;</td> </tr></table><span class="postbody">
<br/>
When the mass of the objects are the same, reaction seems to simplify to exchanging movement along the line of action while leaving alone any movement perpendicular to line of action.
<br/>
<br/>
Is there a cheaper way to do all of this?
<br/>
<br/>
Reference:
<br/>
<a class="postlink" href="http://www.gamasutra.com/features/20020118/vandenhuevel_01.htm" target="_blank">Pool Hall Lessons: Fast, Accurate <b style="color:#FFA34F">Collision</b> Detection between Circles or Spheres</a>
<br/>
<a class="postlink" href="http://www.amazon.com/Macromedia-Flash-MX-2004-Demystified/dp/0735713979/sr=8-1/qid=1170980374/ref=pd_bbs_sr_1/102-2209015-0379359?ie=UTF8&amp;s=books" target="_blank">Macromedia Flash MX 2004 Demystified</a>
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118082 - Miked0801 - Fri Feb 09, 2007 11:13 pm</h4>
    <div class="postbody"><span class="postbody">Could cheat a touch.
<br/>
<br/>
Record last tic's min distance between points.
<br/>
Record this tic's min distance between points (with <b style="color:#FFA34F">collision</b>).
<br/>
Linear interpolate a position between the 2 using the difference between the two points as weight.  Should be very, very close to accurate.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118093 - keldon - Sat Feb 10, 2007 2:30 am</h4>
    <div class="postbody"><span class="postbody">For time to <b style="color:#FFA34F">collision</b> (well I have just calculated distance of collsion) here's something I knocked up with fewer needs for square roots. Also note the obvious constants such as A.radius*B.radius, and that depending on the size of your circles you can simply have a lookup table for <span style="font-style: italic">y</span> to find the distance as <span style="font-weight: bold"><span style="font-style: italic">distance = x - lookup[y]</span></span>.
<br/>
<br/>
If this is faulty then it is currently 01:22 and I have to sleep; but I cannot see why not and the test cases work fine. This will not tell you if there is a <b style="color:#FFA34F">collision</b> without the vector, but instead tells you how far along the vector where you would find A touching B.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">public class CircleCircleCollision {
<br/>
   public static void main ( String argv [] ) {
<br/>
      Circle A = new Circle ( 1d, 0,0, new Vector (10d, 1d));
<br/>
      Circle B = new Circle ( 1d, 10d, 0d, null );
<br/>
      System.out.println( collisionDistance ( A, B ) );
<br/>
   }
<br/>
   
<br/>
   static double collisionDistance ( Circle A, Circle B ) {
<br/>
      // nx,ny = B.x, B.y in A.vector's vector space
<br/>
      double x = B.x - A.x;
<br/>
      double y = B.y - A.y;
<br/>
      
<br/>
      Vector velocity = A.velocity.normalized();
<br/>
      
<br/>
      double nx = x * velocity.x + y * velocity.y;
<br/>
      double ny = x * velocity.cross().x + y * velocity.cross().y;
<br/>
<br/>
      // these two cases are non collisions
<br/>
      if ( nx &lt;= 0d ) return Double.NaN;
<br/>
      if ( !( ny &gt; B.radius - A.radius | ny &lt; B.radius - A.radius)) return Double.NaN;
<br/>
         
<br/>
      double distance = nx - Math.sqrt( (A.radius+B.radius)*(A.radius+B.radius) - (ny * ny));
<br/>
      return distance;
<br/>
   }
<br/>
   
<br/>
   static class Circle {
<br/>
      double radius;
<br/>
      double x,y;
<br/>
      Vector velocity;
<br/>
      
<br/>
      Circle ( double _radius, double _x, double _y, Vector _velocity ) {
<br/>
         radius = _radius;
<br/>
         x = _x;
<br/>
         y = _y;
<br/>
         velocity = _velocity;
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   static class Vector {
<br/>
      double x,y;
<br/>
      
<br/>
      Vector ( double _x, double _y ) {
<br/>
         x = _x;
<br/>
         y = _y;
<br/>
      }
<br/>
      
<br/>
      Vector cross (){
<br/>
         return new Vector ( -y, x);
<br/>
      }
<br/>
      
<br/>
      double length (){
<br/>
         return Math.sqrt(x*x + y*y);
<br/>
      }
<br/>
      
<br/>
      Vector normalized (){ 
<br/>
         return new Vector ( x / length(), y / length () );
<br/>
      }
<br/>
      
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118122 - sgeos - Sat Feb 10, 2007 7:42 am</h4>
    <div class="postbody"><span class="postbody">By linear interpolation, do you mean something like this?  As far as I can tell, this will work if the orbs don't move fast enough to cross eachother.  If this routine is triggered by a doesCollide() routine, fast moving objects could move through eachother.  If delta is calculated with last frame and the frame before that, perhaps this problem will disappear?  (So long as the objects were not colliding last frame as well.)  Is the distance between center points a linear function of time?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">timeToCollision(pA, pB)
<br/>
{
<br/>
   last  = lastFrameDistance(pA, pB);
<br/>
   this  = thisFrameDistance(pA, pB);
<br/>
   delta = last - this;
<br/>
   r     = pA.r + pB.r;
<br/>
<br/>
   // distance = last + time * delta;
<br/>
   // collide at r, solve for time when distance == r
<br/>
   time  = (r - last) / delta;
<br/>
   return time;
<br/>
}
<br/>
<br/>
#define SQ(v)   ((v) * (v))
<br/>
<br/>
lastFrameDistance(pA, pB)
<br/>
{
<br/>
   x = pB.x - pA.x;
<br/>
   y = pB.y - pA.y;
<br/>
   return sqrt( SQ(x) + SQ(y) );
<br/>
}
<br/>
<br/>
thisFrameDistance(pA, pB)
<br/>
{
<br/>
   x = (pB.x + dx) - (pA.x + dx);
<br/>
   y = (pB.y + dy) - (pA.y + dy);
<br/>
   return sqrt( SQ(x) + SQ(y) );
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-weight: bold">EDIT:</span>  Distance is not always a linear function of time.  In a spreadsheet, most of the cases appear to be parabolas.  (I have not graphed them.)  If anyone else cares to give it a shot, treating one of the orbs as a stationary object at (0, 0) will simplify the equations.
<br/>
<br/>
<span style="font-weight: bold">EDIT:</span>  I did graph it.
<br/>
<span style="font-weight: bold">y = sqrt(x^2 + (m * x + b)^2)</span>
<br/>
y is distance
<br/>
x is time
<br/>
m is distance when the moving circle is directly above that stationary one
<br/>
b is movement relative to the stationary circle.
<br/>
<br/>
The function boils down to a fancy linear absolute value function <span style="font-weight: bold">when b is 0</span>.  If b is non-zero, the function curves.  This is where accuracy problems will happen.  I'm not sure how much of a problem this will actually be.  Bigger objects have a higher potential for accuracy problems if the routine is triggered by doesCollide().  I guess this can always be tested on paper given max object sizes.
<br/>
<br/>
Another problem is that the function changes direction after it reaches the closest point.  Ie crossover.  Delta is calculated using lastDist minus currDist, so crossover will give strange results.  (In the worst case scenario, delta will be close to zero.)
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118132 - keldon - Sat Feb 10, 2007 10:32 am</h4>
    <div class="postbody"><span class="postbody"><span style="color: red"><span style="font-weight: bold">Edit</span>: Updated link to pastebin (26 April 2014)</span>
<br/>
<br/>
My method works, try this <a class="postlink" href="http://pastebin.com/8bdb7JBf" target="_blank">CircleCircleCollision.java</a>. Left mouse draws circle 1, right mouse draws circle 2, ctrl+left mouse draws velocity. This example not only draws where the circle would be when it collides, but using the velocity you give it tells you if it collides using only the code given above. Code is included in the jar file.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">      // nx,ny = B.x, B.y in A.vector's vector space
<br/>
      double x = B.x - A.x;
<br/>
      double y = B.y - A.y;
<br/>
      
<br/>
      Vector velocity = A.velocity.normalized();
<br/>
      
<br/>
      double nx = x * velocity.x + y * velocity.y;
<br/>
      double ny = x * velocity.cross().x + y * velocity.cross().y;
<br/>
<br/>
      // these two cases are non collisions
<br/>
      if ( nx &lt;= 0d ) return Double.NaN;
<br/>
      if ( !( ny &gt; B.radius - A.radius | ny &lt; B.radius - A.radius)) return Double.NaN;
<br/>
         
<br/>
      double distance = nx - Math.sqrt( (A.radius+B.radius)*(A.radius+B.radius) - (ny * ny));
<br/>
      return distance; </td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by keldon on Sat Apr 26, 2014 9:29 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#118133 - sgeos - Sat Feb 10, 2007 10:45 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if ( nx &lt;= 0d ) return Double.NaN;</td> </tr></table><span class="postbody">
<br/>
nx is the component of the distance that lies along A's movement vector?
<br/>
In that case, if (nx &lt;= 0), A is moving away from B.  Correct?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if ( !( ny &gt; B.radius - A.radius | ny &lt; B.radius - A.radius)) return Double.NaN;</td> </tr></table><span class="postbody">
<br/>
Why are you taking the difference of radii?  The sum of radii is important, not the difference.
<br/>
Two circles with radii of 5 and 5 would collide at the same time if instead they had radii of 0 and 10.
<br/>
If this is the component of the distance that is perpendicular to A's movement vector, shouldn't
<br/>
this be, if (ABS(A.radius + B.radius) &lt; ny), then they are too far to collide?
<br/>
<br/>
<span style="font-weight: bold">EDIT:</span>  This:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if ( !( ny &gt; B.radius - A.radius | ny &lt; B.radius - A.radius)) return Double.NaN;</td> </tr></table><span class="postbody">
<br/>
<br/>
Is the same as this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if (ny == B.radius - A.radius) return Double.NaN;</td> </tr></table><span class="postbody">
<br/>
<br/>
I don't understand it.  What happens when ny == the difference of the radii?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118145 - keldon - Sat Feb 10, 2007 12:59 pm</h4>
    <div class="postbody"><span class="postbody"><span style="color: red"><span style="font-weight: bold">Update</span>: Now contains pastebin link</span>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">In that case, if (nx &lt;= 0), A is moving away from B. Correct? </td> </tr></table><span class="postbody">
<br/>
Yes. And in that case there is no <b style="color:#FFA34F">collision</b>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if ( !( ny &gt; B.radius - A.radius | ny &lt; B.radius - A.radius)) return Double.NaN;</td> </tr></table><span class="postbody">
<br/>
Why are you taking the difference of radii?  The sum of radii is important, not the difference.
<br/>
Two circles with radii of 5 and 5 would collide at the same time if instead they had radii of 0 and 10.</span></td> </tr></table><span class="postbody">
<br/>
My mistake, that statement is void; it should have been <span style="font-weight: bold"><span style="font-style: italic">if ( ABS(ny) &gt; (A.radius + B.radius )) return Double.NaN</span></span>
<br/>
<br/>
It only worked because it then goes on to calculate the distance, which is NaN - oh wait, just noticed you already gave the corrected statement. And yes if that statement is true then they are too far to collide. And like I said before if the range is small you could make use of a lookup table instead of using a square root.
<br/>
<br/>
By the way did you try the <a class="postlink" href="http://pastebin.com/8bdb7JBf" target="_blank">java file</a>? Has a working gui that allows you to draw your own circle and vector; left mouse + ctrl to make the vector. I also updated it to be more fluid!</span><span class="gensmall"><br/><br/>Last edited by keldon on Sat Apr 26, 2014 9:30 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#118150 - sgeos - Sat Feb 10, 2007 2:14 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">And like I said before if the range is small you could make use of a lookup table instead of using a square root.</td> </tr></table><span class="postbody">
<br/>
I'm not quite sure I follow this.  The square root term is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">sqrt( (A.radius+B.radius)*(A.radius+B.radius) - (ny * ny))</td> </tr></table><span class="postbody">
<br/>
Wouldn't you need a 2D lookup table?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">return nx - lut[ny][r_sum];</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">By the way did you try the <a class="postlink" href="http://konly.co.uk/examples/CircleCircleCollision.jar" target="_blank">jar file</a>?</td> </tr></table><span class="postbody">
<br/>
The jar works well.  I have not looked at the source though.  I'd be curious to know how innaccurate a fixed point (GBA) implementation would be.
<br/>
<br/>
This solution is quite clever.  I like it more than the (horrible) quadratic equation solution.  Something similar to the distance projection needs to be done during the <b style="color:#FFA34F">collision</b> reaction (as opposed to <b style="color:#FFA34F">collision</b> detection), so that routine can be reused.
<br/>
<br/>
The normalized movement vector... can't easily be queued, because in a real game/demo that value will actually be movement relative to A (or B; it doesn't really matter).  You would need a 2D queue.
<br/>
<br/>
This test:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if ( nx &lt;= 0d ) return Double.NaN;</td> </tr></table><span class="postbody">
<br/>
May actually want to come right after <span style="font-weight: bold">nx = ...</span>
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118168 - keldon - Sat Feb 10, 2007 5:01 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">And like I said before if the range is small you could make use of a lookup table instead of using a square root.</td> </tr></table><span class="postbody">
<br/>
I'm not quite sure I follow this.  The square root term is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">sqrt( (A.radius+B.radius)*(A.radius+B.radius) - (ny * ny))</td> </tr></table><span class="postbody">
<br/>
Wouldn't you need a 2D lookup table?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">return nx - lut[ny][r_sum];</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Yes and no. If you have many variable sizes then you will need to; but if you know there will only be a few distinct r_sum's then you need only worry about them. All depends on what your case with it is though.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">May actually want to come right after nx = ... </td> </tr></table><span class="postbody">
<br/>
Good point.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">The jar works well. I have not looked at the source though. I'd be curious to know how inaccurate a fixed point (GBA) implementation would be. </td> </tr></table><span class="postbody">
<br/>
Inside the jar there is a fixed point circle/line <b style="color:#FFA34F">collision</b> that is about as expensive as this and isn't that inaccurate. When I get home I'll see if I can change it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118188 - keldon - Sat Feb 10, 2007 10:52 pm</h4>
    <div class="postbody"><span class="postbody">Download <a class="postlink" href="http://pastebin.com/Vq5Z4bTr" target="_blank">IntegerCircleCircleCollision.java</a>
<br/>
<br/>
It's ok but maybe needs to sacrifice some more points, it is currently using 16:16 for the vector space transformation.
<br/>
<br/>
<span style="font-weight: bold">Edit</span>: Updated to pastebin link (26 April 2014)</span><span class="gensmall"><br/><br/>Last edited by keldon on Sat Apr 26, 2014 9:26 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#118310 - sgeos - Mon Feb 12, 2007 12:52 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">Download <a class="postlink" href="http://konly.co.uk/examples/IntegerCircleCircleCollision.jar" target="_blank">IntegerCircleCircleCollision.jar</a></td> </tr></table><span class="postbody">
<br/>
I noticed some round off error.  Not necessarily a problem so long as objects bounce properly and don't get stuck together.  Currently this is happening with my (unrelated) code.  I'm using a force apart routine to compensate, but I'm not sure that is the best approach.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">It's ok but maybe needs to sacrifice some more points, it is currently using 16:16 for the vector space transformation.</td> </tr></table><span class="postbody">
<br/>
I'm using an 8 bit fractional component, like the GBA rotation/scaling hardware.  It would be interesting if your demo could change the fractional component at runtime.  (+ add a bit, - subtract a bit, * double bits, / half bits).
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120722 - sirpoonga - Mon Mar 05, 2007 8:13 pm</h4>
    <div class="postbody"><span class="postbody">Interesting thread.  Keldon, I haven't looked at the jar yet.  Is there info on colliding a circle with a corner and/or rolling off the edge of an incline?  I am making an labyrinth game for the DS Motion and the physics is the only part I am stuck on right now.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120756 - keldon - Mon Mar 05, 2007 11:15 pm</h4>
    <div class="postbody"><span class="postbody">There is little to worry about for an incline. Your balls will already have a velocity before reaching the incline, so all that happens is that there is no longer the upwards force from the ledge/ground/surface that it is on top of.
<br/>
<br/>
There is a great document on the <a class="postlink" href="http://web.archive.org/web/20050212223513/http://sodaplaycentral.com/features/files/full.pdf" target="_blank">soda race physics</a> by Dr Jeckyl which is unfortunately only available from the web archive (so everyone download it now). I of course have kept a copy but read through that (from page 45), and you will probably have a few questions like how this relates to circle/corner collisions if you don't figure it out. I did find many physics documents/articles/web pages last year, but unfortunately I no longer have them or know how or where to find them.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
