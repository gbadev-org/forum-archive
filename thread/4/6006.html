<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>OOP in GBA Dev - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > OOP in GBA Dev</h2>
<div id="posts">
<div class="post">
    <h4>#45454 - merodia - Fri Jun 10, 2005 8:35 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
Just wondering. When you use objects in programs the compiler allocates new memory for every instance of a class, but that is on the PC which has way more memory than a GBA. What i would like to know is? where would the instances be stored on the GBAs memory if it is possible to do so.
<br/>
<br/>
Thank you</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45459 - poslundc - Fri Jun 10, 2005 9:43 pm</h4>
    <div class="postbody"><span class="postbody">Global objects and objects declared inside of functions go into IWRAM, which is only 32K, as you observed.
<br/>
<br/>
Instances created dynamically with new or malloc go into EWRAM, which you have 256K of, but is much slower than IWRAM.
<br/>
<br/>
(This behaviour is modifiable, but the above is the default.)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46428 - Steve++ - Fri Jun 24, 2005 5:31 pm</h4>
    <div class="postbody"><span class="postbody">Ah crap.... I'm creating large object pools off the stack (haven't compiled anything yet), and you're telling me that will be done in IWRAM? I don't know anything about modifying the behaviour (I'm assuming crt0.s has something to do with it). Can I make local objects allocatble from EWRAM and local variables (primitives) allocatable from IWRAM, or is there just one stack for locals? Is it possible to add an attribute to a local object to make it allocatable from EWRAM?
<br/>
<br/>
Perhaps I should just bite the bullet and dynamically allocate the object pool. I was trying to be a stack allocation purist, but I guess that won't happen now.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46430 - DekuTree64 - Fri Jun 24, 2005 5:49 pm</h4>
    <div class="postbody"><span class="postbody">One trick you cuold use is to make a secondary EWRAM stack. Make a global pointer and set it to the top of EWRAM when you start your game. When you want to allocate from it, subtract the size of your object, and then create it there with placement new.
<br/>
When you're done with the object, just delete it like normal, and then add the size back onto the EWRAM stack pointer.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46432 - poslundc - Fri Jun 24, 2005 5:52 pm</h4>
    <div class="postbody"><span class="postbody">In GCC you can use the __attribute__ directive to specify where you want a variable to be placed, eg.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int variableInEWRAM __attribute__ ((section (".ewram")));     // Placed in EWRAM</td> </tr></table><span class="postbody">
<br/>
<br/>
I believe that you can use .sbss in DevKitARM instead of .ewram to have the same effect but leave the data uninitialized (which keeps your ROM size down).
<br/>
<br/>
Alternatively, if you're not using dynamic allocation or multiboot, EWRAM should be left untouched by the compiler, so you can just grab a pointer and do whatever you want with it. Common uses include mapping EWRAM to a global struct, or taking a pointer to the end of EWRAM and growing your own stack down from it.
<br/>
<br/>
Dan.
<br/>
<br/>
<span style="font-weight: bold">Edit:</span> DekuTree beat me to it... :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46434 - DekuTree64 - Fri Jun 24, 2005 6:32 pm</h4>
    <div class="postbody"><span class="postbody">Oh, and how 'bout this for even more fun:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// void CallWithCustomStack(void *funcAddr, void *stackAddr)
<br/>
<br/>
.global CallWithCustomStack
<br/>
.arm
<br/>
.align 2
<br/>
CallWithCustomStack:
<br/>
mov  r2, sp          // Preserve original stack
<br/>
mov  sp, r1          // Set stack pointer to stackAddr arg
<br/>
stmfd sp!, {r2, lr}  // Save old stack and lr on the custom stack
<br/>
mov  lr, pc          // Call the function
<br/>
bx   r0
<br/>
ldmfd sp, {sp, lr}   // Sneaky, pop the stack off the stack :)
<br/>
bx   lr</td> </tr></table><span class="postbody">
<br/>
<br/>
It'll need to be more complicated if you need to pass arguments to your function, but that will allocate any locals in the function from the stack pointer you pass in, which could be in EWRAM.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46449 - merodia - Sat Jun 25, 2005 1:08 am</h4>
    <div class="postbody"><span class="postbody">Thanx alot for the replies, I think this is a really important topic. When having to implement algorithms for intelligence in games. 
<br/>
<br/>
Thank you very much.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
