<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Hardness maps and background collisions. - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Hardness maps and background collisions.</h2>
<div id="posts">
<div class="post">
    <h4>#4874 - cooky - Sun Apr 13, 2003 7:55 pm</h4>
    <div class="postbody"><span class="postbody">I want to know if people still use hardness map on the GBA. (If anyone on this forum knows what they are)
<br/>
<br/>
If you don't they are an exact copy of a background map with areas of it coloured in a certain colour.
<br/>
Testing for that colour (in respects to the main character) will tell you whether you are colliding with that area of the background or not.
<br/>
<br/>
If any one has some code that does hardness map and an explination of how that code works would be handy.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4879 - pollier - Sun Apr 13, 2003 11:53 pm</h4>
    <div class="postbody"><span class="postbody">I doubt many people are using it on the GBA; most of the time it's overkill and, unless you've got a really straightforward sidescroller, isn't very technically feasible. I remember a post somewhere about using affline registers to get a linear pixel buffer in tile modes--that would probably be helpful... info, anyone?<br/>_________________<br/>(Works for me!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4889 - sgeos - Mon Apr 14, 2003 5:05 am</h4>
    <div class="postbody"><span class="postbody">This might be useful:
<br/>
<br/>
unsigned long bit_squasher(unsigned long val)
<br/>
{
<br/>
  val = (val &amp; 0x33333333) | ((val &amp; 0xCCCCCCCC) &gt;&gt; 2);
<br/>
  return (val &amp; 0x11111111) | ((val &amp; 0x22222222) &gt;&gt; 1);
<br/>
}
<br/>
<br/>
(Untested!)  It can be used used to &amp; pixel data together.  Any non-zero pixel values will be turned into 1's.  For example:
<br/>
  bit_squash(0x01233210) == 0x01111110
<br/>
<br/>
What is the best way, or even just a good way to test if a sprite has collided with a bg?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4891 - sgeos - Mon Apr 14, 2003 5:36 am</h4>
    <div class="postbody"><span class="postbody">Better yet, setting non-zero pixels to 0xF would work better.  This way only one thing needs to be converted.
<br/>
<br/>
unsigned long bit_expander(unsigned long val) 
<br/>
{ 
<br/>
val |= ((val &amp; 0x33333333) &lt;&lt; 2) | ((val &amp; 0xCCCCCCCC) &gt;&gt; 2); 
<br/>
return val | ((val &amp; 0x55555555) &lt;&lt; 1) | ((val &amp; 0xAAAAAAAA) &gt;&gt; 1); 
<br/>
} 
<br/>
<br/>
Again, untested.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4896 - excessus - Mon Apr 14, 2003 8:20 am</h4>
    <div class="postbody"><span class="postbody">I like to call that "collision map" :) ok, basically how I use that is that I draw a 256 color image that has different colors to represent different walls that things hit. Image is then converted to array using gfx2gba. Usage is rather simply, as you move your sprite(or whatever) on screen/map that is visible you also move the "hot points", ie the points where you should check collision, on the collision map. Hot points are placed inside (maybe center) of the sprite and/or on the outlines of the sprite. Then you just do an "if-check" for each hot point and compare them to the collision map array. The collision map and the real map you are using can/should be same size for convinience. Also this kind of map can be used for creating areas of map where you trigger off stuff rather than just collide into things. Of course this is bit too comprehensive collision detection for side scroller shooter. But some games do certainly need quite precise collision detection (pinball comes into mind as i'm trying to code such :).
<br/>
<br/>
below few feeble examples trying to explain my mumblings:
<br/>
actual sprite:
<br/>
<br/>
###
<br/>
###
<br/>
###
<br/>
<br/>
numbers representing hot points and their location:
<br/>
<br/>
#1#
<br/>
203
<br/>
#4#
<br/>
<br/>
actual positions :
<br/>
sprite position : sprite_x = 10, sprite_y = 12 (upper left corner of the sprite)
<br/>
<br/>
hot points:
<br/>
0 : x = sprite_x + 1, y = sprite_y+1
<br/>
1:  x = sprite_x +1 , y = sprite_y
<br/>
...etc
<br/>
<br/>
checking:
<br/>
if ( collision_map_array[hot_point_position[0]] == 0x00) // floor color
<br/>
  do_nothing();
<br/>
else if ( collision_map_array[hot_point_position[0]] == 0x01) // wall color
<br/>
  do_things();
<br/>
<br/>
and so forth...
<br/>
<br/>
phew hope this made any sense :)<br/>_________________<br/>Current binary for my pinball game demo:
<br/>
<a href="http://www.lut.fi/~rusakko/gba/flibu.gba" target="_blank">www.lut.fi/~rusakko/gba/flibu.gba</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4903 - cooky - Mon Apr 14, 2003 12:51 pm</h4>
    <div class="postbody"><span class="postbody">Yeh it made perfect sense just how I was going to do it. Thanks.
<br/>
<br/>
I'm glad to hear people still use this. Thanks alot for the code.
<br/>
:)<br/>_________________<br/>Rolling a six is unlikely but how do you know if you have never picked up the dice.
<br/>
<a href="http://www.ceorron.co.uk" target="_blank">www.ceorron.co.uk</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5943 - blaow2 - Tue May 13, 2003 5:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"> Usage is rather simply, as you move your sprite(or whatever) on screen/map that is visible you also move the "hot points", ie the points where you should check collision, on the collision map</td> </tr></table><span class="postbody">
<br/>
<br/>
lets say our collision map is in a 1d array, whats the best way to move the collision map as the real map moves so the hotspots allways stay where they should be(places where we want to check for collisions on the real map). thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5944 - Quirky - Tue May 13, 2003 5:47 pm</h4>
    <div class="postbody"><span class="postbody">You shouldn't need to - you should be keeping track of the "world x y" as well as the actual hardware BG x,y when you scroll. Then you can just use the world x y values to find the background hotspot tile in ROM, as you would to find the next (visible) tile values in rom.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5945 - sgeos - Tue May 13, 2003 5:57 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>blaow2 wrote:</b></span></td> </tr> <tr> <td class="quote">lets say our collision map is in a 1d array, whats the best way to move the collision map as the real map moves so the hotspots allways stay where they should be(places where we want to check for collisions on the real map). thanks</td> </tr></table><span class="postbody">
<br/>
<br/>
You'll have to arrange it into rows, and keep track of how many rows you have, and the width of each row.  Do the same with your real map.  Here is a diagram:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  ........
<br/>
  .....11.
<br/>
  .22..11.
<br/>
  .22.....
<br/>
  ........
<br/>
  ........</td> </tr></table><span class="postbody">
<br/>
Here the real map has six rows, and each one has a width of eight.  The 1d array has two rows each with a width of two.
<br/>
<br/>
1 and 2 are what your 1d array contains at times 1 and 2.  The dots are your real map.  To simplify things don't let the player leave the real map.  If you do let them travel off it, you'll have to preform boundry checking and decide what gets loaded if a spot is off the map.
<br/>
<br/>
Rereading the thread, I agree that keeping track of the "world x y" should be enough though.  Reloading your 1d array will be half as much trouble as testing against the map in the ROM.  Testing against the 1d array will be the other half...
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5967 - excessus - Wed May 14, 2003 10:31 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>blaow2 wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"> Usage is rather simply, as you move your sprite(or whatever) on screen/map that is visible you also move the "hot points", ie the points where you should check collision, on the collision map</td> </tr></table><span class="postbody">
<br/>
<br/>
lets say our collision map is in a 1d array, whats the best way to move the collision map as the real map moves so the hotspots allways stay where they should be(places where we want to check for collisions on the real map). thanks</span></td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
well lets say you have point in x axis 200 and y 100 in screen that is 240x160 pixels, in 1d array that would be found at position 240 * 100 + 200  = array[24200]  ( map_width * position_y + position_x ). Was this what you meant ?<br/>_________________<br/>Current binary for my pinball game demo:
<br/>
<a href="http://www.lut.fi/~rusakko/gba/flibu.gba" target="_blank">www.lut.fi/~rusakko/gba/flibu.gba</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5998 - tubooboo - Wed May 14, 2003 9:48 pm</h4>
    <div class="postbody"><span class="postbody">another approach to deal with collision is to store an attribute table for each tile on your tilemap that contains information on how this tile affects collision. This method was used in many SNES titles.
<br/>
<br/>
Emanuel<br/>_________________<br/>HAM author
<br/>
<a href="http://www.ngine.de" target="_blank">http://www.ngine.de</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6084 - blaow2 - Fri May 16, 2003 5:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">( map_width * position_y + position_x ). Was this what you meant ?
<br/>
</td> </tr></table><span class="postbody">
<br/>
yes thats exactly what i needed that formula so i know where in the array to check for collision.. thanks everyone for all the tips...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6205 - blaow2 - Mon May 19, 2003 8:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">( map_width * position_y + position_x ). Was this what you meant ? </td> </tr></table><span class="postbody">  i tried the above and it seems to be partially working because my sprite does seem to collide, however it does it in empty space off the target(place where it should collide) i supose this is because
<br/>
im doing this: (map_width*background_y+background_x) to browse for collisions in my 1d collision array, since not only my background moves but also my sprite(my sprite can move without moving the background(jumping) and also moving it(walking)), then to find the real hotspots(places where it should collide)  in the 1d collision array(holds collision positions of  the real background) it should be taken into acount both the background and sprite x y positions to calculate the position to look for collisions in the 1d collision array. the problem is i dont know how..
<br/>
<br/>
 maybe someone could help to clarify this for me.. im using a 1024 * 1024 pixel background (128*128) tiles. my sprite is 16 pixels by 16 pixel.
<br/>
thanks again</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6206 - niltsair - Mon May 19, 2003 9:40 pm</h4>
    <div class="postbody"><span class="postbody">Let's explain how an array works.
<br/>
<br/>
A 2d Array like this :
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u8 i,j;
<br/>
u8 Array2D[3][5];
<br/>
for(i = 0; i &lt; 3; i++)
<br/>
    for(j = 0; j &lt; 5; j++)
<br/>
        Array2d[i][j] = i*10 + j;</td> </tr></table><span class="postbody">
<br/>
<br/>
This code would yield those value :
<br/>
00,01,02,03,04,05,10,11,12,13,14,15,20,21,22,23,24,25
<br/>
<br/>
If we separate it by line :
<br/>
Line 0 (00,01,02,03,04,05)
<br/>
Line 1 (10,11,12,13,14,15)
<br/>
Line 2 (20,21,22,23,24,25)
<br/>
<br/>
As you can see, if you want find an element by acessing it as a 1d array, you would need to do this :
<br/>
(Line*NbItemPerLine) + Col
<br/>
<br/>
So, to reach Line 1, item 4 you do :
<br/>
( 1 * 3) + 4
<br/>
<br/>
Now, for your problem
<br/>
<span style="font-style: italic">i'm using a 1024 * 1024 pixel background</span>
<br/>
That means you have an array of Array[1024][1024]
<br/>
(if you do collision onf pixel level and not tile level, else it's slightly more complicated)
<br/>
<br/>
So to find your sprite X/Y position it's :
<br/>
PosY = MapMoveY + SpriteMoveY
<br/>
PosX = MapMoveX + SpriteMoveX
<br/>
<br/>
So it'll be :
<br/>
(MapMoveY + SpriteMoveY)*1024 + MapMoveX + SpriteMoveX
<br/>
<br/>
Basicly. But you also have to takes something else into account. The SpriteX/SpriteY origin is Top/Left. This means that the collisoin woudl only occurs once hte sprite is totally over the thing it is suppose to collide on. To correct this, SpriteWidth when moving right and the sprite's Height when moving Down, In this case 16 and 16 :
<br/>
<br/>
When moving Right :
<br/>
(MapMoveY + SpriteMoveY)*1024 + MapMoveX + SpriteMoveX + 16
<br/>
<br/>
When moving Down :
<br/>
(MapMoveY + SpriteMoveY + 16)*1024 + MapMoveX + SpriteMoveX
<br/>
<br/>
Or you could use this simple solution, always evaluate the middle of the sprite.
<br/>
(MapMoveY + SpriteMoveY + 8)*1024 + MapMoveX + SpriteMoveX + 8
<br/>
<br/>
Here, hope it'll help you out. Like is said, this solution only apply if you do collision detection on a pixel level, but i think it is more common to do it on a tile level.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6274 - excessus - Wed May 21, 2003 9:35 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>blaow2 wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">( map_width * position_y + position_x ). Was this what you meant ? </td> </tr></table><span class="postbody">  i tried the above and it seems to be partially working because my sprite does seem to collide, however it does it in empty space off the target(place where it should collide) i supose this is because
<br/>
im doing this: (map_width*background_y+background_x) to browse for collisions in my 1d collision array, since not only my background moves but also my sprite(my sprite can move without moving the background(jumping) and also moving it(walking)), then to find the real hotspots(places where it should collide)  in the 1d collision array(holds collision positions of  the real background) it should be taken into acount both the background and sprite x y positions to calculate the position to look for collisions in the 1d collision array. the problem is i dont know how..
<br/>
<br/>
 maybe someone could help to clarify this for me.. im using a 1024 * 1024 pixel background (128*128) tiles. my sprite is 16 pixels by 16 pixel.
<br/>
thanks again</span></td> </tr></table><span class="postbody">
<br/>
<br/>
I suggest you draw a simplified little cartoon on paper how your pixels (bg and sprites) move on map when you scroll and so on. Atleast it clarified for me the math behind it :)<br/>_________________<br/>Current binary for my pinball game demo:
<br/>
<a href="http://www.lut.fi/~rusakko/gba/flibu.gba" target="_blank">www.lut.fi/~rusakko/gba/flibu.gba</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6450 - blaow2 - Mon May 26, 2003 5:54 am</h4>
    <div class="postbody"><span class="postbody">thanks for the help, it had really made clear a lot of things.  however i still got the same problem, i tried a second test on a smaller background, this time 512*512 pixels (64*64)8 pixel tiles and 16*16 sprites. and im still getting offtarget collisions. well i'll post some of the code i got.. maybe someone could help me and point out wich of the parts looks fishy....
<br/>
<br/>
I copy my map data as follows:
<br/>
map=my map data(u8)  1d array;
<br/>
CHAR_SHIFT is set to 1
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u16*mapData;
<br/>
u16* temp;
<br/>
mapData = (u16*)ScreenBaseBlock(28);
<br/>
temp = (u16*)map;
<br/>
    for(int x = 0; x &lt; 64; x++){
<br/>
      for (int y=0; y&lt;64; y++){
<br/>
         mapData[y*64+x] = temp[y*64+x];
<br/>
                                    }
<br/>
                                    }
<br/>
</td> </tr></table><span class="postbody">
<br/>
Then i fill my collision array  //basicly if color is black then collision is set to false for that position (colliding whit everything else but black tiles)
<br/>
collisionMap its an 64*64 boolean 1d array
<br/>
[code]
<br/>
for(int x = 0; x &lt; 64*64; x++){
<br/>
      if((map[x])==0x00)
<br/>
            collisionMap[x]= false;
<br/>
            else
<br/>
            collisionMap[x]= true;
<br/>
}
<br/>
each time the sprite/bg moves the position of the background and sprite prior to the movement are stored for later use in the collision method.
<br/>
which looks something like this:
<br/>
by, bx=background x and y
<br/>
<br/>
[code]
<br/>
if(collisionMap[((by + sprite.y)/8)*64 + ((bx + sprite.x)/8)])
<br/>
set background and sprite posistion to what it was before collision
<br/>
<br/>
if(collisionMap[((by + sprite.y)/8)*64 + (((bx + sprite.x)+ 15)/8)])
<br/>
set background and sprite posistion to what it was before collision
<br/>
<br/>
if((collisionMap[(((by + sprite.y)+ 15)/8)*64 + ((bx + sprite.x)/8)]))
<br/>
set background and sprite posistion to what it was before collision
<br/>
<br/>
if((collisionMap[(((by + sprite.y)+ 15)/8)*64 + (((bx + sprite.x)+15)/8)]))
<br/>
set background and sprite posistion to what it was before collision
<br/>
[/code]
<br/>
<br/>
thats basicly it, thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6463 - niltsair - Mon May 26, 2003 2:24 pm</h4>
    <div class="postbody"><span class="postbody">When you fill your collision array, you have to know how Map layout works.
<br/>
<br/>
You would think that in a 64x64 Map layout, to reach col say 45, is an easy thing, but it's a little crooked. See,  the Gba still works with 32x32 Maps and not 1 big map. So here's the layout for it :
<br/>
<br/>
Map0 | Map1
<br/>
Map2 | Map3
<br/>
<br/>
Before being able to reach Map1 column(32-64)  you need to have totally parsed Map0 data. Before being able to reach Map2, you need to have parsed Map0 and Map1. Each of those maps contains 32x32 elements. So, your loop that fill your collision array, it should look like this :
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int x,y;
<br/>
<br/>
//Map0
<br/>
for( y = 0; y &lt; 32; y++)
<br/>
    for( x = 0; x &lt; 32; x++)
<br/>
        collisionMap[y*64+x] =  (map[(y*32)+x]==0x00);
<br/>
<br/>
//Map1
<br/>
for( y = 0; y &lt; 32; y++)
<br/>
    for( x = 0; x &lt; 32; x++)
<br/>
        collisionMap[y*64+x+32] =  (map[(32*32)+(y*32)+x]==0x00);
<br/>
<br/>
//Map2
<br/>
for( y = 0; y &lt; 32; y++)
<br/>
    for( x = 0; x &lt; 32; x++)
<br/>
        collisionMap[(y+32)*64+x] =  (map[2*(32*32)+*y*32)+x]==0x00);
<br/>
<br/>
//Map3
<br/>
for( y = 0; y &lt; 32; y++)
<br/>
    for( x = 0; x &lt; 32; x++)
<br/>
        collisionMap[(y+32)*64+x+32] =  (map[3*(32*32)+(y*32)+x]==0x00);
<br/>
 </td> </tr></table><span class="postbody">
<br/>
<br/>
This code is far from being optimized and hasn't been tested. But should give you an idea or 2. I also think you should check directly your collision with your map, instead of wasting Cpu's time to calculate a collision table, if it's isn't pre-built.
<br/>
<br/>
Sprite isn't colliding with color 0, it's colliding with Tile 0, small nuance.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6476 - blaow2 - Mon May 26, 2003 10:30 pm</h4>
    <div class="postbody"><span class="postbody">thanks,  makes sence now, i forgot to mention that i use a rotating background for this, i dont supose this matters since i dont rotate or scale anything, does it?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
