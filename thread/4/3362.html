<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How opcodes are treated on startup, and some other questions - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > How opcodes are treated on startup, and some other questions</h2>
<div id="posts">
<div class="post">
    <h4>#20312 - Johnny Watson - Thu May 06, 2004 10:42 pm</h4>
    <div class="postbody"><span class="postbody">After reading through most of the GBA documentation on this website, I'm unsure of a couple of things. Where the game code on the cartridge is stored, and how the Gameboy Advance knows where to load and what code to load. Does it just load instructions and keep any static allocations on the cartridge? I'm not sure how it works, for example, if I have 16KB of instruction data, and 5MB of data implemented through static arrays. Would all the instruction data automatically go into work RAM, and the static array data stays memory mapped on the cartridge? I guess what I'm getting at is, I'm confused when it comes to managing memory on the GBA, and I'm not sure how instructions and literal data within code is placed in memory.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20315 - dagamer34 - Thu May 06, 2004 11:13 pm</h4>
    <div class="postbody"><span class="postbody">Code will always start at 0x8000000 (or 0x2000000 for multiboot). From there on, the program will execute code by jumping to it, and use arrays for whatever they are needed for.
<br/>
<br/>
Instruction data does not automatically go into work RAM unless it is told to do so at startup (by either having a multiboot program where everything is in RAM, or by declaring variables and functions in RAM). The same goes for data.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20316 - poslundc - Thu May 06, 2004 11:15 pm</h4>
    <div class="postbody"><span class="postbody">The linkscript used in devkitadvance (and probably just about any other system as well) treats your data as follows:
<br/>
<br/>
- Executable code and any variables declared as "const" go into ROM.
<br/>
- Any other variables go into IWRAM.
<br/>
- Usually if your devkit includes a malloc() routine it will put its heap in EWRAM.
<br/>
<br/>
Executable code that's in ROM stays in ROM, and is read into the GBA one instruction at a time.
<br/>
<br/>
The big exception to this is if your game is compiled to support multiboot, in which case all of the executable code and const data is copied into EWRAM when the program is loaded.
<br/>
<br/>
You can manually tell the compiler to put your executable code into EWRAM or IWRAM instead of the ROM by using section attributes, or a command-line switch for GCC. In this case, the code is stored in ROM but copied into EWRAM or IWRAM when the GBA is turned on.
<br/>
<br/>
<span style="font-weight: bold">Edit:</span> You win this round, dagamer34...
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20318 - Johnny Watson - Thu May 06, 2004 11:30 pm</h4>
    <div class="postbody"><span class="postbody">Thanks.
<br/>
<br/>
So all non-const data exists in WRAM? Will I get a significant performance increase if program instructions exist in WRAM as opposed to cartridge ROM?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20319 - sajiimori - Thu May 06, 2004 11:37 pm</h4>
    <div class="postbody"><span class="postbody">Code in IWRAM, especially 32 bit ARM code, runs significantly faster than code run from ROM.  It's typical to put a few speed-critical routines in IWRAM when performance starts to degrade.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20323 - poslundc - Fri May 07, 2004 1:00 am</h4>
    <div class="postbody"><span class="postbody">Code in EWRAM, however, will typically run somewhat <span style="font-style: italic">slower</span> than from the ROM (depending on how often the code branches).
<br/>
<br/>
There is a huge difference between the performance of the fast Internal WRAM (which you only have 32K of) and slower External WRAM (which you have 256K of).
<br/>
<br/>
As sajimori says, it's not something worth worrying about until it becomes necessary to optimize a few speed-critical routines. Until then, just compile all of your code as Thumb and leave it to run in ROM (unless it is a multiboot game, in which case it has to run from EWRAM).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20329 - Johnny Watson - Fri May 07, 2004 9:10 am</h4>
    <div class="postbody"><span class="postbody">How would I tell certain instruction sections (ie: functions) to explicitly go to IWRAM for execution?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20334 - Akolade - Fri May 07, 2004 5:53 pm</h4>
    <div class="postbody"><span class="postbody">I found this page useful:
<br/>
<br/>
<a class="postlink" href="http://www.devrs.com/gba/files/gbadevfaqs.php#LongBranch" target="_blank">http://www.devrs.com/gba/files/gbadevfaqs.php#LongBranch</a>
<br/>
<br/>
method 2 seems an easy way to do it. also, search around these forums for info about placing routines in IWRAM.[/url]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20343 - Johnny Watson - Sat May 08, 2004 12:13 am</h4>
    <div class="postbody"><span class="postbody">Thank you a lot. You were all very helpful, though I suppose I should have searched a bit harder.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20358 - ScottLininger - Sat May 08, 2004 9:24 pm</h4>
    <div class="postbody"><span class="postbody">Guys,
<br/>
<br/>
Is there any reason to put code in IWRAM besides performance? Here's a function from a library that's been causing me some compile headaches... And I'm trying to understand if the routine being in IWRAM is necessary.
<br/>
<br/>
From the Header:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define SER_SECTION __attribute__((section(".iwram"), long_call))
<br/>
<br/>
#ifndef REG_BASE   // no mygba.h included
<br/>
<br/>
#define REG_BASE 0x4000000
<br/>
<br/>
#define REG_SIOCNT (REG_BASE+0x128)
<br/>
#define REG_RCNT (REG_BASE+0x134)
<br/>
<br/>
#define REG_SIOMULTI0   (REG_BASE + 0x120)
<br/>
#define REG_SIODATA32 REG_SIOMULTI0
<br/>
#define REG_SIOMULTI1   (REG_BASE + 0x122)
<br/>
#define REG_SIOMLT_SEND (REG_BASE + 0x12a)
<br/>
<br/>
#define XFER_ERROR_SUCCESS 0
<br/>
#define XFER_ERROR_TIMEOUT 1
<br/>
<br/>
#define RW_ERROR_SUCCESS 0
<br/>
#define RW_ERROR_XFER_ERROR 1
<br/>
#define RW_ERROR_TIMEOUT 2
<br/>
#define RW_ERROR_CMD_NAK 3
<br/>
#define RW_ERROR_CHKSUM_ERROR 4
<br/>
#endif
<br/>
<br/>
u32 SER_SECTION stick_xfer32(u32 send);</td> </tr></table><span class="postbody">
<br/>
<br/>
The routine:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u32 SER_SECTION stick_xfer32(u32 send)
<br/>
{
<br/>
   int timeout=0x100000;
<br/>
   stick_xfer_error=XFER_ERROR_SUCCESS;
<br/>
   *(vu16*)REG_RCNT=0;
<br/>
   *(vu16*)REG_SIOCNT=0x1000;
<br/>
   *(vu32*)REG_SIODATA32=send;
<br/>
   *(vu16*)REG_SIOCNT=0x1080;
<br/>
<br/>
   while(timeout--)
<br/>
      if(!((*(vu16*)REG_SIOCNT)&amp;0x80)) break;
<br/>
<br/>
   *(vu16*)REG_SIOCNT=0x1008;
<br/>
   if(!timeout) {
<br/>
      stick_xfer_error=XFER_ERROR_TIMEOUT; return 0;
<br/>
   }
<br/>
   return *(vu32*)REG_SIODATA32;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Just curious...
<br/>
<br/>
:)
<br/>
<br/>
Scott</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
