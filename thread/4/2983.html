<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Mode 4 PlotPixel and DrawLine Needed... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Mode 4 PlotPixel and DrawLine Needed...</h2>
<div id="posts">
<div class="post">
    <h4>#17282 - batblaster - Fri Mar 05, 2004 6:32 pm</h4>
    <div class="postbody"><span class="postbody">Hello , 
<br/>
I want to know if someone have a good plotpixel e/o drawLine for mode 4 but expecially for mode 4 with the check of odd and even pixel address..
<br/>
<br/>
Thanks a lot...
<br/>
<br/>
P.S. "C" or ASM no probs...<br/>_________________<br/>Batblaster / 7 Raven Studios Co. Ltd
<br/>
------------------------------------------</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17288 - Lupin - Fri Mar 05, 2004 9:15 pm</h4>
    <div class="postbody"><span class="postbody">#define TIMES_240(x) (((x) &lt;&lt; 8) - ((x) &lt;&lt; 4)) 
<br/>
#define TIMES_120(x) (((x) &lt;&lt; 7) - ((x) &lt;&lt; 3)) 
<br/>
<br/>
void vplotixel16(int x, int y, u16 c) { 
<br/>
    register u16* p = VideoBuffer + TIMES_240(y) + x; 
<br/>
    register u16 rc = c; 
<br/>
    *p = rc; 
<br/>
}</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17296 - poslundc - Fri Mar 05, 2004 9:41 pm</h4>
    <div class="postbody"><span class="postbody">Ugh... sorry Lupin, but you've gotta take a second look...
<br/>
<br/>
1. Mode 4 is 8-bit paletted, not 16-bit direct.
<br/>
<br/>
2. Even with optimizations turned off, gcc will automatically optimize multiplication by a constant to shifts and adds where appropriate.
<br/>
<br/>
3. Your intermediate variable rc doesn't do anything.
<br/>
<br/>
4. Please use BBCode tags when posting code.
<br/>
<br/>
In addition to those more important points, the register directives are unlikely to do anything helpful (in fact, declaring the second one as a register is a very bad suggestion to the compiler), and using the u16 datatype as a parameter is just going to cause additional overhead in the function call.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17301 - Miked0801 - Fri Mar 05, 2004 11:03 pm</h4>
    <div class="postbody"><span class="postbody">Ok, blind coding here
<br/>
<br/>
This would need a C header like
<br/>
void PlotPixel(u32 xPos, u32 yPos, u8 color, u16 *videoBuffer);
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ Assume 1st param is X and 2nd is Y and both are on screen (should be asserted)
<br/>
<br/>
    .GLOBAL     PlotPixel
<br/>
    .CODE 32
<br/>
<br/>
@ r0 = x
<br/>
@ r1 = y
<br/>
@ r2 = 8-bit value
<br/>
@ r3 = Video buffer (probably should be a constant, but no biggie)
<br/>
<br/>
PlotPixel:
<br/>
   add   r3,r1,r1,#lsl 8      @ Get x240 by 256 - 16
<br/>
   sub   r3,r3,r1,#lsr 4      @ ...
<br/>
   movs  r0,r0,#0,#lsr 1      @ /2 and set carry if we want low byte saved
<br/>
   adc   r0,r0,#0         @ Add carry back in
<br/>
   eor   r0,r0,#1         @ Reverse low byte to read opposite of the address
<br/>
   ldrb  r0,[r3,r0]         @ Read the byte
<br/>
   orrcs r0,r0,r2,#lsl 8      @ if Carry, move color value high
<br/>
   orrcc r0,r2,r0,#lsl 8      @ if not, color low, video value high
<br/>
   strh  r0,[r3]            @ store the result
<br/>
   
<br/>
   bx    r14               @ return
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
For real speed, get rid of call/return (bx), and just macro.  The bx takes more than than the inside code.  Also, I'm pretty sure 1 more cycle can be shaved by combining the mov, eor, adc in a more clever manner, but I can't see it right now.  Anyone else care to compile at test :)
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17307 - batblaster - Sat Mar 06, 2004 2:32 am</h4>
    <div class="postbody"><span class="postbody">Many thanks, i will try to sompile and check if work correctly but on r3 i need to pass the videomemory location like 0x06000000 or 0x0600a000 for the backbuffer...
<br/>
<br/>
Is not good to use a variant like this ???
<br/>
<br/>
        ADD     r3,     r3,     #0x6000000          @ r3 = r3 + VRAM_ADDR
<br/>
<br/>
        @ START - F_DISCNT_BUFSEL_GET
<br/>
        MOV     r7,     #0x04000000                 @ r3 = 0x04000000
<br/>
        LDR     r7,     [r7]                        @ r4 = val from addr 0x04000000
<br/>
        AND     r7,     r7,     #0x10               @ r4 = r4 &amp; 0x10
<br/>
        MOV     r7,     r7,     LSR #4              @ r4 = r4 &gt;&gt; 4
<br/>
        @ End - F_DISCNT_BUFSEL_GET
<br/>
<br/>
        CMP     r7,     #1                          @ r4 == 1
<br/>
        ADDNE   r3,     r3,     #0xA000             @ r3 = r3 + 0xA000 (Backbuffer Addr)
<br/>
<br/>
<br/>
I'm not very good in asm on ARM and i don't know if is faster or not. A check of what memory buffer you want fill in "C" before calling the routine is needed...
<br/>
<br/>
Thanks thanks...<br/>_________________<br/>Batblaster / 7 Raven Studios Co. Ltd
<br/>
------------------------------------------</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17308 - Miked0801 - Sat Mar 06, 2004 2:45 am</h4>
    <div class="postbody"><span class="postbody">Just past in the 4th param as your buffer (r3) and it will work as is.  That's way I made it a register to begin with.  You're supposed to pass in the base address into the register for it to work right.
<br/>
<br/>
Make a 100 pixel vertical line down the screen.
<br/>
<br/>
for(i=0; i&lt;100, i++)
<br/>
{
<br/>
    PlotPixel(0, i, 0x80, (u16 *)(0x06000000));
<br/>
}
<br/>
<br/>
or 
<br/>
<br/>
make it to the back buffer
<br/>
<br/>
for(i=0; i&lt;100, i++)
<br/>
{
<br/>
    PlotPixel(0, i, 0x80, (u16 *)(0x0600a000));
<br/>
}
<br/>
<br/>
or
<br/>
<br/>
to EWRAM if you want
<br/>
<br/>
for(i=0; i&lt;100, i++)
<br/>
{
<br/>
    PlotPixel(0, i, 0x80, (u16 *)(0x02000000));
<br/>
}
<br/>
<br/>
<br/>
The code doesn't care.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17320 - Miked0801 - Sat Mar 06, 2004 9:43 am</h4>
    <div class="postbody"><span class="postbody">Was trying to go to sleep when my mind chimed in and told me there was a bug in my pixel code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
PlotPixel: 
<br/>
   add   r3,r1,r1,#lsl 8      @ Get x240 by 256 - 16 
<br/>
   sub   r3,r3,r1,#lsr 4      @ ... 
<br/>
   movs  r0,r0,#0, #lsr 1     @ x/2 + address and use carry for low/high 
<br/>
   add   r3,r3,r0             @ Add x to address
<br/>
   rsc   r0,r0,#1             @ Use reverse subtract carry to reverse the carry for address read.  
<br/>
   ldrb  r0,[r3,r0]           @ Read the byte (r0 is 0 or 1 for offset)
<br/>
   orrcs r0,r0,r2,#lsl 8      @ if Carry, move color value high 
<br/>
   orrcc r0,r2,r0,#lsl 8      @ if not, color low, video value high 
<br/>
   strh  r0,[r3]              @ store the result with base address only.
<br/>
    
<br/>
   bx    r14                  @ return 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The previous version wasn't storing the value in the right memory location due to halfword accesses not being able to register offset.  BTW, if I'm wrong on halfword access mode (don't have docs here - also the reverse subtract carry pnumonic may be incorrect), we can shave 1 more cycle off this by throwing away the adds X to  address add and just offseting by r3 below.  Not bad: 16 cycles (not including bx which I think would be 8! cycles here if jumping back to ROM code) for a mode 4 pixel write.  I'd love to be able to combine the movs and the following add instructions as they aren't pulling their own weight in this code.  I know there's 1 more cycle to be had here.  Also, correct me if I'm wrong on the timing.  I believe the read in 4 cycles and write is 5 here (assuming VRAM access) - at least that is what no$gba is telling me.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17325 - FluBBa - Sat Mar 06, 2004 12:19 pm</h4>
    <div class="postbody"><span class="postbody">I think it should be something like this...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">PlotPixel: 
<br/>
  rsb  r1,r1,r1,#lsl 4   @ Get x15 
<br/>
  add  r3,r3,r0       @ Add x to address
<br/>
  tst  r0,r0,#1       @ test odd address. 
<br/>
  ldrb r0,[r3,r1,#lsl 4]      @ Read the byte (r1=y*15*16=y*240)
<br/>
  orrcs r0,r0,r2,#lsl 8   @ if Carry, move color value high 
<br/>
  orrcc r0,r2,r0,#lsl 8   @ if not, color low, video value high 
<br/>
  strh r0,[r3,r1,#lsl4]       @ store the result with base address only.
<br/>
  
<br/>
  bx  r14         @ return</td> </tr></table><span class="postbody">
<br/>
<br/>
Not tested yet though.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17328 - torne - Sat Mar 06, 2004 1:36 pm</h4>
    <div class="postbody"><span class="postbody">FluBBa: that code does not work. Halfword loads and stores use ARM addressing mode 3, which does not allow use of the shifter to construct addresses. Only offsets by a constant or a register are allowed, no scaled register offsets.
<br/>
Mike: that's the answer to your question too. Do you not have a copy of the ARM ARM? If you google about, many ARM partners have accidentally made it available for download on their website (which makes it their fault, not yours, if you download it) - I got mine from Altera but that link's been removed since.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17345 - Miked0801 - Sat Mar 06, 2004 6:40 pm</h4>
    <div class="postbody"><span class="postbody">It was 1:00am at home so I didn't have any docs available :)
<br/>
<br/>
That said, is it true that it is broken?  If so, I'll look at it some more and figure it out.
<br/>
<br/>
BTW, no need to use test.  The mov instruction earlier should save the flag.  If it's lost on the rsc, then set the flag on that instruction and chcek against the zero flag instead.  Again, just blind coding, but the results should be really close to working if not already.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17348 - Lupin - Sat Mar 06, 2004 7:09 pm</h4>
    <div class="postbody"><span class="postbody">poslundc: the function shows how to plot 2 8 bit pixels and that's why it is important to have the color data type 16 bit. Plotting single 8 bit pixels in mode 4 makes no sense to me because it is a slowdown.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17354 - Miked0801 - Sat Mar 06, 2004 8:42 pm</h4>
    <div class="postbody"><span class="postbody">Ok, at work - have a compiler and imagine that, my syntax was absolute crap.  Here's a version that is tested to work.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
PlotPixel:
<br/>
   add    r3,r3,r1, lsl #8      @ Get x240 by 256 - 16 
<br/>
   sub    r3,r3,r1, lsl #4      @ ...
<br/>
   movs   r0,r0, lsr #1         @ Place low bit on Carry (shifting X off by 1)   
<br/>
   add    r3,r3,r0, lsl #1      @ Add x (without low bit) back into base address
<br/>
   ldrcsb r0,[r3]               @ Read the low byte if Carry set
<br/>
   ldrccb r0,[r3,#1]            @ Read the high byte if Carry Clear
<br/>
   orrcs  r0,r0,r2, lsl #8      @ if Carry Set, move color value high 
<br/>
   orrcc  r0,r2,r0, lsl #8      @ else, color low, video value high 
<br/>
   strh   r0,[r3]               @ store the result with base address only. 
<br/>
    
<br/>
   bx    r14                    @ return 
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
There is 1 more cycle to be had here - I just know it.  I'm using mov, I've got 2 wasted cycles on nops, and I'm not using a register for offseting on my load/saves.  Anyways, enjoy.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17370 - FluBBa - Sat Mar 06, 2004 11:56 pm</h4>
    <div class="postbody"><span class="postbody">Ok, thought that one over and came up with this...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">PlotPixel: 
<br/>
  rsb  r1,r1,r1,#lsl 4   @ Get Yx15 
<br/>
  eor r0,r0,#1       @read the other byte
<br/>
  add  r3,r3,r0       @ Add X to address
<br/>
  tst  r0,r0,#1       @ test odd address. 
<br/>
  ldrb r0,[r3,r1,#lsl 4]!      @ Read the byte (Y*15*16=Y*240), writeback adr to r3
<br/>
  orrne r0,r0,r2,#lsl 8   @ if Carry, move color value high 
<br/>
  orreq r0,r2,r0,#lsl 8   @ if not, color low, video value high 
<br/>
  strh r0,[r3]       @ store the result with base address only.
<br/>
  
<br/>
  bx  r14         @ return</td> </tr></table><span class="postbody">
<br/>
Not much different in timing from Miked0801's though.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17371 - LOst? - Sun Mar 07, 2004 12:02 am</h4>
    <div class="postbody"><span class="postbody">I did this for my GDI driver in my Windows XP port. It's only a Put Pixel and it is used for drawing lines and circles. I haven't found a way to move a whole buffered picture that isn't ^2 though.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   void Display::PutPixel (int x, int y, u8 PalEntry)
<br/>
   {
<br/>
      /** Delta check start **/
<br/>
   
<br/>
      int x1;
<br/>
      int y1;
<br/>
      int x2;
<br/>
      int y2;
<br/>
   
<br/>
      int deltax;
<br/>
      int deltay;
<br/>
   
<br/>
      x1 = ClippingRect.left;
<br/>
      y1 = ClippingRect.top;
<br/>
      x2 = ClippingRect.right;
<br/>
      y2 = ClippingRect.bottom;
<br/>
   
<br/>
      // First source check
<br/>
      if (x2 - x1 &lt;= 0 || y2 - y1 &lt;= 0)
<br/>
         return;
<br/>
   
<br/>
      // Start and stop source correction
<br/>
      if (x1 &lt; 0)
<br/>
         x1 = 0;
<br/>
      if (y1 &lt; 0)
<br/>
         y1 = 0;
<br/>
      if (240 &lt; x2)
<br/>
         x2 = 240;
<br/>
      if (160 &lt; y2)
<br/>
         y2 = 160;
<br/>
   
<br/>
      // Calculate source deltas
<br/>
      deltax = x2 - x1;
<br/>
      deltay = y2 - y1;
<br/>
      
<br/>
      // Final check
<br/>
      if (deltax &lt;= 0 || deltay &lt;= 0)
<br/>
         return;
<br/>
   
<br/>
      /** Delta check end **/
<br/>
      
<br/>
      u16 color;
<br/>
   
<br/>
      if (x1 &lt;= x &amp;&amp; y1 &lt;= y &amp;&amp; x &lt; x2 &amp;&amp; y &lt; y2)
<br/>
      {
<br/>
         if ((x &amp; 1) == 0)
<br/>
         {
<br/>
            color = (PalEntry &amp; 0xFF);
<br/>
            VirtualScreen [y * 120 + (x &gt;&gt; 1)] = (VirtualScreen [y * 120 + (x &gt;&gt; 1)] &amp; 0xFF00) | color;
<br/>
         }
<br/>
         else
<br/>
         {
<br/>
            color = (PalEntry &amp; 0xFF) &lt;&lt; 8;
<br/>
            VirtualScreen [y * 120 + (x &gt;&gt; 1)] = (VirtualScreen [y * 120 + (x &gt;&gt; 1)] &amp; 0xFF) | color;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And it worked pretty good after all, which made me happy :)
<br/>
<br/>
/LOst</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17389 - Miked0801 - Sun Mar 07, 2004 5:24 am</h4>
    <div class="postbody"><span class="postbody">Ok, I knew there was an extra cycle to be had :)  Your's is 11% faster with the extra cycle gone (flubba).  Well done. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17396 - Miked0801 - Sun Mar 07, 2004 9:18 am</h4>
    <div class="postbody"><span class="postbody">Ok, found a problem.  On X is even (0,2,4...), you eor to Odd, then write that address to r3.  Later you're halfword storing to that odd address which is (according to my documentation an experience) illegal.  We'll have to try again - see the same thread in the asm section :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17402 - batblaster - Sun Mar 07, 2004 12:18 pm</h4>
    <div class="postbody"><span class="postbody">This is the faster Way to write a "C" Version
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline void PutPixel(u16 *pScreen, u32 X, u32 Y, u16 Color)
<br/>
{
<br/>
   u16 *StoreHere = &amp;pScreen[((Y*240)+X)&gt;&gt;1];
<br/>
<br/>
   if(X&amp;1)
<br/>
      *StoreHere = (Color&lt;&lt;8) + (*StoreHere &amp; 0x00FF);
<br/>
   else
<br/>
      *StoreHere = (*StoreHere &amp; 0xFF00) + Color;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>Batblaster / 7 Raven Studios Co. Ltd
<br/>
------------------------------------------</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
