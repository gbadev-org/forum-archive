<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Huffman Decoder in VBA - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Huffman Decoder in VBA</h2>
<div id="posts">
<div class="post">
    <h4>#23001 - f(DarkAngel) - Fri Jul 02, 2004 3:46 pm</h4>
    <div class="postbody"><span class="postbody">Has anyone got huffman encoding work in VBA (1.7.2)? I've been implementing a huffman encoder and it never works correctly on VBA, i can't be sure since i don't have equipment to test it on real hardware either.
<br/>
Both Cowbite and GBATek says the 5th byte is treeSize/2-1 but VBA bios.cpp tries to get the original value by (treeSize&lt;&lt;1)+1 instead of (treeSize+1)&lt;&lt;1.
<br/>
<br/>
Here's the original code from VBA 1.7.2
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// VisualBoyAdvance - Nintendo Gameboy/GameboyAdvance (TM) emulator.
<br/>
// Copyright (C) 1999-2003 Forgotten
<br/>
// Copyright (C) 2004 Forgotten and the VBA development team
<br/>
<br/>
// This program is free software; you can redistribute it and/or modify
<br/>
// it under the terms of the GNU General Public License as published by
<br/>
// the Free Software Foundation; either version 2, or(at your option)
<br/>
// any later version.
<br/>
//
<br/>
// This program is distributed in the hope that it will be useful,
<br/>
// but WITHOUT ANY WARRANTY; without even the implied warranty of
<br/>
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br/>
// GNU General Public License for more details.
<br/>
//
<br/>
// You should have received a copy of the GNU General Public License
<br/>
// along with this program; if not, write to the Free Software Foundation,
<br/>
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<br/>
<br/>
void BIOS_HuffUnComp()
<br/>
{
<br/>
#ifdef DEV_VERSION
<br/>
  if(systemVerbose &amp; VERBOSE_SWI) {
<br/>
    log("HuffUnComp: 0x%08x,0x%08x (VCOUNT=%d)\n",
<br/>
        reg[0].I,
<br/>
        reg[1].I,
<br/>
        VCOUNT);
<br/>
  }
<br/>
#endif
<br/>
  
<br/>
  u32 source = reg[0].I;
<br/>
  u32 dest = reg[1].I;
<br/>
<br/>
  u32 header = CPUReadMemory(source);
<br/>
  source += 4;
<br/>
<br/>
  if(((source &amp; 0xe000000) == 0) ||
<br/>
     ((source + ((header &gt;&gt; 8) &amp; 0x1fffff)) &amp; 0xe000000) == 0)
<br/>
    return;  
<br/>
  
<br/>
  u8 treeSize = CPUReadByte(source++);
<br/>
<br/>
  u32 treeStart = source;
<br/>
<br/>
  source += (treeSize&lt;&lt;1) + 1;
<br/>
  
<br/>
  int len = header &gt;&gt; 8;
<br/>
<br/>
  u32 mask = 0x80000000;
<br/>
  u32 data = CPUReadMemory(source);
<br/>
  source += 4;
<br/>
<br/>
  int pos = 0;
<br/>
  u8 rootNode = CPUReadByte(treeStart);
<br/>
  u8 currentNode = rootNode;
<br/>
  bool writeData = false;
<br/>
  int byteShift = 0;
<br/>
  int byteCount = 0;
<br/>
  u32 writeValue = 0;
<br/>
<br/>
  if((header &amp; 0x0F) == 8) {
<br/>
    while(len &gt; 0) {
<br/>
      // take left
<br/>
      if(pos == 0)
<br/>
        pos++;
<br/>
      else
<br/>
        pos += (((currentNode &amp; 0x3F)+1)&lt;&lt;1);
<br/>
      
<br/>
      if(data &amp; mask) {
<br/>
        // right
<br/>
        if(currentNode &amp; 0x40)
<br/>
          writeData = true;
<br/>
        currentNode = CPUReadByte(treeStart+pos+1);
<br/>
      } else {
<br/>
        // left
<br/>
        if(currentNode &amp; 0x80)
<br/>
          writeData = true;
<br/>
        currentNode = CPUReadByte(treeStart+pos);
<br/>
      }
<br/>
      
<br/>
      if(writeData) {
<br/>
        writeValue |= (currentNode &lt;&lt; byteShift);
<br/>
        byteCount++;
<br/>
        byteShift += 8;
<br/>
<br/>
        pos = 0;
<br/>
        currentNode = rootNode;
<br/>
        writeData = false;
<br/>
<br/>
        if(byteCount == 4) {
<br/>
          byteCount = 0;
<br/>
          byteShift = 0;
<br/>
          CPUWriteMemory(dest, writeValue);
<br/>
          writeValue = 0;
<br/>
          dest += 4;
<br/>
          len -= 4;
<br/>
        }
<br/>
      }
<br/>
      mask &gt;&gt;= 1;
<br/>
      if(mask == 0) {
<br/>
        mask = 0x80000000;
<br/>
        data = CPUReadMemory(source);
<br/>
        source += 4;
<br/>
      }
<br/>
    }
<br/>
  } else {
<br/>
    int halfLen = 0;
<br/>
    int value = 0;
<br/>
    while(len &gt; 0) {
<br/>
      // take left
<br/>
      if(pos == 0)
<br/>
        pos++;
<br/>
      else
<br/>
        pos += (((currentNode &amp; 0x3F)+1)&lt;&lt;1);
<br/>
<br/>
      if((data &amp; mask)) {
<br/>
        // right
<br/>
        if(currentNode &amp; 0x40)
<br/>
          writeData = true;
<br/>
        currentNode = CPUReadByte(treeStart+pos+1);
<br/>
      } else {
<br/>
        // left
<br/>
        if(currentNode &amp; 0x80)
<br/>
          writeData = true;
<br/>
        currentNode = CPUReadByte(treeStart+pos);
<br/>
      }
<br/>
      
<br/>
      if(writeData) {
<br/>
        if(halfLen == 0)
<br/>
          value |= currentNode;
<br/>
        else
<br/>
          value |= (currentNode&lt;&lt;4);
<br/>
<br/>
        halfLen += 4;
<br/>
        if(halfLen == 8) {
<br/>
          writeValue |= (value &lt;&lt; byteShift);
<br/>
          byteCount++;
<br/>
          byteShift += 8;
<br/>
          
<br/>
          halfLen = 0;
<br/>
          value = 0;
<br/>
<br/>
          if(byteCount == 4) {
<br/>
            byteCount = 0;
<br/>
            byteShift = 0;
<br/>
            CPUWriteMemory(dest, writeValue);
<br/>
            dest += 4;
<br/>
            writeValue = 0;
<br/>
            len -= 4;
<br/>
          }
<br/>
        }
<br/>
        pos = 0;
<br/>
        currentNode = rootNode;
<br/>
        writeData = false;
<br/>
      }
<br/>
      mask &gt;&gt;= 1;
<br/>
      if(mask == 0) {
<br/>
        mask = 0x80000000;
<br/>
        data = CPUReadMemory(source);
<br/>
        source += 4;
<br/>
      }
<br/>
    }    
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
If GBATek and Cowbite are correct, this seems to be a bug and i'm going to post a bug-report to sf tracker.<br/>_________________<br/>death scream...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23002 - Lord Graga - Fri Jul 02, 2004 4:02 pm</h4>
    <div class="postbody"><span class="postbody">It's not the BIOS huffuncomp routine unless you actually call that routine via ASM... :P
<br/>
<br/>
HUFF uncomp is done like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//---------------------------------------------------------------------------------
<br/>
void HuffUnComp(void *source, void *dest)
<br/>
//---------------------------------------------------------------------------------
<br/>
{
<br/>
   SystemCall(19);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
This is the definition of SystemCall():
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#if   defined   ( __thumb__ )
<br/>
#define   SystemCall(Number)    asm ("SWI     "#Number"\n" :::  "r0", "r1", "r2", "r3")
<br/>
#else
<br/>
#define   SystemCall(Number)    asm ("SWI     "#Number"   &lt;&lt; 16\n" :::"r0", "r1", "r2", "r3")
<br/>
#endif
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23010 - Miked0801 - Fri Jul 02, 2004 6:14 pm</h4>
    <div class="postbody"><span class="postbody">Bah, right your own decompressor - it'll go faster :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23062 - Lupin - Sat Jul 03, 2004 8:13 am</h4>
    <div class="postbody"><span class="postbody">i think he was just posting the uncompress function of VBA, not his own uncompress function.
<br/>
<br/>
There was a sample on gbadev some time ago showing huffman uncomp - it worked on VBA<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23077 - f(DarkAngel) - Sat Jul 03, 2004 2:38 pm</h4>
    <div class="postbody"><span class="postbody">It think my post was truly clear. I was waiting for at least 1 reply that is an answer related to my question (thanks Lupin).
<br/>
Graga, i know how to execute a swi. Save such posts to "beginners" section. And i said, that didn't work on VBA. This is why i checked out the VBA source code.
<br/>
BTW, I don't know how this "own uncompressor" thing got invented.
<br/>
<br/>
Lupin, do you still have the source?<br/>_________________<br/>death scream...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23138 - FluBBa - Mon Jul 05, 2004 1:21 pm</h4>
    <div class="postbody"><span class="postbody">If you own a GBA (which I hope you do) just download a BIOS from the net somehwere, then you can easily see if it's VBA's implementation that doesn't work or if it's on your side.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23161 - caitsith2 - Tue Jul 06, 2004 4:26 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>FluBBa wrote:</b></span></td> </tr> <tr> <td class="quote">If you own a GBA (which I hope you do) just download a BIOS from the net somehwere, then you can easily see if it's VBA's implementation that doesn't work or if it's on your side.</td> </tr></table><span class="postbody">
<br/>
<br/>
Or even better,  write your own bios dumping routine, and dump it yourself. It goes something like this.   The bios call for MidiKey2Freq is SWI 0x1F, and should be defined as u32 MidiKey2Freq(u32 wavedata, u8 cMK, u8 cFP);.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
    int i, j;
<br/>
<br/>
    for (i=0;i&lt;0x4000;i++)
<br/>
    {
<br/>
        j = MidiKey2Freq(i-(((i &amp; 3)+1)| 3), 168, 0);
<br/>
        j = j * 2;
<br/>
        j = j &gt;&gt; 24;
<br/>
<br/>
        //Code here to somehow transfer j over to your PC.  How you do 
<br/>
        // that transfer, depends on what kind of real hardware/pc 
<br/>
        // development setup you have.  One possibility, if you use just a
<br/>
        // flashcart, is to write j over into the sram, then dump that sram 
<br/>
        // later.
<br/>
    }
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23163 - DiscoStew - Tue Jul 06, 2004 4:57 am</h4>
    <div class="postbody"><span class="postbody">Are you sure it was a good idea to post that?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23164 - tepples - Tue Jul 06, 2004 5:01 am</h4>
    <div class="postbody"><span class="postbody">Martin Korth <a class="postlink" href="http://www.work.de/nocash/gbabios.htm" target="_blank">already posted</a> code equivalent to caitsith2's.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23165 - caitsith2 - Tue Jul 06, 2004 5:59 am</h4>
    <div class="postbody"><span class="postbody">That, and there is an advantage to dumping the bios yourself.  The main advantage, is that it is the only legal way to obtain the bios.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23169 - DiscoStew - Tue Jul 06, 2004 8:57 am</h4>
    <div class="postbody"><span class="postbody">Didn't know, but now I do. It is just one of those things where your not quite sure if it is ok.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23319 - Lupin - Fri Jul 09, 2004 8:50 pm</h4>
    <div class="postbody"><span class="postbody">Hm, i was wrong - the demo was just about LZSS compression not huffman, anyways here is the demo posted some time ago:
<br/>
<br/>
<a href="http://www.gbadev.org/download.php?section=misc&amp;filename=lzssdemo.zip" target="_blank">http://www.gbadev.org/download.php?section=misc&amp;filename=lzssdemo.zip</a><br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
