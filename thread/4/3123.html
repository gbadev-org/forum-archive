<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Fast int->string conversion? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Fast int->string conversion?</h2>
<div id="posts">
<div class="post">
    <h4>#18403 - Lupin - Thu Mar 25, 2004 4:02 pm</h4>
    <div class="postbody"><span class="postbody">I know there are C functions to do this, but i am generally against using these functions because i use asm :)
<br/>
<br/>
Well, i now have an function that divides the number by 10 and takes the mod value of the division. But i think a divide might be too slow for something that's so simple... do you know a better way to convert integers to strings?
<br/>
<br/>
I had another idea just as i wrote this post, we can just create an array of n length where each value is 10^n and then subtract the numbers from the number i want to convert and then just check for LowerThan flag set, if yes add the number back and add the number to the apropriate string position... might be a little slow on higher numbers (if 1 number of the input is 9 we will have to subtract the array number 9 times).<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18411 - poslundc - Thu Mar 25, 2004 6:05 pm</h4>
    <div class="postbody"><span class="postbody">Check out my <a class="postlink" href="http://danposluns.com/gbadev/posprintf/" target="_blank">posprintf page</a>. It essentially provides the same functionality of the sprintf routine to let you printf integers (as well as a couple of other different things) to strings. It also lets you do things like specify the length of the string to print, pad it with leading zeros, etc.
<br/>
<br/>
It's 100% Thumb ASM (so it doesn't consume any of your IWRAM), it's efficient, it's open-source and it uses a very fast base-conversion routine (all additions and shifts for numbers up to +/-65535).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18413 - Lupin - Thu Mar 25, 2004 8:05 pm</h4>
    <div class="postbody"><span class="postbody">uhm, if i understand your documentation right you use the same method that i explained above... but i am searching for a faster way to do this (if there is any :))
<br/>
<br/>
How much cycles/instructions does a bios divide take?<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18415 - sajiimori - Thu Mar 25, 2004 8:13 pm</h4>
    <div class="postbody"><span class="postbody">He just said it's all additions and shifts for a wide-ish range of numbers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18417 - DekuTree64 - Thu Mar 25, 2004 8:33 pm</h4>
    <div class="postbody"><span class="postbody">Here's mine:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@r0 = int between -65535 and 65535
<br/>
<br/>
.global itoa
<br/>
.thumb
<br/>
.align 2
<br/>
.thumb_func
<br/>
itoa:
<br/>
push {r4, r5}
<br/>
mov r5, r0
<br/>
bpl itoa_plus
<br/>
neg r0, r0
<br/>
itoa_plus:
<br/>
ldr r4, =tempStr   @global var, declared elsewhere
<br/>
add r4, #15
<br/>
mov r1, #0
<br/>
strb r1, [r4]
<br/>
ldr r1, =6554
<br/>
<br/>
itoa_loop:
<br/>
mov r3, r0
<br/>
mul r3, r1
<br/>
lsr r3, r3, #16
<br/>
lsl r2, r3, #3
<br/>
add r2, r3
<br/>
add r2, r3
<br/>
sub r0, r2
<br/>
add r0, #'0'
<br/>
sub r4, #1
<br/>
strb r0, [r4]
<br/>
mov r0, r3
<br/>
bne itoa_loop
<br/>
<br/>
cmp r5, #0
<br/>
bpl itoa_return
<br/>
mov r0, #'-'
<br/>
sub r4, #1
<br/>
strb r0, [r4]
<br/>
<br/>
itoa_return:
<br/>
mov r0, r4
<br/>
pop {r4, r5}
<br/>
bx lr
<br/>
<br/>
.pool</td> </tr></table><span class="postbody">
<br/>
<br/>
It's based on reciprocal multiplication to do the divide by 10, and then subtracting the result*10, which can be done with shifts, to get the remainder. You need to have a global called tempStr for it, it should be at least 7 bytes, because the longest number you can use is -65535, which is 6 chars+null. You could deal with 32 bit numbers if you use ARM so you can have 32x32=64 multiplication for a more accurate reciprocal (0x1999999A would be the one, I think), but I only use it for HP displays and stuff, which are never over 9999 anyway.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18419 - poslundc - Thu Mar 25, 2004 8:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lupin wrote:</b></span></td> </tr> <tr> <td class="quote">uhm, if i understand your documentation right you use the same method that i explained above...</td> </tr></table><span class="postbody">
<br/>
<br/>
Oh I don't. Not even remotely. Numbers up to +/-65536 don't require anything except a bunch of shifts and adds.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">How much cycles/instructions does a bios divide take?</td> </tr></table><span class="postbody">
<br/>
<br/>
It depends on the numbers being input into it. You can beat it with your own custom ASM routine or other techniques, but it beats the pants off of gcc's default divide routine.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18422 - Miked0801 - Thu Mar 25, 2004 8:44 pm</h4>
    <div class="postbody"><span class="postbody">BIOS divides take roughly 70 - 250 cycles to execute depending on the terms being divided.  ~60 cycles of this are overhead getting into the SWI interrupt.  Make your own and place it in RAM, don't loop and you can get a function that executes in half this time or better.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18425 - poslundc - Thu Mar 25, 2004 8:59 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">~60 cycles of this are overhead getting into the SWI interrupt.</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-style: italic">Whaaaaat...?</span> Is it really that bad?
<br/>
<br/>
I mean, what? Branch/link to the SWI handler, branch to the divide routine, push a bunch of registers, pop 'em off at the end and brach back, right? That can't be more than 20-30 cycles to get in and get out.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18431 - Miked0801 - Thu Mar 25, 2004 10:51 pm</h4>
    <div class="postbody"><span class="postbody">33 in, 34 out.  That's why I hate using swi stuff.
<br/>
<br/>
Swi - 3 cycles to do branch
<br/>
3 cycles to branch again to correct handler
<br/>
24 cycles to push registers, change the CPU state to system mode, and setup the jump (it is an interrupt after all!)
<br/>
3 cycles to actually get into the divide routine.
<br/>
<br/>
//------------------------------------
<br/>
Do Divide somewhat slowly here (5 cycles instead of 3 per bit as it uses a loop to save space instead of unrolling)
<br/>
//-------------------------------------
<br/>
<br/>
3 cycles at end of div to return
<br/>
28 cycles to unpop, reset the CPU state, and prepare to return
<br/>
3 cycles to jump return.
<br/>
<br/>
So the best case is around 67 + 20 or so cycles of 87 cycles
<br/>
Worst is 67 + 20 + 5*30 or so is about ~240 cycles
<br/>
<br/>
You can do sooo much better with an ARM IWRAM routine.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18433 - poslundc - Thu Mar 25, 2004 11:12 pm</h4>
    <div class="postbody"><span class="postbody">Wow, I didn't think it was nearly that bad. Maybe I should consider writing my own CPUFastSet while I'm at it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18437 - Lupin - Thu Mar 25, 2004 11:21 pm</h4>
    <div class="postbody"><span class="postbody">hmm, i wonder why they even implemented the swi functions? Some of them might be usefull for hardware specific stuff, but the arithmetic and compression functions seem to be beaten easily by some hand written IWRAM code...<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18438 - Miked0801 - Thu Mar 25, 2004 11:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Wow, I didn't think it was nearly that bad. Maybe I should consider writing my own CPUFastSet while I'm at it. 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
We already have - though not for speed reasons.  It's nice to have your own for error checking of values passed in (asserts again.)  But if you ever need a real fast copy/clear - then you should probably write your own copier.  Of course, if you assign a 4-byte alligned, 4 byte multiple size structure to another, the compiler will use ldm/stm for you which is really nice.  It can beat DMAs on smaller assigns do to the overhead of setting of the registers.  In ARM, it would probably be smart enough to do 8 registers at a time which is nice.  Try it sometime and check out the output.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18439 - Miked0801 - Thu Mar 25, 2004 11:39 pm</h4>
    <div class="postbody"><span class="postbody">And Lupin, I totally agree with you.  If they couldn't do it right, why do it at all?  The only reason to use the built in stuff is if you are copying huge things where the overhead doesn't hurt, or when it's something not speed critical (interruptVBlankWait().)  Compression can be written faster and better, the math functions ditto. The utilites ditto.  When I realize just what type of code was there and the overhead to use it, I almost cried at the waste of all that 0 wait-state ROM...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18440 - poslundc - Fri Mar 26, 2004 12:07 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">We already have - though not for speed reasons.  It's nice to have your own for error checking of values passed in (asserts again.)  But if you ever need a real fast copy/clear - then you should probably write your own copier.  Of course, if you assign a 4-byte alligned, 4 byte multiple size structure to another, the compiler will use ldm/stm for you which is really nice.  It can beat DMAs on smaller assigns do to the overhead of setting of the registers.  In ARM, it would probably be smart enough to do 8 registers at a time which is nice.  Try it sometime and check out the output.</td> </tr></table><span class="postbody">
<br/>
<br/>
Bah, it'd be quicker to write my own.
<br/>
<br/>
The obvious advantage to the BIOS functions is they don't consume IWRAM to get the 0-waitstate functionality, and can be useful (I suppose) for stuff that ought to be fast, but isn't necessarily time-critical. Why they couldn't write better algorithms for them... I dunno, deadlines or stupidity I guess.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
