<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>speed of (arithmetic) BIOS calls? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > speed of (arithmetic) BIOS calls?</h2>
<div id="posts">
<div class="post">
    <h4>#23331 - Cearn - Sat Jul 10, 2004 12:29 am</h4>
    <div class="postbody"><span class="postbody">I've been scouring the forum for details about the speeds of the swi routines, but I'm having very little luck here. Does anyone know where I can find their cycle-costs in one neat little package? (preferably gift-wrapped, bow optional)</span><span class="gensmall"><br/><br/>Last edited by Cearn on Sat Jul 10, 2004 11:13 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#23332 - Lord Graga - Sat Jul 10, 2004 12:42 am</h4>
    <div class="postbody"><span class="postbody">Hmm, disassemble the BIOS and start counting! ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23334 - Cearn - Sat Jul 10, 2004 12:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lord Graga wrote:</b></span></td> </tr> <tr> <td class="quote">Hmm, disassemble the BIOS and start counting! ;)</td> </tr></table><span class="postbody">
<br/>
Uhmmm ... I was kinda hoping I didn't have to. Really, <span style="font-style: italic">really</span> hoping.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23335 - dagamer34 - Sat Jul 10, 2004 1:15 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lord Graga wrote:</b></span></td> </tr> <tr> <td class="quote">Hmm, disassemble the BIOS and start counting! ;)</td> </tr></table><span class="postbody">
<br/>
Uhmmm ... I was kinda hoping I didn't have to. Really, <span style="font-style: italic">really</span> hoping.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
I'm guessing it's a complicated process. Mind explaining it to me? I don't have much to do at the moment...<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23337 - poslundc - Sat Jul 10, 2004 1:41 am</h4>
    <div class="postbody"><span class="postbody">All I know is anecdotal stuff, but from what I've heard both the bios functions tend to be algorithmically weak because they are optimized for space instead of speed, and will also do things like bounds checking that may be unnecessary for your application. Also, their speed is further impeded by the cost of issuing a SWI instruction which (although I'm not entirely sure why) takes about 50 cycles or so for the dispatch and return.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23338 - Cearn - Sat Jul 10, 2004 1:51 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">All I know is anecdotal stuff, but from what I've heard both the bios functions tend to be algorithmically weak because they are optimized for space instead of speed, and will also do things like bounds checking that may be unnecessary for your application. Also, their speed is further impeded by the cost of issuing a SWI instruction which (although I'm not entirely sure why) takes about 50 cycles or so for the dispatch and return.
<br/>
<br/>
Dan.</td> </tr></table><span class="postbody">
<br/>
Yeah, that's about what I could make out from reading some of the posts too. I'd read that they seemed optimised for space rather than speed and had a large overhead, but I'd still like to know what their costs actually <span style="font-style: italic">are</span>. I know DekuTree compared CpuFastSet and fixed-source DMA; I thought some people might have taken a closer look at some of the other BIOS functions as well.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23339 - DekuTree64 - Sat Jul 10, 2004 2:37 am</h4>
    <div class="postbody"><span class="postbody">Nope, I've never seen any speed comparisons on any of the others. I am a little curious myself, but I don't really have time to do detailed testing on them. Perhaps someone could make a full SWI profiling program. I think the most parameters any takes is 3, so you could make table of r0-r2 parameters, with a 4th parameter that's just a flag wether to run that SWI or not, and a swi function that you can give a number to in the 4th argument, like 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define FIRST_SWI_TO_TEST 6   // divide, though you could start anywhere
<br/>
#define SWIS_TO_TEST 20   // or however far you want to go
<br/>
<br/>
#define SWI_DO 1
<br/>
#define SWI_SKIP 0
<br/>
<br/>
const u32 table[NUM_SWIS_TO_TEST][4] = {
<br/>
   {50, 7, 0,        SWI_DO},   // for divide, do 50/7
<br/>
   {0, 0, 0,          SWI_SKIP},   // for divArm, skip it because it's only for compatibility
<br/>
   {100, 0, 0,      SWI_DO},   // for square root, do sqrt(100)
<br/>
  ... SWIS_TO_TEST sets of args
<br/>
};
<br/>
<br/>
swiTest(u32 arg1, u32 arg2, u32 arg3, u32 number)
<br/>
{
<br/>
   asm volatile("swi r3");  // r3 is the 'number' argument
<br/>
}
<br/>
 
<br/>
for(i = 0; i &lt; NUM_SWIS_TO_TEST; i++)
<br/>
{
<br/>
   if(table[i][3])
<br/>
   {
<br/>
      swiTest(table[i][0], table[i][1], table[i][2], FIRST_SWI_TO_TEST + i);
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
And set up a timer before calling swiTest in that loop, and then print it after. Call the swi a bunch of times too, to get a more accurate reading.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23384 - Miked0801 - Sun Jul 11, 2004 3:42 pm</h4>
    <div class="postbody"><span class="postbody">Which particular calls were you looking for?  I can single step run them through No$gba and let it add up the cycles for me.  If you single step, it doesn't branch to other interrupts and will also give you a cycle accurate value.  This is how I got the original cycle overhead values (and boy was I suprised!)  It basically has to jump through 2 seperate table lookup - jumps and a bunch of push/pops before it even gets to the code.  Same on the way out.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23386 - Cearn - Sun Jul 11, 2004 3:55 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Which particular calls were you looking for? </td> </tr></table><span class="postbody">
<br/>
Right now, 0x06 (Div) up to 0x0f (ObjAffineSet). I'd also like to know how the normal integer division (you know, when you do 42/13) measures up to the BIOS version, but that might be pushing my luck.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23427 - Miked0801 - Mon Jul 12, 2004 5:35 pm</h4>
    <div class="postbody"><span class="postbody">The divide parts I have studied in depth.  I'll run some quick test to be sure:  GCC is just using the / for a divide, BIOS is calling the SWI, while ARM is a thumb callable ARM routine adapted from Jeff F.'s page.  Note, the ARM routine calculates modulus for free (useful is situations where you need to do x / 10, x % 10) (BTW, all cycle counts are from No$GBAs profiling features and cycle counters.)
<br/>
<br/>
Ok, GCC Divide of 42 / 13 gives 251 cycles
<br/>
BIOS Divide returns at 109 cycles
<br/>
ARM Divide came back at 79 cycles
<br/>
<br/>
Now, I'll choose some larger numbers:
<br/>
42756 / 1083
<br/>
GCC: 339
<br/>
BIOS: 161
<br/>
ARM:78 cycles
<br/>
<br/>
One more
<br/>
4275655 / 78
<br/>
GCC: 507
<br/>
BIOS: 291
<br/>
ARM:110 cycles
<br/>
<br/>
Ok, we'll worst case it:
<br/>
427565555 / 3
<br/>
GCC: 747 cycles
<br/>
BIOS: 447 cycles
<br/>
ARM: 142 cycles
<br/>
<br/>
As you see, the BIOS overhead eats you up on smaller divides and on larger, the compact nature of it loses to a better written ARM one.  I've not tried the  others, but could if needed.
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23439 - tepples - Tue Jul 13, 2004 1:05 am</h4>
    <div class="postbody"><span class="postbody">Typically, the GCC divide is Thumb code in ROM. What happens if you pull out the GCC divide and put it in IWRAM?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23451 - FluBBa - Tue Jul 13, 2004 9:09 am</h4>
    <div class="postbody"><span class="postbody">Quick note, the BIOS divide also returns the modulus in r1 if I'm not misstaken.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23471 - Miked0801 - Tue Jul 13, 2004 6:04 pm</h4>
    <div class="postbody"><span class="postbody">Tepples:
<br/>
<br/>
If we pulled the GCC divide, it's thumb so it wouldn't take advantage of ARM 32-bit access.  I've looked at it and it's also a looped version (not unrolled) so it is losing performance there as well.
<br/>
<br/>
FluBBa:
<br/>
Thanks.  I've always called it through C code so I didn't know that :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23592 - batblaster - Thu Jul 15, 2004 10:24 pm</h4>
    <div class="postbody"><span class="postbody">Very Very good test for the division but can you tell me on how to make a div in arm ??? thanks a lot...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23635 - Miked0801 - Fri Jul 16, 2004 5:47 pm</h4>
    <div class="postbody"><span class="postbody">[url]
<br/>
<a href="http://www.peter-teichmann.de/adiv1e.html" target="_blank">http://www.peter-teichmann.de/adiv1e.html</a>
<br/>
[/url]
<br/>
<br/>
:)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#23642 - batblaster - Fri Jul 16, 2004 9:05 pm</h4>
    <div class="postbody"><span class="postbody">Many many Thanks for the division routines...<br/>_________________<br/>Batblaster / 7 Raven Studios Co. Ltd
<br/>
------------------------------------------</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49593 - ymalik - Sun Jul 31, 2005 7:30 pm</h4>
    <div class="postbody"><span class="postbody">Sorry for bumping this thread up, but I thought there wasn't any assembly instruction for division in ARM.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49596 - tepples - Sun Jul 31, 2005 7:41 pm</h4>
    <div class="postbody"><span class="postbody">There isn't. The GBA BIOS implements division in terms of repeated shifts and subtractions.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
