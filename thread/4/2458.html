<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Rams and Rom - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Rams and Rom</h2>
<div id="posts">
<div class="post">
    <h4>#13231 - RaBBi - Tue Dec 09, 2003 8:54 am</h4>
    <div class="postbody"><span class="postbody">Hi all,
<br/>
<br/>
After reading the first chapters of the new e-book "Programming the Nintendo Game Boy Advance" which has been given away for free by the author, I learned a bit more about types of Ram of the GBA.
<br/>
<br/>
But I think I don't have a good understanding of them yet.
<br/>
<br/>
So could someone give me a brief explanation about different memory parts of the GBA?
<br/>
(IWRAM, EWRAM, RAM...) and ROM.
<br/>
I would like to know for what purpose may I have to use a certain Ram, or Rom, and how to write in them respectivly.
<br/>
<br/>
Thank you ^^<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13232 - mathieu - Tue Dec 09, 2003 11:12 am</h4>
    <div class="postbody"><span class="postbody">The memory parts of the GBA can be subdivided into 2 categories :
<br/>
<br/>
1. the internal parts
<br/>
<br/>
Those are fast SRAMS. IWRAM goes at the same speed as the CPU (16 Mhz), and therefore a memory access takes 1 cycle (we talk about wait-states to define how many cycles does the CPU use to access a random part of the memory --&gt; N wait-states = N+1 cycles), therefore it is a 0-wait-state memory, and it is 32 kB wide. Moreover, its access bus is 32-bit wide, and therefore you can fetch a word (32-bit) every cycle.
<br/>
<br/>
EWRAM is bigger (256 kB), and has no wait-state either (not sure of that however). But as its bus is only 16-bit wide, to fetch a word the memory chipset will perform two memory reads (therefore it takes 2 cycles).
<br/>
<br/>
And last, there is the system ROM, containing the GBA bios, 32-bit and 0 wait-state according to the Cowbite spec.
<br/>
<br/>
2. The external parts
<br/>
<br/>
On a cartidge, you have generally :
<br/>
<br/>
A ROM (PROM, EPROM, EEPROM) containing your program and static data.
<br/>
The ROMs specifications can vary (generally 16-bit wide, and 0-2 wait-states).
<br/>
<br/>
Cart RAM, which is generally either an EEPROM or a SRAM, 8-bit wide bus, and wait-states varying depending on your cart.
<br/>
<br/>
<br/>
3. Purpose.
<br/>
<br/>
IWRAM is here to store variables or inner program loops (if you program a bit in ARM assembly, for example).
<br/>
<br/>
EWRAM is used by multi-boot to store a program that can be up to 256 kB, or can be used as a general-purpose memory (if you need more than 32 kB of RAM to work on). If you choose to execute a program from it, prefer Thumb code, which should be faster on a 16-bit bus RAM.
<br/>
<br/>
Those two can be accessed from code at run-time.
<br/>
<br/>
Cart ROM is where all the data and the main program reside - graphics, audio,
<br/>
basically everything taking a lot of space. It can be programmed using a flash-linker, and usually can be only read at run-time.
<br/>
<br/>
Cart RAM is used to save data between games, and shouldn't be used as a general-purpose memory.  Your program needs to behave in a special way to store or read data from it.
<br/>
<br/>
<br/>
I guess that's all... Any thoughts ?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13233 - krozen - Tue Dec 09, 2003 11:17 am</h4>
    <div class="postbody"><span class="postbody">Hey,
<br/>
Just learing about this myself from that book too :)
<br/>
If you don't expliclity tell the compiler where to put functions etc., where does it go? is it better to say where in memory to put things, rather than having the compiler handle it? Is it possible to handle the loading of code into IWRAM dynamically e.g. adding a function, removing it, adding another at runtime?
<br/>
Thanks for your help guys</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13234 - ampz - Tue Dec 09, 2003 12:22 pm</h4>
    <div class="postbody"><span class="postbody">How about reading some FAQ's and GBA documents before asking? Pretty much everything you are asking is well covered by a number of FAQ's.
<br/>
And if you really need to ask about theese kind of basic stuff, post it to the "Beginners" section. There is a reason it exists.
<br/>
<br/>
mathieu: There is no cart with 0 waitstate ROM, and the cart ROM is allways 16bit wide. Also I think EWRAM operates at 1 waitstate.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13235 - mathieu - Tue Dec 09, 2003 1:03 pm</h4>
    <div class="postbody"><span class="postbody">As for EWRAM... If it operates with 1 waitstate, that means you need 2 cycles to get a half-word (because it's 16-bit wide) --&gt; therefore 4 cycles to get a word ?
<br/>
<br/>
(or three, if there is fast-read operation ?)
<br/>
<br/>
Or can one get a word in 2 cycles, thus meaning it has "1 waitstate" (considering the "word" viewpoint), but 0 real waitstate --&gt; considering you get a half-word in 1 cycle ?
<br/>
<br/>
Argh, this gets confusing :-p.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13237 - torne - Tue Dec 09, 2003 3:06 pm</h4>
    <div class="postbody"><span class="postbody">IWRAM has zero wait states and is on a 32-bit bus, so one cycle for 32 bits.
<br/>
<br/>
EWRAM has two wait states. It's possible to set it to run in 1WS but that's possibly unstable and is an undocumented function. As it's 2WS memory, it takes three cycles to load a 16-bit value from EWRAM, and six to load a 32-bit value (there is no sequential timing for EWRAM)
<br/>
<br/>
ROM (in the cart) has 4 wait states by default; you can also select 8, 3, or 2. For a sequential access (i.e. the next halfword), only 2 wait states (can also select 4, 8, or 1) are needed. Thus, to load a 16-bit value from ROM with default settings takes 3 cycles if it's sequential, or 5 if it's nonsequential. To load a 32-bit value from ROM with default settings takes 6 cycles if it's sequential (the second halfword is always sequential), or 8 cycles if it's nonsequential.
<br/>
<br/>
The definition of 'sequential' is not really 'the next halfword', however. The way the GBA's bus is multiplexed means that any two addresses whose lower 9 bits (the bottom bit of an address is always ignored as the cart bus always transfers halfwords) are the same, are sequential, and any two addresses whose lower 9 bits differ are nonsequential. Thus, 0x8000000 and 0x800002D are considered to be sequential, whereas 0x80001FE and 0x8000200 are not (despite being consecutive halfwords).
<br/>
<br/>
Hope this is a sufficiently clear and detailed answer. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13238 - RaBBi - Tue Dec 09, 2003 3:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">How about reading some FAQ's and GBA documents before asking? Pretty much everything you are asking is well covered by a number of FAQ's.
<br/>
And if you really need to ask about theese kind of basic stuff, post it to the "Beginners" section. There is a reason it exists.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Sorry for this ampz, I'm not the one who asks before reading.
<br/>
I use to search by myself.
<br/>
But I didn't find anything which explain clearly and explicitly the purpose of the Rams and HOW and WHEN to write in them. (with the correct syntax and what the syntaxe do exactly).
<br/>
[I'm a phpBB board admin too, and it's too simple to move a topic.
<br/>
I think it can be done easily. But I'll remind it for next time]
<br/>
<br/>
Some tell that the compiler can handle this task.
<br/>
But it doesn't know that it works for GBA, doesn't it?
<br/>
<br/>
Anyway, thanks for all your answers.
<br/>
There are things I knew yet.
<br/>
In fact, I need code to illustrate this.
<br/>
<br/>
Thank you.<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13241 - Miked0801 - Tue Dec 09, 2003 7:06 pm</h4>
    <div class="postbody"><span class="postbody">Torne, are those Sequential WaitState access time for prefetched ROM or not?  BTW, can anyone here explain just how the prefetch function works for timings?
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13243 - ampz - Tue Dec 09, 2003 8:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">The definition of 'sequential' is not really 'the next halfword', however. The way the GBA's bus is multiplexed means that any two addresses whose lower 9 bits (the bottom bit of an address is always ignored as the cart bus always transfers halfwords) are the same, are sequential, and any two addresses whose lower 9 bits differ are nonsequential. Thus, 0x8000000 and 0x800002D are considered to be sequential, whereas 0x80001FE and 0x8000200 are not (despite being consecutive halfwords).</td> </tr></table><span class="postbody">
<br/>
<br/>
This is incorrect.
<br/>
The definition of "sequantial" IS "the next half word", even in GBA world. I have no idea how you came up with this 9-bit idea, and I cannot see how you can possibly map it onto the GBA cart interface.
<br/>
The lower 16bits of the address bus are multiplexed with the data bus, the upper 8bits are not. In theory, two accesses where the lower 16bits of the addresses are sequential, but the upper 8bits are not, could be made a sequential access, but Nintendo's engineers did not make the hardware that way since there would be no point of doing that.
<br/>
<br/>
RaBBi: Thoose questions are not GBA questions, but basic C language stuff. The compiler knows nothing about memory areas, and it does not have to, it's the linkers job. You tell the linker the addresses of each memory area you want to use, and for what purpose.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13245 - torne - Tue Dec 09, 2003 10:25 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">The definition of "sequantial" IS "the next half word", even in GBA world. I have no idea how you came up with this 9-bit idea, and I cannot see how you can possibly map it onto the GBA cart interface.</td> </tr></table><span class="postbody">
<br/>
<br/>
The description of the cart interface that I had says that the upper 16 bits are latched and the lower 8 can be changed. This gives you 9 bits of 'sequential' accesses (due to halfword alignment). I don't remember where this came from, it's some random text file I have amongst my ARM docs that doesn't have an author. The description in the no$ documentation, though slightly vague, says as you did in your post; I'd just not read that before. I don't doubt that you're right, but the way I described would be a much better hardware design. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13273 - RaBBi - Wed Dec 10, 2003 1:59 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<br/>
RaBBi: Thoose questions are not GBA questions, but basic C language stuff. The compiler knows nothing about memory areas, and it does not have to, it's the linkers job. You tell the linker the addresses of each memory area you want to use, and for what purpose.</td> </tr></table><span class="postbody">
<br/>
<br/>
Ok. Understood.
<br/>
But how exactly?
<br/>
<br/>
I just need very detailed explanation, just samples of what I need to do/wrote to specify Ram Type/section I want to use.
<br/>
<br/>
Do you want me to recreate a topic un C/C++ section?<br/>_________________<br/>Sorry for my poor english, but it would be worst for you to understand me if I speak in my native language, French ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13277 - tepples - Wed Dec 10, 2003 4:32 pm</h4>
    <div class="postbody"><span class="postbody">Telling the linker where to put your code is explained <a class="postlink" href="http://www.devrs.com/gba/files/gbadevfaqs.php#IntRamCode" target="_blank">here</a>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
