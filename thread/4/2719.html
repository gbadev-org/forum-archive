<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Collision detection with 45 degree tiles? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Collision detection with 45 degree tiles?</h2>
<div id="posts">
<div class="post">
    <h4>#15364 - LOst? - Wed Jan 21, 2004 1:11 pm</h4>
    <div class="postbody"><span class="postbody">I have seen that nessie.gbadev.org has a map editor that I want to use, mostly because it allows flipping of tiles and 16 color tiles.
<br/>
But I've seen that the sample map that comes with the maped zip has 45 degree tiles in its collision array.
<br/>
How do you program 45 degree colision detection?
<br/>
Is there any good formula for making other collision tiles with different degrees?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15375 - batblaster - Wed Jan 21, 2004 4:43 pm</h4>
    <div class="postbody"><span class="postbody">The only way to check 45 deg. is pixel by pixel creatin a mask of your tile... I think is the only way to do but you can found some problem when manage all other routines like jump and gravity...
<br/>
<br/>
You need to work a lot, i made mine for a platform i want to release but now i'm in vacation and is not 100% fixed i've some small problem...<br/>_________________<br/>Batblaster / 7 Raven Studios Co. Ltd
<br/>
------------------------------------------</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15378 - yaustar - Wed Jan 21, 2004 5:40 pm</h4>
    <div class="postbody"><span class="postbody">I did it quite easily actually but I cannot remember how I did coded it (damn my amature coding)  <span style="font-style: italic">how</span> I did it though.....:/<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15380 - LOst? - Wed Jan 21, 2004 7:19 pm</h4>
    <div class="postbody"><span class="postbody">Well, if someone can help me. I want to know how to make it as fast as possible.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15382 - yaustar - Wed Jan 21, 2004 7:24 pm</h4>
    <div class="postbody"><span class="postbody">here is the code for the character moving up
<br/>
var_x and var_y is the co ords for the map and the character always stays in the center of the screen.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
case 1://up
<br/>
        {    
<br/>
            switch((Tank_Out_Collision[var_snakeHeight][((((var_y+71) &gt;&gt; 3) &lt;&lt; 6)) + 
<br/>
                        ((var_x+108) &gt;&gt; 3)+65] &amp; 0x000F))
<br/>
            {
<br/>
            case 4: return 1; break; //solid squares
<br/>
            case 2: return 1; break; //bottom left triangle
<br/>
            case 1: return 1; break; //bottom right triangle
<br/>
            case 5: func_moveEnvir(var_x, var_y, -1, 0); break; //top right triangle
<br/>
            case 6: func_moveEnvir(var_x, var_y, 1, 0); break; //top left triangle
<br/>
            case 3: var_snakeHeight--; break; //drop a level
<br/>
            case 7: var_snakeHeight++; break; //rise a level
<br/>
            default: break;
<br/>
            }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I can send the binary of it in action if you want...
<br/>
<br/>
btw sorry about the magic numbers :(<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"><br/><br/>Last edited by yaustar on Wed Jan 21, 2004 8:53 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#15385 - sajiimori - Wed Jan 21, 2004 8:34 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The only way to check 45 deg. is pixel by pixel creatin a mask of your tile...
<br/>
</td> </tr></table><span class="postbody">
<br/>
When you're tempted to say something that begins with "The only way to...", you would do well to reconsider, unless you have some reason to believe that you've explored every possible alternative (unlikely).
<br/>
<br/>
When colliding with perfect square blocks, a collision occurs anywhere in the block.  When colliding with blocks that have a 45 degree slope, a collision only happens in the solid half.
<br/>
<br/>
For example, if tx is the distance from the left tile border, and ty is the distance from the top tile border, and the tile is solid on the bottom-right (i.e. a right incline), then a collision occurs when tx &gt; tile_height - ty.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15392 - Miked0801 - Wed Jan 21, 2004 10:02 pm</h4>
    <div class="postbody"><span class="postbody">I've coded arbitrary angle collision detection tiles a couple of times now.  The code for it is very simple and fast to run.  You just need some basic knowledge of Vector Math to pull it off.  Basically, setup 2 points on the edge of the char (in char coords), turn this into a vector.  Assume that all points to the right of this line are solid.  To test collision, get where on the char you wish to check, take the 2D determinant (cross product) of the line vector against the vector formed from your point and the starting point of the edge vector.  If it's positive, you're colliding, negative, you're not, 0, you're on the line.  Very qucik and can be turned into a reflection or slide along endge with ease.
<br/>
<br/>
Example of 45 degree diagonal (a solid char can be coded by running a vector along the edge of the tile):
<br/>
<br/>
Vector AB = {8 - 0, 8 - 0} = {8,8}
<br/>
<br/>
Vector AB = {8,8}
<br/>
Vector AC = {1,4}
<br/>
Vector AD = {5,2}
<br/>
Vector AE = {2,2}
<br/>
<br/>
Det(AB, AC) = 8 * 4 - 1 * 8 = 24 : positive == collide
<br/>
Det(AB, AD) = 8 * 2 - 5 * 8 = -24 : negative == no collide
<br/>
Det(AB, AE) = 8 * 2 - 5 * 2 = 0 : On line
<br/>
<br/>
BTW, if you turn the line vector into a unit vector, the result of the Det is the actual distance from the line :)
<br/>
<br/>
I love vector math!
<br/>
<br/>
Mike
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
A-+-+-+-+-+-+-+-+
<br/>
|X| | | | | | | |
<br/>
+-\-+-+-+-+-+-+-+
<br/>
|X|X| | | | | | |
<br/>
+-+-E-+-+-D-+-+-+
<br/>
|X|X|X| | | | | |
<br/>
+-+-+-\-+-+-+-+-+
<br/>
|X|X|X|X| | | | |
<br/>
+-C-+-+-\-+-+-+-+
<br/>
|X|X|X|X|X| | | |
<br/>
+-+-+-+-+-\-+-+-+
<br/>
|X|X|X|X|X|X| | |
<br/>
+-+-+-+-+-+-\-+-+
<br/>
|X|X|X|X|X|X|X| |
<br/>
+-+-+-+-+-+-+-\-+
<br/>
|X|X|X|X|X|X|X|X|
<br/>
+-+-+-+-+-+-+-+-B
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15408 - Derek - Thu Jan 22, 2004 6:02 am</h4>
    <div class="postbody"><span class="postbody">Its actually a lot simpler than that for 45 degree angles.
<br/>
<br/>
The basic forumlar is just: D = X - Y
<br/>
D will be neg for one side or pos for the other.
<br/>
<br/>
Assuming you are using 24:8 fix point maths then, you first detect a full cell collision, then a part cell collision using only the fractional component of the 24:8 fix point coords.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">D = (X &amp; 0xFF) - (Y &amp; 0xFF)</td> </tr></table><span class="postbody">
<br/>
For other 45 degree angles you swap one or both of the coords:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">D = (0x100 - (X &amp; 0xFF)) - (Y &amp; 0xFF)</td> </tr></table><span class="postbody">
<br/>
<br/>
So there are no multiplies required.
<br/>
<br/>
BTW: This is the same method used to clip 3D polygons to 45 degree plains without using multiplies. Plus, the distances returned by this method can be plugged into a lerp function to calc the clipping point.
<br/>
<br/>
Derek Evans
<br/>
<a class="postlink" href="http://www.theteahouse.com.au/gba/index.html" target="_blank">http://www.theteahouse.com.au/gba/index.html</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15409 - Derek - Thu Jan 22, 2004 6:14 am</h4>
    <div class="postbody"><span class="postbody">The other method which is the best IMHO. Is, to grab the disance to the cell under your feet, and then grab the distance to the next cell to the right. The distances should be 24:8 fix point maths.
<br/>
<br/>
You can then calc the actually distance based on your fractional X pos using a linear interpolation function:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define f2i(A) ((A)&gt;&gt;8)
<br/>
#define i2f(A) ((A)&lt;&lt;8)
<br/>
#define intmul(A,B) ((A)*(B))
<br/>
#define fixmul(A,B) f2i(intmul(A,B))
<br/>
#define FIXLERP(A,B,C) ((A)+fixmul((B)-(A),(C)))
<br/>
int realdist = FIXLERP(d1, d2, e-&gt;x &amp; 0xFF);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This is the method used by 3D terrain engines. You can view a platform game as a 2D terrain. Note: you only have to use a LERP for cells which are defined as a terrain.
<br/>
<br/>
Derek Evans</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15427 - LOst? - Thu Jan 22, 2004 2:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Derek wrote:</b></span></td> </tr> <tr> <td class="quote">The other method which is the best IMHO. Is, to grab the disance to the cell under your feet, and then grab the distance to the next cell to the right. The distances should be 24:8 fix point maths.
<br/>
<br/>
You can then calc the actually distance based on your fractional X pos using a linear interpolation function:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define f2i(A) ((A)&gt;&gt;8)
<br/>
#define i2f(A) ((A)&lt;&lt;8)
<br/>
#define intmul(A,B) ((A)*(B))
<br/>
#define fixmul(A,B) f2i(intmul(A,B))
<br/>
#define FIXLERP(A,B,C) ((A)+fixmul((B)-(A),(C)))
<br/>
int realdist = FIXLERP(d1, d2, e-&gt;x &amp; 0xFF);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This is the method used by 3D terrain engines. You can view a platform game as a 2D terrain. Note: you only have to use a LERP for cells which are defined as a terrain.
<br/>
<br/>
Derek Evans</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Your code may be useful to me!
<br/>
<br/>
Do you have any source code for this you can send me?
<br/>
<br/>
mail:
<br/>
ola[(((((((((at))))]logotypes.se</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15429 - LOst? - Thu Jan 22, 2004 2:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">I've coded arbitrary angle collision detection tiles a couple of times now.  The code for it is very simple and fast to run.  You just need some basic knowledge of Vector Math to pull it off.  Basically, setup 2 points on the edge of the char (in char coords), turn this into a vector.  Assume that all points to the right of this line are solid.  To test collision, get where on the char you wish to check, take the 2D determinant (cross product) of the line vector against the vector formed from your point and the starting point of the edge vector.  If it's positive, you're colliding, negative, you're not, 0, you're on the line.  Very qucik and can be turned into a reflection or slide along endge with ease.
<br/>
<br/>
Example of 45 degree diagonal (a solid char can be coded by running a vector along the edge of the tile):
<br/>
<br/>
Vector AB = {8 - 0, 8 - 0} = {8,8}
<br/>
<br/>
Vector AB = {8,8}
<br/>
Vector AC = {1,4}
<br/>
Vector AD = {5,2}
<br/>
Vector AE = {2,2}
<br/>
<br/>
Det(AB, AC) = 8 * 4 - 1 * 8 = 24 : positive == collide
<br/>
Det(AB, AD) = 8 * 2 - 5 * 8 = -24 : negative == no collide
<br/>
Det(AB, AE) = 8 * 2 - 5 * 2 = 0 : On line
<br/>
<br/>
BTW, if you turn the line vector into a unit vector, the result of the Det is the actual distance from the line :)
<br/>
<br/>
I love vector math!
<br/>
<br/>
Mike
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
A-+-+-+-+-+-+-+-+
<br/>
|X| | | | | | | |
<br/>
+-\-+-+-+-+-+-+-+
<br/>
|X|X| | | | | | |
<br/>
+-+-E-+-+-D-+-+-+
<br/>
|X|X|X| | | | | |
<br/>
+-+-+-\-+-+-+-+-+
<br/>
|X|X|X|X| | | | |
<br/>
+-C-+-+-\-+-+-+-+
<br/>
|X|X|X|X|X| | | |
<br/>
+-+-+-+-+-\-+-+-+
<br/>
|X|X|X|X|X|X| | |
<br/>
+-+-+-+-+-+-\-+-+
<br/>
|X|X|X|X|X|X|X| |
<br/>
+-+-+-+-+-+-+-\-+
<br/>
|X|X|X|X|X|X|X|X|
<br/>
+-+-+-+-+-+-+-+-B
<br/>
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
<br/>
Wow, can I set up any degrees in a ytile for collision with this code?
<br/>
<br/>
Vector Math, no I've never worked with it. Can you teach me quick?
<br/>
<br/>
2D determinant (cross product), teach me quick, this is heavy stuff :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15433 - poslundc - Thu Jan 22, 2004 3:16 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Vector Math, no I've never worked with it. Can you teach me quick?
<br/>
<br/>
2D determinant (cross product), teach me quick, this is heavy stuff :P</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah Mike... teach him vector math, but make it snappy...
<br/>
<br/>
(Some of us spent several years in university learning vector math.)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15435 - LOst? - Thu Jan 22, 2004 5:34 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Vector Math, no I've never worked with it. Can you teach me quick?
<br/>
<br/>
2D determinant (cross product), teach me quick, this is heavy stuff :P</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah Mike... teach him vector math, but make it snappy...
<br/>
<br/>
(Some of us spent several years in university learning vector math.)
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
lol
<br/>
<br/>
Come on. I only need the goodies!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15436 - Miked0801 - Thu Jan 22, 2004 6:53 pm</h4>
    <div class="postbody"><span class="postbody">lol!
<br/>
<br/>
Vectors 101
<br/>
<br/>
A vector is line with a direction.  It can be formed by subtracting 2 points.  The first point is an anchor, the second gives direction.
<br/>
<br/>
Vectors can be added, subtracted.  They can be multiplied in 2 ways - through dot products and cross products.  Without delving to deep into theory, a dot product can be thought as the projection of one vector upon another while a cross product returns a vector that is perpendicular to the 2 vectors that were crossed (useful for finding a normal to a plane - or if used right, the distance between a point and a line which is how I'm using it.)
<br/>
<br/>
A dot is calculated by multiplying like terms between the vectors and adding the results (giving a scalar value which is a magnitude.)
<br/>
<br/>
A cross is a bit more complicated but for 2D is formed by multiplying and adding/subtracting terms to form a new vector - or in the case of a Determinent, adding and subtracting the values. 
<br/>
<br/>
Bah.  Read a physics book.  Learn.  Enjoy the fruits of your own labors (labours) :)
<br/>
<br/>
There's a lot more to it than this.  I can't prove my theories to you without you having basic knowledge - but if you learn vectors, yu will be amazed at how many sin/cos/tan/arctan type trig functions turn into simple additions, subtractions, and multiplies.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15437 - alek - Thu Jan 22, 2004 6:54 pm</h4>
    <div class="postbody"><span class="postbody">Determinant:
<br/>
<br/>
A determinant is a certain kind of function that associates a real number with a square Matrix.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">A = [ a  b]
<br/>
    [ c  d]
<br/>
<br/>
det(A) = a*d-b*c</td> </tr></table><span class="postbody">
<br/>
<br/>
Cross product 
<br/>
If <span style="font-weight: bold">u</span> = (u(1), u(2), u(3)) and <span style="font-weight: bold">v</span> = (v(1), v(2), v(3)) are vectors in 3-space, then the cross product <span style="font-weight: bold">u </span> x <span style="font-weight: bold">v</span> is the vector defined by: 
<br/>
<span style="font-weight: bold">u </span> x <span style="font-weight: bold">v</span> =  (u(2)*v(3)-u(3)*v(2), u(3)*v(1)-u(1)*v(3), u(1)*v(2)-u(2)*v(1)) 
<br/>
and is perpendicular to both <span style="font-weight: bold">u </span> and <span style="font-weight: bold">v</span>
<br/>
<br/>
:)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15438 - Miked0801 - Thu Jan 22, 2004 7:00 pm</h4>
    <div class="postbody"><span class="postbody">lol.  That's straight out of a linear Algebra book :)
<br/>
<br/>
I'm waiting for the full N-Space theory stuff next to confuse him :)
<br/>
<br/>
BTW, yes - my method works for any arbitrary angle - and can work across tile boundaries if you want to define you collision set in the world as a group of lines - though there are issues with this that involve finding the correct line to check against :)
<br/>
<br/>
Just define a different vector for each angle.
<br/>
<br/>
22.5 degrees - The A vector defined as (4,8).
<br/>
0 degress  - (0, 8)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15464 - LOst? - Thu Jan 22, 2004 10:38 pm</h4>
    <div class="postbody"><span class="postbody">So, your "Vector" variable? Can I see the typedef of it?
<br/>
<br/>
Let me guess (Ok, I'm really blind, so help me):
<br/>
<br/>
typedef struct
<br/>
{
<br/>
int x; // X coordinate
<br/>
int y; // Y coordinate
<br/>
int speed_x; // Horizontal speed
<br/>
int speed_y; // Vertical speed
<br/>
} Vector;
<br/>
<br/>
I really should learn some math :P
<br/>
This is heavy stuff!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15471 - Miked0801 - Thu Jan 22, 2004 11:09 pm</h4>
    <div class="postbody"><span class="postbody">typedef struct _VECTOR2D {
<br/>
s32 x;
<br/>
s32 y;
<br/>
} VECTOR2D;
<br/>
<br/>
or you can use an array as well.  Just need 2 values for a 2D array like I'm showing in my samples.  (8,8), (8,0), etc.
<br/>
<br/>
truth is in our engine its defined as an f16_16.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15472 - LOst? - Thu Jan 22, 2004 11:13 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;math.h&gt;
<br/>
#include "vector.h"
<br/>
<br/>
<br/>
//-----------------------------------------------------------------------------
<br/>
// Name:
<br/>
// Desc:
<br/>
//-----------------------------------------------------------------------------
<br/>
<br/>
void CVector::operator = (CVector v)
<br/>
{
<br/>
   x = v.x;
<br/>
   y = v.y;
<br/>
   z = v.z;
<br/>
}
<br/>
<br/>
//-----------------------------------------------------------------------------
<br/>
// Name:
<br/>
// Desc:
<br/>
//-----------------------------------------------------------------------------
<br/>
<br/>
CVector CVector::operator - (CVector a)
<br/>
{
<br/>
   CVector t;
<br/>
   
<br/>
   t.x = x - a.x;
<br/>
   t.y = y - a.y;
<br/>
   t.z = z - a.z;
<br/>
   
<br/>
   return t;
<br/>
}
<br/>
<br/>
//-----------------------------------------------------------------------------
<br/>
// Name:
<br/>
// Desc:
<br/>
//-----------------------------------------------------------------------------
<br/>
<br/>
float CVector::Lenght ()
<br/>
{
<br/>
   return (float)sqrt (x*x+y*y+z*z);
<br/>
}
<br/>
<br/>
//-----------------------------------------------------------------------------
<br/>
// Name:
<br/>
// Desc: Convert to uint vector whit lenght 0-1
<br/>
//-----------------------------------------------------------------------------
<br/>
<br/>
void CVector::Normalize ()
<br/>
{
<br/>
   float len = 1 / Lenght ();
<br/>
   
<br/>
   x*=len; y*=len; z*=len;
<br/>
<br/>
}
<br/>
<br/>
//-----------------------------------------------------------------------------
<br/>
// Name: Dot product 
<br/>
// Desc: a Dot b = |b|*|a| * cos (theta)
<br/>
// 
<br/>
// a dot b &gt; 0 less than 90 apart 
<br/>
// a dot b = 0 exactly 90 apart 
<br/>
// a dot b &lt; 0 more than 90 apart  
<br/>
// 
<br/>
//-----------------------------------------------------------------------------
<br/>
<br/>
float CVector::Dot (CVector v)
<br/>
{
<br/>
   return ( x*v.x + y*v.y + z*v.z);
<br/>
}
<br/>
<br/>
//-----------------------------------------------------------------------------
<br/>
// Name:
<br/>
// Desc:
<br/>
//-----------------------------------------------------------------------------
<br/>
<br/>
void CVector::Cross (CVector a, CVector b)
<br/>
{   
<br/>
   x = a.y*b.z - a.z*b.y;
<br/>
   y = a.z*b.x - a.x*b.z;
<br/>
   z = a.x*b.y - a.y*b.x;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I looked at my friend's 3d engine, and guess what I found :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15475 - Miked0801 - Thu Jan 22, 2004 11:17 pm</h4>
    <div class="postbody"><span class="postbody">Imagine that :)
<br/>
<br/>
Truthfully, creating a vector class is almost always one of the tasks given to newbie C++ programmers.  You can find millions of these around :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15803 - NitroSR - Fri Jan 30, 2004 5:47 pm</h4>
    <div class="postbody"><span class="postbody">Here's a structure for a vector that I am working on... the idea is to split the components of a vector logically into it's fixed point and tile-based components using a series of unions.  By accessing a vector's x_tile member, you get which tile your entity is located in, x_whole gives you the true x-component and so forth.  This allows for 16.16 fixed point math and easy tile-based management... 
<br/>
<br/>
This of course, assumes 8x8 logical tiles are being used for collision detection/response, it's not to difficult to change this to 16x16.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">struct tile_vector {
<br/>
   
<br/>
   union { /* Allow X Coordinate to be accessed raw, or via it's components. */
<br/>
   
<br/>
      int x;
<br/>
    
<br/>
      struct {
<br/>
      
<br/>
         short x_fraction:16;  /* for 16.16 fixed point. */       
<br/>
       
<br/>
         union {
<br/>
         
<br/>
            short x_whole:16;
<br/>
         
<br/>
            struct {  
<br/>
               short x_subtile:3;    
<br/>
               short x_tile:13;
<br/>
               }; /* The whole bits can be divided into the tile and sub_tile position. */
<br/>
         
<br/>
            }; /* ends whole component union */
<br/>
      
<br/>
         }; /* ends anonymous struct x_bits */
<br/>
      
<br/>
      }; /* ends anonymous union x */
<br/>
     
<br/>
   union { /* Allow Y Coordinate to be accessed raw, or via it's components. */
<br/>
   
<br/>
      int y;
<br/>
    
<br/>
      struct {
<br/>
      
<br/>
         short y_fraction:16;  /* for 16.16 fixed point. */       
<br/>
       
<br/>
         union {
<br/>
         
<br/>
            short y_whole:16;
<br/>
         
<br/>
            struct {  
<br/>
               short y_subtile:3;    
<br/>
               short y_tile:13;
<br/>
               }; /* The whole bits can be divided into the tile and sub_tile position. */
<br/>
         
<br/>
            }; /* ends whole component union */
<br/>
      
<br/>
         }; /* ends anonymous struct y_bits */
<br/>
      
<br/>
      }; /* ends anonymous union y */
<br/>
   
<br/>
   }; /* ends struct tile_coord */</td> </tr></table><span class="postbody">
<br/>
<br/>
Of course, you can always access the pure x/y components if you wish as these would be used for normal math functions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15808 - Miked0801 - Fri Jan 30, 2004 7:19 pm</h4>
    <div class="postbody"><span class="postbody">I'm always very wary of bitfields.  ANSI C doesn't define the  way that the data has to be stored such that one compiler may store data Big Endian, another Small, another reverse, etc.
<br/>
<br/>
Call me paranoid, but I like to access my Fixed Data with Macros and bit operators so I know exactly how my data is stored and used.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#15810 - NitroSR - Fri Jan 30, 2004 7:32 pm</h4>
    <div class="postbody"><span class="postbody">I understand your concern... MACROS are definately a safe solution for accessing these sorts of things and on top of that you are also completely certain of what sort of code is being generated to access the various fields.
<br/>
<br/>
However, if you keep your development environment sufficiently consistent, the bitfield issue should not cause any problems, also the edian issue can probably be handled with #ifdefs
<br/>
<br/>
I meant this as a suggestion, but thanks for the feedback, I still have a ways to go with my GBA development and I may drop this union/struct idea all together.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27155 - abilyk - Mon Oct 04, 2004 9:38 pm</h4>
    <div class="postbody"><span class="postbody">Hey Mike, this was part of your post on the first page:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Assume that all points to the right of this line are solid. To test collision, get where on the char you wish to check, take the 2D determinant (cross product) of the line vector against the vector formed from your point and the starting point of the edge vector. If it's positive, you're colliding, negative, you're not, 0, you're on the line. Very qucik and <span style="font-weight: bold">can be turned into a reflection or slide along endge with ease</span>.</td> </tr></table><span class="postbody">
<br/>
<br/>
Can you go into detail regarding expanding this method for sliding along an edge?  I think I get the general idea, to use a projection, but I'm having problems fully understanding it.  Any clarification would be appreciated.
<br/>
<br/>
Thanks,
<br/>
Andrew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27215 - Miked0801 - Wed Oct 06, 2004 7:04 pm</h4>
    <div class="postbody"><span class="postbody">Pulling up the old archives huh.  Haven't seen that in a while :)
<br/>
<br/>
Sliding - use the previously mentioned method for determining a collision has occured.  Move the offending object out of collision by either backing him up 1 tics movement (quick, but will cause some slighy jiggling of the sprite as it moves along the edge), or my determining at what point the movement vector crossed into the target object and placing him there (the correct dot product will tell you the magnitude along the wall where the collide occured.  A mul and an add per coordinate gets you the location.)  
<br/>
<br/>
Now, determine which direction relative to the edge normal that the player wishes to move (more dot/determinent quick work.)  and slide the player in that direction using the walls positive or negative vector.
<br/>
<br/>
Easy right :)
<br/>
<br/>
The cool thing about this approach is that it works in N space for any vectors (2D, 3D, nD.)  
<br/>
<br/>
Enjoy</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27218 - abilyk - Wed Oct 06, 2004 9:51 pm</h4>
    <div class="postbody"><span class="postbody">Thanks a lot for the reply, Mike.  It seems really straightforward, and I understand all of it except for one part:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">(the correct dot product will tell you the magnitude along the wall where the collide occured. A mul and an add per coordinate gets you the location.)</td> </tr></table><span class="postbody">
<br/>
<br/>
Using the example below, AB is my collision vector, CD is my movement vector, and point E is where the vectors meet.
<br/>
<br/>
AB = {8,8}
<br/>
CD = {-4,2}
<br/>
AD = {1,4}
<br/>
<br/>
I guess my question is that, which vectors do I need to take the dot product of?  I assume that it's one of these two pairs,
<br/>
<br/>
AB dot CD = 8 * -4 + 8 * 2 = -32 + 16 = -16
<br/>
AB dot AD = 8 * 1 + 8 * 4 = 8 + 32 = 40
<br/>
<br/>
but I haven't been able to figure out how either of those values relates to point E.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
A-+-+-+-+-+-+-+-+
<br/>
|X| | | | | | | |
<br/>
+-\-+-+-+-+-+-+-+
<br/>
|X|X| | | | | | |
<br/>
+-+-\-+-+-C-+-+-+
<br/>
|X|X|X| | | | | |
<br/>
+-+-+-E-+-+-+-+-+
<br/>
|X|X|X|X| | | | |
<br/>
+-D-+-+-\-+-+-+-+
<br/>
|X|X|X|X|X| | | |
<br/>
+-+-+-+-+-\-+-+-+
<br/>
|X|X|X|X|X|X| | |
<br/>
+-+-+-+-+-+-\-+-+
<br/>
|X|X|X|X|X|X|X| |
<br/>
+-+-+-+-+-+-+-\-+
<br/>
|X|X|X|X|X|X|X|X|
<br/>
+-+-+-+-+-+-+-+-B
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27231 - Miked0801 - Thu Oct 07, 2004 1:49 am</h4>
    <div class="postbody"><span class="postbody">The problem is to get the exact point of collison along the line, you have to normalize a vector which is expensive (read a coupl of divides and sqrts or edists and inverse muls if you're careful.)  That's the reason in our engine, I just back them up a tic and deal with a touch of jiggling as they get close to the wall.  I've run out of time tonight, but I'll post the exact formula tomorrow after I get some work done :)
<br/>
<br/>
You could also solve the simultanous system of equations that the 2 lines represent, but that'd be a bit slow as gausian elimination requires some horse power :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
