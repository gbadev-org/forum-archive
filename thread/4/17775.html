<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>game save: memory block copying - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > game save: memory block copying</h2>
<div id="posts">
<div class="post">
    <h4>#176999 - blessingta@hotmail.co.uk - Sat Nov 19, 2011 12:11 am</h4>
    <div class="postbody"><span class="postbody">I'm trying to create a function to copy memory for what will be my game saves in bytes. And so far I have been trying to make my algorithm work in c++ but it refuses to work. 
<br/>
<br/>
the problem is where </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">*pt_destination++ = *pt_source++;</td> </tr></table><span class="postbody"> its complaining that I'm not allowed to access this.
<br/>
<br/>
why is it?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//why wont this function work?
<br/>
<br/>
void* memory_copy(void * x_destination, void const * x_source, size_t bytes)
<br/>
{
<br/>
   //cast destination to the size of a byte
<br/>
char * pt_destination = (char*) x_destination;
<br/>
//cast source to the size of a byte 
<br/>
char const *pt_source = (char const *) x_source;
<br/>
<br/>
//loop terminates when all the bytes have been copied
<br/>
while (bytes--)
<br/>
{
<br/>
*pt_destination++ = *pt_source++;
<br/>
<br/>
}
<br/>
return (x_destination);
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177000 - elhobbs - Sat Nov 19, 2011 1:08 am</h4>
    <div class="postbody"><span class="postbody">I think you want "const char *pt_source" not "char const *pt_source"</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177001 - blessingta@hotmail.co.uk - Sat Nov 19, 2011 10:25 am</h4>
    <div class="postbody"><span class="postbody">I still get the error after the code modifications:
<br/>
<br/>
error message
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">An unhandled exception of type 'System.NullReferenceException' occurred in memorycopying.exe
<br/>
<br/>
Additional information: Object reference not set to an instance of an object.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// memorycopying.cpp : main project file.
<br/>
<br/>
#include "stdafx.h"
<br/>
#include &lt;string&gt;
<br/>
#include &lt;iostream&gt;
<br/>
using namespace System;
<br/>
<br/>
//MEMORT COPY
<br/>
//Arguements:
<br/>
//void * x_destination: what we are copying to
<br/>
//void * x_source: what we are copying from
<br/>
//size_t bytes: amount bytes to be copied
<br/>
//Purpose: For copying a block of code which will be used as a gamesave else where
<br/>
void* memory_copy(void * x_destination,  void const* x_source, size_t bytes);
<br/>
<br/>
int main(array&lt;System::String ^&gt; ^args)
<br/>
{
<br/>
    Console::WriteLine(L"Hello World");
<br/>
<br/>
   char * Message = "whats good blessman? whats really good?boondocks reference";
<br/>
   char * whats_my_message;
<br/>
   //memory copied
<br/>
   memory_copy(whats_my_message,Message,sizeof Message);
<br/>
<br/>
   std::cout&lt;&lt;whats_my_message&lt;&lt;std::endl;
<br/>
    return 0;
<br/>
}
<br/>
<br/>
<br/>
void* memory_copy(void * x_destination,  void const* x_source, size_t bytes)
<br/>
{
<br/>
   //cast destination to the size of a byte
<br/>
char * pt_destination = (char*) x_destination;
<br/>
//cast source to the size of a byte 
<br/>
const char *pt_source = (const char*) x_source;
<br/>
<br/>
//loop terminates when all the bytes have been copied
<br/>
while (bytes--)
<br/>
{
<br/>
*pt_destination++ = *pt_source++;
<br/>
<br/>
}
<br/>
return (x_destination);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">[/quote]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177002 - Dwedit - Sat Nov 19, 2011 5:21 pm</h4>
    <div class="postbody"><span class="postbody">The memory copy function itself looks fine, but I can't say the same about the rest of the code.  It's a total mess.  Lots of .NET framework specific code there, I thought you were targeting the GBA?
<br/>
<br/>
Lots of fundamental misunderstandings with C code here.
<br/>
Let's start with this line:
<br/>
   char * Message = "whats good blessman? whats really good?boondocks reference";
<br/>
<br/>
That's a string literal.  The memory for the string itself lives in the .rodata section.  On the GBA, that's in cartridge ROM.  You created a local variable that points to the string literal.  This is not the same as creating a local variable that is a *copy* of the string.  For string literals living in a read only section, a pointer to them should always be const.
<br/>
<br/>
If you want to easily create a writable copy of the string, declare it as an array instead: char Message[] = "...";  This create a char array that lives in the stack, and it is initialized to a copy of your literal string.  You can't enlarge this, but you can modify it.
<br/>
<br/>
<br/>
On the next line, you are creating a local variable that doesn't point to anything.  It's not even initialized to anything.  Of course you get a null pointer exception, you're writing to address 0, that's exactly what a null pointer exception is.
<br/>
<br/>
In order to copy memory, you need memory to copy to.  The memory could live on the stack, or in the heap.
<br/>
"xx = malloc(80);" will allocate 80 bytes on the heap.  So will "xx = new char[80];"  "char xx[80];" will create a local array on the stack that you can write to.
<br/>
<br/>
Note that you need to know the size of the memory.  If you write past the end of your allocated memory, you've create a buffer overflow bug, and the memory after it gets corrupted.  There's no automatic bounds checking for these kind of things.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177003 - blessingta@hotmail.co.uk - Sun Nov 20, 2011 2:23 am</h4>
    <div class="postbody"><span class="postbody">thanks, but I had just been trying out a memory copy algorithm before I got it onto asm. It turns out threre was another problem wrong with it, but it worked when I re-compiled the test again in visual studio.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
