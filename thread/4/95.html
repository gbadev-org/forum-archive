<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>FIFO - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > FIFO</h2>
<div id="posts">
<div class="post">
    <h4>#531 - lordmetroid - Wed Jan 08, 2003 2:47 pm</h4>
    <div class="postbody"><span class="postbody">I'm in the middle of creating my dynamic tile engine.
<br/>
<br/>
And thought that it would be smart not to overwrite a just rescently used tile from VRAM, in case it will be reused in a small amount of time...
<br/>
<br/>
So I decided to have a FIFO array, that keep track of what phys tile is representing the logic tile, together with a lock counter...
<br/>
<br/>
The array needs of course to overwrite itself or else it would go throught the whole memory destroying all other data in it's path.
<br/>
<br/>
The problem is I never done any FIFO system before, so how do one do?<br/>_________________<br/>*Spam*
<br/>
Open Solutions for an open mind, <a href="http://www.areta.org" target="_blank">www.areta.org</a>
<br/>
<br/>
Areta is an organization of coders codeing mostly open source project, but there is alot of sections like GBA dev, Language learning communities, RPG communities, etc...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#538 - Touchstone - Wed Jan 08, 2003 3:11 pm</h4>
    <div class="postbody"><span class="postbody">Just think of your FIFO buffer as a circular buffer.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">const int g_FIFOSize = 10;
<br/>
char g_pFIFO[g_FIFOSize];
<br/>
int g_FIFOCurrentPos;
<br/>
<br/>
void FIFOInit()
<br/>
{
<br/>
   g_FIFOCurrentPos = 0;
<br/>
}
<br/>
<br/>
void FIFOAddEntry(char _Entry)
<br/>
{
<br/>
   if (++g_FIFOCurrentPos == g_FIFOSize)
<br/>
      g_FIFOCurrentPos = 0;
<br/>
<br/>
   g_pFIFO[g_FIFOCurrentPos] = _Entry;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Obviously it can be implemented differently but the idea is that a FIFO buffer is just a circular buffer.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#541 - Splam - Wed Jan 08, 2003 4:35 pm</h4>
    <div class="postbody"><span class="postbody">FIFO isn't really the best way to do this as you could throw a load of tiles out when they hit the end of the buffer then suddenly need them again.  One thing I've always done is allow some space for tiles that are there a large amount of the time and they never get changed, then you can do things like read ahead slightly as you're drawing the new row/column to see whats coming up or even have an extra part of your map data thats predefined (in the map editor or wherever) that has the frequency of the tiles being used, then they're less likely to get kicked out of vram if they're on screen 90% of the time (or however often).
<br/>
<br/>
I had to do one of these for a playstation game a while ago, if I can find my source I'll have a look at exactly how I did it.
<br/>
<br/>
If you want to get really crazy you can use processor time when no new tiles are needed in vram for that frame to jiggle some of the others around so the next time you have to copy some in you only need 1 dma instead of lots of small ones.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
