<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>CPUFastSet (swi 12) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > CPUFastSet (swi 12)</h2>
<div id="posts">
<div class="post">
    <h4>#8584 - abilyk - Tue Jul 15, 2003 8:34 pm</h4>
    <div class="postbody"><span class="postbody">Greetings.
<br/>
<br/>
I've been trying to test the speeds of several data copy methods (so far, memcpy &amp; CPUFastSet) to find out the best way to implement a dynamic background-loading engine.
<br/>
<br/>
Memcpy certainly didn't give me any problems, but I'm having difficulty with CPUFastSet.  I believe I have the asm code set up correctly, but whenever I attempt a copy, it doesn't work.  (Note:  I've tried using both "swi 0x0C" and "swi 0x0C0000."  One doesn't do anything, and the other seems to freeze the system.  Though I'm not sure which to use, I do know that there's something else wrong)
<br/>
<br/>
I was initially trying to copy from ROM to VRAM.  After hours of struggle, it hit me that the registers (r0 and r1) that hold the source and destination addresses are only 32 bit, and because of that the complete address of each wouldn't be able to fit.  Hopeful, I then tried to copy from EWRAM to VRAM, and after that, VRAM to VRAM.  But neither of these worked.
<br/>
<br/>
Could someone more experience help me out?  Is it possible to copy from any address to any address with this method, or must they be within a certain distance from each other?  Following is the related code I've been using:
<br/>
<br/>
// function
<br/>
void CPUFastSet(void *source, void *dest, u32 length_mode) 
<br/>
{
<br/>
	asm volatile
<br/>
	(
<br/>
		"mov r0, %0\nmov r1, %1\nmov r2, %2\nswi 0x0C0000\n":  // asm code
<br/>
		:  // function output (none)
<br/>
		"r" (source), "r" (dest), "r" (length_mode) :  // function input
<br/>
		"r0", "r1", "r2"  //registers destroyed 
<br/>
	); 
<br/>
}
<br/>
<br/>
// map declaration
<br/>
const u16 map0[320] __attribute__ ((section(".ewram"))) = {0x0094,0x0094, etc.... )
<br/>
<br/>
// function call
<br/>
CPUFastSet((u32*)map0, VideoBuffer, (u32)20);
<br/>
<br/>
<br/>
Thanks,
<br/>
Andrew P. Bilyk
<br/>
<br/>
<br/>
P.S.  Also, some of you might suggest to just leave the SWI calls alone and use DMA.  The reason I'm shying from that is the fact that I'm planning on using the Krawall sound library with my games, and I don't want my DMA use to interfere with Krawall's.  Is this a valid concern?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8585 - ampz - Tue Jul 15, 2003 9:00 pm</h4>
    <div class="postbody"><span class="postbody">There should be no problem using DMA... There are several DMA channels. Two are reserved for audio.
<br/>
There is a general purpose DMA channel... I think it is channel 3. It should not interfere with anything.
<br/>
<br/>
And yes, you should leave swi's and software memcpy's alone and use DMA :)
<br/>
However, one very neat way to do it is to setup your memcpy to use DMA. It makes the code more portable too.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8593 - DekuTree64 - Wed Jul 16, 2003 12:01 am</h4>
    <div class="postbody"><span class="postbody">I think the problem is you have the size set to 20, it has to be a multiple of 8, since the length is in words, and it copies 8 of them (32 bytes) at a time.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8607 - Lupin - Wed Jul 16, 2003 12:43 pm</h4>
    <div class="postbody"><span class="postbody">Why does the GBA even have this swi instruction? Why doesn't it use DMA for all data transfers? I wonder where's the use of this instruction...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8610 - Quirky - Wed Jul 16, 2003 2:01 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lupin wrote:</b></span></td> </tr> <tr> <td class="quote">Why does the GBA even have this swi instruction? Why doesn't it use DMA for all data transfers? I wonder where's the use of this instruction...</td> </tr></table><span class="postbody">
<br/>
<br/>
DMA stops the cpu, so perhaps this routine is used for when the transfer needs to be interruptable? e.g. when you have multi-player code in your game, which is very sensitive to timings. Of course if the bios routines are not interruptable then that would be a load of rubbish.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
