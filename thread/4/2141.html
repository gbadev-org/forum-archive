<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Mode7 background coordinates - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Mode7 background coordinates</h2>
<div id="posts">
<div class="post">
    <h4>#11115 - poslundc - Fri Sep 26, 2003 6:09 am</h4>
    <div class="postbody"><span class="postbody">I did the Pern tutorial on Mode7 which was all well and good, but I decided I wanted to have control over the vertical angle of the camera, which meant I couldn't use the simple division method used in Pern.
<br/>
<br/>
So I started fooling around with raycasting... I think I've got the basic principle but I'm at my wits end trying to get it to work properly with the scale/rotate hardware. Here's a diagram of what I'm trying to do:
<br/>
<br/>
<a href="http://www.danposluns.com/raycasting.gif">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
(In case it isn't clear, the horizontal line on the bottom is the background I'm trying to render, and the vertical line at the right is the perpendicular height (z) to the camera, which has an angle theta that measures the vertical swivel.)
<br/>
<br/>
My basic strategy is to cast a ray from the top to the bottom of the viewport (160 pixels). I calculate the length of the ray (which is in pixels) then divide by the pixel-distance from the camera to the viewport (which I have precalculated from a fixed field-of-vision) to get what I believe is the proper scaling value.
<br/>
<br/>
I think I am correct so far... anyway, I can't seem to calculate the proper x and y scroll-coordinate for each scanline. I figure that since it scales from the upper-left origin, I would need to shrink my x and y coordinates by the same factor that I am scaling the image.
<br/>
<br/>
In other words:
<br/>
new_x = camera_x / zoom_factor
<br/>
new_y = (camera_y + current scanline) / zoom_factor
<br/>
<br/>
... But no matter how many variations I've tried on this theme, the image always winds up terribly warped.
<br/>
<br/>
Here's the code I call every frame to calculate the new register values (data types and variable names are pretty obvious):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
slice = gCamera.fov / 160;
<br/>
<br/>
for (i = 0; i &lt; 160; i++)
<br/>
{
<br/>
   angle = gCamera.theta + (gCamera.fov &gt;&gt; 1) - (i * slice);
<br/>
   if (angle &lt; 0)
<br/>
      angle += (360 &lt;&lt; 8);
<br/>
   dist = ((gCamera.z &lt;&lt; 16) / gCosLUT[angle &gt;&gt; 8]);
<br/>
   zoom = dist / 172; // precaluclated pixel-distance to viewport
<br/>
<br/>
   cX = ((gCamera.x &lt;&lt; 8) / zoom);
<br/>
   cY = (((gCamera.y + (i &lt;&lt; 8)) &lt;&lt; 8) / zoom);
<br/>
<br/>
   bgTransform[i].pa = zoom;
<br/>
   bgTransform[i].pb = 0;
<br/>
   bgTransform[i].pc = 0;
<br/>
   bgTransform[i].pd = zoom;
<br/>
   bgTransform[i].x = cX;
<br/>
   bgTransform[i].y = cY;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
(I realize that this code is sub-optimal, but I'm shooting for correctness at this point rather than efficiency.)
<br/>
<br/>
If anyone can suggest to me what I'm doing wrong, it would be greatly appreciated!
<br/>
<br/>
Thanks,
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11134 - poslundc - Sat Sep 27, 2003 2:46 am</h4>
    <div class="postbody"><span class="postbody">It's okay, I finally figured it out.
<br/>
<br/>
... but not until after wading through a sea of utter heck figuring out how to properly use those scroll registers.
<br/>
<br/>
In case anyone cares, the trick was figuring out that the hardware will automatigically scale the location you provide on the map so that it appears at the origin of the viewport (ie. at 0,0 on the screen). Which meant I had to incorporate that scaling into any offset I wanted to provide.
<br/>
<br/>
Somebody might consider making a tutorial that explains raycasting for Mode7, with less detail on the geometry and more explaining how to adapt the technique (which is already well-enough documented) to the GBA's hardware. All of the tutorials I've found are either do Mode7 at a more elementary level (such as the Pern demo) or focus too much on the mathematics of 3D and not enough on the science of GBA.
<br/>
<br/>
I would probably be willing to do so, if there is a demand for it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
