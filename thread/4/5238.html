<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Tile replacement policy - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Tile replacement policy</h2>
<div id="posts">
<div class="post">
    <h4>#38044 - Steve++ - Mon Mar 21, 2005 1:25 am</h4>
    <div class="postbody"><span class="postbody">I'm implementing a tilemap engine with dynamic tile loading. I've figured most of it out (using a LUT and reverse LUT). I'm just wondering what the best tile replacement policy would be - one that would typically result in the least number of tile loads. I was thinking of using the LRU (least recently used) policy because it seems to be used in operating systems (for paging), but it might not be the best policy in this instance. I'm not really a level designer, so I don't know the answer to such questions as,
<br/>
   "If a tile occurs somewhere, is it likely that tile will also occur nearby?"
<br/>
<br/>
What other policies are there anyway? The only one I can think of is,
<br/>
   "Just pick the first tile that's not visible in this frame and evict it."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38054 - sajiimori - Mon Mar 21, 2005 3:53 am</h4>
    <div class="postbody"><span class="postbody">LRU is a good step up from the most trivial strategies.  If the performance is still not acceptable, look into IBM's ARC strategy.  It supposedly has minimal overhead and gives significant benefits over LRU, but I haven't had the need to apply it just yet.
<br/>
<br/>
<a href="http://www.almaden.ibm.com/StorageSystems/autonomic_storage/ARC/index.shtml" target="_blank">http://www.almaden.ibm.com/StorageSystems/autonomic_storage/ARC/index.shtml</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38058 - Steve++ - Mon Mar 21, 2005 5:48 am</h4>
    <div class="postbody"><span class="postbody">Thanks. That may be just what I'm looking for.
<br/>
<br/>
I was writing a very generic class template that implements LRU. So generic that it could be used in an OS or GBA game (or any other caching situation). This is achieved by implementing only the caching policy, leaving the actual page-to-cache loading to the user. It should be interesting doing this with ARC.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38059 - sajiimori - Mon Mar 21, 2005 6:22 am</h4>
    <div class="postbody"><span class="postbody">Cool, if you end up having both implementations and you're up for it, how about posting some statistics on hits/misses in your tile engine when you're done?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38063 - Steve++ - Mon Mar 21, 2005 9:43 am</h4>
    <div class="postbody"><span class="postbody">Hehe... I'm not one for gathering statistics, but I must try one day. In the meantime, I came up with a paging policy interface and an implementation based on LRU. Here it is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">template&lt;typename INDEX_TYPE&gt;
<br/>
class PagingPolicy
<br/>
{
<br/>
public:
<br/>
   virtual void notifyCacheAccess(INDEX_TYPE index) = 0;
<br/>
   virtual void setPageIndex(INDEX_TYPE cacheIndex, INDEX_TYPE pageIndex) = 0;
<br/>
   virtual INDEX_TYPE getEvicteeIndex() = 0;
<br/>
   virtual INDEX_TYPE getPageIndex(INDEX_TYPE cacheIndex) = 0;
<br/>
};
<br/>
   
<br/>
<br/>
template&lt;int CACHE_SIZE, typename INDEX_TYPE, INDEX_TYPE UNMAPPED_VALUE&gt;
<br/>
class LRUpolicy : public PagingPolicy&lt;INDEX_TYPE&gt;
<br/>
{
<br/>
   // Representation of a page mapped into the cache
<br/>
   struct CachePage
<br/>
   {
<br/>
      INDEX_TYPE pageIndex;   // page lookup
<br/>
      INDEX_TYPE prev;      // next stalest cache page
<br/>
      INDEX_TYPE next;      // next freshest cache page
<br/>
   } __attribute__((packed));
<br/>
   
<br/>
   CachePage   cache[CACHE_SIZE];      // representation of the cache
<br/>
   INDEX_TYPE   stalestCacheIndex;      // the least recently accessed cache page
<br/>
   INDEX_TYPE   freshestCacheIndex;      // the most recently accessed cache page
<br/>
   
<br/>
public:
<br/>
   LRUpolicy()
<br/>
   {
<br/>
      for (INDEX_TYPE i=0; i&lt;CACHE_SIZE; ++i)
<br/>
      {
<br/>
         cache[i].pageIndex = UNMAPPED_VALUE;
<br/>
         cache[i].prev = i-1;
<br/>
         cache[i].next = i+1;
<br/>
      }
<br/>
      stalestCacheIndex = 0;
<br/>
      freshestCacheIndex = CACHE_SIZE-1;
<br/>
   }
<br/>
   
<br/>
   // The most recently accessed cache page moves
<br/>
   // to the top of the list (becomes freshest).
<br/>
   void notifyCacheAccess(INDEX_TYPE index)
<br/>
   {
<br/>
      if (index != freshestCacheIndex)
<br/>
      {
<br/>
         if (index != stalestCacheIndex)
<br/>
         {
<br/>
            cache[cache[index].prev].next = cache[index].next;
<br/>
            cache[cache[index].next].prev = cache[index].prev;
<br/>
         }
<br/>
         else
<br/>
         {
<br/>
            stalestCacheIndex = cache[index].next;
<br/>
         }
<br/>
         cache[index].prev = freshestCacheIndex;
<br/>
         cache[freshestCacheIndex].next = index;
<br/>
         freshestCacheIndex = index;
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   // Map a page to the cache
<br/>
   void setPageIndex(INDEX_TYPE cacheIndex, INDEX_TYPE pageIndex)
<br/>
   {
<br/>
      cache[cacheIndex].pageIndex = pageIndex;
<br/>
   }
<br/>
   
<br/>
   // Get the cache page to have its page evicted
<br/>
   INDEX_TYPE getEvicteeIndex()
<br/>
   {
<br/>
      return stalestCacheIndex;
<br/>
   }
<br/>
   
<br/>
   // Return the index of the page mapped to the specified cache index
<br/>
   INDEX_TYPE getPageIndex(INDEX_TYPE cacheIndex)
<br/>
   {
<br/>
      return cache[cacheIndex].pageIndex;
<br/>
   }
<br/>
};
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
See, I told you I would write something very generic. I even opted for a linked list structure that uses indices instead of pointers, because it allows a memory saving in some cases. On the GBA, the index type can be u16 or s16, which uses half the space as a pointer.
<br/>
<br/>
GBA example:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">LRUpolicy&lt;0x8000,0x0400,s16,-1&gt; lru;</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Of course, this class template only implements half of the solution. You'll notice there's no reverse LUT and no code for even swapping pages in/out. That is to be implemented elsewhere. This code just portably implements the policy. Perhaps I can write an abstract class template that will implement what it can portably (such as reverse LUT) and provide empty methods for the nonportable stuff.
<br/>
<br/>
Watch this thread for an ARC submission.
<br/>
<br/>
EDIT: Just removed a template parameter from LRUpolicy. It was not used.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38076 - Steve++ - Mon Mar 21, 2005 6:51 pm</h4>
    <div class="postbody"><span class="postbody">I normally don't reply to myself. I've written an adapter template that can take any policy and implement demand paging.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
template&lt;typename INDEX_TYPE, INDEX_TYPE UNMAPPED_VALUE&gt;
<br/>
struct PageFault
<br/>
{
<br/>
    INDEX_TYPE pageIndex;
<br/>
    INDEX_TYPE cacheIndex;
<br/>
    PageFault()
<br/>
    {
<br/>
    }
<br/>
    PageFault(INDEX_TYPE pageIndex, INDEX_TYPE cacheIndex) : pageIndex(pageIndex), cacheIndex(cacheIndex)
<br/>
    {
<br/>
    }
<br/>
    bool isFault()
<br/>
    {
<br/>
        return pageIndex != UNMAPPED_VALUE;
<br/>
    }
<br/>
};
<br/>
<br/>
// DemandPager is implemented as an adapter to a paging policy (much like adapters and containers in STL)
<br/>
template&lt;int PAGES, int CACHE_SIZE, typename INDEX_TYPE, INDEX_TYPE UNMAPPED_VALUE, typename PAGING_POLICY&gt;
<br/>
class DemandPager
<br/>
{
<br/>
    PAGING_POLICY   policy;
<br/>
    INDEX_TYPE      pages2cache[PAGES];     // Reverse LUT - pages to cache pages
<br/>
<br/>
public:
<br/>
    DemandPager()
<br/>
    {
<br/>
        // All pages are initially unmapped (causing page faults)
<br/>
        for (INDEX_TYPE i=0; i&lt;PAGES; ++i)
<br/>
        {
<br/>
            pages2cache[i] = UNMAPPED_VALUE;
<br/>
        }
<br/>
    }
<br/>
<br/>
    // Lookup the cache index for a page. If it is uncached, a page fault is generated
<br/>
    // and the page is cached. The page fault information is return via pageFault.
<br/>
    // This method returns the cache index.
<br/>
    INDEX_TYPE lookupPage(INDEX_TYPE pageIndex, PageFault&lt;INDEX_TYPE,UNMAPPED_VALUE&gt;* pageFault)
<br/>
    {
<br/>
        INDEX_TYPE cacheIndex = pages2cache[page];
<br/>
        if (cacheIndex == UNMAPPED_VALUE)
<br/>
        {
<br/>
            cacheIndex = pages2cache[policy.getEvicteeIndex()];
<br/>
            pages2cache[pageIndex] = cacheIndex;
<br/>
            policy.setPageIndex(cacheIndex, pageIndex);
<br/>
            *pageFault = PageFault&lt;INDEX_TYPE,UNMAPPED_VALUE&gt;(pageIndex, cacheIndex);
<br/>
        }
<br/>
        else
<br/>
        {
<br/>
            *pageFault = PageFault&lt;INDEX_TYPE,UNMAPPED_VALUE&gt;(UNMAPPED_VALUE, UNMAPPED_VALUE);
<br/>
        }
<br/>
        policy.notifyCacheAccess(cacheIndex);
<br/>
        return cacheIndex;
<br/>
    }
<br/>
};
<br/>
<br/>
// Helper macro to make life easier
<br/>
#define DEMAND_PAGER(p,c,i,u,policy) DemandPager&lt;p,c,i,u,policy&lt;c,i,u&gt; &gt;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
A couple of instantiation examples (both are identical):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">DemandPager&lt;0x10000,1024,short,-1,LRUpolicy&lt;1024,short,-1&gt; &gt; pager;    // The regular way
<br/>
DEMAND_PAGER(0x10000,1024,short,-1,LRUpolicy) pager2;                  // The easy way
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This is pretty good if I may say so myself. From a user point of view, all that needs to be done is
<br/>
<br/>
1. Create a DemandPager object with the specified template parameters
<br/>
2. Write the actual page loading code (in my case, loading a tile or sprite into VRAM)
<br/>
3. Call lookupPage on each page to get the cache index, loading pages as necessary and specified by pageFault.
<br/>
<br/>
Easy!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38079 - sajiimori - Mon Mar 21, 2005 7:51 pm</h4>
    <div class="postbody"><span class="postbody">Well done.  As for statistics, it could be something as simple as scrolling along the same path twice, once with LRU and once with ARC, and counting how many tile loads happened.
<br/>
<br/>
Obviously the nature of the map, the path, and the cache settings will affect the results, so mixing it up a bit would make things clearer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38085 - ampz - Mon Mar 21, 2005 10:02 pm</h4>
    <div class="postbody"><span class="postbody">Actually, I read that "random" is not a very bad cache paging policy. Would probably work for tiles as well.
<br/>
<br/>
You don't want a too complex tile replacement policy either, because that could easily eat up the few cycles it takes to replace a tile using DMA (or load/store multiple asm instruction)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38142 - Steve++ - Tue Mar 22, 2005 11:33 pm</h4>
    <div class="postbody"><span class="postbody">True...
<br/>
LRU does require some list rearrangement on every tile access, but if optimised, would probably only take the same time as loading a small number of tiles (maybe around 5?).
<br/>
<br/>
The thing we have to think of in GBA games is that we don't necessarily want a completely nondeterministic CPU usage. So I may implement something that uses a lot less time, so it fluctuates within a smaller CPU usage window. This would be especially useful for tilemaps that run close to worst-case-scenario most of the time. I think something like FIFO would be useful here.
<br/>
<br/>
Also, if I can find the fastest tile loading code possible, it may be possible to implement something I gave up on a while ago - four layers with a worst-case-scenario of every visible tile being unique. This would require some clever scheduling. I want to use krawall also, which will probably need large buffers due to the demand placed on the system by the tile engine.
<br/>
<br/>
In the four layer system, I would partition the VRAM into four pieces - one for each layer. Each partition has enough space for that layer's tilemap and seven rows of unique tiles. But of course, we need to display up to 22 rows of tiles, so I need a number that is a factor of 22 and is less than 7. That leaves only 2. So every two rows, another two rows of tiles will need to be loaded. I could either use FIFO or just evict and reload everything - both of these are compatible with my adapter template. Nice, eh?
<br/>
<br/>
The only trick is scheduling tile loading. This will need some sort of time-based queue. Shouldn't be too hard to calculate times - this depends only on the remainder of the map position's y coordinate when divided by 8. Simple. I just hope after coding it up that there is enough CPU time (and some to spare) to do all this. I wonder how many cycles it takes to load 2816 (32x22x4) tiles...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38143 - Steve++ - Tue Mar 22, 2005 11:45 pm</h4>
    <div class="postbody"><span class="postbody">Hmm, here's an intersting thought - a generic temporal queue that executes objects placed on it at the specified time. Interesting.... I could run the whole game through it, not just tile loading. Since it would be a queue structure, I would need more than one of them. They would have a priority order. I think these queues would be a lot safer than interrupts for doing the same thing, especially when operations take a long time.
<br/>
<br/>
The temporal parameters would be:
<br/>
earliest time to start
<br/>
latest time to start
<br/>
estimated time to complete
<br/>
<br/>
They would be used like this: The queue executor wait until the time is greater than or equal to <span style="font-style: italic">earliest time to start.</span>If, on the first check, it is already greater than <span style="font-style: italic">latest time to start</span>, it will skip that item. If the item is on a low priority queue, the executor will use <span style="font-style: italic">estimated time to complete</span> to decide if that item is going to prevent a higher priority item to execute.
<br/>
<br/>
I think I could just get rid of estimated time to complete. It would probably add too much overhead.
<br/>
<br/>
I could just imaging the case where something interrupts a tile load, and for a split second, two rows of tiles are completely garbled. That would look kind of funny, but it would be a sign that the queue system is working to ensure that earlier items don't delay later items to much.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38197 - tepples - Wed Mar 23, 2005 10:56 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Steve++ wrote:</b></span></td> </tr> <tr> <td class="quote">Hmm, here's an intersting thought - a generic temporal queue that executes objects placed on it at the specified time. Interesting.... I could run the whole game through it, not just tile loading.</td> </tr></table><span class="postbody">
<br/>
In fact, this is how PlayStation 2 programs and other real-time programs work: as a dataflow diagram with real-time constraints. Good luck on your miniature real-time OS :)<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38212 - sajiimori - Thu Mar 24, 2005 1:09 am</h4>
    <div class="postbody"><span class="postbody">Is there something unusual about the PS2 that makes that scheme particularly appealing?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38213 - tepples - Thu Mar 24, 2005 1:15 am</h4>
    <div class="postbody"><span class="postbody">The PS2 has multiple independent processors, and interpreting your program as a dataflow diagram makes it a lot easier to synchronize them. This will go double for the Cell processors in the PS3. Think of the GBA's PPU as another processor that executes the "program" in the registers on the "data" in VRAM.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38216 - Steve++ - Thu Mar 24, 2005 2:05 am</h4>
    <div class="postbody"><span class="postbody">Tepples, I modified the code to allow for the possibility of different types for cache indices and page indices. I also changed some template parameter naming and ordering. All this code supercedes the above code.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
template&lt;typename PAGE_INDEX_TYPE, typename CACHE_PAGE_INDEX_TYPE&gt;
<br/>
class PagingPolicy
<br/>
{
<br/>
public:
<br/>
    virtual void notifyCacheAccess(CACHE_PAGE_INDEX_TYPE index) = 0;
<br/>
    virtual void setPageIndex(CACHE_PAGE_INDEX_TYPE cacheIndex, PAGE_INDEX_TYPE pageIndex) = 0;
<br/>
    virtual CACHE_PAGE_INDEX_TYPE getEvicteeIndex() = 0;
<br/>
    virtual PAGE_INDEX_TYPE getPageIndex(CACHE_PAGE_INDEX_TYPE cacheIndex) = 0;
<br/>
};
<br/>
<br/>
<br/>
template&lt;   typename                PAGE_INDEX_TYPE,
<br/>
            PAGE_INDEX_TYPE         UNCACHED,
<br/>
            typename                CACHE_PAGE_INDEX_TYPE,
<br/>
            CACHE_PAGE_INDEX_TYPE   CACHE_SIZE&gt;
<br/>
class LRUpolicy : public PagingPolicy&lt;PAGE_INDEX_TYPE, CACHE_PAGE_INDEX_TYPE&gt;
<br/>
{
<br/>
    // Representation of a page mapped into the cache
<br/>
    struct CachePage
<br/>
    {
<br/>
        PAGE_INDEX_TYPE         pageIndex;  // page lookup
<br/>
        CACHE_PAGE_INDEX_TYPE   prev;       // next stalest cache page
<br/>
        CACHE_PAGE_INDEX_TYPE   next;       // next freshest cache page
<br/>
    } __attribute__((packed));
<br/>
<br/>
    CachePage               cache[CACHE_SIZE];      // representation of the cache (and LUT)
<br/>
    CACHE_PAGE_INDEX_TYPE   stalestCacheIndex;      // the least recently accessed cache page
<br/>
    CACHE_PAGE_INDEX_TYPE   freshestCacheIndex;     // the most recently accessed cache page
<br/>
<br/>
public:
<br/>
    LRUpolicy()
<br/>
    {
<br/>
        for (CACHE_PAGE_INDEX_TYPE i=0; i&lt;CACHE_SIZE; ++i)
<br/>
        {
<br/>
            cache[i].pageIndex = UNCACHED;
<br/>
            cache[i].prev = i-1;
<br/>
            cache[i].next = i+1;
<br/>
        }
<br/>
        stalestCacheIndex = 0;
<br/>
        freshestCacheIndex = CACHE_SIZE-1;
<br/>
    }
<br/>
<br/>
    // The most recently accessed cache page moves
<br/>
    // to the top of the list (becomes freshest).
<br/>
    void notifyCacheAccess(CACHE_PAGE_INDEX_TYPE index)
<br/>
    {
<br/>
        if (index != freshestCacheIndex)
<br/>
        {
<br/>
            if (index != stalestCacheIndex)
<br/>
            {
<br/>
                cache[cache[index].prev].next = cache[index].next;
<br/>
                cache[cache[index].next].prev = cache[index].prev;
<br/>
            }
<br/>
            else
<br/>
            {
<br/>
                stalestCacheIndex = cache[index].next;
<br/>
            }
<br/>
            cache[index].prev = freshestCacheIndex;
<br/>
            cache[freshestCacheIndex].next = index;
<br/>
            freshestCacheIndex = index;
<br/>
        }
<br/>
    }
<br/>
<br/>
    // Map a page to the cache
<br/>
    void setPageIndex(CACHE_PAGE_INDEX_TYPE cacheIndex, PAGE_INDEX_TYPE pageIndex)
<br/>
    {
<br/>
        cache[cacheIndex].pageIndex = pageIndex;
<br/>
    }
<br/>
<br/>
    // Get the cache page to have its page evicted
<br/>
    CACHE_PAGE_INDEX_TYPE getEvicteeIndex()
<br/>
    {
<br/>
        return stalestCacheIndex;
<br/>
    }
<br/>
<br/>
    // Return the index of the page mapped to the specified cache index
<br/>
    PAGE_INDEX_TYPE getPageIndex(CACHE_PAGE_INDEX_TYPE cacheIndex)
<br/>
    {
<br/>
        return cache[cacheIndex].pageIndex;
<br/>
    }
<br/>
};
<br/>
<br/>
<br/>
template&lt;typename PAGE_INDEX_TYPE, PAGE_INDEX_TYPE UNCACHED, typename CACHE_PAGE_INDEX_TYPE&gt;
<br/>
struct PageFault
<br/>
{
<br/>
    PAGE_INDEX_TYPE         pageIndex;
<br/>
    CACHE_PAGE_INDEX_TYPE   cacheIndex;
<br/>
    PageFault() : pageIndex(UNCACHED)
<br/>
    {
<br/>
    }
<br/>
    PageFault(PAGE_INDEX_TYPE pageIndex, CACHE_PAGE_INDEX_TYPE cacheIndex) : pageIndex(pageIndex), cacheIndex(cacheIndex)
<br/>
    {
<br/>
    }
<br/>
    bool isFault()
<br/>
    {
<br/>
        return pageIndex != UNCACHED;
<br/>
    }
<br/>
};
<br/>
<br/>
// DemandPager is implemented as an adapter to a paging policy (much like adapters and containers in STL)
<br/>
template&lt;   typename                PAGE_INDEX_TYPE,
<br/>
            PAGE_INDEX_TYPE         PAGES,
<br/>
            PAGE_INDEX_TYPE         UNCACHED,
<br/>
            typename                CACHE_PAGE_INDEX_TYPE,
<br/>
            CACHE_PAGE_INDEX_TYPE   CACHE_SIZE,
<br/>
            typename                PAGING_POLICY&gt;
<br/>
class DemandPager
<br/>
{
<br/>
    PAGING_POLICY           policy;
<br/>
    CACHE_PAGE_INDEX_TYPE   pages2cache[PAGES];     // Reverse LUT - pages to cache pages
<br/>
<br/>
public:
<br/>
    DemandPager()
<br/>
    {
<br/>
        // All pages are initially unmapped (causing page faults)
<br/>
        for (PAGE_INDEX_TYPE i=0; i&lt;PAGES; ++i)
<br/>
        {
<br/>
            pages2cache[i] = UNCACHED;
<br/>
        }
<br/>
    }
<br/>
<br/>
    // Lookup the cache index for a page. If it is uncached, a page fault is generated
<br/>
    // and it the page is cached. The page fault information is return via pageFault.
<br/>
    // This method returns the cache index.
<br/>
    CACHE_PAGE_INDEX_TYPE lookupPage(PAGE_INDEX_TYPE pageIndex, PageFault&lt;PAGE_INDEX_TYPE,UNCACHED,CACHE_PAGE_INDEX_TYPE&gt;* pageFault)
<br/>
    {
<br/>
        CACHE_PAGE_INDEX_TYPE cacheIndex = pages2cache[page];
<br/>
        if (cacheIndex == UNCACHED)
<br/>
        {
<br/>
            cacheIndex = pages2cache[policy.getEvicteeIndex()];
<br/>
            pages2cache[pageIndex] = cacheIndex;
<br/>
            policy.setPageIndex(cacheIndex, pageIndex);
<br/>
            *pageFault = PageFault&lt;PAGE_INDEX_TYPE,UNCACHED,CACHE_PAGE_INDEX_TYPE&gt;(pageIndex, cacheIndex);
<br/>
        }
<br/>
        else
<br/>
        {
<br/>
            *pageFault = PageFault&lt;PAGE_INDEX_TYPE,UNCACHED,CACHE_PAGE_INDEX_TYPE&gt;();
<br/>
        }
<br/>
        policy.notifyCacheAccess(cacheIndex);
<br/>
        return cacheIndex;
<br/>
    }
<br/>
};
<br/>
<br/>
// Helper macro to make life easier
<br/>
#define DEMAND_PAGER(ptype,pages,u,ctype,cache,policy) DemandPager&lt;ptype,pages,u,ctype,cache,policy&lt;ptype,u,ctype,cache&gt; &gt;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Instantiation examples (both equivalent):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
DemandPager&lt;int,0x20000,-1,short,0x400,LRUpolicy&lt;int,-1,short,0x400&gt; &gt; pager;    // The regular way
<br/>
DEMAND_PAGER(int,0x20000,-1,short,0x400,LRUpolicy) pager2;                       // The easy way
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
