<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Sprite timing - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Sprite timing</h2>
<div id="posts">
<div class="post">
    <h4>#174816 - Kensai - Wed Jul 21, 2010 9:42 am</h4>
    <div class="postbody"><span class="postbody">There is an inventory in my game which shows the items one of my party members is carring. Each item (sword, armor, etc.) is represented by a 16x16 sprite. If I press a shoulder button the inventory of the next/prev hero is displayed - which means, all sprites have to be overwritten. And here is the problem: If I overwrite the sprites, some of them appear simulanously on the screen (they simply pop up IN NO TIME - even if I decreasy the framerate to 10%) while others show up with a visible delay. I don't understand whats going on there. Shouldn't they ALL pop up simulanously OR being ALL displayed one after another? How can I solve this problem? Do I have to draw the sprites off-screen or is there another method?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Inventory 1:
<br/>
 ___ ___ ___ 
<br/>
|   |   |   | 
<br/>
| 1 | 1 | 1 |
<br/>
|___|___|___|
<br/>
|   |   |   |
<br/>
| 1 | 1 | 1 |
<br/>
|___|___|___|
<br/>
<br/>
You see this picture for a brief moment:
<br/>
 ___ ___ ___ 
<br/>
|   |   |   |  
<br/>
| 2 | 2 | 2 |
<br/>
|___|___|___|
<br/>
|   |   |   |
<br/>
| 2 | 2 | 1 |
<br/>
|___|___|___|
<br/>
<br/>
The first five items are displayed in no time while the sixth item is delayed.
<br/>
<br/>
Inventory 2:
<br/>
 ___ ___ ___ 
<br/>
|   |   |   |
<br/>
| 2 | 2 | 2 |
<br/>
|___|___|___|
<br/>
|   |   |   |
<br/>
| 2 | 2 | 2 |
<br/>
|___|___|___|
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174817 - Azenris - Wed Jul 21, 2010 10:24 am</h4>
    <div class="postbody"><span class="postbody">Are you using waitforvsync function?
<br/>
<br/>
Not sure really, never had the problem myself. Maybe post alittle code in that area.<br/>_________________<br/><a class="postlink" href="http://sacredpotion.blogspot.com/" target="_blank"><span style="color: red">My Homebrew Games</span></a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174818 - Kensai - Wed Jul 21, 2010 10:53 am</h4>
    <div class="postbody"><span class="postbody">Yes, I use waitforvsync:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">drawBackground();             // draws the background of the inventory (-&gt; mode 4 back buffer)
<br/>
vsync();                      // waits for vsync
<br/>
flip_video_buffer();          // back buffer &lt;-&gt; front buffer
<br/>
<br/>
write_sprite_16(0, sprite0)   // overwrites the sprites
<br/>
write_sprite_16(1, sprite1)   //
<br/>
write_sprite_16(2, sprite2)   //
<br/>
write_sprite_16(3, sprite3)   //
<br/>
write_sprite_16(4, sprite4)   //
<br/>
write_sprite_16(5, sprite5)   //
<br/>
<br/>
///////////////////////////////////////////////////////////////////////////////
<br/>
///////////////////////////////////////////////////////////////////////////////
<br/>
////////////////////////////////////////////////////////////////////////////////
<br/>
<br/>
INLINE void write_spr_16(int spr, u16* img)
<br/>
{
<br/>
  int i = 128*spr;  // 8x16 = 128
<br/>
  int j = i + 128;
<br/>
  for(i; i&lt;j; i++)
<br/>
  {
<br/>
    ObjDataMem[i] = *img++;
<br/>
  }
<br/>
}
<br/>
<br/>
///////////////////////////////////////////////////////////////////////////////
<br/>
<br/>
INLINE void vsync()
<br/>
{
<br/>
  while(REG_VCOUNT &gt;= 160); // VDraw
<br/>
  while(REG_VCOUNT &lt;  160); // VBlank
<br/>
}
<br/>
<br/>
///////////////////////////////////////////////////////////////////////////////
<br/>
   
<br/>
INLINE void flip_video_buffer() 
<br/>
{      
<br/>
  if (REG_DISPCNT &amp; DCNT_PAGE)
<br/>
  {
<br/>
    REG_DISPCNT &amp;= ~DCNT_PAGE; // BackBuffer = Page 2
<br/>
    BackBuffer  =  VRAM_PAGE2;
<br/>
    FrontBuffer =  VRAM_PAGE1;
<br/>
  }
<br/>
 else
<br/>
 {
<br/>
    REG_DISPCNT |= DCNT_PAGE;  // BackBuffer = Page 1
<br/>
    BackBuffer  =  VRAM_PAGE1;
<br/>
    FrontBuffer =  VRAM_PAGE2;
<br/>
  }
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174821 - Dwedit - Wed Jul 21, 2010 1:52 pm</h4>
    <div class="postbody"><span class="postbody">You have posted the textbook example of how NOT to wait for Vsync.  That runs the CPU at 100% usage, reducing battery life.
<br/>
<br/>
See SWI 0x05, VBlankIntrWait.  LibGBA provides the function VBlankIntrWait() you can call.  You must have some kind of interrupt handler running, which LibGBA also provides for you, also probably need the Vblank interrupt enabled.
<br/>
<br/>
Anyway, to avoid sprite glitches, make sure you are setting the new sprites AND the new graphics for the sprites at the same time, both during Vblank time.  Getting the sprite table updated is more important, since drawing to VRAM can also be done while the screen is rendering, you will just get tearing or incorrect graphics if you're too slow.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174822 - Kensai - Wed Jul 21, 2010 5:05 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">You have posted the textbook example of how NOT to wait for Vsync. That runs the CPU at 100% usage, reducing battery life. 
<br/>
<br/>
See SWI 0x05, VBlankIntrWait. LibGBA provides the function VBlankIntrWait() you can call. You must have some kind of interrupt handler running, which LibGBA also provides for you, also probably need the Vblank interrupt enabled. </td> </tr></table><span class="postbody">
<br/>
<br/>
Thank you for the information. I will fix it asap.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Anyway, to avoid sprite glitches, make sure you are setting the new sprites AND the new graphics for the sprites at the same time, both during Vblank time. Getting the sprite table updated is more important, since drawing to VRAM can also be done while the screen is rendering, you will just get tearing or incorrect graphics if you're too slow.</td> </tr></table><span class="postbody">
<br/>
<br/>
The sprite table doesn't have to be changed - all sprites have a fix position on the screen. All I have to do is overwriting the sprite graphics. But some sprite graphics still show up faster than others. How can this be possible? You say, that I might get these glitches if I'm too slow. But the sprite function is quite flawless - I don't think that it can be made any faster... And there aren't any other functions involved. It's just...
<br/>
<br/>
waitForVSync()
<br/>
flipScreen()
<br/>
overwriteSpriteGraphics()
<br/>
<br/>
And that's it!
<br/>
Any suggestions?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174825 - Dwedit - Wed Jul 21, 2010 9:34 pm</h4>
    <div class="postbody"><span class="postbody">Try using DMA copy instead of the for loop.  Hope you don't need DMA Channel #3 for some other purpose.
<br/>
<br/>
The function prototype:
<br/>
<br/>
static inline void dmaCopy(const void * source, void * dest, u32 size);
<br/>
<br/>
Size is in bytes.  The transfer is 16-bit DMA, which is good for reading from a cartridge, and writing to VRAM.
<br/>
<br/>
DMA temporarily halts the CPU so it can just do a series of memory reads and writes as fast as possible, then wakes it up when the transfer is finished.  So if you have any interrupts that can't wait for 256 bytes to be transferred, consider something else.  DMA is also less useful on the Nintendo DS because of the cache, cached memory writes may not take effect until much later, so you need to flush the write cache before doing any DMA.
<br/>
<br/>
Where is ObjDataMem?  Is it inside VRAM?
<br/>
<br/>
<br/>
Edit: Actually, this seems silly, I don't think it's a speed issue at all.  Copying 1.5k of memory shouldn't eat up all of vblank time, there might be a bug somewhere else.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174832 - Kensai - Thu Jul 22, 2010 10:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Where is ObjDataMem? Is it inside VRAM?</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, it is inside VRAM:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define OBJ_VRAM (u16*)0x6014000
<br/>
u16* ObjDataMem = OBJ_VRAM;</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Copying 1.5k of memory shouldn't eat up all of vblank time, there might be a bug somewhere else.</td> </tr></table><span class="postbody">
<br/>
<br/>
I use DevKitAdv. Could this be the reason? I consider switching to DevKitPro but I'm undecided. I'm not sure about the advantages but there are definitely some disadvantages. For example, you can't test your roms in MappyVM which is my favorite gba emulator.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
