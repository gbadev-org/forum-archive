<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>bounding ellipse - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > bounding ellipse</h2>
<div id="posts">
<div class="post">
    <h4>#22291 - sgeos - Thu Jun 17, 2004 4:07 am</h4>
    <div class="postbody"><span class="postbody">Has anyone considered a bounding ellipse?  How difficult would this be to implement?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22307 - sgeos - Thu Jun 17, 2004 11:34 am</h4>
    <div class="postbody"><span class="postbody">It looks like we are looking at something like this to pull off a bound ellipse:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define TRUE   1
<br/>
#define FALSE   0
<br/>
<br/>
struct circle_critter {
<br/>
   int x;
<br/>
   int y;
<br/>
   int r;
<br/>
};
<br/>
<br/>
struct ellipse_critter {
<br/>
   int x;
<br/>
   int y;
<br/>
   int w;
<br/>
   int h;
<br/>
};
<br/>
<br/>
int safe_distance_sq
<br/>
(
<br/>
   int x0,
<br/>
   int y0,
<br/>
   int x1,
<br/>
   int y1
<br/>
)
<br/>
{
<br/>
   int x_distance_sq;
<br/>
   int y_distance_sq;
<br/>
<br/>
   x_distance_sq = x0 - x1;
<br/>
   x_distance_sq *= x_distance_sq;
<br/>
   y_distance_sq = y0 - y1;
<br/>
   y_distance_sq *= y_distance_sq;
<br/>
   return x_distance + y_distance + 1;
<br/>
}
<br/>
<br/>
int
<br/>
radius_collision
<br/>
(
<br/>
   int source_r_sq,
<br/>
   int target_r_sq,
<br/>
   int safe_sq
<br/>
)
<br/>
{
<br/>
   if ((source_r_sq + target_r_sq) &lt; safe_sq)
<br/>
      return TRUE;
<br/>
   /* else */
<br/>
      return FALSE;
<br/>
}
<br/>
<br/>
int
<br/>
circle_collision
<br/>
(
<br/>
   circle_critter *s, // source
<br/>
   circle_critter *t  // target
<br/>
)
<br/>
{
<br/>
   return
<br/>
      radius_collision
<br/>
      (
<br/>
         s.r * s.r,
<br/>
         t.r * t.r,
<br/>
         safe_distance_sq(s.x, s.y, t.x, t.y)
<br/>
      );
<br/>
}
<br/>
<br/>
int ellipse_r_sq(ellipse_critter *unit, angle_t theta)
<br/>
{
<br/>
   int rw_sq;
<br/>
   int rh_sq;
<br/>
<br/>
   rw_sq = unit.w * unit.w * cos(theta);
<br/>
   rh_sq = unit.h * unit.h * sin(theta);
<br/>
   return rw_sq + rh_sq;
<br/>
}
<br/>
<br/>
int
<br/>
ellipse_collision
<br/>
(
<br/>
   ellipse_critter *s, // source
<br/>
   ellipse_critter *t  // source
<br/>
)
<br/>
{
<br/>
   angle_t theta;
<br/>
   int rs_sq;  // source's effective radius squared
<br/>
   int rt_sq;  // targets's effective radius squared
<br/>
<br/>
   theta = arctan(s.x - t.x, s.y - t.y);
<br/>
   rs_sq = ellipse_r_sq(s, theta)
<br/>
   rs_tq = ellipse_r_sq(t, theta)
<br/>
   return
<br/>
      radius_collision
<br/>
      (
<br/>
         rs_sq,
<br/>
         rt_sq,
<br/>
         safe_distance_sq(s.x, s.y, t.x, t.y)
<br/>
      );
<br/>
}</td> </tr></table><span class="postbody">This is pseodocode.  If you see any, please point out any flaws.  A bounding circle is cheap.  Cheaper if r_sq is stored.  A bouding ellipse is more expense.  The final collision test is the used in the bounding circle, the only problem is that the "effective radius" changes with angle from the source to the target.  We need to know this angle before we can calculate the effective radius.  (Therefore the effective radius can not be stored.)   All in all, in addition to the bounding circle overhead, a bounding ellipse requires one call to arctan, two calls to sin, and two calls to cos.
<br/>
<br/>
Because bounding ellipse and bounding circle collision detection are so similar, a circle to ellipse function would be easy to construct.  It would require one arctan, one sin, and one cos call in addition to the standard bounding circle call.
<br/>
<br/>
Because most critters are not square, a bounding ellipse looks like a pretty accurate way covering a critter. How does it compare to pixel level collison detection?  Thoughts in general?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22315 - sgeos - Thu Jun 17, 2004 3:40 pm</h4>
    <div class="postbody"><span class="postbody">A correction and some clarification.  w and h in struct ellipse_critter are from the centre to the edge.  That is, they are 1/2 the total w or h of the entire bounding box.  'absolute w-radius' and 'absolute h-radius'.  Perhaps they should be called wr and hr?  (Or rw and rh like the function below?)
<br/>
<br/>
ellipse_r_sq() should read:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int ellipse_r_sq(ellipse_critter *unit, angle_t theta)
<br/>
{
<br/>
   int rw_sq;  // effective w-radius for this angle (squared)
<br/>
   int rh_sq;  // effective h-radius for this angle (squared)
<br/>
<br/>
   rw_sq = unit.w * cos(theta);  // get w component of effective radius
<br/>
   rw_sq *= rw_sq;               // square w component
<br/>
   rh_sq = unit.h * sin(theta);  // get h component of effective radius
<br/>
   rh_sq *= rh_sq;               // square h component
<br/>
   return rw_sq + rh_sq;         // combine for total effective radius
<br/>
}</td> </tr></table><span class="postbody">All of this is still pseudo-code/theory-code.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
