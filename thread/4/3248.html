<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Detecting key presses and releases in 8 directions. - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Detecting key presses and releases in 8 directions.</h2>
<div id="posts">
<div class="post">
    <h4>#19359 - mr_schmoe - Sat Apr 17, 2004 10:45 pm</h4>
    <div class="postbody"><span class="postbody">Ok, here's the skinny. I want to detect when the player moves the d-pad in one of eight directions. Also, it needs to tell whether it is a new direction or the same one. In others words, if the player first presses the down button it issues a command to start the player moving down (that is, load the proper animation and set the action variable to moving in the down direction,) but then it shouldn't issue that same command next cycle around. I save the key register to compare it with the currect key register next cycle to detect that. Four directions isn't the issue, it's when I work with eight directions it get complicated. here's the code I'm using, please pardon the sloppyness of it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static u16 lastkeys;
<br/>
u16 currkeys = 0;
<br/>
u16 command = 0;
<br/>
<br/>
/* each of the four directions
<br/>
bit0: 0 - pressed, 1 - released
<br/>
bit1: 0 - same as last cycle, 1 - just barely
<br/>
i.e. 00 = 0 = the key was pressed in the previous cycle and in this cycle, contiously pressed
<br/>
11 = 3 = the key was barely released */
<br/>
u8 arrowkeys[4]; 
<br/>
<br/>
u16 action;
<br/>
<br/>
currkeys = KEYS; // get the current keys from the register
<br/>
<br/>
if ((~currkeys &amp; KEY_UP) &amp;&amp; (!(~lastkeys &amp; KEY_UP))) arrowkeys[0] = 2;
<br/>
if ((!(~currkeys &amp; KEY_UP)) &amp;&amp; (~lastkeys &amp; KEY_UP)) arrowkeys[0] = 3;
<br/>
if ((!(~currkeys &amp; KEY_UP)) &amp;&amp; (!(~lastkeys &amp; KEY_UP))) arrowkeys[0] = 1;
<br/>
if ((~currkeys &amp; KEY_UP) &amp;&amp; (~lastkeys &amp; KEY_UP)) arrowkeys[0] = 0;
<br/>
<br/>
if ((~currkeys &amp; KEY_DOWN) &amp;&amp; (!(~lastkeys &amp; KEY_DOWN))) arrowkeys[1] = 2;
<br/>
if ((!(~currkeys &amp; KEY_DOWN)) &amp;&amp; (~lastkeys &amp; KEY_DOWN)) arrowkeys[1] = 3;
<br/>
if ((!(~currkeys &amp; KEY_DOWN)) &amp;&amp; (!(~lastkeys &amp; KEY_DOWN))) arrowkeys[1] = 1;
<br/>
if ((~currkeys &amp; KEY_DOWN) &amp;&amp; (~lastkeys &amp; KEY_DOWN)) arrowkeys[1] = 0;
<br/>
<br/>
if ((~currkeys &amp; KEY_LEFT) &amp;&amp; (!(~lastkeys &amp; KEY_LEFT))) arrowkeys[2] = 2;
<br/>
if ((!(~currkeys &amp; KEY_LEFT)) &amp;&amp; (~lastkeys &amp; KEY_LEFT)) arrowkeys[2] = 3;
<br/>
if ((!(~currkeys &amp; KEY_LEFT)) &amp;&amp; (!(~lastkeys &amp; KEY_LEFT))) arrowkeys[2] = 1;
<br/>
if ((~currkeys &amp; KEY_LEFT) &amp;&amp; (~lastkeys &amp; KEY_LEFT)) arrowkeys[2] = 0;
<br/>
<br/>
if ((~currkeys &amp; KEY_RIGHT) &amp;&amp; (!(~lastkeys &amp; KEY_RIGHT))) arrowkeys[3] = 2;
<br/>
if ((!(~currkeys &amp; KEY_RIGHT)) &amp;&amp; (~lastkeys &amp; KEY_RIGHT)) arrowkeys[3] = 3;
<br/>
if ((!(~currkeys &amp; KEY_RIGHT)) &amp;&amp; (!(~lastkeys &amp; KEY_RIGHT))) arrowkeys[3] = 1;
<br/>
if ((~currkeys &amp; KEY_RIGHT) &amp;&amp; (~lastkeys &amp; KEY_RIGHT)) arrowkeys[3] = 0;
<br/>
<br/>
if ((arrowkeys[0] == 2) &amp;&amp; (arrowkeys[1] &amp; 1) &amp;&amp; (arrowkeys[2] &amp; 1) &amp;&amp; (arrowkeys[3] &amp; 1))
<br/>
   command = WALK_BACK;
<br/>
<br/>
if ((arrowkeys[1] == 2) &amp;&amp; (arrowkeys[0] &amp; 1) &amp;&amp; (arrowkeys[2] &amp; 1) &amp;&amp; (arrowkeys[3] &amp; 1))
<br/>
   command = WALK_FORWARD;
<br/>
<br/>
if ((arrowkeys[2] == 2) &amp;&amp; (arrowkeys[0] &amp; 1) &amp;&amp; (arrowkeys[1] &amp; 1) &amp;&amp; (arrowkeys[3] &amp; 1))
<br/>
   command = WALK_LEFT;
<br/>
<br/>
if ((arrowkeys[3] == 2) &amp;&amp; (arrowkeys[0] &amp; 1) &amp;&amp; (arrowkeys[1] &amp; 1) &amp;&amp; (arrowkeys[2] &amp; 1))
<br/>
   command = WALK_RIGHT;
<br/>
<br/>
if ((~arrowkeys[2] &amp; 1) &amp;&amp; (~arrowkeys[1] &amp; 1) &amp;&amp; (arrowkeys[0] &amp; 1) &amp;&amp; (arrowkeys[3] &amp; 1))
<br/>
   command = WALK_FORWARD_LEFT;
<br/>
<br/>
if ((~arrowkeys[3] &amp; 1) &amp;&amp; (~arrowkeys[1] &amp; 1) &amp;&amp; (arrowkeys[0] &amp; 1) &amp;&amp; (arrowkeys[2] &amp; 1))
<br/>
   command = WALK_FORWARD_RIGHT;
<br/>
<br/>
if ((~arrowkeys[2] &amp; 1) &amp;&amp; (~arrowkeys[0] &amp; 1) &amp;&amp; (arrowkeys[1] &amp; 1) &amp;&amp; (arrowkeys[3] &amp; 1))
<br/>
   command = WALK_BACK_LEFT;
<br/>
<br/>
if ((~arrowkeys[3] &amp; 1) &amp;&amp; (~arrowkeys[0] &amp; 1) &amp;&amp; (arrowkeys[1] &amp; 1) &amp;&amp; (arrowkeys[2] &amp; 1))
<br/>
   command = WALK_BACK_RIGHT;
<br/>
<br/>
if (command == WALK_BACK) action = 8;
<br/>
if (command == WALK_FORWARD) action = 9;
<br/>
if (command == WALK_LEFT) action = 10;
<br/>
if (command == WALK_RIGHT) action = 11;
<br/>
if (command == WALK_BACK_LEFT) action = 12;
<br/>
if (command == WALK_BACK_RIGHT) action = 13;
<br/>
if (command == WALK_FORWARD_LEFT) action = 14;
<br/>
if (command == WALK_FORWARD_RIGHT) action = 15;
<br/>
<br/>
if (action == 8) // do some appropreate action stuff
<br/>
...
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Any suggestions? I could figure this out on my own, it might take a while, but currently I have to start getting ready for work. And besides it get others a chance to work those brain mussels. Thanks alot.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19365 - sajiimori - Sun Apr 18, 2004 12:38 am</h4>
    <div class="postbody"><span class="postbody">Too complicated!  You need to abstract over the hardware, then forget about it.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int pressed(int key)
<br/>
{
<br/>
  return !(*KEYS &amp; key);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Enumerate the 9 keypad states (nothing pressed or one of 8 directions), and write a function that returns the current state.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
enum
<br/>
{
<br/>
  DIR_NONE,
<br/>
  DIR_U,
<br/>
  DIR_UR,
<br/>
  DIR_R,
<br/>
  DIR_DR,
<br/>
  DIR_D,
<br/>
  DIR_DL,
<br/>
  DIR_L,
<br/>
  DIR_UL,
<br/>
  DIR_NUMDIRS
<br/>
};
<br/>
<br/>
int get_dirpad_state()
<br/>
{
<br/>
  if(pressed(KEY_UP))
<br/>
    if(pressed(KEY_LEFT))
<br/>
      return DIR_UL;
<br/>
    else if(pressed(KEY_RIGHT))
<br/>
      return DIR_UR;
<br/>
    else
<br/>
      return DIR_U;
<br/>
  else if(pressed(KEY_DOWN))
<br/>
    if(pressed(KEY_LEFT))
<br/>
      return DIR_DL;
<br/>
    else if(pressed(KEY_RIGHT))
<br/>
      return DIR_DR;
<br/>
    else
<br/>
      return DIR_D;
<br/>
  else if(pressed(KEY_LEFT))
<br/>
    return DIR_L;
<br/>
  else if(pressed(KEY_RIGHT))
<br/>
    return DIR_R;
<br/>
  return DIR_NONE;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Because you need more functionality than that, add another abstraction layer.  Don't add more values to the DIR_ enum or change get_dirpad_state() to add features -- keep your abstractions minimal and to the point.
<br/>
<br/>
You could implement another function that uses get_dirpad_state(), but also maintains other information, such as the state on the previous frame.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
struct DirPadState
<br/>
{
<br/>
  int current;
<br/>
  int previous;
<br/>
<br/>
  // other info you need
<br/>
  ...
<br/>
};
<br/>
<br/>
void load_dirpad_state(DirPadState* s)
<br/>
{
<br/>
  static int previous;
<br/>
  s-&gt;current = get_dirpad_state();
<br/>
  s-&gt;previous = previous;
<br/>
  previous = s-&gt;current;
<br/>
<br/>
  // load other info into struct
<br/>
  ...
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Make the struct hold all the information you'll need to decide what to do in the game.  After that, you just write one last function that does the appropriate thing to the game's state based on the directional pad's state.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void apply_dirpad_state(DirPadState* s, GameState* g)
<br/>
{
<br/>
  switch(s-&gt;current)
<br/>
  {
<br/>
    ...
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
The direction the player is moving is part of the game's state, not part of input.  They should be seperate.  This sort of modularization really pays off in the end.
<br/>
<br/>
If you think that "command" concept will be useful (for instance, if the player could customize controls, keys could map to different commands), you could do this instead of apply_dirpad_state():
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
enum
<br/>
{
<br/>
  CMD_NONE,
<br/>
  CMD_WALKUP,
<br/>
  ...
<br/>
}
<br/>
<br/>
// Note that the command issued is dependent on the
<br/>
// game's state.  Also, the full key state might be needed
<br/>
// rather than just the dir pad, so another struct would
<br/>
// wrap it.
<br/>
int determine_command(DirPadState* s, GameState* g)
<br/>
{
<br/>
  ...
<br/>
}
<br/>
<br/>
void apply_command(int cmd, GameState* g)
<br/>
{
<br/>
  ...
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Notice how the additional concept of a "command" added another step to the process.  This is normal -- it is said that most problems in programming can be solved by adding an additional indirection.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19380 - mr_schmoe - Sun Apr 18, 2004 6:45 pm</h4>
    <div class="postbody"><span class="postbody">You gave some really good insight, sajiimori. But I still don't think I have enough education or experience to do what I'm trying to do. Do you know of a good book that teaches abstract concepts and good programming technices specifically geared towards game programming. I only program as a hobby and I don't really have any intentions of going pro or selling my game. But I still want to learn. And I believe that's what the coding section of this forum is all about, helping beginners and novices learn good coding technices. So, if you don't mind, let me tell you a little more about what I'm trying to do.
<br/>
<br/>
I want to write a top view action adventure game/demo kind of like the Legend of Zelda: A Link to the Past. I have one sprite, (or a series of images for animation) for each of the 4 direction and 4 more for using your weapon in 4 direction, 4 more for getting hit, etc. That way, I can load a new animation if it's a new direction or the player hit the weapon button and just update the sprite attributes for the next frame until the action is completed. But the problem is, I need to poll for input just incase in mid step the player changes direction, but I don't need to poll for a new input if the player uses the weapon because you can't change the action have way through swinging his sword, you need to wait till the character's done. You know, now that I think about it, has someone made a game similar to what I'm doing that is willing to release the source code I can look off of. That would work better. But I think I need to stop writing now, I'm confusing myself.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19402 - poslundc - Mon Apr 19, 2004 4:17 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>mr_schmoe wrote:</b></span></td> </tr> <tr> <td class="quote">And I believe that's what the coding section of this forum is all about, helping beginners and novices learn good coding technices.</td> </tr></table><span class="postbody">
<br/>
<br/>
Actually, that's what the Beginner's section is for, but I think we can let it slide. :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I want to write a top view action adventure game/demo kind of like the Legend of Zelda: A Link to the Past. I have one sprite, (or a series of images for animation) for each of the 4 direction and 4 more for using your weapon in 4 direction, 4 more for getting hit, etc. That way, I can load a new animation if it's a new direction or the player hit the weapon button and just update the sprite attributes for the next frame until the action is completed. But the problem is, I need to poll for input just incase in mid step the player changes direction, but I don't need to poll for a new input if the player uses the weapon because you can't change the action have way through swinging his sword, you need to wait till the character's done.</td> </tr></table><span class="postbody">
<br/>
<br/>
This is the second time tonight that I am advising someone to read up on <a class="postlink" href="http://www.google.com/search?q=finite+state+machine" target="_blank">finite state machines</a>.
<br/>
<br/>
FSMs give you a simple and straightforward way to organize a game in the way you are describing. The player has a state, whether he's walking, swinging his sword, standing still, etc. and depending on what state he's in the game will respond differently depending on what buttons are pressed. Every frame you check the input, and based on whatever state he is currently in, you switch to a new state if necessary. You do this input check exactly once per frame, every frame, and update to the new state once per frame, every frame.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19406 - yaustar - Mon Apr 19, 2004 6:12 am</h4>
    <div class="postbody"><span class="postbody">I am not sure what you're original intention was.. (it could be due to the early hours of the morning :p) ar you having trouble with the states or are you having trouble detecting a diagonal?<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19419 - Miked0801 - Mon Apr 19, 2004 6:56 pm</h4>
    <div class="postbody"><span class="postbody">Yum.  Finite State Machines are your friend.  We use them in so many places/ways in our games to make life easy.  Actors, Menu system, scripting system, etc.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19420 - mr_schmoe - Mon Apr 19, 2004 7:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I am not sure what you're original intention was.. (it could be due to the early hours of the morning :p) ar you having trouble with the states or are you having trouble detecting a diagonal?</td> </tr></table><span class="postbody">
<br/>
<br/>
Actually, it started out as me trying to detect 8 direction movement, but when sajiimori expained a whole lot simpler way it turned into a discution on game engines.
<br/>
<br/>
I've been reading up on finite state machines, so far it has been very interesting. My original concept uses something similar to what I've been reading. There was an aciton variable that was set based on when the character was doing at any givin time, and the input changes that action in a certain way based on what kind of input it is. I'm quite interested in reading more to see how I can improve on it. 
<br/>
<br/>
You guys have been really great, you must have a lot of patients to deal with use noobies.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19425 - sajiimori - Mon Apr 19, 2004 8:19 pm</h4>
    <div class="postbody"><span class="postbody">I didn't even know what a Finite State Machine was until recently.  I had assumed it must be some really complicated technique for graduate students at MIT, until I found out I had been doing essentially the same thing for years.  Trying to write good C often leads to FSM-like structure, even unintentionally.
<br/>
<br/>
One more comment about code structure.  Compare these 2 ways of organizing apply_dirpad_state():
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void apply_dirpad_state(DirPadState* s, GameState* g)
<br/>
{
<br/>
  switch(s-&gt;current)
<br/>
  {
<br/>
  case DIR_U:
<br/>
    switch(g-&gt;player.state)
<br/>
    {
<br/>
    case PL_SWING:
<br/>
      ...
<br/>
      break;
<br/>
    case PL_WALKUP:
<br/>
      ...
<br/>
    }
<br/>
    break;
<br/>
<br/>
  case DIR_UR:
<br/>
    switch(g-&gt;player.state)
<br/>
      ...
<br/>
  }
<br/>
}
<br/>
<br/>
void apply_dirpad_state(DirPadState* s, GameState* g)
<br/>
{
<br/>
  switch(g-&gt;player.state)
<br/>
  {
<br/>
  case PL_SWING:
<br/>
    switch(s-&gt;current)
<br/>
    {
<br/>
    case DIR_U:
<br/>
      ...
<br/>
    case DIR_UR:
<br/>
      ...
<br/>
    }
<br/>
    break;
<br/>
<br/>
  case PL_WALKUP:
<br/>
    switch(s-&gt;current)
<br/>
      ...
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
The first switches on the pad state first, and the second switches on the player's state first.  Which is better?  It largely depends on which set of states is more likely to be altered in the future.
<br/>
<br/>
What if you added another player state?  What would you have to do to the first version above, versus the second version?  In the first, you would have to add another case to each inner switch block.  In the second, you only have to add one case to the outer block.
<br/>
<br/>
So, since the number of pad states is fixed to 9, and the number of player states might change, switch on the player's state first.
<br/>
<br/>
IMO, the best solution of all is a data-driven approach, but unfortunately C often makes data-driven programming awkward.
<br/>
<br/>
In the above functions, how many inner cases are there total?  There's 1 inner switch block for each outer case, so the total is the number of player states times the number of game states.  You could draw a table where the columns are player states and the rows are game states, and each entry in the table could be 1 case.
<br/>
<br/>
In the above functions, we are trying to express 2-dimensional data in a 1-dimensional way.  The cases would be much more naturally expressed as a 2D array.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef void (*DirPadStateApplier)(DirPadState* s,
<br/>
                                   GameState* g);
<br/>
<br/>
const DirPadStateApplier
<br/>
  dirpad_state_appliers[DIR_NUMDIRS][PL_NUMSTATES] =
<br/>
{
<br/>
  ...
<br/>
};
<br/>
<br/>
void apply_dirpad_state(DirPadState* s, GameState* g)
<br/>
{
<br/>
  dirpad_state_appliers[s-&gt;current][g-&gt;player.state](s, g);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Replacing the "..." in C is the awkward part, because there are no anonymous functions.  You would have to make a seperate named function for each table entry.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19436 - yaustar - Tue Apr 20, 2004 2:26 am</h4>
    <div class="postbody"><span class="postbody">Diagonals I can help :) FSM just learning them myself with AI
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if((*KEYS &amp; 0x00F0)==176)                   //if the UP key is pressed
<br/>
if((*KEYS &amp; 0x00F0)==112)                 //if the DOWN key is pressed
<br/>
if((*KEYS &amp; 0x00F0)==208)                 //if the LEFT key is pressed
<br/>
if((*KEYS &amp; 0x00F0) == 224)                //if the RIGHT key is pressed
<br/>
if((*KEYS &amp; 0x00F0) == 96)                 //if the RIGHT + DOWN keys are pressed
<br/>
if((*KEYS &amp; 0x00F0) == 80)                 //if the LEFT + DOWN keys are pressed
<br/>
if((*KEYS &amp; 0x00F0) == 160)                 //if the RIGHT + UP keys are pressed
<br/>
if((*KEYS &amp; 0x00F0) == 144)                 //if the LEFT + UP keys are pressed</td> </tr></table><span class="postbody">
<br/>
Basically you mask the bits which the d pad affects from the register check it against the value of the keypress<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19493 - abilyk - Tue Apr 20, 2004 9:59 pm</h4>
    <div class="postbody"><span class="postbody">A few suggestions... some have been mentioned before in other topics, but are worth repeating.  This is how I do it, at least.
<br/>
<br/>
1) Read the keys register only once per frame (or whatever duration suits your project) and store it in a variable.  If you instead read the register over and over in a sequence of if statements, for example, the register value could change from one test to the other.  Since the register is active low (a 0 represents a pressed button), I find it more logical to store and work with the complement (so now a 1 represents a pressed button).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">keys = ~REG_KEYS;</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
2)  Use defines.  It makes your code much easier to read.  Further, I use hex numbers in my defines as opposed to decimal.  In this case and many others, the values correspond to individual bits being 0 or 1 as opposed to logically representing a value.  Hex numbers make such patterns more apparent.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define KEY_A                   0x0001
<br/>
#define KEY_B                   0x0002
<br/>
#define KEY_SELECT              0x0004
<br/>
#define KEY_START               0x0008
<br/>
#define KEY_RIGHT               0x0010
<br/>
#define KEY_LEFT                0x0020
<br/>
#define KEY_UP                  0x0040
<br/>
#define KEY_DOWN                0x0080
<br/>
#define KEY_R                   0x0100
<br/>
#define KEY_L                   0x0200</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
3)  Don't define (or calculate values for) specific combinations.  Instead use bitwise operators to combine your defined values.  Going along with the examples shown above, this will test for a diagonal left+up.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if(keys &amp; (KEY_LEFT | KEY_UP))
<br/>
    DoWhatever();</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
