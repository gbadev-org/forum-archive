<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>HBlank and Bios WaitVBL - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > HBlank and Bios WaitVBL</h2>
<div id="posts">
<div class="post">
    <h4>#9457 - Wanderer - Tue Aug 05, 2003 11:54 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I'm having a bit of trouble getting some of my code to work on hardware, although it seems to work fine with VisualBoyAdvance 1.5.1
<br/>
<br/>
The code is using HBlank interrupts and is also calling the Bios VBlankIntrWait function.  On the emu this works fine, however on the GBA the HBlank seems to get serviced but the code never returns from the Bios call (as far as I can tell).
<br/>
<br/>
Here's the code that seems to be at the centre of the problem:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void WaitForVsyncSetup() {
<br/>
   GBA_INTERPROC = (u16*)&amp;interProc;
<br/>
   
<br/>
   GBA_REG_IE  |= GBA_VBLANK_INTR;
<br/>
   GBA_REG_DISPSTAT |= 0x0008;
<br/>
   GBA_REG_IME = 0x01;
<br/>
}
<br/>
<br/>
void OnHBlankSetup(void (*HProc)(void)) {
<br/>
   GBA_INTERPROC = (u16*)&amp;interProc;
<br/>
   
<br/>
   MyHProc = HProc;
<br/>
   
<br/>
   GBA_REG_IE  |= GBA_HBLANK_INTR;
<br/>
   GBA_REG_DISPSTAT |= 0x0010;
<br/>
   GBA_REG_IME = 0x01;
<br/>
}
<br/>
<br/>
// Wait for the Vertical sync.
<br/>
void WaitForVsync()
<br/>
{
<br/>
   asm volatile("swi 0x50000");
<br/>
}
<br/>
<br/>
void interProc() {
<br/>
   GBA_REG_IME = 0x00;
<br/>
   
<br/>
   if(GBA_REG_IF &amp; GBA_VBLANK_INTR) {
<br/>
      (*(volatile u32*)0x03fffff8) = GBA_VBLANK_INTR;
<br/>
      GBA_REG_IF |= GBA_VBLANK_INTR;
<br/>
   }
<br/>
   
<br/>
   if(GBA_REG_IF &amp; GBA_HBLANK_INTR) {
<br/>
      (*(volatile u32*)0x03fffff8) = GBA_HBLANK_INTR;
<br/>
      GBA_REG_IF |= GBA_HBLANK_INTR;
<br/>
      
<br/>
      MyHProc();
<br/>
   }
<br/>
   
<br/>
   GBA_REG_IME = 0x01;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
From what I understand this should all work, but it doesn't.  Can someone please tell me what I'm doing wrong?
<br/>
<br/>
cheers,
<br/>
<br/>
<br/>
Wanderer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9468 - tepples - Tue Aug 05, 2003 3:41 pm</h4>
    <div class="postbody"><span class="postbody">It seems that the BIOS is not returning to your code after the ISR finishes.  Does your program run correctly in VBA when using a BIOS file (Options &gt; Emulator &gt; Use BIOS), or only with VBA's default high-level emulation of the BIOS in native code?
<br/>
<br/>
You might also want to try the following ISR, modeled after my boilerplate master ISR, which is a bit simpler than the one you gave:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void interProc() {
<br/>
  u16 got_if;
<br/>
<br/>
  GBA_REG_IME = 0x00;
<br/>
  /* capture what interrupts occurred so that we need to read REG_IF
<br/>
     only once */
<br/>
  got_if = GBA_REG_IF;
<br/>
   
<br/>
  if(got_if &amp; GBA_VBLANK_INTR) {
<br/>
  }
<br/>
   
<br/>
  if(GBA_REG_IF &amp; GBA_HBLANK_INTR) {
<br/>
    /* ... */
<br/>
    MyHProc();
<br/>
  }
<br/>
<br/>
  /* change sky colour on every interrupt, for debug purposes */
<br/>
  (*(volatile u16*)0x05000000) ^= 0x4210;
<br/>
<br/>
  /* the hardware automatically ORs in the bits you write to GBA_REG_IF,
<br/>
     so don't use the read-modify-write |= instruction when writing to
<br/>
     GBA_REG_IF but do use |= when writing to the mirror of it in IWRAM */
<br/>
  GBA_REG_IF = got_if;
<br/>
  (*(volatile u16*)0x03fffff8) |= got_if;
<br/>
  GBA_REG_IME = 0x01;
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9472 - Wanderer - Tue Aug 05, 2003 5:16 pm</h4>
    <div class="postbody"><span class="postbody">Thanks!!,
<br/>
<br/>
it was the |= on REF_IF that was causing it to hang.  I'd had it writing direct to the register a while back but unfortunately it got 'corrected' when I was tidying my code up a bit, and I didn't notice immediately because the emu was accepting it.
<br/>
<br/>
cheers,
<br/>
<br/>
<br/>
Wanderer.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
