<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Colors Off When Packing Data (RGB8 macro not working on PC) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Colors Off When Packing Data (RGB8 macro not working on PC)</h2>
<div id="posts">
<div class="post">
    <h4>#128963 - Karatorian - Thu May 17, 2007 3:55 am</h4>
    <div class="postbody"><span class="postbody">As a simple venture into GBA coding, I wrote a simple image display program. The first version of this program simply loaded an image stored in a C header file. (I saved it from the Gimp, which has a built in .h exporter.) It worked as expected.
<br/>
<br/>
As a precursor experiment towards a more advanced image packing program, I made a small change for the next version. Rather than use the header directly, I wrote a quick hack to turn the header file into an assembly file. When I run this version, the colors are all wrong. I suspect I'm running into a problem involving the difference in endianess between the ARM (where the display code is run) and the Intel (where the packing code is run), but I'm not sure and I can't figure out how to compensate. (To tell the truth, I barely understand endianness.)
<br/>
<br/>
Here's the display code, which is almost the same as the version that used the C header.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// Really Simple Image Display
<br/>
// Copyright 2007 Levi Aho
<br/>
// All Rights Reserved
<br/>
<br/>
#include &lt;gba.h&gt;
<br/>
<br/>
short img_data[SCREEN_HEIGHT * SCREEN_WIDTH];
<br/>
<br/>
int main()
<br/>
{
<br/>
   int i = 0, x, y;
<br/>
   
<br/>
   SetMode(MODE_3 | BG2_ON);
<br/>
   for (x = 0; x &lt; SCREEN_HEIGHT; x++)
<br/>
   {
<br/>
      for (y = 0; y &lt; SCREEN_WIDTH; y++)
<br/>
      {
<br/>
         MODE3_FB[x][y] = img_data[i++];
<br/>
      }
<br/>
   }
<br/>
   while (1) {}
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And here's the code for the image conversion hack. It's quick and dirty, and is not intended as finished code. It's simply a proof of concept sort of thing, but it doesn't work like it's supposed to. I tried various changes to attempt to fix it, but I couldn't get the colors to come out right, so I'm posting the original version.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// Really Simple Image Display
<br/>
// Copyright 2007 Levi Aho
<br/>
// All Rights Reserved
<br/>
<br/>
#include &lt;stdio.h&gt;
<br/>
#include &lt;gba_video.h&gt;
<br/>
#include "studio-karatorian.h"
<br/>
<br/>
int main()
<br/>
{
<br/>
   int i;
<br/>
   char p[3];
<br/>
   short d;
<br/>
   
<br/>
   printf(".global\timg_data\n");
<br/>
   printf("img_data:\n");
<br/>
   printf("\t.align\t4\n");
<br/>
   
<br/>
   for (i = 0; i &lt; SCREEN_HEIGHT * SCREEN_WIDTH; i++)
<br/>
   {
<br/>
         HEADER_PIXEL(header_data, p);
<br/>
         d = RGB8(p[0],p[1],p[2]);
<br/>
         printf("\t.short\t0x%hX\n", d);
<br/>
   }
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm fairly sure that I need to change the last line in the loop to account for the endian difference, but I'm not sure how to do so. I know that it works for the most part as the image has the right shapes and stuff, only the colors are wrong. Can someone please help me out?
<br/>
<br/>
<span style="font-weight: bold">Edit:</span> I did some more searching and investigating and discovered it has nothing to do with endianess. As it turns out, the ARM and the Intel are both little endian, so there is no conflict there.
<br/>
<br/>
What I have discovered is that the RGB8 macro from gba_video.h didn't behave correctly when used on the PC by the conversion program. As it turns out, I had declared my p array as a "char", instead of an "unsigned char", which it should have been. For some reason, such code worked fine on the GBA, but not on the PC. Does anyone know why?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
