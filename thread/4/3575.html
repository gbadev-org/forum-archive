<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>which is faster? DMA3 or asm linear buffer copy? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > which is faster? DMA3 or asm linear buffer copy?</h2>
<div id="posts">
<div class="post">
    <h4>#22328 - Marill - Fri Jun 18, 2004 6:43 am</h4>
    <div class="postbody"><span class="postbody">I'm not too sure about the speeds, I am trying to evaluate which method should I use to copy sprites into VRAM.
<br/>
<br/>
Immediately, DMA3 comes to mind.
<br/>
<br/>
But looking at the SGADE source code, instead of using DMA3 to perform the transfer, they used a fast asm linear buffer copy instead.
<br/>
<br/>
This insterest me because with all the loading of sprites into memory, SGADE uses DMA3 copy. (eg. SoSpriteMemManaerLoad).
<br/>
<br/>
But, with SoSpriteMemManagerLoadFromImage() function, instead of using DMA3 copy, the asm linear buffer copy is used.
<br/>
<br/>
Anyone has any idea why this is so?
<br/>
<br/>
I am thinking it may be a speed issue, which is faster? DMA3 or the asm?
<br/>
<br/>
the asm is here in it's full glory:
<br/>
(i checked the SGADE license and i think it allows me to post source code here, if I am mistaken, please let me know!)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ ---------------------------------------------------------------------------------
<br/>
@ Title:    SpriteCopy
<br/>
@ File:     sprite_copy.text.iwram.s
<br/>
@ Author:   Willem Kokke (Gabriele Scibilia)
<br/>
@ Created:  March 20 2002 (June 29 2003)
<br/>
@
<br/>
@ Info:This file contains the assembly implementation 
<br/>
@      of a function to copy a linear buffer to sprite format, which is
<br/>
@      organised in a linear array of 8*8 blocks
<br/>
@
<br/>
@      This function is located in iwram
<br/>
@
<br/>
@      For optimal performance, make sure the source buffer is in iwram
<br/>
@      If your destination buffer is in vram, make sure to only use this in vblank,
<br/>
@      since the accestimes to vram are undefined while refreshing the display
<br/>
@
<br/>
@      The function Willem wrote takes ~ 2% cpu time for a 64*64 sprite, Gabriele
<br/>
@      unrolled the loop and now it is even faster. The latest implementation
<br/>
@      takes about 14% for a 240*160 fullscreen (while the oldest was ~ 18%)
<br/>
<br/>
<br/>
@ ---------------------------------------------------------------------------------
<br/>
@ Initialize;
<br/>
@ ---------------------------------------------------------------------------------
<br/>
<br/>
        .ARM
<br/>
        .ALIGN
<br/>
        .GLOBL  SoTileSetCopyFromLinearBuffer
<br/>
<br/>
@ ---------------------------------------------------------------------------------
<br/>
@ Externals;
<br/>
@ ---------------------------------------------------------------------------------
<br/>
<br/>
<br/>
@ ---------------------------------------------------------------------------------
<br/>
@ SpriteCopy
<br/>
@
<br/>
@ Prototype: 
<br/>
@
<br/>
@ __attribute__ (( long_call )) 
<br/>
@void SpriteCopy( u32* source, u32* dest, u32 width, u32 height );
<br/>
@
<br/>
@ Parameters:
<br/>
@
<br/>
@ source:   r0 = the start of the linear buffer in iwram
<br/>
@ dest:     r1 = the start of the sprite in vram
<br/>
@ width:    r2 = the width of the iwram buffer in pixels
<br/>
@ height:   r3 = the height of the iwram buffer in pixels
<br/>
@ ---------------------------------------------------------------------------------
<br/>
<br/>
SoTileSetCopyFromLinearBuffer:
<br/>
<br/>
   @ Store the registers we crush on the stack;
<br/>
<br/>
       stmfd   sp!,{r0-r12,r14}
<br/>
<br/>
   @ calculate the number of 8*8 blocks across the width and height
<br/>
   @ r4 indicates how many pixels to copy per line
<br/>
   @ r3 indicates how many lines of pixels to copy
<br/>
<br/>
       mov     r4, r2
<br/>
<br/>
<br/>
   @ Copy a 8*8 block from the linear buffer to vram
<br/>
   @ r14 is the temporary source pointer
<br/>
<br/>
<br/>
   Copy8x8Block:
<br/>
<br/>
       mov     r14,r0              @ set the start position for the new block
<br/>
       add     r0, r14, #8         @ save the start position for the next block
<br/>
       ldmia   r14,{r5, r6}        @ load 8 bytes from iwram
<br/>
       add     r14,r14, r2         @ increase the source pointer with "width" bytes
<br/>
       ldmia   r14,{r7, r8}        @ load 8 bytes from iwram
<br/>
       add     r14,r14, r2         @ increase the source pointer with "width" bytes
<br/>
       ldmia   r14,{r9, r10}       @ load 8 bytes from iwram
<br/>
       add     r14,r14, r2         @ increase the source pointer with "width" bytes
<br/>
       ldmia   r14,{r11,r12}       @ load 8 bytes from iwram
<br/>
       stmia   r1!,{r5 -r12}       @ store 32 bytes in vram, and writeback the pointer
<br/>
       add     r14,r14, r2         @ increase the source pointer with "width" bytes
<br/>
<br/>
       ldmia   r14,{r5, r6}        @ repeat this 2 times for a full 8*8 block
<br/>
       add     r14,r14, r2
<br/>
       ldmia   r14,{r7, r8}
<br/>
       add     r14,r14, r2
<br/>
       ldmia   r14,{r9, r10}
<br/>
       add     r14,r14, r2
<br/>
       ldmia   r14,{r11,r12}
<br/>
       stmia   r1!,{r5 -r12}
<br/>
<br/>
       subs    r4, r4, #8          @ Substract 8 from the total number of pixels to copy
<br/>
       bne     Copy8x8Block        @ Zero left?? then go to next row, else copy the next block
<br/>
<br/>
       subs    r3, r3, #8          @ Decrease the number of rows with 8
<br/>
       beq     CopyEnd             @ Zero left?? then branch to end
<br/>
<br/>
       mov     r4, r2              @ A new line, so a new blocks per row counter
<br/>
       add     r0, r14, #8         @ Move the source pointer to the next 8 rows
<br/>
<br/>
       b       Copy8x8Block        @ Start the next row
<br/>
<br/>
   @ we're finished, restore the registers and lets get outta here
<br/>
<br/>
   CopyEnd:
<br/>
<br/>
       ldmfd   sp!,{r0-r12,r14}
<br/>
       bx      lr
<br/>
<br/>
@ ---------------------------------------------------------------------------------
<br/>
@ EOF;
<br/>
@ ---------------------------------------------------------------------------------
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22329 - Marill - Fri Jun 18, 2004 6:52 am</h4>
    <div class="postbody"><span class="postbody">From the comments in the source code
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">The function Willem wrote takes ~ 2% cpu time for a 64*64 sprite, Gabriele unrolled the loop and now it is even faster</td> </tr></table><span class="postbody">
<br/>
<br/>
Okies I think I missed that previously.
<br/>
<br/>
So let's take a 64x64 sprite.
<br/>
<br/>
This asm takes less than 2% cpu time from the comments above.
<br/>
<br/>
How long will DMA3 halt the CPU for a 64x64 sprite transfer? Assuming 256 color sprite.
<br/>
<br/>
Thanks in advance! :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22330 - tepples - Fri Jun 18, 2004 7:05 am</h4>
    <div class="postbody"><span class="postbody">A 256 color sprite cel at 64x64 pixels takes 1024 bytes.
<br/>
<br/>
Assuming 3/1 wait state (the default is 4/2; most commercial games switch to 3/1 on start), each copy of 2 bytes takes 3 cycles (1 wait, 1 read ROM, 1 write VRAM). A 1024 byte DMA transfer from ROM will take 1024 / 2 * 3 = 1536 cycles, or 0.54 percent of one frame's total time, or 1.83 percent of one frame's vblank time, or slightly longer than one scanline.  If you need subscanline interrupt latency (such as if you're doing hblank tricks or serial communication, or if your mixer's double buffer is clocked off an interrupt rather than off vblank), use the BIOS function CpuFastSet to do such copies.
<br/>
<br/>
Thing is, that assembly code also converts the cel from a raw linear bitmap (as would be found in .bmp) to a tile-format bitmap. DMA can't do this conversion. Most commercial games seem to store their sprite cels in ROM either as tile-format bitmaps or in some compressed format.
<br/>
<br/>
And is there a specific reason you need to use 256-color sprites? Using 256-color sprites means you need to use the same palette for all sprites unless you use complicated hblank tricks. Most commercial games actually use 16-color sprites.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22332 - Marill - Fri Jun 18, 2004 7:40 am</h4>
    <div class="postbody"><span class="postbody">thanks for the explanation, tepples. I am using 16 color sprites.
<br/>
<br/>
the reason the assumption is in 256 color sprites is because the higher level SGADE function that calls this asm works on 256 color sprites, so I'm just using 256 color sprites for comparison with DMA copy.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22337 - Marill - Fri Jun 18, 2004 1:20 pm</h4>
    <div class="postbody"><span class="postbody">okies I think I understand why linear buffer is used instead, thanks tepples for the pointers.
<br/>
<br/>
You can DMA the data into VRAM if your sprite data have already been formatted into 8x8 blocks. This is used coz the SGADE sprite data are pre-foramtted into 8x8 blocks (1D mode)
<br/>
<br/>
For loading of Images, the SGADE images are stored in linear buffer, and thus cannot be DMA'ed into the VRAM diretly. The asm is used to convert the linear buffer into 8x8 format first, tehn copy into VRAM.
<br/>
<br/>
it all makes sense now! thanks! ;)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
