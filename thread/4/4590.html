<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Worms-type game ; makin' holes! - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Worms-type game ; makin' holes!</h2>
<div id="posts">
<div class="post">
    <h4>#31350 - kiwibonga - Fri Dec 10, 2004 8:08 am</h4>
    <div class="postbody"><span class="postbody">I'm making a GBA version of Gunbound (http://www.gunbound.net). It's a worms style game, with some RPG elements. Some people say it's close to Scorched Planet, I haven't played that though, so I wouldn't know..
<br/>
<br/>
Anyways... The project just started, and I'm already facing some problems :P
<br/>
<br/>
Here's the deal, with a worms-type game, when a missile lands, it makes a hole, a hole that the characters can walk into, a hole that the player can see. The hole is basically a transparent color filled-oval drawn over the background.
<br/>
<br/>
But here's the deal. The WHOLE background is destructible, this means that I need to keep track of every single pixel that has been destroyed! Even worse, the maps are bigger than one screen in size, so I can't just draw holes to the screen, I have to keep track of them even when they're off screen..
<br/>
<br/>
Obviously, keeping a big 256 color bitmapped background in memory isn't really efficient if you have to scroll. I was able to make a scrolling bitmap BG by making this function that copies an area of a 480x320 bitmap in ROM to VRAM using DMA, it was fast enough but it's definitely not a good idea if you have to redraw the holes every time it's scrolled, even if you're using a bit mask or whatever.
<br/>
<br/>
So what I have now is a tiled BG, with only unique, 16 color tiles, except for transparent tiles of course.
<br/>
<br/>
What I want to do is directly modify the tiles by copying a rectangle from the background to a bitmap array, drawing the oval to that bitmap, and then writing to the tiles.
<br/>
<br/>
Problem is... 4 bits per pixel means each byte is a pair of pixels, even worse, the highest 4 bits code for the right pixel, and the lowest 4 bits for the left pixel.
<br/>
<br/>
So basically I would have to save an array of tile numbers, copy each tile 8 pixels at a time to a bitmap "canvas," not forgetting to pick out the higher and lower 4 bits of each byte and storing them in a char array.. Then I'll draw my oval, and do the conversion backwards, and finally write the tile data back...
<br/>
<br/>
In short, I need help with this because it's a huge headache to plan, and I'm sure something is gonna go wrong!
<br/>
<br/>
How it would go if I did it:
<br/>
<br/>
(assume that the missile's landing point is the top left of the oval hole's rectangle bounding box, for simplicity, if that helps at all....)
<br/>
<br/>
missile lands at landx,landy
<br/>
tile position: landxt = landx/8, landyt = landy/8
<br/>
width and height of the explosion: exwidth, exheight
<br/>
same thing but in tiles: exwidtht = ceiling(exwidth/8), exheightt = ceiling(exheight/8)
<br/>
temporary bitmap to draw the explosion oval to: u8* tempBg = malloc(exwidtht * 8 * exheightt * 8)
<br/>
temporary array that contains tile numbers: u16* tempTiles = malloc(exwidtht * exheightt * 2)
<br/>
<br/>
[loop to list the tile numbers in the specified region and store them into the tempTiles array]
<br/>
<br/>
[loop to fetch each tile and draw it to the temporary bitmap]
<br/>
<br/>
[call the function I made to draw an oval to the temporary bitmap]
<br/>
<br/>
[loop to write each tile to the appropriate position in VRAM]
<br/>
<br/>
And... we're done. It looks simple huh?
<br/>
<br/>
Questions:
<br/>
<br/>
- Do you know a quick way to convert a 4bpp bitmap with reversed half-bytes to a 8bpp bitmap? The way I see it I'll have to take each byte, AND it with 0F, save the result, then AND it with F0, shift it 4 bits to the right, save it to the next value, repeat 4 times, write that 8 pixel line to the bitmap, and do that 8 times in total for just one tile... Is there a simpler way to do it?
<br/>
<br/>
- Better yet, do you know a way to directly draw something to the tile data? I'm having tremendous trouble visualizing how to even draw a rectangle to the tile data without converting it, storing it temporarily in something more linear, and converting it back and writing it... It would be so much simpler if the tileset was just this big bitmap, and not 32 byte strings tile after tile...
<br/>
<br/>
- Is my idea total crap?
<br/>
<br/>
- Ultimate question: is there already a worms style homebrewn game with source out there which does exactly what I'm trying to do? :P
<br/>
<br/>
And well, that's about all I wanted to ask... Thanks a bunch to anyone who can help me out ^^<br/>_________________<br/><a href="http://www.kiwibonga.com" target="_blank">http://www.kiwibonga.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31375 - _pluto9 - Fri Dec 10, 2004 5:50 pm</h4>
    <div class="postbody"><span class="postbody">I have an idea... you could use 8x8 tiles. It wouldn't be to pretty, but it'd work... and if your really feeling adventurous you could use different types of tiles (for edges and corners and diagonals), and then write an algorithm to "smooth out" your map. (if you remeber how the Warcraft II map editor works)
<br/>
<br/>
....
<br/>
<br/>
I did a little thinking, and came up with an algorithm that *might* work (I didn't test it, I'm at school)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for (x=0; x&lt;mapsizex; x++)
<br/>
   for (y=0; y&lt;mapsizey; y++)
<br/>
      if (map(x,y)&gt;0)
<br/>
      {
<br/>
         int top=1, bottom=1, left=1, right=1;
<br/>
<br/>
         if (map(x+1, y)&gt;0)
<br/>
            right = 0;
<br/>
         if (map(x-1, y)&gt;0)
<br/>
            left = 0;
<br/>
         if (map(x, y+1)&gt;0)
<br/>
            bottom = 0;
<br/>
         if (map(x, y-1)&gt;0)
<br/>
            top = 0;
<br/>
         
<br/>
         /*if (left &amp;&amp; right &amp;&amp; top)
<br/>
            top = 0;
<br/>
         if (left &amp;&amp; right &amp;&amp; bottom)
<br/>
            bottom = 0;
<br/>
         if (top &amp;&amp; bottom &amp;&amp; right)
<br/>
            right = 0;
<br/>
         if (top &amp;&amp; bottom &amp;&amp; left)
<br/>
            left = 0;*/
<br/>
<br/>
         map(x, y) = top + bottom&lt;&lt;1 + left&lt;&lt;2 + right&lt;&lt;3;
<br/>
         //        = top + bottom *2 + left *4 + right *8; 
<br/>
      }</td> </tr></table><span class="postbody">
<br/>
<br/>
now of course you'll have to arrange your tiles in the right way for this... (just look at the second last line of code). The top,bottom,left,right variables indicate that the tile comes to a point at that position</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31409 - sajiimori - Fri Dec 10, 2004 9:14 pm</h4>
    <div class="postbody"><span class="postbody">Using a tile BG, the number of tiles that are partially destroyed should be small compared to the number that are either untouched or totally destroyed.
<br/>
<br/>
Going by that theory, here's my suggestion:
<br/>
<br/>
Have the pixel data and map in ROM.
<br/>
<br/>
Make an array with 2 bits per tile, with enumerations for untouched, destroyed, or bitmasked.
<br/>
<br/>
Allocate space for a limited number of bitmasked tiles, due to probable RAM limitations.  Each entry is 8x8 bits.  Entries can be allocated on demand, and are freed when a tile changes to the "destroyed" state.
<br/>
<br/>
When you run out of bitmask entries, sadly you'd have to go straight to "destroyed" which would result in hard angles.  Allocate enough entries so you probably won't have that problem during an average battle.  Such is life on limited hardware.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31572 - AnthC - Sun Dec 12, 2004 11:23 am</h4>
    <div class="postbody"><span class="postbody">Just my suggestion 
<br/>
<br/>
Assuming a 160x240 screen is about 600 tiles.
<br/>
I would map the screen as linear tile arrays and modify the strip that is coming on and off the screen when scrolling.
<br/>
<br/>
So your screen would look like this in tile numbers :-
<br/>
<br/>
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 
<br/>
30 31 etc.
<br/>
60 61 etc...
<br/>
etc..
<br/>
etc..
<br/>
<br/>
So when you scroll your screen left, you would modify your vertical strip of tiles (on the right) 29 59 89 etc.
<br/>
Now this leads to the problem of destroyed tiles.
<br/>
How I would handle this is by having a 1 bit mask in ram that represents each pixel in your map and 'cookie cut' chunks out of this and modify the respective tiles on screen. Each 'mask screen' would take up 160*240/8 bytes in RAM (about 4.7k) so you have room for about 54 screens in slow RAM which is quite a large amount.
<br/>
When you blast chunks out of your map you simply cookie cut bits out of the mask and modify the on screen tiles.
<br/>
If you need more screens then you could tile your RAM and remove the blank areas but that would be more complex and need better handling.
<br/>
<br/>
You might need a bigger tile area for scrolling (extra column and row) so you you hide the scrolling section but you get the general idea.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31588 - sajiimori - Sun Dec 12, 2004 7:35 pm</h4>
    <div class="postbody"><span class="postbody">...which is basically my suggestion except slower and more RAM hungry.  But if it's good enough, then go for it.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
