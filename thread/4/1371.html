<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Distance between two 2D points? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > Distance between two 2D points?</h2>
<div id="posts">
<div class="post">
    <h4>#6876 - Alunze - Wed Jun 04, 2003 1:56 am</h4>
    <div class="postbody"><span class="postbody">I guess this has been asked to death, but I still have to do it, what would be a fast algorithm for calculating the distance between two 2D points?
<br/>
<br/>
    Thanks in *advance* &gt;_6</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6883 - jd - Wed Jun 04, 2003 5:20 am</h4>
    <div class="postbody"><span class="postbody">This is the only algo I know of:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
dx = x1 - x2;
<br/>
dy = y1 - y2;
<br/>
dist = sqrt((dx*dx) + (dy*dy));
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The built-in square root function is very slow, but there are faster ones available such as this one which takes 51 cycles - 11 times faster than the standard code:
<br/>
<br/>
<a class="postlink" href="http://www.gbadev.org/download.php?section=demos&amp;filename=isqr.zip" target="_blank">http://www.gbadev.org/download.php?section=demos&amp;filename=isqr.zip</a>
<br/>
<br/>
Alternatively, you might find that finding the square of the distance is acceptable for your purposes - in which case you can remove the square root altogether.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6906 - peteh - Wed Jun 04, 2003 1:30 pm</h4>
    <div class="postbody"><span class="postbody">There's currently a nice ongoing thread at gamedev covering this topic :
<br/>
<a href="http://www.gamedev.net/community/forums/topic.asp?topic_id=160085" target="_blank">http://www.gamedev.net/community/forums/topic.asp?topic_id=160085</a>
<br/>
<br/>
Basically distilled down to a decent approximation algorithm which is within 7% of the real answer :
<br/>
<br/>
#define FIVE_OVER_SIXTEEN 0.3125
<br/>
int finddist(int x,int y)
<br/>
{   
<br/>
return ( x &lt; y ? ( x + y * FIVE_OVER_SIXTEEN ) : ( y + x * FIVE_OVER_SIXTEEN ) );
<br/>
}
<br/>
<br/>
As well as a discussion on the Taylor Series.
<br/>
<br/>
Hope that helps</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6915 - Jason Wilkins - Wed Jun 04, 2003 2:49 pm</h4>
    <div class="postbody"><span class="postbody">Try using fsqrt instead of sqrt, it will use single precision instead of double and thus be a bit faster.  It would be best to find an integer sqrt function however.
<br/>
<br/>
In the same line, it would be better for FIVE_OVER_SIXTEEN to be 0.3125f instead of 0.3125 because that will not force the multiplication to be double precision.
<br/>
<br/>
In fact, if we want it to be integer, it would almost certainly be faster to change the code to this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
return (x &lt; y) ? (x + ((y * 5) &gt;&gt; 4)) : (y + ((x * 5) &gt;&gt; 4));
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Actually, I am amazed that anyone would propose the code above to use doubles, even on a Pentium processor.  On the ARM processor (y * 5) &gt;&gt; 4 can become a single instruction.
<br/>
<br/>
ADDENDUM:
<br/>
<br/>
I wrote the following program to test out this approximation.  I originally wrote it to test all dx and dy between 0 and 300 because I wanted to see how good it would be for testing the distance between sprites in pixels.  The result was that sometimes the percentage error was much greater than 7 percent.  The version below multiplies 300 by 1000 in order to prevent lose of precision.  Because it never tests values less than 1000 (except 0), the max error is indeed only around 7 percent, and that is when dx == dy.
<br/>
<br/>
If you graph out the approximation and the actual distance equation, then you will see that they are very similar until dx ~= dy, then the error gets bigger and bigger.  With a lot of precision, the error never gets more than 7.19 percent.
<br/>
<br/>
I would recommend that if you want to use this to find distances that are less than 1000, such as pixel distances, then you should use fixed point numbers.  
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;math.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
int idist(int dx, int dy)
<br/>
{
<br/>
   return (dy &lt; dx) ? (dx + ((dy * 5) &gt;&gt; 4)) : (dy + ((dx * 5) &gt;&gt; 4));
<br/>
}
<br/>
<br/>
float fdist (float dx, float dy)
<br/>
{
<br/>
   return (float)sqrt((dx*dx) + (dy*dy));
<br/>
}
<br/>
<br/>
<br/>
#define ABS(x) ((x &gt; 0) ? (x) : -(x))
<br/>
<br/>
float percent_error(float actual, float approx)
<br/>
{
<br/>
   return (actual != 0) ? ABS((approx / actual) - 1) * 100.0f : -1;
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   int dx, dy;
<br/>
   int id;
<br/>
   float fd;
<br/>
   float absolute_error;
<br/>
   float error;
<br/>
   float max_error = 0;
<br/>
   float abs_for_perc = 0;
<br/>
   int dx_for_abs;
<br/>
   int dy_for_abs;
<br/>
   float max_absolute_error = 0;
<br/>
   float perc_for_abs = 0;
<br/>
   int dx_for_perc;
<br/>
   int dy_for_perc;
<br/>
   
<br/>
   for (dx = 0; dx &lt; 300000; dx += 10000) {
<br/>
      for (dy = 0; dy &lt; 300000; dy += 10000) {
<br/>
         id = idist(dx, dy);
<br/>
         fd = fdist(dx, dy);
<br/>
         absolute_error = ABS(((float)id) - fd);
<br/>
         error = percent_error(fd, id);
<br/>
<br/>
         if (error &gt; max_error) {
<br/>
            max_error = error;
<br/>
            abs_for_perc = absolute_error;
<br/>
            dx_for_perc = dx;
<br/>
            dy_for_perc = dy;
<br/>
         }
<br/>
<br/>
         if (absolute_error &gt; max_absolute_error) {
<br/>
            max_absolute_error = absolute_error;
<br/>
            perc_for_abs = error;
<br/>
            dx_for_abs = dx;
<br/>
            dy_for_abs = dy;
<br/>
         }
<br/>
<br/>
         printf("[%d, %d]\t idist = %d\t fdist = %.2f\t absolute_error = %.2f\t error = %%%.2f\n", dx, dy, id, fd, absolute_error, error);
<br/>
      }
<br/>
   }
<br/>
<br/>
   printf("max absolute error = %f (%%%f) [%d, %d]\n", max_absolute_error, perc_for_abs, dx_for_abs, dy_for_abs);
<br/>
   printf("max error = %%%f (%f) [%d, %d]\n", max_error, abs_for_perc, dx_for_perc, dy_for_perc);
<br/>
<br/>
   return 0;   
<br/>
}
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26774 - Mephisto - Sat Sep 25, 2004 8:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">#define FIVE_OVER_SIXTEEN 0.3125 
<br/>
int finddist(int x,int y) 
<br/>
{ 
<br/>
return ( x &lt; y ? ( x + y * FIVE_OVER_SIXTEEN ) : ( y + x * FIVE_OVER_SIXTEEN ) ); 
<br/>
} </td> </tr></table><span class="postbody">
<br/>
<br/>
wtf are x and y ?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26775 - tepples - Sat Sep 25, 2004 8:58 pm</h4>
    <div class="postbody"><span class="postbody">the horizontal and vertical components of distance<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26776 - DiscoStew - Sat Sep 25, 2004 8:58 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mephisto wrote:</b></span></td> </tr> <tr> <td class="quote">wtf are x and y ?</td> </tr></table><span class="postbody">
<br/>
Probably a point extending from the origin.
<br/>
A line from (2, 3)-(4, 8) would translate into (0, 0)-(2, 5).
<br/>
Same distance.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26777 - poslundc - Sat Sep 25, 2004 9:32 pm</h4>
    <div class="postbody"><span class="postbody">Ugh... using floating-point totally defeats the purpose of the distance-approximation algorithm. Here's the version I use:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// distApprox adds 8 to the precision of the result.
<br/>
// Therefore two integers will generate a 24.8 result.
<br/>
// Expected error around 7%.
<br/>
<br/>
#define DA_FOS(n)   ((n &lt;&lt; 6) + (n &lt;&lt; 4))
<br/>
<br/>
inline s32 distApprox(s32 x, s32 y)
<br/>
{
<br/>
   if (x &lt; y)
<br/>
      return ((x &lt;&lt; 8) + DA_FOS(y));
<br/>
   else
<br/>
      return ((y &lt;&lt; 8) + DA_FOS(x));
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
It is worth mentioning that if you don't need to find the actual distance, but just compare two distances to see which is bigger, you can just compare a1*a1 + b1*b1 to a2*a2 + b2*b2.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26778 - poslundc - Sat Sep 25, 2004 9:34 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">On the ARM processor (y * 5) &gt;&gt; 4 can become a single instruction.</td> </tr></table><span class="postbody">
<br/>
<br/>
How d'you figure?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26779 - DekuTree64 - Sat Sep 25, 2004 9:59 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">On the ARM processor (y * 5) &gt;&gt; 4 can become a single instruction.</td> </tr></table><span class="postbody">
<br/>
<br/>
How d'you figure?
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
add reg, reg, reg, asr #2 would do the trick. Personally I haven't done anything involving lots of distance checks, but this one looks pretty nice. And if the accuracy drop when the values get close together is too much, you could probably get away with checking for it and using a more accurate algorithm if needed, since it's so fast.
<br/>
<br/>
EDIT: Silly me, putting an lsr on something that will obviously be negative half the time...<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26780 - poslundc - Sun Sep 26, 2004 12:04 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">On the ARM processor (y * 5) &gt;&gt; 4 can become a single instruction.</td> </tr></table><span class="postbody">
<br/>
<br/>
How d'you figure?
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
add reg, reg, reg, asr #2 would do the trick.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
...
<br/>
<br/>
Uh, it don't add up...
<br/>
<br/>
Let y = 32
<br/>
Then (y * 5) &gt;&gt; 4 == 10
<br/>
add y, y, y, asr #2 == 40
<br/>
<br/>
I'm interested in knowing if there's a clever mathematical way of doing this, but as far as I can tell there's no way to do it in one instruction.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26781 - ampz - Sun Sep 26, 2004 12:48 am</h4>
    <div class="postbody"><span class="postbody">How about a simple lookup table?
<br/>
The GBA screen is not incredible high-resolution, so the number "X*X+Y*Y" can never be larger than 83200 for on-screen objects.
<br/>
Each table entry needs to be 9bit to represent the longest possible on-screen distance (288), this means 16bit table entrys. If you don't want to waste 80kB extra ROM, just rightshift every table entry one step. You vill only loose 1 bit precision. Or simply round the largest entrys down to 255. Results in poor precision only for the most distant objects, and in most games, we only care about the objects nearby anyway, and we rarely need to calculate the distance between objects in oposite corners of the screen.
<br/>
<br/>
So, Two 8bit multiplications, one addition and one ROM table lookup is all it takes for a perfect precision distance algorithm. Should be about 10 cycles or so?
<br/>
<br/>
Of course, if you need to be able to calculate the distance between various off-screen objects, then a lookup table is not a very realistic solution.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26782 - Krakken - Sun Sep 26, 2004 1:05 am</h4>
    <div class="postbody"><span class="postbody">That would be ~83kb of memory. I expect that would only be useful if you don't care about your final ROM size or you're going to be using it constantly and you desperately need the speed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26784 - ecurtz - Sun Sep 26, 2004 2:28 am</h4>
    <div class="postbody"><span class="postbody">Here's a good approximate function (with some helpful explanation) that I've got bookmarked.
<br/>
<br/>
<a class="postlink" href="http://www.flipcode.com/articles/article_fastdistance.shtml" target="_blank">flipcode distance article</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26788 - DekuTree64 - Sun Sep 26, 2004 3:12 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">On the ARM processor (y * 5) &gt;&gt; 4 can become a single instruction.</td> </tr></table><span class="postbody">
<br/>
<br/>
How d'you figure?
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
add reg, reg, reg, asr #2 would do the trick.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
...
<br/>
<br/>
Uh, it don't add up...
<br/>
<br/>
Let y = 32
<br/>
Then (y * 5) &gt;&gt; 4 == 10
<br/>
add y, y, y, asr #2 == 40
<br/>
<br/>
I'm interested in knowing if there's a clever mathematical way of doing this, but as far as I can tell there's no way to do it in one instruction.
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Indeed you're right. I was looking at is as (y * 5) <span style="font-weight: bold">/</span> 4, not &gt;&gt; 4. Yeah, that will take 2 instructions, but the second can be absorbed into the adding of x:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">add ry, ry, ry, lsl #2       // y * 5
<br/>
add rDest, rx, ry, asr #4    // x + (y * 5 &gt;&gt; 4)</td> </tr></table><span class="postbody">
<br/>
<br/>
As for using lookup tables, eeh, I don't like it. Maybe for something like cloth simulation where you have to do crazy numbers of square roots between all the vertices, but they're all nice and close together, but for a real game, I doubt you'd ever have enough sprites on-screen for even a regular square root to kill you.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26801 - ampz - Sun Sep 26, 2004 1:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Krakken wrote:</b></span></td> </tr> <tr> <td class="quote">That would be ~83kb of memory. I expect that would only be useful if you don't care about your final ROM size or you're going to be using it constantly and you desperately need the speed.</td> </tr></table><span class="postbody">Well, is that not what this thread is all about?
<br/>
jd posted a link to a 51 cycle square root function, if that is not fast enough, then a approximation or a lookup table are the only options.
<br/>
83kByte is not too high a price if you need both speed and accuracy.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">As for using lookup tables, eeh, I don't like it. Maybe for something like cloth simulation where you have to do crazy numbers of square roots between all the vertices, but they're all nice and close together, but for a real game, I doubt you'd ever have enough sprites on-screen for even a regular square root to kill you.</td> </tr></table><span class="postbody">Then what is this thread all about? The 51 cycle square root function should be plenty fast if you don't need to do too many square roots per frame.
<br/>
<br/>
I just realized that a square root lookup table should of course be 2-dimensional.
<br/>
char sqrt[240][160];
<br/>
This is only 38400 Bytes and takes only a few cycles.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26846 - FluBBa - Mon Sep 27, 2004 11:33 am</h4>
    <div class="postbody"><span class="postbody">Not to be picky about it but the longest distance between both corners is 288 "pixels".
<br/>
I don't really see the problem of a 76800 bytes big table if you are after speed though.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26851 - poslundc - Mon Sep 27, 2004 2:19 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>FluBBa wrote:</b></span></td> </tr> <tr> <td class="quote">I don't really see the problem of a 76800 bytes big table if you are after speed though.</td> </tr></table><span class="postbody">
<br/>
<br/>
For the record, it's not going to be THAT speedy, unless you let it consume a huge chunk of your EWRAM. If you keep it in ROM, you're going to have huge access time delays, especially if your code is running from ROM as well. I'd take the fast distance function I provided earlier in the thread: you can put it in IWRAM in ARM mode if you want and optimize it using conditional execution and probably end up with comparable performance, without the restrictions of the table size.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26862 - ampz - Mon Sep 27, 2004 10:11 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>FluBBa wrote:</b></span></td> </tr> <tr> <td class="quote">Not to be picky about it but the longest distance between both corners is 288 "pixels".
<br/>
I don't really see the problem of a 76800 bytes big table if you are after speed though.</td> </tr></table><span class="postbody">I know. But there are ways around that.
<br/>
If a +-1 error is acceptable, or you don't need to know the exact distance between objects in opposite corners, then you can get away with only 8bit table entrys.
<br/>
You could also use a simple trick like: distance=x+sqrt_table[x][y]. This will keep the table entrys down to 8 bit, give you perfect precision, and only cost you a single extra instruction.
<br/>
<br/>
poslundc: A ROM table lookup should be 6 cycles if the code is executed from IWRAM. Add to this the X+Y addition and we get 7 cycles. You save another cycle if you can afford to put the table in EWRAM.
<br/>
<br/>
A 6-7cycle precision sqrt function is as fast as it gets.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
