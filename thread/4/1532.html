<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>good start file for ARM STD/ADS? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > good start file for ARM STD/ADS?</h2>
<div id="posts">
<div class="post">
    <h4>#7783 - Lupin - Tue Jun 24, 2003 4:42 pm</h4>
    <div class="postbody"><span class="postbody">where could I get one? Wich is the best one?
<br/>
<br/>
I'm not good enough to write my own :(
<br/>
<br/>
But I want to do interrupt handling myself (the start file should just set the address of my interrupt handler)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7788 - DekuTree64 - Tue Jun 24, 2003 5:59 pm</h4>
    <div class="postbody"><span class="postbody">I haven't used ARM SDT since I was first starting out and didn't have a clue what I was doing, so I can't help you with that, but for an interrupt handler, just set the address in your own code. Use 
<br/>
#define REG_INTERRUPT	*(volatile u32*)0x3007FFC
<br/>
And set REG_INTERRUPT to the address of your function and it will get called whenever an interrupt happens.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7791 - Lupin - Tue Jun 24, 2003 6:32 pm</h4>
    <div class="postbody"><span class="postbody">Do I actually need an start.s file? Seems like the GBA automatically calls a symbol named "start", so if i would name my entry function "start", the gba would perhaps call it, then I would just have to copy my rom into the gba memory.
<br/>
<br/>
Thanks for your hint, I will do it that way</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7812 - Jason Wilkins - Wed Jun 25, 2003 2:26 pm</h4>
    <div class="postbody"><span class="postbody">You should start with assembly because that is the best way to create a ROM header and the only way to set the stack addresses.  I'm don't know what the default values for the stack are on real hardware, but for VBA, the IRQ and USR stacks have the same address, so it wouldn't work unless you fix them up.
<br/>
<br/>
The interrupt handler does not have to be in crt0.S, as DekuTree64 pointed out.  That is just another example of people not thinking and just copying what has been done before.  It is easy enough to do using C code.
<br/>
<br/>
GBA does not call a symbol called _start, that is just the traditional name of the entry point.  On some systems, like Linux which parse elf files, the OS does indeed call that symbol, on other systems, that start symbol is put where it will be called first.  In other words, you have to make arrangements for _start to be where it will be called first because the system does not look for it.
<br/>
<br/>
The GBA just starts executing code at 0x08000000, so you make arrangments to put the start symbol there, it could just as easily be call robert.  You don't even have to give it a symbol.
<br/>
<br/>
All this said, I did write a crt0.c, and it worked.  I had to use inline assembly for the header and stack setting functions, and make sure the _start function was at the beginning of the file and make sure that crt0.o was the first thing on the linking command line.  All of this can only be done because I know that the gcc toolchain will put _start first in the resulting file, there is nothing in the ANSI standard to guarantee that.
<br/>
<br/>
I used the naked, noreturn, and always_inline attributes to make the code almost as small as a hand written assembly routine.  But, all this was just an exercise in learning, not something I would ever really use.
<br/>
<br/>
It would be easy to write a tool which translated ARM assembly syntax to gcc assembly syntax and visa versa.  You could use flex, and it would take you about an hour or two.<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7814 - Lupin - Wed Jun 25, 2003 3:18 pm</h4>
    <div class="postbody"><span class="postbody">thx for the input! I already know basic asm, but I don't know what the stack is used for and why I should initialize it... I don't think that I would be able to write an start file from scratch...
<br/>
<br/>
So, what exactly must actually be done within the start file?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7817 - DekuTree64 - Wed Jun 25, 2003 4:35 pm</h4>
    <div class="postbody"><span class="postbody">I think all that really HAS to be done is making a header, setting the stack pointers and and branching to your main function. Jeff's Crt0 includes al the neccessary stuff to run in multiboot mode, and handy stuff like if you run a multiboot ROM from a flash cart, it will copy it into EWRAM for you and branch to it. It also clears all the memory to 0, but unless your code depends on things being set to 0 to start with, that shouldn't really make a difference.
<br/>
And if you're using functions in IWRAM, you need to copy in anything from the .iwram section. From Jeff's:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ Copy internal work ram (iwram section) from LMA to VMA (ROM to RAM)
<br/>
ldr     r1,=__iwram_lma
<br/>
ldr     r2,=__iwram_start
<br/>
ldr     r4,=__iwram_end
<br/>
bl      CopyMemChk
<br/>
</td> </tr></table><span class="postbody">
<br/>
Those are defined by the linkscript, so basically what that does is a memcpy(__iwram_start, __iwram_lma, __iwram_end - __iwram_start);
<br/>
<br/>
And it sets the IRQ handler too, but I use my own, since I find it handy in an RPG to have like one interrupt table for walking around maps, and a different table for battles. If you have the irqTable variable just a pointer to a table, you can do irqTable = mapIrq; to switch between them without having to copy the whole thing to a temporary place. Pretty cool, though not totaly neccessary.
<br/>
<br/>
Just read through Crt0.S every now and then and eventually it will start to make sense. At least it did for me, I used to be completely confused by it, but now it pretty much makes sense.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7820 - Jason Wilkins - Wed Jun 25, 2003 5:48 pm</h4>
    <div class="postbody"><span class="postbody">You should read my crt0.S for DKA5, I am pretty damn proud of it.<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7821 - Lupin - Wed Jun 25, 2003 7:07 pm</h4>
    <div class="postbody"><span class="postbody">Jason: What files do I really need to compile using DKA5?
<br/>
<br/>
Deku: Since I'm trying to use ADS the __iwram_XXX symbols would perhaps not be defined... documentation for ADS is really bad :(
<br/>
<br/>
I tried to load the address of an interrupt handler function into the register, but somehow it doesn't work correctly, could you please tell me what i did wrong here?
<br/>
<br/>
#define REG_INTERUPT (*(vu32*)0x3007FFC)
<br/>
typedef void (*fp)(void);
<br/>
<br/>
  fp inthndlr;
<br/>
  inthndlr = HandleInterrupt;
<br/>
  REG_INTERUPT = (u32)inthndlr;
<br/>
<br/>
void HandleInterrupt() {
<br/>
  switch (REG_IF) {
<br/>
   case INT_VBLANK:
<br/>
    VBLANK();
<br/>
    REG_IF = INT_VBLANK;
<br/>
   case INT_KEYBOARD:
<br/>
    KEYBOARD();
<br/>
    REG_IF = INT_KEYBOARD;
<br/>
  }
<br/>
}
<br/>
<br/>
<br/>
sorry for asking so much dumb stuff :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7822 - Jason Wilkins - Wed Jun 25, 2003 8:10 pm</h4>
    <div class="postbody"><span class="postbody">You need to have a pointer to a pointer to a function.
<br/>
<br/>
The location, scrictly speaking, is not a register.  Its location and function are determined totally by software, so it is just a variable.
<br/>
<br/>
It does not have to be volatile.  Only values which can be changed by factors other than the current thread of execution or values which are different if you read them as opposed to write them need to be volatile (some hardware, including the GBA, saves address space by overlapping read-only and write-only registers).
<br/>
<br/>
So, the interrupt vector is not volatile.  Of course, you could make it volatile by having an interrupt handler change it, but this rule applies to all variables which you change in an interrupt handler if you read them from code that may be interrupted by that handler.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef void (*interrupt_handler_t)();
<br/>
typedef interrupt_handler_t *interrupt_handler_ptr_t;
<br/>
<br/>
#define INTERRUPT_VECTOR (*((interrupt_handler_ptr_t)0x03007FFC))
<br/>
<br/>
void my_interrupt_handler(void)
<br/>
{
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   INTERRUPT_VECTOR = my_interrupt_handler;
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
DevKit Advance can be downloaded here:  <a class="postlink" href="http://sourceforge.net/project/showfiles.php?group_id=673150" target="_blank">http://sourceforge.net/project/showfiles.php?group_id=673150</a>
<br/>
<br/>
Or, you could have followed the link in my sig and found it ^_^<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"><br/><br/>Last edited by Jason Wilkins on Wed Jun 25, 2003 8:20 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#7823 - DekuTree64 - Wed Jun 25, 2003 8:15 pm</h4>
    <div class="postbody"><span class="postbody">Yea, just leave out that IWRAM stuff until you figure out how to put code in different places with ADS. 
<br/>
And for the interrupt handler, you don't need to make a function pointer first, but that shouldn't cause any problems either. Just use REG_INTERRUPT = (u32)HandleInterrupt;
<br/>
Are you compiling that to ARM? When an interrupt happens, the CPU automatically switches to ARM mode, so if you're using THUMB, it will get confused.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7824 - Jason Wilkins - Wed Jun 25, 2003 8:23 pm</h4>
    <div class="postbody"><span class="postbody">I think it is a good rule in C programming to never use type casts unless you have to.  It is just sloppy, and contributed to Lupin not understanding what exactly is going on.  Would he have had to make a second post asking what he was doing wrong if no obsfucating cast had been used?  Why say something you don't mean?
<br/>
<br/>
You could declare int_handler_ptr_t as
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef void (**int_handler_ptr_t)(void);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
if you want to, I just broke it into two declarations so that it is clearer.<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7825 - DekuTree64 - Wed Jun 25, 2003 11:43 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">I think it is a good rule in C programming to never use type casts unless you have to.  It is just sloppy, and contributed to Lupin not understanding what exactly is going on.  Would he have had to make a second post asking what he was doing wrong if no obsfucating cast had been used?  Why say something you don't mean?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Actually, my last post was a reply to Lupin's, not yours. You just got there first while I was typing it. 
<br/>
But when did I ever use a confusing typecast? Was it that #define REG_INTERRUPT *(volatile u32*)0x3007FFC? I prefer using the u/s 8/16/32 types for pretty much everything, since that makes it more clear exactly how the compiler will treat them. But if you think typecasts are sloppy, you'd most certainly hate my code^_^ I use them a lot, just to be sure exactly what's going on.
<br/>
But anyway, sorry for any confusion I've caused</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#7848 - Jason Wilkins - Thu Jun 26, 2003 3:50 pm</h4>
    <div class="postbody"><span class="postbody">Excuse me then.
<br/>
<br/>
The typecast for 0x03007FFC is necessary, there are a few other ways to do it, but none of them involve C.
<br/>
<br/>
The problem is saying that it is a u32 when it is not.  It is a pointer to a function.  Why chose a u32?  Why not an i32?  or an int?  or hell, why not a float?  They are all equally arbitruary and require you to use a cast everytime you assign it.
<br/>
<br/>
Imagine if I used declared an integer as a float and then cast it to an int every time I used it.  Of course, i would know 'how the compiler is going to treat it' but it is still silly.
<br/>
<br/>
Actually, I think it is pointless to have the uNN and iNN types.  Everyone knows that an int is 32 bits and a short is 16 bits, no need to make it explicit.  BUT, it does save some typing, and it is all just a matter of opinion.  That was not the source of my comment.
<br/>
<br/>
My point was that you shouldn't create a declaration that forces you to use a typecast every single time, you may as well have cast it into strawberry_jam_t, as long as strawberry_jam_t was 32-bit it would work, but why?
<br/>
<br/>
If you use type casts a lot, it is not just a matter of 'hating' your code.  I do not see this as a matter of opinion, it is more like having an objective reason to think that you don't know what you are doing.  Just like you would say that a person who doesn't know how to punctuate a sentence is probably not a good writer.
<br/>
<br/>
A static type cast turns off the compiler's ability to check for errors, by using them you are just asking for it.  It is a sign that you have not thought about what you are doing enough.  
<br/>
<br/>
Of course, I can't really make any specific judgements about YOUR code DekuTree64, these are just general statements about type casts.  I would have to see your code to make any real call on it.  It is likely that you are just talking about using type casts for changing integer literals to pointers which is totally necessary for low level hardware programming.  Maybe it is something else, but if I see code with a lot of type casts, it is the same to me as seeing a lot of gotos (not 1 goto, but lots).<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
