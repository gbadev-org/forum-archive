<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>rotated sprite/bg collision - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > rotated sprite/bg collision</h2>
<div id="posts">
<div class="post">
    <h4>#6424 - sgeos - Sun May 25, 2003 6:05 am</h4>
    <div class="postbody"><span class="postbody">What is the best general approach to collision between two sprites, or a bg and a sprite, where one or both is rotated.  I do not think it should matter which sprite/bg, or if both are rotated.  I think they will all boil down to variations of the same thing.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6428 - Jason Wilkins - Sun May 25, 2003 10:08 am</h4>
    <div class="postbody"><span class="postbody">Generally, I would probably approximate the shape of the sprites with sets of convex polygons and check for collisions between the polygons.  Polygonal collision is fairly simple.   Transform one polygon into the other polygon's space, and then check for line segment intersections.
<br/>
<br/>
To keep from having to test line segments, you could do a square-of-the-distance check to see if they are too far away (square of the distance, because you do not want to do a sqrt to find the actual distance).
<br/>
<br/>
I would have to experiment some to figure out the best way to do these sort of collision tests while avoiding doing too many divides.
<br/>
<br/>
I am sure there are quite a few optimizations if you force all your convex polygons to be rectangles, as I am sure things simplify somewhat if one of your line segments are always perpendicular.
<br/>
<br/>
This might be too high a level explanation if you are not familiar with transforming points into different spaces.<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6447 - sgeos - Sun May 25, 2003 10:43 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">Transform one polygon into the other polygon's space, and then check for line segment intersections.</td> </tr></table><span class="postbody">
<br/>
<br/>
What is the best way to test for a line segment intersection?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">I am sure there are quite a few optimizations if you force all your convex polygons to be rectangles...</td> </tr></table><span class="postbody">
<br/>
<br/>
Sounds like the way to go.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">This might be too high a level explanation if you are not familiar with transforming points into different spaces.</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not familiar with transforming points into different spaces.  At least, I would not say I am.  At any rate, it gave me some ideas.  Thanks!
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6471 - Jason Wilkins - Mon May 26, 2003 9:00 pm</h4>
    <div class="postbody"><span class="postbody">I realized that I said 'convex polygon' because I was originally thinking of doing a simple 'point in polygon' test, which is easiest if the polygon is convex.  But, then I realized 'point in polygon' tests do not work generally to test if two polygons overlap.  If you use line intersections, you can test if any type of polygons overlap.  In that case, you do not need a set of polygons, because you do not have to simulate concave shapes with convex polygons.
<br/>
<br/>
I guess however, that if you wanted to simplify the tests by only using rectangles, then you may need to represent a shape with more than one if you have any odd shapes that cannot be approximated well using one rectangle.
<br/>
<br/>
Oh, and by rectangles, I mean axis-aligned rectangles, because it means that one of the lines in any line intersection test will be horizontal or vertical
<br/>
<br/>
I would have to put a considerable amount of thought into how to most efficiently represent the polygons, transform them, and how to do the intersection tests.  I guess I could work it out and post again later.<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6504 - tepples - Tue May 27, 2003 10:35 pm</h4>
    <div class="postbody"><span class="postbody">Or just use circles for intersection. A squared distance vs. squared sum of radii test is really cheap on a processor with fast multiplication such as the ARM7TDMI.
<br/>
<br/>
For testing against the background, translate the sprite's position into the world space (that's how you should be storing positions anyway), and use circle-square intersection testing (which is straightforward) for each sprite against each background tile that overlaps the sprite's bounding box.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6509 - sgeos - Wed May 28, 2003 5:06 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">Oh, and by rectangles, I mean axis-aligned rectangles, because it means that one of the lines in any line intersection test will be horizontal or vertical.</td> </tr></table><span class="postbody">
<br/>
<br/>
Could not the distance be taken, and the collision be checked relative to one of the rotated rectangles?  Relative to one of them because then that one will be axis aligned.  This would require adjusting the rotation of the other one, of course.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Or just use circles for intersection. A squared distance vs. squared sum of radii test is really cheap on a processor with fast multiplication such as the ARM7TDMI.</td> </tr></table><span class="postbody">
<br/>
<br/>
if ((x_dist * x_dist + y_dist * y_dist) &lt; (rad0 + rad1) * (rad0 + rad1))
<br/>
  /* It's a hit? */
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">For testing against the background, translate the sprite's position into the world space (that's how you should be storing positions anyway), and use circle-square intersection testing (which is straightforward)</td> </tr></table><span class="postbody">
<br/>
<br/>
Never tried a circle-square intersection test, although I imagine a circle-anything intersection test must be pretty simple.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">for each sprite against each background tile that overlaps the sprite's bounding box.</td> </tr></table><span class="postbody">
<br/>
<br/>
Do you mean bounding box before rotation, bounding box enlarged to take rotation into account, or bounding circle?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6511 - tepples - Wed May 28, 2003 5:41 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Or just use circles for intersection. A squared distance vs. squared sum of radii test is really cheap on a processor with fast multiplication such as the ARM7TDMI.</td> </tr></table><span class="postbody">
<br/>
if ((x_dist * x_dist + y_dist * y_dist) &lt; (rad0 + rad1) * (rad0 + rad1))
<br/>
  /* It's a hit? */
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
That's about right.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">For testing against the background, translate the sprite's position into the world space (that's how you should be storing positions anyway), and use circle-square intersection testing (which is straightforward)</td> </tr></table><span class="postbody">
<br/>
<br/>
Never tried a circle-square intersection test, although I imagine a circle-anything intersection test must be pretty simple.</span></td> </tr></table><span class="postbody">
<br/>
Here's how to test intersection of a circle and rectangle.  Given a circle of radius r centered at (x, y) and an axis-aligned rectangle with corners (0, 0) and (w, h):
<br/>
<br/>
If x &gt; 0
<br/>
  If x &lt; w then x = 0 else x -= w
<br/>
If y &gt; 0
<br/>
  If y &lt; h then y = 0 else y -= h
<br/>
If x^2 + y^2 &lt; r^2 then collision
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">for each sprite against each background tile that overlaps the sprite's bounding box.</td> </tr></table><span class="postbody">
<br/>
Do you mean bounding box before rotation, bounding box enlarged to take rotation into account, or bounding circle?</span></td> </tr></table><span class="postbody">
<br/>
Use the bounding box of the bounding circle for looping over the tiles, and use the bounding circle itself for the collision test.  It's not too wasteful; about pi-fourths (78.6%) of the circle's bounding box is inside the circle.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6528 - sgeos - Wed May 28, 2003 1:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Here's how to test intersection of a circle and rectangle.  Given a circle of radius r centered at (x, y) and an axis-aligned rectangle with corners (0, 0) and (w, h):
<br/>
<br/>
If x &gt; 0
<br/>
  If x &lt; w then x = 0 else x -= w
<br/>
If y &gt; 0
<br/>
  If y &lt; h then y = 0 else y -= h
<br/>
If x^2 + y^2 &lt; r^2 then collision</td> </tr></table><span class="postbody">
<br/>
<br/>
It took e a second to figure out how that works.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Use the bounding box of the bounding circle for looping over the tiles, and use the bounding circle itself for the collision test.  It's not too wasteful; about pi-fourths (78.6%) of the circle's bounding box is inside the circle.</td> </tr></table><span class="postbody">
<br/>
<br/>
I see how that works.  How would I determine the side of the tile I hit (and perhaps the angle of the collision)?  For the side of the tile I collide with, it looks to me like I'll need to figure out which quadrant the collision occured in.
<br/>
<br/>
-Bredan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6534 - Jason Wilkins - Wed May 28, 2003 3:13 pm</h4>
    <div class="postbody"><span class="postbody">I was under the impression that you wanted something that would handle oddshaped sprites under rotation without weird results.  It didn't occur to me that you might not have a clue how to do collision detection at all, otherwise I would have just suggested squared distance bounding circles just like tepples.
<br/>
<br/>
If you needed more precise collision detection, you would use a method like what I suggested after you used the basic circle method to determine if the objects are close enough to touch.<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6537 - sgeos - Wed May 28, 2003 4:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">I was under the impression that you wanted something that would handle oddshaped sprites under rotation without weird results.</td> </tr></table><span class="postbody">
<br/>
<br/>
Thats the goal.  Although oddshaped might be tall rectangles for now.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">It didn't occur to me that you might not have a clue how to do collision detection at all,</td> </tr></table><span class="postbody">
<br/>
<br/>
It's fairly easy to figure out sprites that don't rotate, but I did not how to start attacking rotating sprites.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">otherwise I would have just suggested squared distance bounding circles just like tepples.</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm glad you suggested something different.  Bounding circles will not give satisfactory results in all cases.  The further the shape is from a circle, the less satisfactory the results.  Restricted to rectangles, a square will give the best results.  Still, this is much better than nothing.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">If you needed more precise collision detection, you would use a method like what I suggested after you used the basic circle method to determine if the objects are close enough to touch.</td> </tr></table><span class="postbody">
<br/>
<br/>
That comes out to three tests?  Bounding box of bounding circle, bounding circle, and last line intersection test?  Or should the bounding circle test be replaced by the line intersection test?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6553 - Jason Wilkins - Wed May 28, 2003 8:41 pm</h4>
    <div class="postbody"><span class="postbody">I do not think I would do both a bounding box and bounding circle test.  The bounding circle test actually seems cheaper than the bounding box test, since the multiplication seems like it would be cheaper than all the branches required by bounding box test.
<br/>
<br/>
I feel the need to write a demo ^_^<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6577 - sgeos - Thu May 29, 2003 5:58 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">I feel the need to write a demo ^_^</td> </tr></table><span class="postbody">
<br/>
<br/>
Excellent.  Must see. =)
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6757 - Marcel24 - Mon Jun 02, 2003 3:59 pm</h4>
    <div class="postbody"><span class="postbody">Hi..
<br/>
This is my first Posting here ;)
<br/>
<br/>
I hope my ideas arent bad at all.. 
<br/>
<br/>
So i would do it like this...
<br/>
<br/>
1) Test where your sprite colides in the map array (positions)
<br/>
2) Take theres tiles that may colide with your sprite 
<br/>
3) There rotate those in memory
<br/>
4) pixel to pixel colision (only fore areas who are overlap,need some bounding box tests)
<br/>
<br/>
<br/>
I hope you understand my strange ideas ;)
<br/>
<br/>
Or ist my idea slow an evil ?
<br/>
<br/>
Tnx..</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
