<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Urgent 16:16 fixed point division code requires - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Urgent 16:16 fixed point division code requires</h2>
<div id="posts">
<div class="post">
    <h4>#19300 - corranga - Fri Apr 16, 2004 3:31 pm</h4>
    <div class="postbody"><span class="postbody">Ok, I desperetly need 16:16 fixed point GBA division code to see if the rest of my code works.  (My division doesn't seem to work properly!)
<br/>
<br/>
I don't care if it is in assembler or if it is just C code as long as it works (with as much of the 16:16 accuracy as possible!
<br/>
<br/>
Please help me before i pull my hair out!
<br/>
<br/>
Chris<br/>_________________<br/>If virtual reality is ever on a par with reality, I want to be Bomberman! :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19302 - jma - Fri Apr 16, 2004 3:54 pm</h4>
    <div class="postbody"><span class="postbody">If you want something that you know works, just do this:
<br/>
<br/>
// return a/b (note: 24:8 fp math)
<br/>
#define FIXDIV(a,b) ((a) &lt;&lt; 8) / (b))
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19305 - shadow_gg - Fri Apr 16, 2004 6:20 pm</h4>
    <div class="postbody"><span class="postbody">hum u wanna a 16:16 division code,
<br/>
so u should have 32:32 number for the denominator,and a 16:16 for the numerator bcs 32:32 / 16:16 = 16:16
<br/>
<br/>
maybe u should get a 8:8 division code,
<br/>
just divide a 16:16 by a 8:8 and u will have a 8:8 result 
<br/>
<br/>
so u dont' need a function to do this just write it directly in ur code
<br/>
hope it will help u
<br/>
good luck !</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19306 - Miked0801 - Fri Apr 16, 2004 6:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
s32 dividef1616(s32 f1, s32 f2)
<br/>
{
<br/>
    return Div((f1 * 64), (f2 / 64)) * 16;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Where Div is a call to the GBA BIOS divide.
<br/>
<br/>
If you don't know how to get that to work then:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
s32 dividef1616(s32 f1, s32 f2)
<br/>
{
<br/>
    return ((f1 * 64) / (f2 / 64)) * 16;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This minimizes bit loss across both terms due to shifting.  All terms are assumed to be Fixed 16:16.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19330 - corranga - Sat Apr 17, 2004 3:34 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Miked0801, that worked although the accuracy isn't high enough.
<br/>
(I'm working on wireframe 3d on the gba so accuracy is a bit of a must)
<br/>
<br/>
Chris<br/>_________________<br/>If virtual reality is ever on a par with reality, I want to be Bomberman! :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19338 - Miked0801 - Sat Apr 17, 2004 6:56 pm</h4>
    <div class="postbody"><span class="postbody">Hmm.  What kind of accuracy are you looking for?  What kind of terms are you dividing?  What kind of speed do you need?  If you need every bit, you could do 2 divides - break the numerator into high/low 16-bits and divide each individually, shift and add terms when complete (kinda like when multiplying.)  Of course, this is painfully slow.  Another way would be to create a 64-bit divide in assembly and go that way.  Still, I've never ever had need for that kind of accuracy which again begs the question of do you really need all those bits of accuracy?  Losing a few bits on a divide shouldn't cause that much error unless you keep putting the error'd term back into the divide and do it again and again - at which point you will get noticable error.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19350 - poslundc - Sat Apr 17, 2004 7:55 pm</h4>
    <div class="postbody"><span class="postbody">Mike's division algorithm is accurate within approximately +/- 0.000122.
<br/>
<br/>
Or put another way, it only creates uncertainty in the bottom four bits of your 16-bit fractional portion.
<br/>
<br/>
How much precision do you really need?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19372 - corranga - Sun Apr 18, 2004 2:26 pm</h4>
    <div class="postbody"><span class="postbody">Edit:
<br/>
It is definetly the division code that isn't working properly, 
<br/>
An example of the calculation that is giving me troubles is:
<br/>
34611200 / 1015360 = 2233965 (using windows fixed point code I wrote)
<br/>
528.125 / 15.4931640625 = 34.0876007080078125
<br/>
and
<br/>
34611200 / 1015360 = -2097536 (using Mikes code)
<br/>
528.125 / 15.4931640625 = -32.005859375 (note the negative, I presume meaning the signed bit is being changed?)
<br/>
<br/>
where the floating point answer should be 34.087614245194
<br/>
although I now presume this is an overflow problem on the range side rather than an issue with accuracy?
<br/>
<br/>
<br/>
Chris<br/>_________________<br/>If virtual reality is ever on a par with reality, I want to be Bomberman! :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19373 - corranga - Sun Apr 18, 2004 4:36 pm</h4>
    <div class="postbody"><span class="postbody">Ok, fixed...
<br/>
I just gave up a bit of accuracy for more range
<br/>
<br/>
Thanks for your help once more! :D
<br/>
Chris<br/>_________________<br/>If virtual reality is ever on a par with reality, I want to be Bomberman! :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19376 - poslundc - Sun Apr 18, 2004 5:42 pm</h4>
    <div class="postbody"><span class="postbody">Yes, it is a matter of overflow. There is always a trade-off to be made between precision and the maximum range of your variables.
<br/>
<br/>
It is a much bigger problem with division than multiplication, because you can always do long-multiplication (with the long long datatype or the MULL family of assembly instructions) in order to retain precision. Another good reason for using reciprocal look-up tables for division.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
