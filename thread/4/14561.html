<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ye Mighty Lexer Compiler ^_^ - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Ye Mighty Lexer Compiler ^_^</h2>
<div id="posts">
<div class="post">
    <h4>#145738 - keldon - Wed Nov 21, 2007 7:17 am</h4>
    <div class="postbody"><span class="postbody"><span style="font-weight: bold"><span style="color: red">---=== POST REMOVED (ORIGINAL CONTENT NO LONGER EXISTS) DUE TO CONFUSION CAUSED BY ITS DESCRIPTION ===---</span></span>
<br/>
<br/>
My <span style="font-weight: bold">library/tool</span> is called <span style="font-weight: bold">Ye Mighty Lexer Compiler</span> (currently in Java).
<br/>
The input it takes is a <a class="postlink" href="http://en.wikipedia.org/wiki/Formal_grammar" target="_blank">grammar</a> (or a set of grammars) and text to parse.
<br/>
The output it produces is <span style="font-weight: bold">the largest string</span> it can extract from the input string <span style="font-weight: bold">using the set of grammars</span>, and also which grammar it used.
<br/>
Before this tool existed, life sucked because you had to <span style="font-weight: bold">manually code a unique parser</span>.
<br/>
Now that this tool exists, life is better because you can <span style="font-weight: bold">define a grammar to <span style="text-decoration: underline">automatically</span> parse and lex</span> text by using simple grammars; it also shows you how easy the code is to create.</span><span class="gensmall"><br/><br/>Last edited by keldon on Fri Dec 14, 2007 8:23 am; edited 4 times in total</span></div>    
</div>
<div class="post">
    <h4>#145761 - Lick - Wed Nov 21, 2007 7:15 pm</h4>
    <div class="postbody"><span class="postbody">You mean auto-completion? 
<br/>
<br/>
T9 is more of a system that works with multiple characters mapped to a smaller amount of keys/buttons. It would then make sense to guess which combination of characters could form a word that most used (using a tree or whatever).
<br/>
<br/>
On a system with only one or two characters mapped to each key/button, it wouldn't make sense to implement T9. Auto-completion on the other hand is what lots of websites have already implemented using Javascript and XHRs (XHttpRequests).<br/>_________________<br/><a class="postlink" href="http://licklick.wordpress.com" target="_blank">http://licklick.wordpress.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145778 - keldon - Wed Nov 21, 2007 11:14 pm</h4>
    <div class="postbody"><span class="postbody"><span style="font-weight: bold"><span style="color: red">POST REMOVED DUE TO CONFUSIONS CAUSED BY IT, FORGET EVERYTHING BEFORE</span></span></span><span class="gensmall"><br/><br/>Last edited by keldon on Fri Dec 14, 2007 10:04 am; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#145827 - keldon - Fri Nov 23, 2007 10:44 am</h4>
    <div class="postbody"><span class="postbody">I've done it!
<br/>
<br/>
You feed it a token grammar and a string, and this son-of-a-gun will give you the next token. <span style="font-weight: bold">Warning:</span> like any declarative language this will do what you tell it to do, therefore do not give it faulty grammars (like ones that will accept nothing)!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
      ArrayList&lt;Node&gt; alphaNumericList = new ArrayList&lt;Node&gt;();
<br/>
      ArrayList&lt;Node&gt; sentenceList = new ArrayList&lt;Node&gt;();
<br/>
      ArrayList&lt;Node&gt; anotherWordList = new ArrayList&lt;Node&gt;();
<br/>
      ArrayList&lt;Node&gt; wordList = new ArrayList&lt;Node&gt;();
<br/>
      ArrayList&lt;Node&gt; whitespaceList = new ArrayList&lt;Node&gt;();
<br/>
      
<br/>
      Node whitespace;
<br/>
      Node word;
<br/>
      Node anotherWord;
<br/>
      Node sentence;
<br/>
      
<br/>
      whitespaceList.add ( TerminalFactory.createTerminalString(" "));
<br/>
      whitespaceList.add (  RepetitionFactory.createRepetition(TerminalFactory.createTerminalString(" ")) );
<br/>
      whitespace = ListFactory.createList(whitespaceList);
<br/>
      
<br/>
      alphaNumericList.add(number());
<br/>
      alphaNumericList.add(letter());
<br/>
      
<br/>
      wordList.add (letter());
<br/>
      wordList.add(RepetitionFactory.createRepetition( letter() ));
<br/>
      word = ListFactory.createList(wordList);
<br/>
<br/>
      anotherWordList.add(whitespace);
<br/>
      anotherWordList.add(word);
<br/>
      anotherWord = ListFactory.createList(anotherWordList);
<br/>
      
<br/>
      sentenceList.add (word);
<br/>
      sentenceList.add (RepetitionFactory.createRepetition(anotherWord));
<br/>
      sentenceList.add (OptionFactory.createOptional(TerminalFactory.createTerminalString(".")));
<br/>
      sentence = ListFactory.createList(sentenceList);
<br/>
      
<br/>
      
<br/>
      System.out.println ( Parser.parse("The dirty fairies are dead", sentence));
<br/>
      System.out.println ( Parser.parse("The dirty fairies are dead.", sentence));
<br/>
      System.out.println ( Parser.parse("The dirty fai.ries are dead.", sentence));</td> </tr></table><span class="postbody">
<br/>
<br/>
Output:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">26
<br/>
27
<br/>
14</td> </tr></table><span class="postbody">
<br/>
<br/>
Pretty neat, eh? I'll upload code to my server later today when I get into the office and cure my sleep deprivation with 900% of my recommended daily allowance for glucose and vitamins with a block of Barocca.
<br/>
<br/>
P.s. it is possible to code efficiently in C without garbage collection; I've just used these constructs for simplicity.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145831 - keldon - Fri Nov 23, 2007 1:30 pm</h4>
    <div class="postbody"><span class="postbody"><span style="font-weight: bold">Legal disclaimer</span>:
<br/>
<span style="font-style: italic">By downloading the said file, knowingly or not, you agree to have no rights to its code or your knowledge of the knowledge gained upon mentally processing it. You have no copying rights, understanding rights, or right to process any thoughts derived from the knowledge of the said file. You are however given the right to live and breathe under the condition you do so without violation of any stated rule in this disclaimer.</span>
<br/>
<br/>
<br/>
Code available at <a href="https://github.com/keldon85-avasopht/mighty-parser" target="_blank">https://github.com/keldon85-avasopht/mighty-parser</a>
<br/>
<br/>
As for the approach, I've never done anything like this before, I just looked at the rules for grammars and created factories for them. The parser does most of the work, but you can see from the [poorly (un)commented] code how it works.
<br/>
<br/>
<span style="font-weight: bold">Edit</span>: I've made a further update to have it select from a list of grammars, returning the grammar that gave the best match. Note that ambiguous grammars will give ambiguous results, such as one grammar accepting white space (only) and another beginning with being able to accept white space. On another note I've added in detection of faulty grammar!
<br/>
<br/>
<span style="font-weight: bold">Edit</span>: I've made the next update: now the parser will return the largest valid token from a string, which it was not doing before. Before the code could either determine whether a string completely satisfies a grammar or extract the largest string that is accepted. Now it will extract the largest valid grammar, hence is a complete tokenizer.
<br/>
<br/>
<span style="font-weight: bold"><span style="color: red">---=== THIS POST CONTAINS A SIMPLE EXPLANATION AND TEST CASE ===---</span></span>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b><a class="postlink" href="http://www.javagaming.org/forums/index.php?topic=17769.msg139525#msg139525" target="_blank">DzzD </a> wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
sry, I dont understand anything, could you explain a simple test case please ?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Okay, basically this code can automatically tokenize any string based on the <a class="postlink" href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank">[CFG] rules</a> you give it. And for free it also doubles up as an automatic <a class="postlink" href="http://en.wikipedia.org/wiki/Lexical_analysis" target="_blank">lexer</a>.
<br/>
<br/>
So as a test case, consider the following grammar (shown in the last post, and also in the code example) ...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">word = LETTER {LETTER} .
<br/>
anotherWord = whiteSpace word .
<br/>
sentence = word {anotherWord} ["."] .</td> </tr></table><span class="postbody">
<br/>
... and also the following rule (also defined in the code) ...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">whitespace = " " {" "} .</td> </tr></table><span class="postbody">
<br/>
... if you were to call Parser.parse ("This is a lovely valid sentence. This is the next sentence!", sentence), it would return you the number of characters that form a valid <span style="font-weight: bold">sentence</span>, which would be "This is a lovely sentence."
<br/>
<br/>
If you then were to call Parser.parse ("       This is not a valid sentence because sentences do not begin with whitespace.", sentence), it would return -1 to tell you that it could not return a token. If you were to pass <span style="font-weight: bold">whitespace</span> instead of <span style="font-weight: bold">sentence</span> then it would return 7, i.e. "       "!
<br/>
<br/>
My latest code update will also return a lexeme (as <span style="text-decoration: underline">com.avasopht.mightyParser.traversing.Token</span>).
<br/>
<br/>
<span style="font-weight: bold">Edit</span>: I did a little speed test with a valid sentence formed of 12 031 characters; it searched 2 140 577 nodes and took 1.469 seconds to parse. Bearing in mind that the grammar depicting sentences involves branching for each character, increasing the search space. If you have a specific word then it generates a list that does not require so many nodes, so if your grammar defines the text, "some_reserved_keyword" then it will not need to branch at each letter.
<br/>
<br/>
Now for a C++ version.</span><span class="gensmall"><br/><br/>Last edited by keldon on Fri Jul 20, 2012 12:32 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#146071 - keldon - Wed Nov 28, 2007 12:45 pm</h4>
    <div class="postbody"><span class="postbody">I've made a further advancement in the code, which I need to update some time. Basically the parser can have the saving of the stack eliminated as it is redundant in the presence of the "choice stack". This [should] give it a significant speed improvement.
<br/>
<br/>
It will also make a C++ conversion 10 times simpler, in fact there's practically nothing to it!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#146078 - Lick - Wed Nov 28, 2007 5:59 pm</h4>
    <div class="postbody"><span class="postbody">I fail to see the use of such a system, unless you're an language teacher?<br/>_________________<br/><a class="postlink" href="http://licklick.wordpress.com" target="_blank">http://licklick.wordpress.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#146085 - keldon - Wed Nov 28, 2007 7:01 pm</h4>
    <div class="postbody"><span class="postbody">Here's why I did it
<br/>
 - fun (honestly)
<br/>
 - frustration (also)
<br/>
 - tokenizing to regular expressions (if you wanted to add it in)
<br/>
 - flexible lexing and ability to change lex and tokenizing rules easily
<br/>
 - just to see how it's done (or if I could do it)
<br/>
<br/>
I could have performed lexing using regular expressions, but gained much more by creating my own.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#146467 - keldon - Tue Dec 04, 2007 5:00 pm</h4>
    <div class="postbody"><span class="postbody">Ok, I've also found a way that this code can tidily generate a parse tree! The 'choice stack' holds the key to it, what I think I'll do is dedicate my site to explaining these algorithms or something.
<br/>
<br/>
Plus it lets me do a little less work for the site, but still have a fair amount of 'kick' behind it!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147061 - elyk1212 - Thu Dec 13, 2007 10:13 pm</h4>
    <div class="postbody"><span class="postbody">I am not sure what this is for exactly, but why not consider "a recursive decent parser" if using this for sentence syntax?  They are simple to write, and easy to extend and can be directly based on EBNF grammer you specify.
<br/>
<br/>
A thought...:
<br/>
Else, if you are using it for T9 (that's for text intuition/prediction?) , 
<br/>
<br/>
you could use <span style="font-weight: bold">pattern based heuristics</span> with IDA* (or something like this) on a search tree, constructed from all words in your dictionary.  It is an A.I. approach, and I am not completely sure about how to get pattern values (usage data) based on each word. 
<br/>
<br/>
 You would have to either be given this or you could write a scrapper that searched relevant papers/books and tallied word usage statistics.  It would have to have some modern samples in there, to get all the crazy slang/abbreviations though.
<br/>
<br/>
<br/>
Anyway, without some kind of search heuristics, if your dictionary is fairly large, your users could get significant delays.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147070 - keldon - Fri Dec 14, 2007 1:00 am</h4>
    <div class="postbody"><span class="postbody">Well this allows you to write a grammar as opposed to code that reads a grammar! If you look at the more recent posts you'll see what it does.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147073 - sajiimori - Fri Dec 14, 2007 1:28 am</h4>
    <div class="postbody"><span class="postbody">Maybe you should write a post that explains it a bit more plainly, since nobody seems to understand what this thread is about.  :)
<br/>
<br/>
My program is called ________.
<br/>
The input it takes is __________, and it looks like this: _______.
<br/>
The output it produces is ________, and it looks like this: _________.
<br/>
Before this tool existed, life sucked because you had to __________.
<br/>
Now that this tool exists, life is better because you can _________.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147076 - keldon - Fri Dec 14, 2007 1:51 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Maybe you should write a post that explains it a bit more plainly, since nobody seems to understand what this thread is about.  :)
<br/>
<br/>
My program is called ________.
<br/>
The input it takes is __________, and it looks like this: _______.
<br/>
The output it produces is ________, and it looks like this: _________.
<br/>
Before this tool existed, life sucked because you had to __________.
<br/>
Now that this tool exists, life is better because you can _________.</td> </tr></table><span class="postbody">
<br/>
<br/>
Good call; I've edited the original post accordingly. On another note I have an alternative method of walking the nodes. My view on parsing is that once you create the structure there are 3 main types of node properties.
<br/>
<ul><span style="font-weight: bold">Choices</span>
<br/>
When a node contains more than one out edge it creates a choice. Choices should not contain terminals or children.
<br/>
<br/>
<span style="font-weight: bold">Children</span>
<br/>
When a node contains a child, you cannot get past it without first going through the child node! Nodes with children should not contain choices or terminal.
<br/>
<br/>
<span style="font-weight: bold">Terminal</span>
<br/>
When a node contains a character it is a terminal node. Terminal nodes should have <span style="font-weight: bold">exactly one out edge</span> and no children.</ul>
<br/>
A node that is neither a choice, parent, or terminal is an end node. Essentially the code will <span style="font-weight: bold">tokenize</span> based on a grammar, but such a task can also lex and parse. It works by traversing the structure using the following behaviour:
<br/>
<ul> - <span style="font-weight: bold">grammar is a graph</span>: every grammar is equivalent to a graph  where nodes can contain terminals or child nodes. A grammars is passed as a node!
<br/>
 - <span style="font-weight: bold">track 'parents'</span>: every time you enter a child node store the parent node in a stack like manor, popping it (to return to the node) when you reach an end node
<br/>
 - <span style="font-weight: bold">track 'choice points'</span>: every time you have a choice, store the 'cur_pos', 'parent stack' and which choice you took (in a stack)
<br/>
 - <span style="font-weight: bold">store 'cur_pos'</span>: keep track of how many letters have been accepted (<span style="font-style: italic">i.e. what character we are up to</span>)
<br/>
 - <span style="font-weight: bold">only one end ('last_char_read')</span>: There is only one valid end node, which is the node that can be reached directly from the 'grammar node' without going through any children. There should only be one. When this is reached store it as the new 'last_char_read'
<br/>
 - <span style="font-weight: bold">terminals terminate</span>: when a terminal is reached you it either matches the character at the 'cur_pos', or you have to <span style="font-style: italic">pop</span> your choice stack until you reach one where you have another choice. Store 'cur_pos', 'parent_stack' and the new choice you took. If you cannot then return the last_char_read. Also perform the same action if you have read every character.
<br/>
</ul>
<br/>
<br/>
So my current method walks the nodes one by one, but my alternative method (which was actually the first approach I thought up) involves working with a single "walker". The walker just tries to find its way around the nodes, keeping track of the parents it finds; but every time it reaches a choice point it will duplicate itself and the duplicates will follow each choice!
<br/>
<br/>
The walkers will die whenever they reach a terminal that does not satisfy their cur_pos.</span><span class="gensmall"><br/><br/>Last edited by keldon on Fri Dec 14, 2007 9:21 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#147089 - elyk1212 - Fri Dec 14, 2007 8:30 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"> POST REMOVED DUE TO COMPLICATIONS, FORGET EVERYTHING BEFORE </td> </tr></table><span class="postbody">
<br/>
<br/>
LOL, That's awesome.
<br/>
<br/>
Dude you sound like me (especially when I have too many projects). ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#147092 - keldon - Fri Dec 14, 2007 10:04 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elyk1212 wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"> POST REMOVED DUE TO COMPLICATIONS, FORGET EVERYTHING BEFORE </td> </tr></table><span class="postbody">
<br/>
<br/>
LOL, That's awesome.
<br/>
<br/>
Dude you sound like me (especially when I have too many projects). ;)</span></td> </tr></table><span class="postbody">
<br/>
That was a typo, I meant confusions ^_^</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
