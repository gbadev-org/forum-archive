<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>algorithm for straight line - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > algorithm for straight line</h2>
<div id="posts">
<div class="post">
    <h4>#6832 - Psyk - Tue Jun 03, 2003 9:30 am</h4>
    <div class="postbody"><span class="postbody">I know there is a very simple algorithm for drawing a straight line in any direction in C but i just cant remember what it is! Could someone point me in the right direction plz?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6833 - joet - Tue Jun 03, 2003 9:49 am</h4>
    <div class="postbody"><span class="postbody">Do a quick Google search for Bresenham ...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6834 - Quirky - Tue Jun 03, 2003 10:07 am</h4>
    <div class="postbody"><span class="postbody">staring monkey's demo library from the main gbadev page has an implementation of Bresenham in there too, IIRC.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6837 - Psyk - Tue Jun 03, 2003 10:09 am</h4>
    <div class="postbody"><span class="postbody">arg! I cant find anything simple enough for my puny mind! I'll try looking in some source codes, im bound to find it in there somewhere.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6839 - pbmtp - Tue Jun 03, 2003 10:29 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define ClipMinX 0
<br/>
#define ClipMaxX 240
<br/>
#define ClipMinY 0
<br/>
#define ClipMaxY 160
<br/>
<br/>
static void BresenhamLine(int x1,int y1,int x2,int y2,uchar color)
<br/>
{
<br/>
   int i;
<br/>
   int x,y;
<br/>
   int IncX,IncY;
<br/>
   int Dx,Dy;
<br/>
   int Err;
<br/>
   int inc1,inc2;
<br/>
   int offset;
<br/>
<br/>
   if(x1&lt;ClipMinX &amp;&amp; x2&lt;ClipMinX) return;
<br/>
   if(y1&lt;ClipMinY &amp;&amp; y2&lt;ClipMinY) return;
<br/>
   
<br/>
   x=x1;
<br/>
   y=y1;
<br/>
<br/>
   if(x1&lt;=x2)
<br/>
   {
<br/>
      IncX=1;
<br/>
      Dx=x2-x1;
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
      IncX=-1;
<br/>
      Dx=x1-x2;
<br/>
   }
<br/>
<br/>
   if(y1&lt;=y2)
<br/>
   {
<br/>
      IncY=1;
<br/>
      Dy=y2-y1;
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
      IncY=-1;
<br/>
      Dy=y1-y2;
<br/>
   }
<br/>
<br/>
   if(Dy&lt;Dx)
<br/>
   {
<br/>
      inc1=(Dy-Dx)&lt;&lt;1;
<br/>
      inc2=Dy&lt;&lt;1;
<br/>
      Err=inc2-Dx;
<br/>
      
<br/>
      offset=GBA_SCREEN_WIDTH*y+x;
<br/>
<br/>
      for(i=0;i&lt;Dx;i++)
<br/>
      {
<br/>
         if(x&gt;ClipMinX &amp;&amp; x&lt;ClipMaxX &amp;&amp; y&gt;ClipMinY &amp;&amp; y&lt;ClipMaxY)
<br/>
           Video[offset]=color;
<br/>
<br/>
         if(Err&gt;0)
<br/>
         {
<br/>
            y+=IncY;
<br/>
            offset+=IncY*GBA_SCREEN_WIDTH;
<br/>
            Err+=inc1;
<br/>
         }
<br/>
         else
<br/>
            Err+=inc2;
<br/>
<br/>
         x+=IncX;
<br/>
         offset+=IncX;
<br/>
      }
<br/>
   }else
<br/>
   {
<br/>
      inc1=(Dx-Dy)&lt;&lt;1;
<br/>
      inc2=Dx&lt;&lt;1;
<br/>
      Err=inc2-Dy;
<br/>
<br/>
      offset=GBA_SCREEN_WIDTH*y+x;
<br/>
      for(i=0;i&lt;Dy;i++)
<br/>
      {
<br/>
         if(x&gt;ClipMinX &amp;&amp; x&lt;ClipMaxX &amp;&amp; y&gt;ClipMinY &amp;&amp; y&lt;ClipMaxY) 
<br/>
           Video[offset]=color;
<br/>
<br/>
         if(Err&gt;0)
<br/>
         {
<br/>
            x+=IncX;
<br/>
            offset+=IncX;
<br/>
            Err+=inc1;
<br/>
         }
<br/>
         else
<br/>
            Err+=inc2;
<br/>
<br/>
         y+=IncY;
<br/>
         offset+=IncY*GBA_SCREEN_WIDTH;
<br/>
      }
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Hope it will help
<br/>
[/code]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6843 - Psyk - Tue Jun 03, 2003 12:19 pm</h4>
    <div class="postbody"><span class="postbody">that will do nicely
<br/>
<br/>
thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6917 - hnager - Wed Jun 04, 2003 3:01 pm</h4>
    <div class="postbody"><span class="postbody">Would that work in MODE 4?
<br/>
<br/>
this is what I have:
<br/>
<br/>
void BLine(int x0, int y0, int x1, int y1, unsigned char color){
<br/>
<br/>
	int dx, dy, x_inc, y_inc, error=0, index, x, y;
<br/>
<br/>
	u16* vidMem;
<br/>
	x = x0;
<br/>
	y = y0;
<br/>
<br/>
	dx = x1-x0;
<br/>
	dy = y1-y0;
<br/>
<br/>
	if (dx&gt;0){
<br/>
		x_inc = 1;
<br/>
	}else{
<br/>
		x_inc = -1;
<br/>
		dx = -dx;
<br/>
	}
<br/>
<br/>
	if (dy&gt;0){
<br/>
		y_inc = 1;
<br/>
	}else{
<br/>
		y_inc = -1;
<br/>
		dy = -dy;
<br/>
	}
<br/>
<br/>
	if(dx&gt;dy){
<br/>
<br/>
		for(index=0; index&lt;=dx; index++){
<br/>
<br/>
			vidMem = &amp;VideoBuffer[  ((y*240) + x)&gt;&gt;1 ]; 
<br/>
<br/>
			 if(x % 2) 
<br/>
				*vidMem = (*vidMem &amp; 0x00FF) | (color&lt;&lt;8); 
<br/>
			 else 
<br/>
				*vidMem = (*vidMem &amp; 0xFF00) | color;
<br/>
<br/>
			error+=dy;
<br/>
<br/>
			if(error&gt;dx){
<br/>
				error-=dx;
<br/>
				y+=y_inc;
<br/>
			}
<br/>
			x+=x_inc;
<br/>
<br/>
		}
<br/>
	} else {
<br/>
		for(index=0; index &lt;=dy; index++){
<br/>
<br/>
			vidMem = &amp;VideoBuffer[  ((y*240) + x)&gt;&gt;1 ]; 
<br/>
<br/>
			 if(x % 2) 
<br/>
				*vidMem = (*vidMem &amp; 0x00FF) | (color&lt;&lt;8); 
<br/>
			 else 
<br/>
				*vidMem = (*vidMem &amp; 0xFF00) | color;
<br/>
<br/>
			error+=dx;
<br/>
<br/>
			if(error&gt;0){
<br/>
				error -= dy;
<br/>
				x+=x_inc;
<br/>
			}
<br/>
			y+=y_inc;
<br/>
		}
<br/>
	}
<br/>
<br/>
}</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6939 - philip - Wed Jun 04, 2003 8:06 pm</h4>
    <div class="postbody"><span class="postbody">There's probably room for a little optimisation in Mode 4. When dx&gt;dy, you will sometimes get consecutive pixels on the same scanline. If the first is EVEN and the second is ODD, then these can be drawn in a single operation without wasting time reading the screen memory to retain a pixel we're about to change anyway. So:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if thispixel is EVEN
<br/>
   record Y ordinate in lastpixel.Y
<br/>
else //Pixel ODD
<br/>
   if thispixel.Y=lastpixel.Y
<br/>
   THEN
<br/>
      Write both pixels with one operation :-)
<br/>
   ELSE
<br/>
      Write both separately :-(
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This is ONLY possible when dx&gt;dy. It becomes more efficient the closer the line is to being flat, because more double pixels exist. When we have pairs of pixels like this, we write them both with just a single memory write, rather than the simplest method which would do two reads and two writes to achive the same effect. 
<br/>
<br/>
I'm assuming drawing the line from left to right here (in a pixel pair, even pixel will be encountered first), so take into account possibility of going the other way. Personally, I'd just swap the start and end points to ensure drawing in that direction. I THINK these checks are quicker than all the memory access to screen space, because you can store lastpixel.Y in a register and compare it quickly, whereas with single pixel writes, you're guaranteed to have to do nasty bitmasking and memory accessing. Or am I wrong?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
