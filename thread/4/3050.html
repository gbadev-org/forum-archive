<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ongoing problem with arctan2/sprite rendering - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Ongoing problem with arctan2/sprite rendering</h2>
<div id="posts">
<div class="post">
    <h4>#17775 - Lupin - Sun Mar 14, 2004 5:48 pm</h4>
    <div class="postbody"><span class="postbody">My knowledge about trigonometry is quite blury so i hope you may help me a little bit :)
<br/>
<br/>
I am using the swi 0xA0000 function to get the angle between 2 points. I started to write a test to see if it works for me...
<br/>
<br/>
The goal is to display a sprite whenever it is in my frustum (the frustum is defined by an angle from 0...2047 (2047 entry lut for sin and cos)).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
test = (ArcTan2(posX&gt;&gt;17,posY&gt;&gt;17)&gt;&gt;3)-ViewY;
<br/>
<br/>
if((test &lt;= 239) &amp; (test &gt;= 0)) {
<br/>
    //visible
<br/>
    sprites[4].attribute0 = A0_COLOR_256 | A0_SHAPE_SQUARE | (40);
<br/>
    sprites[4].attribute1 = A1_SIZE_8 | (test);
<br/>
    sprites[4].attribute2 = A2_PRIORITY(0) | (512+64);
<br/>
} else {
<br/>
   //invisible
<br/>
    sprites[4].attribute0 = 160;
<br/>
    sprites[4].attribute1 = 240;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
well, posX and posY is in this format:
<br/>
IIII IIII IIFF FFFF FFFF FFFF FFFF FFFF
<br/>
<br/>
I = integer
<br/>
F = fraction
<br/>
<br/>
i shift it down 17 bits because the docu said that the function will take a 16 bit value with 1 bit sign, 1 bit integer and 14 bit fraction (i shift by 17 and not by 16 because posX and posY is always positive).
<br/>
<br/>
ViewY is the rotation of my camera. I thought that after subtracting it from the angle between (0,0) and (posX, posY) i would get the X coordinate because each column of my screen represents 1 "degree" of my custom sin/cos function.
<br/>
<br/>
Well, of course it doesn't work ;(
<br/>
I have no clue how to get it work but i think i do something very simple very wrong :P
<br/>
Please tell me how to work with arctan2...</span><span class="gensmall"><br/><br/>Last edited by Lupin on Sun Mar 21, 2004 8:50 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#18005 - Cearn - Thu Mar 18, 2004 10:10 am</h4>
    <div class="postbody"><span class="postbody">I can see a couple of things that might cause problems
<br/>
<br/>
1) if posX and posY are 10.22 fixeds, the shifting it down 17 notches makes them 27.5 fixeds, and not .14 fixed that arctan wants. But this hardly matters, since ArcTan2 calculates atan(y/x), so the fixed point is divided out anyway.
<br/>
<br/>
2) what does matter is what types you use in your definition of the function ArcTan2. what I use is
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
s16 ArcTan2(s16 x, s16 y)
<br/>
{   asm("swi 0x0a");   }
<br/>
</td> </tr></table><span class="postbody">
<br/>
which seems to work fine. If you use standard ints or (or any unsigned types), get ready to be amazed. 
<br/>
<br/>
3) Uhm, that single "&amp;" in the <span style="font-weight: bold">if</span> statement makes me very nervous. 
<br/>
<br/>
4) the angle that arctan returns is between -0x4000 and +0x4000, which you don't want to write into OAM as the x coordinate. I know that's what the <span style="font-weight: bold">if</span> is for, but I thought I'd mention it anyway.
<br/>
<br/>
I have modified my swi_demo to use ArcTan2 as well. See <a class="postlink" href="http://user.chem.tue.nl/jakvijn/tonc/swi.htm" target="_blank">http://user.chem.tue.nl/jakvijn/tonc/swi.htm</a> for details.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18041 - Derek - Fri Mar 19, 2004 5:21 pm</h4>
    <div class="postbody"><span class="postbody">Just some thoughts on the angle of a line topic since I happened to be working on this over the last 2 days.
<br/>
<br/>
How fast is ArcTan2 on the GBA? The following function uses a atan lookup table, which is portable, but Im unsure how the GBA code does it. Uses one divide. I've included the tablegen code for reference. Obviously you would have to convert the table to a C/C++ array. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define ABS(A) ((A)&lt;(0)?-(A):(A))
<br/>
#define f2i(A) ((A)&gt;&gt;8)
<br/>
#define i2f(A) ((A)&lt;&lt;8)
<br/>
#define fixdiv(A,B) (i2f(A)/(B))
<br/>
<br/>
#define DEG_1   i2f(1)
<br/>
#define DEG_45  i2f(32)
<br/>
#define DEG_90  i2f(64)
<br/>
#define DEG_180 i2f(128)
<br/>
#define DEG_270 i2f(192)
<br/>
#define DEG_360 i2f(256)
<br/>
<br/>
/*
<br/>
** Name: fixangle
<br/>
** Desc: Returns the angle of a line. Angles are defined as
<br/>
**       (u16)(0...65536) = 0..360 degrees. Which means they fit into u16's
<br/>
**       and wrap nicely without using AND's. Plus you have ample fractional
<br/>
**       bits for angular velocity. X &amp; Y position uses 24:8 fixed point maths.
<br/>
*/
<br/>
u16 fixangle(int x, int y)
<br/>
{
<br/>
  static int table[32768];
<br/>
  
<br/>
  if (!table[100])
<br/>
  {
<br/>
    int i;
<br/>
<br/>
    for (i = 32768; i--;)
<br/>
    {
<br/>
      table[i] = atan(i * M_PI / 180.0) * 256.0 * 8192.0 / 360.0;
<br/>
    }
<br/>
  }
<br/>
  if (y || x)
<br/>
  {
<br/>
    int yabs = ABS(y), xabs = ABS(x);
<br/>
    int degs = xabs &lt;= yabs ? table[fixdiv(xabs, yabs)] : DEG_90 - table[fixdiv(yabs, xabs)];
<br/>
    return x &lt; 0 ? y &lt; 0 ? degs - DEG_180 : -degs : y &lt; 0 ? DEG_180 - degs : degs;
<br/>
  }
<br/>
  else
<br/>
  {
<br/>
    return 0;
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
On the speed issue. The best "point in frustum" check is via dot products.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  int cx = 200; // Camera X
<br/>
  int cy = 200; // Camera Y
<br/>
  int angle = 0; // Camera view angle. ie Turn.
<br/>
<br/>
  // These should be lookup tables. Demo code only :-)
<br/>
  int lx = cos(DegToRad(angle - 25)) * 256; // Left plane X
<br/>
  int ly = sin(DegToRad(angle - 25)) * 256; // Left plane Y
<br/>
  int rx = cos(DegToRad(angle + 25)) * 256; // Right plane X
<br/>
  int ry = sin(DegToRad(angle + 25)) * 256; // Right plane Y
<br/>
<br/>
  // Convert world test point to camera relative position.
<br/>
  X -= cx;
<br/>
  Y -= cy;
<br/>
<br/>
  // A couple of dot products detects a points visiblity.
<br/>
  int isvisible = (ly * X - lx * Y) &lt; 0 &amp;&amp; (rx * Y - ry * X) &lt; 0;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Worst case = 4 lookups and 4 multiplies.
<br/>
Best case = 2 lookups and 2 multiplies. 
<br/>
(if lookups are merged into the test)
<br/>
<br/>
Would be great for a large number of point tests, and if the FOV is 90 degrees, then the equation breaks down to 4 additions/subtractions.
<br/>
<br/>
Variable FOV is achieved via multipling the matrix using 3 multiplies per loop.
<br/>
<br/>
Hope that helps. I actually found it tuff to find a fast working arctan2 function.
<br/>
<br/>
Derek</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18048 - Miked0801 - Fri Mar 19, 2004 7:20 pm</h4>
    <div class="postbody"><span class="postbody">Assume it's not too fast.  :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18145 - Lupin - Sun Mar 21, 2004 8:39 pm</h4>
    <div class="postbody"><span class="postbody">Ok, i tried a lot of different arctan functions including the bios one of course but for now it seems like my own atan2 function works best.
<br/>
<br/>
How it should work: Every column of my screen represents 1 degre in my sin/cos LUT (0...2047) and i cast my rays for my voxel renderer using these columns (thus giving me 1 slice of terrain for each column). Now i want to render sprites and i thought i would just a) Get the angle from my current position to the sprite b) check if the sprite lies within my cameras frustum and then just draw it
<br/>
<br/>
How it works now: it displays the sprite now but when i move my camera left or right it moves way too fast and it doesn't look like the sprite is stuck to a specific point of the terrain (since the sprite is a tree that's really bad :)).
<br/>
<br/>
Now please take a look at this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//The sprite should be in the middle of the map
<br/>
//posX is XXXX XXXX XXFF FFFF FFFF FFFF FFFF FFFF
<br/>
//where X is integer and F is decimal part
<br/>
//The shift is just because for preventing overflow
<br/>
a = ((s32)(posX&gt;&gt;12))-0x7F000;
<br/>
b = ((s32)(posY&gt;&gt;12))-0x7F000;
<br/>
<br/>
//ArcTan2 return values:
<br/>
//If the sprite is right above the position it should be 2048, if you move the sprite clockwise around the position it goes from 2048 to 0
<br/>
//I don't really know why i subtract 1024 here but it seems to work better :)
<br/>
test=((-ArcTan2(b,a) - 1024) &amp; 0x7FF) - ViewY;
<br/>
a &gt;&gt;= 10; //shift down because ^2 would overflow the value
<br/>
b &gt;&gt;= 10;
<br/>
//This is like projection calculation, don't pay attention to this because it works :)
<br/>
//persp is a divide LUT with 12 bit precission
<br/>
//CamHeight is just for fake up/down "rotation"
<br/>
//the (s32) is redundant because 128-384 is signed
<br/>
d=CamHeight - ((s32)((128-384) * persp[iSqrt(a*a+b*b)])&gt;&gt;12);
<br/>
<br/>
//Test if the sprite is outside of the screen (but don't clamp half visible sprites, that's why i test with -64)
<br/>
if((test &lt;= 239) &amp;&amp; (test &gt;= -64)) {
<br/>
    sprites[4].attribute0 = A0_COLOR_256 | A0_SHAPE_TALL | (d&amp;255);
<br/>
    sprites[4].attribute1 = A1_SIZE_64 | (test&amp;511);
<br/>
    sprites[4].attribute2 = A2_PRIORITY(1) | (512+100);
<br/>
} else {
<br/>
    sprites[4].attribute0 = 160;
<br/>
    sprites[4].attribute1 = 240;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
To test the result by yourself just run... <a href="http://home.arcor.de/lupin003/test.bin" target="_blank">http://home.arcor.de/lupin003/test.bin</a> ... in emulator and move around a bit and see what happens. You should see the sprite if you move the camera angle down a bit and just rotate around.
<br/>
<br/>
You can find the ArcTan2 code here: <a href="http://home.arcor.de/lupin003/arctan2.txt" target="_blank">http://home.arcor.de/lupin003/arctan2.txt</a>
<br/>
<br/>
any help would be greatly appreciated!<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18183 - Derek - Mon Mar 22, 2004 2:15 pm</h4>
    <div class="postbody"><span class="postbody">Hi Lupin,
<br/>
<br/>
Very nice demo. But, is that a arctan function? Looks like a slope of line function to me, but I could be wrong.
<br/>
<br/>
Problem is, If you had 100 trees, are you saying you are planning on 100 atans &amp; 100 isqrts just to find the visible ones?!
<br/>
<br/>
Couldn't you use your raycasting to find the visible trees &amp; objects + z-order? ie: a second terrain map with entity id's. Check the entity map to see if a tree should be rendered at the current ray position.
<br/>
<br/>
Lets say your ray is rx &amp; ry and your screen pos is sx &amp; sy.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if (entity_map[f2i(ry)][f2i(rx)] == ENTITY_TREE)
<br/>
{
<br/>
  // position tree sprite at sx, sy
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Im guessing you also have a depth that could be used to scale the tree as well.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18187 - Lupin - Mon Mar 22, 2004 2:57 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, i already thought about that Derek, but that would mean i would have to check for entities in every step of my ray and this approx like 120*256 times and it's also possible that my rays won't hit the entitie and don't grab the information of it (because the rays are spreading in distance). I would have to use a low precission entity map to avoid missing some of the sprites but that would force me to do extra calculations.... i think i won't come away with less than 4 additional opcodes per step of my ray (and you also have to take the branch into account when the sprite is invisible)...
<br/>
<br/>
Of course i am going to add scaling to the sprites, but i didn't yet bother with it (though i know how to do it :))<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18192 - Derek - Mon Mar 22, 2004 4:03 pm</h4>
    <div class="postbody"><span class="postbody">Yea, I though those might be problems after I posted, but you can still use the idea in a secondary ray casting algorithm for entitiy management.
<br/>
<br/>
1) For yeti3d (and previous terrain engines I've written), I shoot rays out to collect a visible cells list. I also tag/mark each cell with the current frame count. 
<br/>
<br/>
2) I then iterate the entities, grab the cell pointer the entity is in and compare the current frame count with the one stored in the cell to see if the entity is visible. 
<br/>
<br/>
3) If the entity is in a visible cell, I then rotate the entity and add it to the cell entity link list based on Z. Its just a insertion sort.
<br/>
<br/>
4) I can then iterate the cell VIS (which is just an array of XY's) and iterate the link list in each cell to render the entities in the correct order. The view space XYZ coords are stored in each entity from step (3) so its just a simple projection.
<br/>
<br/>
This system doesn't bog down and should work for both mode 7 and voxel engines.
<br/>
<br/>
*****
<br/>
<br/>
But, on second thought. It would probably be easier to use the 2 frustum vectors and use 2 2D dotproducts to get a entities visiblity before rotation/projection. But, then with a large number of visible entities you will have a larger sorting task. 
<br/>
<br/>
Should be fine for this task.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18279 - Cearn - Tue Mar 23, 2004 3:18 pm</h4>
    <div class="postbody"><span class="postbody">[quote=Derek]Very nice demo. But, is that a arctan function? Looks like a slope of line function to me, but I could be wrong. [/quote]
<br/>
I was wondering about this too ... is there a LUT access in here somewhere that we're not seeing here too?
<br/>
<br/>
Anyway, about the demo itself. I've been playing with it for a while and it almost seems as if the sprite's rotation is around a point somewhere in the distance. I've traced the way that the tree moves (see <a class="postlink" href="http://user.chem.tue.nl/jakvijn/voxspr1.png" target="_blank">voxspr1.png</a> and <a class="postlink" href="http://user.chem.tue.nl/jakvijn/voxspr2.png" target="_blank">voxspr2.png</a>). The tree does follow the terrain, but, like I said, seems to be moving in a circle around a point in far view, but it's kinda hard to tell what's going on exactly. Maybe debugging would be easier if with a flat map (preferably with grid-lines) and a big red dot where the tree is supposed to be. 
<br/>
<br/>
Also, erm, there are three coordinates that you have to take into account: the world-system, the camera system (both 3D) and the GBA screen coordinates (2d, seems cylindrical coords, what with the angles and everything). In which system are posX and posY? They should be in the camera system, but I can't tell from the provided code. Also, I'm not too sure about why you need the length of (a,b); shouldn't this be a dot-product with the view-direction or something?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18283 - Lupin - Tue Mar 23, 2004 4:58 pm</h4>
    <div class="postbody"><span class="postbody">I set up a simple test for my atan2 function. Please don't kill me for using VB for a simple test app, but it proves that my atan2 function works (at least it should work because the code i used in this sample is a direct port from my asm code).
<br/>
<br/>
I tried to work out the math behind it and it seemed to work with my test app, but as i tried to port it to gba it didn't want to work :(
<br/>
<br/>
<a href="http://home.arcor.de/lupin003/atan2test.zip" target="_blank">http://home.arcor.de/lupin003/atan2test.zip</a>
<br/>
<br/>
I can send you the full source via mail if you want to help me (i don't want to publish it public).<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18292 - Derek - Tue Mar 23, 2004 6:38 pm</h4>
    <div class="postbody"><span class="postbody">Interesting. The function does seem to return an approximate arctan2. The angle returned seems to pan arround the true angle by about 4 degrees. I'll have to check that. Cool. So, I converted the code to C.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
/*
<br/>
** Name: lupin_arctan2
<br/>
** Desc: Returns an approximate arctan2 angle. 
<br/>
**       Angles are 0..2048 = 0..360 degrees
<br/>
**       AND the result by 2047 to clip.
<br/>
*/
<br/>
int lupin_arctan2(int y, int x)
<br/>
{
<br/>
  int a = ABS(x);
<br/>
  y = y &lt; 0 ?
<br/>
    1792 - (y + a) / ((a - y) &gt;&gt; 8) :
<br/>
    1280 - (y - a) / ((y + a) &gt;&gt; 8) ;
<br/>
  return x &lt; 0 ? -y : y;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I then wrote a quick plugin for my fixangle() function used in Yeti3D.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u16 fixangle(int x, int y)
<br/>
{
<br/>
  return lupin_arctan2(-y &lt;&lt; 8, -x &lt;&lt; 8) &lt;&lt; 5;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Works a treat! Mmm, kinda. Im using this for a 3rd person camera view. The function works perfect for a 2D rotation camera, but has wobble/shuttering problems with a 3D camera. ie: When I get both the turn and pitch angle of the view vector, the angles returned cause the camera to "kick" since the wobble is added in 3D. In 2D it looks like a smooth "sin wave"-ish offset.
<br/>
<br/>
**EDIT** Actually, the shuttering might be an unrelated bug. Maybe
<br/>
<br/>
But, yea. cool. Learn something everyday. This would be valid for a 2D 3rd person view like a mode 7 car game. But, the arctan LUT version isn't that much slower, produces nicer camera movement and is only called once to setup the camera matrix.
<br/>
<br/>
I'd still use the dotproduct method of determining visible sprites. I'll see if I can code something generic tommorrow. The code should be able to rip though hundreds of entities without a single divide or function call.<br/>_________________<br/>Yeti3D Portable 3D Engine</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18297 - Derek - Tue Mar 23, 2004 7:09 pm</h4>
    <div class="postbody"><span class="postbody">How about this. Shift up by 8 bits before the divide. Looks a little smoother but it could just be the late hour.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int lupin_arctan2(int y, int x)
<br/>
{
<br/>
  int a = ABS(x);
<br/>
  y = y &lt; 0 ?
<br/>
    1792 - ((y + a) &lt;&lt; 8) / (a - y) :
<br/>
    1280 - ((y - a) &lt;&lt; 8) / (y + a) ;
<br/>
  return x &lt; 0 ? -y : y;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
So the final code becomes:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int lupin_arctan2(int y, int x)
<br/>
{
<br/>
  int a = ABS(x);
<br/>
  y = y &lt; 0 ? 1792 - fixdiv(y + a, a - y) : 1280 - fixdiv(y - a, y + a);
<br/>
  return x &lt; 0 ? -y : y;
<br/>
}
<br/>
<br/>
u16 fixangle(int x, int y)
<br/>
{
<br/>
  return lupin_arctan2(-y, -x) &lt;&lt; 5;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
crazy stuff, can a arctan2 be this simple !<br/>_________________<br/>Yeti3D Portable 3D Engine</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18305 - Lupin - Tue Mar 23, 2004 8:30 pm</h4>
    <div class="postbody"><span class="postbody">well, but you got to be aware of evil overflow errors if your input values are fixed point :)
<br/>
<br/>
For me even this is not giving better results:
<br/>
    y = 1792 - ((((y + a)&lt;&lt;16) / ((a - y)))&gt;&gt;8);<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18655 - Lupin - Wed Mar 31, 2004 12:38 am</h4>
    <div class="postbody"><span class="postbody">I started to create a little game structure (an array with enemies) and i tried to tidy up my code :)
<br/>
<br/>
Well, here is what i got and it's (of course) still not working as it should:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
nRotations = 0;
<br/>
nSprites = 4;
<br/>
for(i=0;i&lt;32;i++) {
<br/>
<br/>
  //positions are all 9.23 bit fixed point (that's why i shift down here)
<br/>
  a = (s32)(posY&gt;&gt;16)-(s32)(Enemies[i].y&gt;&gt;16);
<br/>
  b = (s32)(posX&gt;&gt;16)-(s32)(Enemies[i].x&gt;&gt;16);      
<br/>
  //AcrTan3 = bios atan2
<br/>
  test = (((ArcTan3((s16)a,(s16)b)&gt;&gt;5)-1024)  - ViewY) &amp; 0x7FF;
<br/>
  //Shift down to decimal bits (9 bits) because of ^2
<br/>
  a &gt;&gt;= 7; b &gt;&gt;= 7;
<br/>
  c = (iSqrt(a*a+b*b));
<br/>
      
<br/>
  //"far-" and "near-cliping"
<br/>
  if((c &lt;= 256) &amp;&amp; (c &gt;= 32)) {
<br/>
    //Perspective calculation (that's not mathematical correct at all, but looks ok)
<br/>
    d= ((s32)((384-0x200) * persp[128+c&gt;&gt;1])&gt;&gt;12)-16;
<br/>
    //Sprites are 32x32, get the center by x=x-16
<br/>
    test = test - 16;
<br/>
<br/>
    //If the sprite is still on screenY
<br/>
    if(d &lt; (160+16)) {
<br/>
      //if the sprite is still on screenX (how to check for X&lt;0 here? Because x&lt;0 would result in test being something like 2047 (2047=-1, 2046=-2, 2045=-3... bla) this happens because of the AND i am using above
<br/>
      if((test &lt;= 239)) {
<br/>
        sprites[nSprites].attribute0 = A0_COLOR_256 | A0_SHAPE_SQUARE | A0_SIZE_DOUBLE | A0_ROTATION_FLAG | (d&amp;255);
<br/>
        sprites[nSprites].attribute1 = A1_SIZE_32 | A1_ROTDATAINDEX(nRotations) | (test&amp;511);
<br/>
        sprites[nSprites].attribute2 = A2_PRIORITY(1) | (512+INTERCEPTOR_START);
<br/>
        //perspective scaling
<br/>
        rotData[nRotations].hdx = 96+c;
<br/>
        rotData[nRotations].hdy = 0;
<br/>
        rotData[nRotations].vdx = 0;
<br/>
        rotData[nRotations].vdy = 96+c;
<br/>
        nSprites++;                      
<br/>
        nRotations++; 
<br/>
      //this is my attempt of checking for negative x values (but it really sucks :))
<br/>
      } else if(((test-2048) &gt;= (-48)) &amp;&amp; (test &gt; 1808)) {
<br/>
          
<br/>
        sprites[nSprites].attribute0 = A0_COLOR_256 | A0_SHAPE_SQUARE | A0_SIZE_DOUBLE | A0_ROTATION_FLAG | (d&amp;255);
<br/>
        sprites[nSprites].attribute1 = A1_SIZE_32 | A1_ROTDATAINDEX(nRotations) | ((test-2048)&amp;511);
<br/>
        sprites[nSprites].attribute2 = A2_PRIORITY(1) | (512+INTERCEPTOR_START);
<br/>
        rotData[nRotations].hdx = 96+c;
<br/>
        rotData[nRotations].hdy = 0;
<br/>
        rotData[nRotations].vdx = 0;
<br/>
        rotData[nRotations].vdy = 96+c;
<br/>
        nSprites++;                      
<br/>
        nRotations++;         
<br/>
            
<br/>
     }    
<br/>
    }
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The result can be viewed here: <a href="http://spacecruiser.sourceforge.net/voxel.gba" target="_blank">http://spacecruiser.sourceforge.net/voxel.gba</a><br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18675 - Cearn - Wed Mar 31, 2004 3:36 pm</h4>
    <div class="postbody"><span class="postbody">It seems that when you rotate, near object move in the right direction, but further away off there's trouble. There's a freaky sign inversion going on somehwere, but I'm not eactly sure what it is right now. I'm guessing it's something to do with the line
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">test = (((ArcTan3((s16)a,(s16)b)&gt;&gt;5)-1024)  - ViewY) &amp; 0x7FF;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Here's what I think the intermediate ranges are:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">alpha = atan(a,b)
<br/>
<br/>
alpha:  &lt;-4000h, +4000h&gt;   // represents open range &lt;-pi/2, +pi/2&gt;
<br/>
<br/>
2s comp:  &lt;c000h, 4000h&gt;    // &lt;-4000h, +4000h&gt;
<br/>
&gt;&gt;5:      &lt;fe00h, 0200h&gt;    // &lt;-0200h, +0200h&gt; are you sure it shouldn't be &gt;&gt;4 ?
<br/>
-0x0400:  &lt;fa00h, fe00h&gt;    // &lt;-0600h, -0200h&gt; both are negative!
<br/>
viewY=0:  &lt;fa00h, fe00h&gt;
<br/>
&amp;0x07ff:  &lt;0600h, 0200h&gt;    // &lt;+0600h, +0200h&gt;, signes are inverted!
<br/>
</td> </tr></table><span class="postbody">
<br/>
Unless I made a mistake here, the AND at the end inverts the signs which is exactly what the end result looks like. But, since close-by everything seems to work OK, there's probably something else as well. Anyway, instead of shifting down the result of ArcTan3, you could also shift viewY up, do all the difference-calculations and the &lt;i&gt;shift&lt;/i&gt; test down instead of ANDing it. If you use signed integers throughout, this should extend the sign bit as well, so you can test negative values like you wanted to in the first place.
<br/>
<br/>
Two other things, by the way: the arctan of y/x (which is what the BIOS ArcTan2 does) gives the counter-clockwise angle between the vector (x,y) and the x-axis. I have a feeling that your viewY angle is the clock-wise angle between the heading and the y-axis. This may be part of the problem as well. 
<br/>
The other thing concerns the line 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  d= ((s32)((384-0x200) * persp[128+c&gt;&gt;1])&gt;&gt;12)-16; 
<br/>
</td> </tr></table><span class="postbody">
<br/>
You &lt;i&gt;do&lt;/i&gt; know that in C addition takes precedence over shifting, right? Are you sure (128+c)&gt;&gt;1 is what you want?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
