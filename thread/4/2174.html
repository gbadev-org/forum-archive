<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>SWI 6 disabling an interrupt ? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > SWI 6 disabling an interrupt ?</h2>
<div id="posts">
<div class="post">
    <h4>#11296 - mathieu - Wed Oct 01, 2003 6:31 pm</h4>
    <div class="postbody"><span class="postbody">Hello all !
<br/>
<br/>
I am coding a little sound system, which uses DMA1 and 2 (stereo sound), and timers 0 and 1. The synchronization of the system is made by an interrupt function hooked to timer1, thus it is not necessary to call something every vblank - once initialized, the system works by itself.
<br/>
<br/>
Everything was fine until I tried to call somewhere in my main code, while the soundsystem is running, the following thumb function :
<br/>
<br/>
u32 div(u32 num, u32 den) {
<br/>
        u32 result;
<br/>
        __asm ("mov r0, %[num]
<br/>
                mov r1, %[den]
<br/>
                swi #6
<br/>
                mov %[result], r3
<br/>
                " : [result] "=r" (result) : [num] "r" (num), [den] "r" (den) : 
<br/>
"r0", "r1", "r2", "r3");
<br/>
        return result;
<br/>
}
<br/>
<br/>
And as soon as I call that, the sound output stop working and makes "clicks", just as if the interrupts were inhibited.
<br/>
<br/>
Are there things one should care about before calling a SWI instruction ?
<br/>
<br/>
Any clue would be greatly appreciated :).
<br/>
<br/>
Best regards,
<br/>
<br/>
mathieu</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11298 - tepples - Wed Oct 01, 2003 7:25 pm</h4>
    <div class="postbody"><span class="postbody">A few problems I can see:<ul><li>swi 6 is division. Division by zero is undefined.</li><li>swi 6 is <span style="font-style: italic">signed</span> division, and your function seems to take unsigned arguments.</li><li>It'd probably be better to write the divide function in assembly language rather than in C with inline assembly.</li></ul>
<br/>
<br/>
Here's an excerpt from my math.s that addresses all three of these. It was designed for coordinate projection, so it does something useful with division by zero rather than crashing; namely, it returns INT_MAX.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ int div(int num, int den)
<br/>
@ Divide two signed integers.
<br/>
<br/>
.THUMB
<br/>
.THUMB_FUNC
<br/>
.ALIGN
<br/>
.GLOBL  div
<br/>
<br/>
div:
<br/>
  cmp r1, #0
<br/>
  beq 0f
<br/>
  swi 6
<br/>
  bx lr
<br/>
0:
<br/>
  ldr r0, =0x7fffffff
<br/>
  bx lr
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11300 - mathieu - Wed Oct 01, 2003 7:45 pm</h4>
    <div class="postbody"><span class="postbody">So, you're right for unsigned arguments - I forgot about that and it can be quite a problem.
<br/>
<br/>
However, I tested the case of the division by 0, which should be the only case of swi 6 going in an infinite loop.
<br/>
<br/>
I set in my call the "den"(for denominator) value to 1. And it still does the same thing --&gt; the GBA suddenly makes "clicks" instead of sound.
<br/>
<br/>
Thus my assumption of SWI 6 doing something with interrupts...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11303 - mathieu - Wed Oct 01, 2003 11:51 pm</h4>
    <div class="postbody"><span class="postbody">Well, I know now what actually happened.
<br/>
<br/>
I was building my files using the gcc 3.2 -mthumb-interwork flag, thinking (with the "mthumb" written) that it was generating Thumb code.
<br/>
<br/>
Well, as a matter of fact, it was generating arm code.
<br/>
<br/>
And "swi #6" in arm code hangs, logically.
<br/>
<br/>
I think it is strange to use a "-mthumb -mthumb-interwork" double-flag to create thumb code. I'd rather see something like "-mthumb-interwork" and "-marm-interwork" to specify whether I want an Thumb or ARM binary code.
<br/>
<br/>
But well, it doesn't work this way...
<br/>
<br/>
Best regards,
<br/>
<br/>
Mathieu</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11306 - poslundc - Thu Oct 02, 2003 12:33 am</h4>
    <div class="postbody"><span class="postbody">Sort of shooting off on a tangent here... I haven't really delved that much into ASM yet, but it's only a matter of time before I'll have to in order to optimize the crap I'm doing. And while I'm not shy about assembly-level coding, knowing the correct keywords to use, etc. when faced with all of the different configurations and compilers out there as well as coding for two different processors is enough to make me tug at my collar with some apprehension.
<br/>
<br/>
So on that note... if I call gcc on an assembler file, what determines if it generates ARM or Thumb code? Is it just placing a ".arm" statement at the beginning of the file? Likewise, is ".iwram" all it takes to load it into IWRAM?
<br/>
<br/>
I understood the -mthumb-interwork flag to tell the compiler that you want your code to be callable from thumb code, but does it therefore also automatically assume that you must be writing ARM code if you want that?
<br/>
<br/>
Thanks,
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11310 - DekuTree64 - Thu Oct 02, 2003 3:37 am</h4>
    <div class="postbody"><span class="postbody">The default for C files is -marm. You have to specifically say -mthumb if you want to generate THUMB code, and then -mthumb-interwork is a whole other option completely, which is poorly named. It would be nicer to just say -interwork, but I guess it doesn't really matter now that you know the difference. 
<br/>
And yes, just use .arm and .thumb to switch instruction sets in ASM files. To put code in IWRAM though, you need to use 
<br/>
.section .iwram, "ax", %progbits
<br/>
and to switch back to normal ROM code, just put 
<br/>
.text
<br/>
I'm not really sure why you don't have to do the whole .section deal with .text, but I got an error when I did, so whatever works I guess.
<br/>
Don't forget to put an .align 4 before actually writing ARM code though.
<br/>
ALso, pretty much none of the flags do anything to an assembler file. For example, interworking is just in the way you call functions, so if you want to support it, be sure to use 
<br/>
ldr rTemp, =FuncName
<br/>
mov lr, pc @or mov r14, r15. r15 points 2 instructions ahead, so this will return to the instruction after the bx
<br/>
bx rTemp
<br/>
instead of just bl FuncName. But if you're going to the trouble to write in ASM, you can keep track of what language your functions are in and always bx to the ones in the other language, and bl to the ones that use the same language, because it's much faster and easier.
<br/>
And always return with bx lr, not mov pc, lr. They're the same speed anyway.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11334 - torne - Thu Oct 02, 2003 8:31 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">To put code in IWRAM though, you need to use 
<br/>
.section .iwram, "ax", %progbits
<br/>
and to switch back to normal ROM code, just put 
<br/>
.text
<br/>
I'm not really sure why you don't have to do the whole .section deal with .text, but I got an error when I did, so whatever works I guess.</td> </tr></table><span class="postbody">
<br/>
The reason you don't have to do this is because .text is a shorthand for .section text, "ax", %progbits. The section's name is text, not .text, if you refer to it in a .section directive (the dot prefix is to make it into an assembler directive, not part of the name).
<br/>
<br/>
The bits about interworking in asm are accurate; read the ARM/Thumb Procedure Call Standard (on ARM's website) and/or my various posts explaining this before for more information on how assembly function calls should work. It's unfortunate that the GBA's processor, the ARM7, implements the ARMv4 instruction set, as the ARMv5 set has both a blx instruction (branch with link and exchange, does the same as bx but sets lr for you too), and sets cpu modes on a PC load or pop (avoids having to pop lr into a temp register and bx to it; can just pop lr directly into pc). =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11365 - funkeejeffou - Fri Oct 03, 2003 8:39 am</h4>
    <div class="postbody"><span class="postbody">There are known problems when using interrupts and bios functiuns:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">In some cases the BIOS may allow interrupts to be executed from inside of the SWI procedure. If so, and if the interrupt handler calls further SWIs, then care should be taken that the Supervisor Stack does not overflow.</td> </tr></table><span class="postbody"> <span style="font-style: italic">from the GBATEK doc</span>.
<br/>
<br/>
The reason is that an interrupt might occur while the code is running a bios call, and a interrupt calls the bios. Me too had problems using both of them so you can try this :
<br/>
Before any bios calls disable the interrupts and enable them back after ou are out. That should fix it (I hope you do not have too much divisions though...).
<br/>
You can get ASM division code from <a href="http://www.devrs.com" target="_blank">www.devrs.com</a> wich runs as fast as the one from the BIOS, and therefore you will call this code. Note that this code will certainly run slowerly than the bios one if the result from your division is supposed to be very high(26684321/31). Otherwise this code will beat the BIOS one (as for 655/69).
<br/>
Finally, I've done some code under gcc and sometime, even if you think your code is thumb or arm, better be sure. So try replacing swi 0x6 by swi 0x60000(ARM).
<br/>
<br/>
Hope this helps</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11369 - torne - Fri Oct 03, 2003 4:23 pm</h4>
    <div class="postbody"><span class="postbody">Alternatively, just point the supervisor mode stack pointer to somewhere with more space, if you have memory to spare. This will greatly decrease the chance that you run out.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
