<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Double Buffering - Determining what surface to draw on - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Double Buffering - Determining what surface to draw on</h2>
<div id="posts">
<div class="post">
    <h4>#10771 - Ruiner - Mon Sep 15, 2003 6:48 am</h4>
    <div class="postbody"><span class="postbody">I have a few title screens at the beginning of my game giving credits where due. On the first flip it works and it doesn't on the second.
<br/>
<br/>
I'm guessing the reason this doesn't work is because its not actually switching the backbuffer pointer to whatever surface is actually in back. Can anyone verify this for me? Flip writes the backbuffer to the front no matter what REG_DISPCNT equals so I assumed I could just blast data to the back every time. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void DMA3Copy(u16* _source, u16* _dest, u32 _wordCount, u32 _mode)
<br/>
{
<br/>
   REG_DM3SAD = (u32)_source;
<br/>
   REG_DM3DAD = (u32)_dest;
<br/>
   REG_DM3CNT = _wordCount | _mode;
<br/>
}
<br/>
<br/>
void Flip()
<br/>
{
<br/>
   if (REG_DISPCNT &amp; BACKBUFFER)
<br/>
   {
<br/>
      REG_DISPCNT &amp;= ~BACKBUFFER;
<br/>
      VideoBuffer = BackBuffer;
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
      REG_DISPCNT |= BACKBUFFER;
<br/>
      VideoBuffer = BackBuffer;
<br/>
   }
<br/>
} 
<br/>
<br/>
void DisplaySplash(const u16* _palette, const u16* _data)
<br/>
{
<br/>
    DMA3Copy(const_cast &lt;u16*&gt; (_palette), BGPaletteMem, 256, DMA_16NOW);
<br/>
    DMA3Copy(const_cast &lt;u16*&gt; (_data), BackBuffer, 19200, DMA_16NOW);
<br/>
   WaitForVblank();
<br/>
   Flip();
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
      key_refresh();
<br/>
      for(u16 i = 0; i &lt; 10; i++)
<br/>
         if(release[i])
<br/>
            return;
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Also Im not entirely sure whats going on there. Should VideoBuffer = BackBuffer possibly be DMA'd or is that just swapping pointer addresses?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10772 - DekuTree64 - Mon Sep 15, 2003 7:02 am</h4>
    <div class="postbody"><span class="postbody">You should set VideoBuffer to 0x6000000 when BACKBUFFER is set, and 0x600A000 when it's unset. That way, you're drawing to the buffer that's not curren't being shown. You shouldn't have to copy anything when using hardware double-buffering, that's why it's so good to have.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10775 - Ruiner - Mon Sep 15, 2003 7:14 am</h4>
    <div class="postbody"><span class="postbody">So something to the effect of:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void Flip() 
<br/>
{ 
<br/>
   if (REG_DISPCNT &amp; BACKBUFFER) 
<br/>
   { 
<br/>
      REG_DISPCNT &amp;= ~BACKBUFFER; 
<br/>
      VideoBuffer = BackBuffer;
<br/>
      BackBuffer = (u16*)0x600A000; 
<br/>
   } 
<br/>
   else 
<br/>
   { 
<br/>
      REG_DISPCNT |= BACKBUFFER; 
<br/>
      VideoBuffer = BackBuffer; 
<br/>
      BackBuffer = (u16*)0x6000000;
<br/>
   } 
<br/>
} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10790 - Quirky - Mon Sep 15, 2003 7:42 pm</h4>
    <div class="postbody"><span class="postbody">I have this code and I always draw to the array "theBackBuffer". swapBank gets called at the end of every frame.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define VideoBuffer    (( volatile u16*)0x6000000)
<br/>
#define BackBuffer    (( volatile u16*)0x600A000)
<br/>
volatile u16* theBackBuffer = BackBuffer;
<br/>
void swapBank(void) {
<br/>
 
<br/>
  if (REG_DISPCNT &amp; BACKBUFFER)
<br/>
  {
<br/>
    REG_DISPCNT &amp;= ~BACKBUFFER;
<br/>
    theBackBuffer = BackBuffer;
<br/>
  }
<br/>
  else
<br/>
  {
<br/>
    REG_DISPCNT |= BACKBUFFER;
<br/>
    theBackBuffer = VideoBuffer;
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
However that is badly named, as the technique in the GBA isn't back buffering at all, it is page flipping. When you have the relevent bit set in REG_DISPCNT the screen refresheses itself from the data at 600A000, when the bit is not set in the register, the screen refreshes from 6000000. 
<br/>
<br/>
If it were a true buffer then the data from 600A000 would be copied to 6000000 and the screen would always read from 6000000.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10795 - Ruiner - Tue Sep 16, 2003 12:45 am</h4>
    <div class="postbody"><span class="postbody">Quirky thanks for the response. That one works to. I tried using the flip I posted above and that also works but I prefer swapping the pointer address like you did. Thanks</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
