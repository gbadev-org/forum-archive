<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Screen control problems - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Coding > Screen control problems</h2>
<div id="posts">
<div class="post">
    <h4>#4822 - Unciaa - Fri Apr 11, 2003 12:31 am</h4>
    <div class="postbody"><span class="postbody">I've written a simple tile-based display engine [32x32 VRAM area, actual map area of undefined sizes, yadayada...] and have started implementing a primitive collision engine [for now assuming my main sprite will always be in a certain position on screen, will see if I need more later].
<br/>
Now while testing for tile data at coordinates works perfectly, I hit some problems when I try to do them per-direction. This is the relevant code...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void charcontrol(int direction, int scroll){
<br/>
   int terminator=1;
<br/>
   u16 x;
<br/>
   CopyOAM();
<br/>
   while(terminator){
<br/>
      direction=GetInput(direction);
<br/>
      WaitForVsync();
<br/>
      if(direction==1){
<br/>
         x=fullmapX/8+14+(fullmapY/8+9)*mapsizeX;
<br/>
         if((map[x] == 0x16))
<br/>
            scrollscreen(direction, scroll);
<br/>
         }
<br/>
      direction=0;
<br/>
      }
<br/>
   }
<br/>
<br/>
int main(void){
<br/>
   REG_BG0CNT = CHAR_BASE(1) | BG_MOSAIC_ENABLE | BG_COLOR_256;
<br/>
   SetMode(MODE_1 | BG0_ENABLE | OBJ_MAP_1D| OBJ_ENABLE );
<br/>
   int i, direction=0, scroll=2;
<br/>
   
<br/>
   map=map1;
<br/>
   MakeSPRITE();
<br/>
   MakeBKG();
<br/>
   
<br/>
   InitializeSprite1();
<br/>
   while (1){
<br/>
      charcontrol(direction, scroll);
<br/>
      }
<br/>
   }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
What the program so far is supposed to do is point a pointer to our current map data, fill the VRAM 32x32 area with appropritate tiles given the starting coordinates [in our case 16x16, so the upper left corner is two tiles right and two tiles down], then just run a character control module.
<br/>
<br/>
The character control module creates a 16x16 sprite roughly in the middle [7x5th tile], then runs a loop in which it
<br/>
-fetches the key direction [1=up 2=down 3=left 4=right 0=else], waits for sync, then if the direction is 1 checks if the tile above us is the designated blank tile. If it is we scroll the screen in the given direction for the [scroll] amount of tiles, reset the direction, then rinse and repeat.
<br/>
[I'm just using this method until I get around to implementing double buffering... So no excessive flaming on it ;)]
<br/>
<br/>
The problem is, if I use
<br/>
if(direction==1){}
<br/>
for some reason the screen [at boot up] displays at the very upper left corner, then jumps to the correct position once I move. If I replace that with
<br/>
if(1){}
<br/>
the screen displays at the given coordinates correctly.
<br/>
<br/>
What the heck? Am I overwriting one memory location with another? I'm pretty sure I'm not [there are 6 integer global variables, one const u8 pointer and the OAM stuff]... Perhaps I'm not taking in account GBA's lag with certain things, but I fail to see what the problem is. Especially since testing for something produces different results from just saying "always", even though we start off the same and that if loop isn't even ran at that time. Help?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
