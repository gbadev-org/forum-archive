<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>LZSS decompress - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Coding > LZSS decompress</h2>
<div id="posts">
<div class="post">
    <h4>#175867 - brave_orakio - Mon Feb 21, 2011 5:34 am</h4>
    <div class="postbody"><span class="postbody">Hi, I'm gonna make an LZSS decompressor but my compressed data isn't vram safe because... I fail at it. The data is correctly compressed though cause I tried using the GBA built in decompressor (decompressed to EWRAM) and the image that I got was correct when I transferred it to vram.
<br/>
<br/>
so I decided to try to make the decompression vram safe by buffering to 8 or 16 word chunks and then copy these to vram as they get filled up and then repeat the preocess till the whole image is decompressed. Question is, are these 8 or 16 word chunks better being copied to vram through dma or am I better off using stmia/ldmia using C asm function?
<br/>
<br/>
Also does reading data from ROM have a huge performance hit? I plan to put the decompress function in IWRAM but the compressed data will be read straight from ROM into 8 or 16 word buffer(Technically still IWRAM) and then to vram.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175870 - Miked0801 - Mon Feb 21, 2011 3:57 pm</h4>
    <div class="postbody"><span class="postbody">For such small xfers, don't use DMA.  ldmia/stmia will be much more efficient.  Better yet, have your algorithm copy directly to VRAM or wherever instead of to a staging buffer.  If you output at least 16-bits of data at a time, then you can copy directly to VRAM without issue.  Or if you need the staging buffer and don't want to use asm, do something like this:
<br/>
<br/>
struct Generic_32_bytes
<br/>
{
<br/>
   unsigned int word1;
<br/>
   unsigned int word2;
<br/>
   unsigned int word3;
<br/>
   unsigned int word4;
<br/>
   unsigned int word5;
<br/>
   unsigned int word6;
<br/>
   unsigned int word7;
<br/>
   unsigned int word8;
<br/>
};
<br/>
<br/>
void copy32Bytes(u8 *inputPtr, u8 *outputPtr)
<br/>
{
<br/>
    Generic_32_bytes *src, *dest;
<br/>
<br/>
    src = (Generic_32_bytes *)inputPtr;
<br/>
    dest = (Generic_32_bytes *)outputPtr;
<br/>
<br/>
   *dest = *src;
<br/>
}
<br/>
<br/>
The above should translate nicely into the asm instructions you want.  Be sure to tell it to compile as ARM and to place it in fast RAM as well.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175872 - brave_orakio - Tue Feb 22, 2011 1:22 am</h4>
    <div class="postbody"><span class="postbody">Ah yes! Thank you that sounds much easier to do. I am ashamed to admit that I am not very comfortable with ASM! I probably need/want the buffer since it might make things faster especially when copying in chunks like this.
<br/>
<br/>
But then I'll also try your suggestion to copy directly, I could definitely be wrong about copying in chunks being faster since the algorithm will definitely be a little complicated thanks to the buffer.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
