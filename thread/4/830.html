<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Mode 0, Background 0, and sprites... all work but one (UGH) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Coding > Mode 0, Background 0, and sprites... all work but one (UGH)</h2>
<div id="posts">
<div class="post">
    <h4>#4149 - slippers2k - Thu Mar 20, 2003 11:18 pm</h4>
    <div class="postbody"><span class="postbody">Help!
<br/>
<br/>
I've successfully managed to load a background in mode 0. It is background 0, loaded with appropriate tiles (I understand background 0 has transparency information in it which is fine for me as long as I can get a demo going).
<br/>
<br/>
I load the background, and I load all my sprites. My input commands work just fine for the numbered sprites and the computer ai (which is REALLY simple right now) works great. But my player's sprite will not move at all (the graphic stays put)! It does "move" apparently, but the sprite will not budge.
<br/>
<br/>
I've tried changing the player sprite's character number, changing the offset into OAMData (i.e. (u16*)0x6010000), and other general checks to see if things were going to work. Nothing.
<br/>
<br/>
Is it that I'm loading my sprites into mode 0? Is it that there is a problem with my character number naming system? Or is it something else? Code provided (sorry about the mess...)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// new_pong_proj.c AGBmain Entry point is contained here (main program loop)
<br/>
<br/>
#include &lt;gba.h&gt;      //extra-large header file - screenmode, keys, sprite info and more
<br/>
#include "stdlib.h"      //standard code needed for certain functions (not sure which)
<br/>
#include &lt;mathluts.h&gt;   //precompiled sin and cos values (not necessary)
<br/>
#include &lt;interupts.h&gt;   //GBA interrupt information above and beyond that of gba.h
<br/>
#include "TEST.h"      //background file
<br/>
#include "SPRITE1.h"   //sprite#1 - my first car
<br/>
#include "SPRITE2.h"   //sprite#2 - a big square tennis ball
<br/>
#include "SPRITE4.h"    //sprite#4 - blue car (computer opponent)
<br/>
#include "NUMBER0.h"   //numbered sprites for keeping score onscreen (Jan 26 2003)
<br/>
#include "NUMBER1.h"
<br/>
#include "NUMBER2.h"
<br/>
#include "NUMBER3.h"
<br/>
#include "NUMBER4.h"
<br/>
#include "NUMBER5.h"
<br/>
#include "NUMBER6.h"
<br/>
#include "NUMBER7.h"
<br/>
#include "NUMBER8.h"
<br/>
#include "NUMBER9.h"
<br/>
#include "CARPONG.h"    //splash screen
<br/>
<br/>
#include "levelone1.c"   //my first level map
<br/>
#include "levelone1.h"   //my first level map header
<br/>
<br/>
// GLOBAL VARIABLES
<br/>
<br/>
u16* OAM = (u16*)0x7000000;
<br/>
OAMEntry sprites[128];
<br/>
pRotData rotData = (pRotData)sprites;
<br/>
<br/>
//determines whether ball travels toward player or computer
<br/>
<br/>
int direction_x = 1; 
<br/>
int direction_y = 1;
<br/>
<br/>
//variables for scrolling the background
<br/>
<br/>
/////////////////////////SPRITE GLOBAL VARIABLES//////////////////////////////////////
<br/>
<br/>
///these are global so i do not have to pass them to GetInput -dovoto
<br/>
<br/>
//x and y for sprite 1 - yellow car
<br/>
s16 x = 0;
<br/>
s16 y = 50;
<br/>
<br/>
<br/>
int count = 0;
<br/>
<br/>
//Character number global vars below allow us to swap sprite contents on the fly
<br/>
//(Jan 26 2003)
<br/>
<br/>
u16 char_number = 0;
<br/>
u16 char_number_yellow = 0;
<br/>
u16 char_number_blue = 0;
<br/>
u16 char_number_n0 = 0;
<br/>
u16 char_number_n1 = 0;
<br/>
u16 char_number_n2 = 0;
<br/>
u16 char_number_n3 = 0;
<br/>
u16 char_number_n4 = 0;
<br/>
u16 char_number_n5 = 0;
<br/>
u16 char_number_n6 = 0;
<br/>
u16 char_number_n7 = 0;
<br/>
u16 char_number_n8 = 0;
<br/>
u16 char_number_n9 = 0;
<br/>
<br/>
u16 char_number_ntemp = 0;
<br/>
<br/>
//x and y for tennis ball (yes, I know it's square :)
<br/>
s16 xs = 100;
<br/>
s16 ys = 50;
<br/>
<br/>
//x and y for sprite 4 - blue car
<br/>
s16 x4 = 180;
<br/>
s16 y4 = 50;
<br/>
<br/>
//for collision detection: define bounding boxes for the 64x64 sprites - me (12/9/02)
<br/>
//UPDATE: 12/12/02 - decided to use 32x32 sprites for paddles
<br/>
//(game will be "car pong")
<br/>
<br/>
s16 x_ur = 0;
<br/>
s16 y_ll = 0;
<br/>
<br/>
s16 xs_ur = 0;
<br/>
s16 ys_ll = 0;
<br/>
<br/>
s16 x4_ur = 0;
<br/>
s16 y4_ll = 0;
<br/>
<br/>
/////////////////////////////// RGB macro
<br/>
/************************************************************\
<br/>
* The GBA stores 15 bit color in blue green red format meaning
<br/>
* the first 5 bits are the red the next 5 bits are green and the next
<br/>
* 5 blue. This macro just shifts the colors over the correct amount.
<br/>
* RGB is the more standard way to represent color. 
<br/>
\************************************************************/
<br/>
#define RGB(r,g,b) ((r)+((g)&lt;&lt;5)+((b)&lt;&lt;10)) /*both do the same thing but just in case you prefer RGB notation i included both macros */
<br/>
#define BGR(b,g,r) ((r)+((g)&lt;&lt;5)+((b)&lt;&lt;10))
<br/>
<br/>
//DMA_Copy - FAST memory copying on the gba Mar 20 2003
<br/>
<br/>
void DMA_Copy(u8 channel, void* source, void* dest, u32 WordCount, u32 mode)
<br/>
{
<br/>
   switch (channel)
<br/>
   {
<br/>
      case 0: 
<br/>
         REG_DMA0SAD = (u32)source;
<br/>
         REG_DMA0DAD = (u32)dest;         
<br/>
         REG_DMA0CNT = WordCount | mode;
<br/>
         break;
<br/>
      case 1:
<br/>
         REG_DMA1SAD = (u32)source;
<br/>
         REG_DMA1DAD = (u32)dest;
<br/>
         REG_DMA1CNT = WordCount | mode;
<br/>
         break;
<br/>
      case 2:
<br/>
         REG_DMA2SAD = (u32)source;
<br/>
         REG_DMA2DAD = (u32)dest;
<br/>
         REG_DMA2CNT = WordCount | mode;
<br/>
         break;
<br/>
<br/>
      case 3:
<br/>
         REG_DMA3SAD = (u32)source;
<br/>
         REG_DMA3DAD = (u32)dest;
<br/>
         REG_DMA3CNT = WordCount | mode;
<br/>
         break;
<br/>
<br/>
   }
<br/>
}
<br/>
<br/>
//my plot pixle function from day 2 -dovoto
<br/>
void PlotPixel(int x,int y, unsigned short int c) {VideoBuffer[(y) *120 + (x)] = (c);}
<br/>
<br/>
// functions (all functions -dovoto unless otherwise stated)
<br/>
<br/>
void InitializeSprites(void)
<br/>
{
<br/>
   int loop;
<br/>
   for(loop = 0; loop &lt; 128; loop++)
<br/>
   {
<br/>
      sprites[loop].attribute0 = 160;  //y to &gt; 159
<br/>
      sprites[loop].attribute1 = 240;  //x to &gt; 239
<br/>
   }
<br/>
}
<br/>
<br/>
//wait for the screen to stop drawing
<br/>
void WaitForVsync(void)
<br/>
{
<br/>
   while((volatile u16)REG_VCOUNT != 160){}   
<br/>
<br/>
}
<br/>
<br/>
///Test for key presses
<br/>
void GetInput(void)
<br/>
{
<br/>
<br/>
   //for collision detection: define bounding boxes for the 64x64 sprites - me (12/9/02)
<br/>
   // x_ur = X coordinate of first sprite at upper right corner (BAD variable naming...sorry!)
<br/>
   // y_ll = Y coordinate of first sprite at lower left corner
<br/>
<br/>
   // xs_ur = X coordinate of second sprite at upper right corner
<br/>
   // ys_ll = Y coordinate of second sprite at lower left corner
<br/>
<br/>
   x_ur = x + 32;
<br/>
   y_ll = y + 32;
<br/>
<br/>
   xs_ur = xs + 16;
<br/>
   ys_ll = ys + 16;
<br/>
<br/>
   x4_ur = x4 + 32;
<br/>
   y4_ll = y4 + 32;
<br/>
<br/>
   if(!(*KEYS &amp; KEY_UP))
<br/>
   {
<br/>
       y--;
<br/>
      if(y==ys_ll)
<br/>
         if(x&lt;=xs_ur)
<br/>
            if(x_ur&gt;=xs)
<br/>
               y++;
<br/>
      //experimental
<br/>
      //y4--;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_DOWN))
<br/>
   {
<br/>
       y++;
<br/>
      if(y_ll==ys)
<br/>
         if(x&lt;=xs_ur)
<br/>
            if(x_ur&gt;=xs)
<br/>
               y--;
<br/>
      //experimental
<br/>
      //y4++;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_LEFT))
<br/>
   {
<br/>
       x--;
<br/>
      if(x==xs_ur)
<br/>
         if(y&lt;=ys_ll)
<br/>
            if(y_ll&gt;=ys)
<br/>
               x++;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_RIGHT)) 
<br/>
   {
<br/>
       x++;
<br/>
      if(x_ur==xs)
<br/>
         if(y&lt;=ys_ll)
<br/>
            if(y_ll&gt;=ys)
<br/>
               x--;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_START))
<br/>
   {
<br/>
      while(1) //man-made infinite loop with a break condition
<br/>
      {
<br/>
         WaitForVsync();
<br/>
         if(!(*KEYS &amp; KEY_START))
<br/>
            break;
<br/>
      }
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_A))
<br/>
   {
<br/>
      sprites[0].attribute2 = char_number_blue;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_B))
<br/>
   {
<br/>
      sprites[0].attribute2 = char_number_yellow;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_L))
<br/>
   {
<br/>
      if (count == 0)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n1;
<br/>
      }
<br/>
      if (count == 1)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n2;
<br/>
      }
<br/>
      if (count == 2)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n3;
<br/>
      }
<br/>
      if (count == 3)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n4;
<br/>
      }
<br/>
      if (count == 4)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n5;
<br/>
      }
<br/>
      if (count == 5)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n6;
<br/>
      }
<br/>
      if (count == 6)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n7;
<br/>
      }
<br/>
      if (count == 7)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n8;
<br/>
      }
<br/>
      if (count == 8)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_n9;
<br/>
      }
<br/>
      if (count == 9)
<br/>
      {
<br/>
         sprites[3].attribute2 = char_number_ntemp;
<br/>
         count = 0;
<br/>
      }
<br/>
      count++;
<br/>
      //sprites[3].attribute2 = char_number_n1;
<br/>
   }
<br/>
   if(!(*KEYS &amp; KEY_R))
<br/>
   {
<br/>
      sprites[3].attribute2 = char_number_n0;
<br/>
   }
<br/>
<br/>
}
<br/>
<br/>
//move the sprite
<br/>
void MoveSprite(OAMEntry* sp, int x, int y)
<br/>
{
<br/>
   if(x &lt; 0)         //if it is off the left corect
<br/>
      x = 512 + x;
<br/>
   if(y &lt; 0)         //if off the top corect
<br/>
      y = 256 + y;
<br/>
<br/>
   /////////////////////////COLLISION DETECTION CODE/////////////////
<br/>
   ///////////////////(FOR TENNIS BALL)//////////////////////////////
<br/>
<br/>
   xs -= direction_x;
<br/>
<br/>
   if (xs == 0)
<br/>
   {
<br/>
      direction_x *= -1;
<br/>
      xs++;
<br/>
   }
<br/>
<br/>
   if (xs == 220)
<br/>
   {
<br/>
      direction_x *= -1;
<br/>
      xs--;
<br/>
   }
<br/>
<br/>
   if (xs==x4)
<br/>
      if(ys&lt;=y4_ll)
<br/>
         if(ys_ll&gt;=y4)
<br/>
            {
<br/>
               direction_x *= -1;
<br/>
               xs--;
<br/>
            }
<br/>
<br/>
   if (xs==x_ur)
<br/>
      if(ys&lt;=y_ll)
<br/>
         if(ys_ll&gt;=y)
<br/>
            {
<br/>
               direction_x *= -1;
<br/>
               xs++;
<br/>
            }
<br/>
<br/>
   ys -= direction_y;
<br/>
<br/>
   if (ys == 0)
<br/>
   {
<br/>
      direction_y = -1;
<br/>
      ys++;
<br/>
   }
<br/>
   if (ys == 140)
<br/>
   {
<br/>
      direction_y *= -1;
<br/>
      ys--;
<br/>
   }
<br/>
<br/>
   //experimental (12/14/2002)
<br/>
   y4 = ys;
<br/>
<br/>
   //approaching tennis ball from the left
<br/>
   //if((x)==(xs))
<br/>
   //   x--;
<br/>
<br/>
   //approaching from the right
<br/>
   //if((x)&lt;(xs))
<br/>
   //   x++;
<br/>
<br/>
   //////////////END COLLISION DETECTION CODE ///////////////////////
<br/>
   ///(CALL YOUR INSURANCE COMPANY!!! :)/////////////////////////////
<br/>
<br/>
   sp-&gt;attribute1 = sp-&gt;attribute1 &amp; 0xFE00;  //clear the old x value
<br/>
   sp-&gt;attribute1 = sp-&gt;attribute1 | x;
<br/>
   
<br/>
   sp-&gt;attribute0 = sp-&gt;attribute0 &amp; 0xFF00;  //clear the old y value
<br/>
   sp-&gt;attribute0 = sp-&gt;attribute0 | y;
<br/>
}   
<br/>
<br/>
///Copy our sprite array to OAM
<br/>
void CopyOAM(void)
<br/>
{
<br/>
   u16 loop;
<br/>
   u16* temp;
<br/>
   temp = (u16*)sprites;
<br/>
   for(loop = 0; loop &lt; 128*4; loop++)
<br/>
   {
<br/>
      OAM[loop] = temp[loop];
<br/>
   }
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   int index = 0;  //some looping variables for loops :)
<br/>
   u16 loop;
<br/>
   
<br/>
   
<br/>
   
<br/>
   SetMode(MODE_4 | BG2_ENABLE| OBJ_ENABLE | OBJ_MAP_1D); //set mode 2 and enable sprites and 2d mapping 
<br/>
<br/>
   for(loop = 0; loop &lt; 256; loop++)
<br/>
      OBJPaletteMem[loop] = SPRITE1Palette[loop];   //loop through and store the palette from your pict 
<br/>
                           //palette into obj palette mem OBJPaletteMem is 
<br/>
                           //defined in gba.h.  sprite1Palette is from
<br/>
                           //pcx2gba tool sprite1.h.
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
      for(loop = 0; loop &lt; 256; loop++)
<br/>
         BGPaletteMem[loop] = CARPONGPalette[loop];
<br/>
<br/>
      for (y = 0; y &lt; 160; y++)
<br/>
      {
<br/>
         for (x = 0; x &lt; 120; x++)
<br/>
         {
<br/>
            PlotPixel(x,y,CARPONGData[y*120+x]);
<br/>
         }
<br/>
      }
<br/>
<br/>
      if(!(*KEYS &amp; KEY_START))
<br/>
         break;
<br/>
   }
<br/>
<br/>
   //Regular background (mode 4) is now disabled, going to load mode 0 background (Mar 18 2003)
<br/>
   //for(loop = 0; loop &lt; 256; loop++)
<br/>
   //   BGPaletteMem[loop] = TESTPalette[loop];   //loop through and store the palette from your pict 
<br/>
   //                        //palette into video palette mem 
<br/>
   //
<br/>
   //for(y = 0; y &lt; 160; y++)
<br/>
   //{
<br/>
   //   for(x = 0; x &lt; 120; x++)
<br/>
<br/>
   //   {
<br/>
   //      PlotPixel(x,y,TESTData[y*120+x]);//testData contains the color values of your pict
<br/>
         //if((x&gt;0)&amp;&amp;((x%10)==0))
<br/>
         //   PlotPixel(x,y,RGB(31,31,31));
<br/>
         // HISTORY: Above two lines are debug scaffolding... used to delineate x coords
<br/>
         // (Dec 9 2002)
<br/>
         
<br/>
   //   }
<br/>
   //}
<br/>
<br/>
   //
<br/>
<br/>
   int x=0,y=0; //just some looping vars
<br/>
<br/>
   //this is a temparary pointer that we will point to the last screen memory block(31)
<br/>
   u16* bg0map =(u16*)ScreenBaseBlock(31);
<br/>
<br/>
   //bg0map now points to were we are going to put our map data
<br/>
<br/>
   //now we set up background 0 to be a 256 x 256 256 color background and make sure it 
<br/>
   //it looks in the right place for its map data
<br/>
   REG_BG0CNT = BG_COLOR256 | TEXTBG_SIZE_256x256 | (31 &lt;&lt; SCREEN_SHIFT) | WRAPAROUND;
<br/>
<br/>
   //good old set mode function. here we just set it to mode 0 and enable background 0
<br/>
   SetMode(MODE_0 | BG0_ENABLE| OBJ_ENABLE | OBJ_MAP_1D); //added OBJ_ENABLE and OBJ_MAP_1D
<br/>
                                             //Mar 18 2003
<br/>
<br/>
<br/>
   //now we use our DMA copy routine to copy in the palette 
<br/>
   DMA_Copy(3,(void*)levelone1Map.pal,(void*)BGPaletteMem,256,DMA_16NOW);
<br/>
<br/>
   //now we copy in the tile data
<br/>
   DMA_Copy(3,(void*)levelone1Map.tiledata,(void*)CharBaseBlock(0),levelone1Map.tileDataSize/4,DMA_32NOW);
<br/>
<br/>
   //now we copy in the map. this could be done with dma as well but this is a bit more flexible
<br/>
   for(y = 0; y &lt; 32; y++) //loop through all 32x32 tiles
<br/>
   {
<br/>
      for(x = 0; x &lt; 32; x++)
<br/>
      {
<br/>
      //this is were the data from our map editor is copied to video memory
<br/>
         bg0map[x + y * 32] = levelone1Map.layers[0].data[x + y * levelone1Map.layers[0].w];
<br/>
   
<br/>
      }
<br/>
   
<br/>
   }
<br/>
<br/>
<br/>
//our main loop..this is were we would normaly do stuff
<br/>
//for now we just let you scroll around a bit with the keys
<br/>
//to see your map.
<br/>
<br/>
<br/>
//while(1)
<br/>
//{
<br/>
<br/>
     //while(!(REG_DISPSTAT &amp; 1));//wait for vblank to start
<br/>
<br/>
//use the hardware to scroll around some
<br/>
     //if(!(KEYS &amp; KEY_LEFT))x--;
<br/>
     //if(!(KEYS &amp; KEY_RIGHT))x++;
<br/>
     //if(!(KEYS &amp; KEY_UP))y--;
<br/>
     //if(!(KEYS &amp; KEY_DOWN))y++;
<br/>
<br/>
//We load x and y into the offset registers and the GBA scrolls the background for us
<br/>
     //REG_BG0VOFS = y ;
<br/>
     //REG_BG0HOFS = x ;
<br/>
<br/>
     //while((REG_DISPSTAT &amp; 1));//wait for vblank to end
<br/>
<br/>
//}//end while
<br/>
//}//end main
<br/>
<br/>
<br/>
   //
<br/>
<br/>
   x = 10;
<br/>
   y = 10;
<br/>
   InitializeSprites();  //set all 128 sprites to offscreen
<br/>
<br/>
   //this is were we define our sprite atributes for the first sprite
<br/>
   //256 color 64x64 sprite that starts at character 0.  Character 0 is
<br/>
   //the first sprite data memory location.
<br/>
<br/>
   sprites[0].attribute0 = COLOR_256 | SQUARE | y;  
<br/>
   sprites[0].attribute1 = SIZE_32 | x;
<br/>
   sprites[0].attribute2 = char_number; //bit map mode so the first 512 chars are not available
<br/>
                               //UPDATE: mode 0 - no more need to add 512 (3/18/03)
<br/>
<br/>
   char_number_yellow = char_number;
<br/>
<br/>
   sprites[1].attribute0 = COLOR_256 | SQUARE | ys;  
<br/>
   sprites[1].attribute1 = SIZE_16 | xs;
<br/>
   sprites[1].attribute2 = char_number+(128); //bit map mode so the first 512 chars are not available each 64x64 sprite uses 128 tiles
<br/>
                                    ////UPDATE: mode 0 - no more need to add 512 (3/18/03)
<br/>
                        
<br/>
   sprites[2].attribute0 = COLOR_256 | SQUARE | y4;
<br/>
   sprites[2].attribute1 = SIZE_32 | x4;
<br/>
   sprites[2].attribute2 = char_number+(128+64);
<br/>
<br/>
   char_number_blue = char_number+(128+64);
<br/>
<br/>
   //DEFINING NUMBER SPRITES
<br/>
<br/>
   sprites[3].attribute0 = COLOR_256 | SQUARE | y+10;//0;
<br/>
   sprites[3].attribute1 = SIZE_32 | x+10;//0;
<br/>
   sprites[3].attribute2 = char_number+(128+128);
<br/>
<br/>
   char_number_n0 = char_number+(128+128);
<br/>
   char_number_ntemp = char_number_n0;
<br/>
<br/>
   sprites[4].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[4].attribute1 = SIZE_32 | 0;
<br/>
   sprites[4].attribute2 = char_number+(128+192);
<br/>
<br/>
   char_number_n1 = char_number+(128+192);
<br/>
<br/>
   sprites[5].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[5].attribute1 = SIZE_32 | 0;
<br/>
   sprites[5].attribute2 = char_number+(128+256);
<br/>
<br/>
   char_number_n2 = char_number+(128+256);
<br/>
<br/>
   sprites[6].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[6].attribute1 = SIZE_32 | 0;
<br/>
   sprites[6].attribute2 = char_number+(128+320);
<br/>
<br/>
   char_number_n3 = char_number+(128+320);
<br/>
<br/>
   sprites[7].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[7].attribute1 = SIZE_32 | 0;
<br/>
   sprites[7].attribute2 = char_number+(128+384);
<br/>
<br/>
   char_number_n4 = char_number+(128+384);
<br/>
<br/>
   sprites[8].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[8].attribute1 = SIZE_32 | 0;
<br/>
   sprites[8].attribute2 = char_number+(128+448);
<br/>
<br/>
   char_number_n5 = char_number+(128+448);
<br/>
<br/>
   sprites[9].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[9].attribute1 = SIZE_32 | 0;
<br/>
   sprites[9].attribute2 = char_number+(128+512);
<br/>
<br/>
   char_number_n6 = char_number+(128+512);
<br/>
<br/>
   sprites[10].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[10].attribute1 = SIZE_32 | 0;
<br/>
   sprites[10].attribute2 = char_number+(128+576);
<br/>
<br/>
   char_number_n7 = char_number+(128+576);
<br/>
<br/>
   sprites[11].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[11].attribute1 = SIZE_32 | 0;
<br/>
   sprites[11].attribute2 = char_number+(128+640);
<br/>
<br/>
   char_number_n8 = char_number+(128+640);
<br/>
<br/>
   sprites[12].attribute0 = COLOR_256 | SQUARE | 0;
<br/>
   sprites[12].attribute1 = SIZE_32 | 0;
<br/>
   sprites[12].attribute2 = char_number+(128+704);
<br/>
<br/>
   char_number_n9 = char_number+(128+704);
<br/>
<br/>
//allright now to copy in the sprites bitmap.  The data in sprite1Data is allready striped 
<br/>
//so we just copy it in one row of tiles at a time.  The only difference between this and a 
<br/>
//2D sprite is that we would need to keep in mind the fact that the tiles are not all in a row.
<br/>
//We could just use one big for loop.  There are 8 rows (64x64 = 8x8 tiles) so we loop through
<br/>
//all 8.  There is 512 bytes per row (8 tiles * 8x8 = 512) but since we copy 2 bytes at a 
<br/>
//time that equals 256.  The width of char memory is 32 * 8x8 = 1024 (512 double bytes).
<br/>
//   
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index] = SPRITE1Data[index];  //copy it starting 512 tiles into oamdata mem.  remember one tile = 32bytes and OAMdata is 16 bit pointer so offset is 512*16
<br/>
                                       //UPDATE: 512 tile offset no longer needed
<br/>
                                       //Mar 20 2003
<br/>
      }//end index loop
<br/>
      for(index =0 ; index &lt;256*2 ; index++)
<br/>
      {
<br/>
         OAMData[index+256*8] = SPRITE2Data[index];  
<br/>
         
<br/>
      }//end index loop
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*12] = SPRITE4Data[index];
<br/>
      }
<br/>
<br/>
      //inserting number sprites to OAM
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*16] = NUMBER0Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*20] = NUMBER1Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*24] = NUMBER2Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*28] = NUMBER3Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*32] = NUMBER4Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*36] = NUMBER5Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*40] = NUMBER6Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*44] = NUMBER7Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*48] = NUMBER8Data[index];
<br/>
      }
<br/>
<br/>
      for(index = 0; index &lt; 256*4; index++)
<br/>
      {
<br/>
         OAMData[index+256*52] = NUMBER9Data[index];
<br/>
      }
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
      while(!(REG_DISPSTAT &amp; 1));//wait for vblank to start
<br/>
      GetInput();    //get input changes the x and y based on input
<br/>
      MoveSprite(&amp;sprites[0],x,y); //changes sprite atributes based on new x,y
<br/>
      MoveSprite(&amp;sprites[1],xs,ys);
<br/>
      MoveSprite(&amp;sprites[2],x4,y4);
<br/>
      REG_BG0VOFS = y ;
<br/>
      REG_BG0HOFS = x ;
<br/>
      while((REG_DISPSTAT &amp; 1));//wait for vblank to end
<br/>
      WaitForVsync();         //waits for the screen to stop drawing
<br/>
      CopyOAM();            //Copies our sprite array into OAM.
<br/>
   }
<br/>
}
<br/>
<br/>
//end of entry point
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
That's all, folks... thanks for your time. Any assistance would be most appreciated. This is one of the last hurdles before I add more levels and more logic into the engine. Let me know if you'd like a demo!
<br/>
<br/>
-slippers2k<br/>_________________<br/>Subaru -
<br/>
Because you never thought you'd get your ego handed to you by a station wagon on the track.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4154 - Paul Shirley - Fri Mar 21, 2003 11:26 am</h4>
    <div class="postbody"><span class="postbody">...removed: misread part of the post...</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
