<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ROM prefetch question - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Hardware > ROM prefetch question</h2>
<div id="posts">
<div class="post">
    <h4>#1775 - col - Wed Jan 22, 2003 11:08 pm</h4>
    <div class="postbody"><span class="postbody">when the rom prefetch is switched on:
<br/>
<br/>
If i'm running code in iwram, and accessing sequential data in rom, will prefetch work even if the rom reads are seperated by instructions in iwram? 
<br/>
<br/>
cheers
<br/>
<br/>
col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1799 - ampz - Thu Jan 23, 2003 8:56 am</h4>
    <div class="postbody"><span class="postbody">I'd say so, yes.
<br/>
Makes little sense otherwise...
<br/>
<br/>
Oh, always do sequential ROM acesses with a _increasing_ adress pointer. If you use a decreasing pointer you'll get the worst case access time for every read.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2127 - Paradroid - Wed Jan 29, 2003 10:46 pm</h4>
    <div class="postbody"><span class="postbody">...sorry, but it won't go faster...
<br/>
<br/>
If you're reading data from ROM the prefetch setting won't make any difference. Only CPU instructions go through the prefetch. If you've got your code in WRAM then ROM data accesses will be the same...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2129 - Splam - Wed Jan 29, 2003 11:06 pm</h4>
    <div class="postbody"><span class="postbody">This from the Nintendo manual
<br/>
<br/>
When the Prefetch Buffer Flag is enabled and there is some free space, the Prefetch Buffer takes control of the Game Pak Bus during the time when the CPU is not using it, and reads Game Pak ROM data repeatedly. When the CPU tries to read instructions from the Game Pak and if it hits the Prefetch Buffer, the fetch is completed with no wait in respect to the CPU. If there is no hit, the fetch is done from the Game Pak ROM and there is a wait based on the set wait state. 
<br/>
<br/>
If the Prefetch Buffer Flag is disabled, the fetch is done from the Game Pak ROM. There is a wait based on the wait state associated with the fetch instruction to the Game Pak ROM in respect to the CPU.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2133 - tepples - Wed Jan 29, 2003 11:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Splam wrote:</b></span></td> </tr> <tr> <td class="quote">This from the Nintendo manual</td> </tr></table><span class="postbody">
<br/>
Isn't quoting Nintendo manuals an NDA violation?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2134 - ampz - Wed Jan 29, 2003 11:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Paradroid wrote:</b></span></td> </tr> <tr> <td class="quote">...sorry, but it won't go faster...
<br/>
<br/>
If you're reading data from ROM the prefetch setting won't make any difference. Only CPU instructions go through the prefetch. If you've got your code in WRAM then ROM data accesses will be the same...</td> </tr></table><span class="postbody">
<br/>
<br/>
I think you are confusing the GBA cart bus prefetch buffer with the ARM7 pipeline fetch stage.
<br/>
That's two totally different prefetch buffers.
<br/>
<br/>
As Splam so nicely quoted from the (illegal?) doc, it will speed up any sequential access from the cart bus.
<br/>
<br/>
EDIT
<br/>
tepples: The unfortunate fact is that most of the info available probably comes from that doc from the beginning anyway. The dangerous thing is that there is no way of knowing where the info comes from..
<br/>
I'am at least happy to know that the hardware info I have used to produce GBA cart designs comes from a 100% legal session with a logic analyser. :)
<br/>
<br/>
EDIT again
<br/>
Oh, does anyone know how deep the prefetch buffer is? Some logic analyser data I have suggests it might be 4 words deep (4 * 16bit).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2137 - Splam - Wed Jan 29, 2003 11:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Splam wrote:</b></span></td> </tr> <tr> <td class="quote">This from the Nintendo manual</td> </tr></table><span class="postbody">
<br/>
Isn't quoting Nintendo manuals an NDA violation?</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Who said I signed an NDA? :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2152 - tepples - Thu Jan 30, 2003 5:40 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Splam wrote:</b></span></td> </tr> <tr> <td class="quote">Who said I signed an NDA?</td> </tr></table><span class="postbody">
<br/>
Then how'd you come upon the manual?
<br/>
<br/>
I work only from the CowBite spec.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2154 - Costis - Thu Jan 30, 2003 7:44 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
Yes, we'd rather you don't post from any illegal\official documents or other stuff here, please. Safety and moral issues involved.
<br/>
<br/>
Costis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2156 - ampz - Thu Jan 30, 2003 9:05 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Splam wrote:</b></span></td> </tr> <tr> <td class="quote">Who said I signed an NDA?</td> </tr></table><span class="postbody">
<br/>
Then how'd you come upon the manual?
<br/>
I work only from the CowBite spec.</span></td> </tr></table><span class="postbody">
<br/>
Where do you think the cowbite spec. comes from, originally?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2159 - Paradroid - Thu Jan 30, 2003 10:12 am</h4>
    <div class="postbody"><span class="postbody">Ampz, Cols question was if the ROM prefetch is on will it help with sequential access when code is running in WRAM - and according to the Nintendo doc's(above) it won't as it is a CPU cache (of 3x16-bit words). The section just below the bit Splam copied explains the wait states for the ROM and it's this that helps with data access (and naturally instructions aswell as it's a general ROM setting).
<br/>
<br/>
What you need is to set the wait-state settings for the ROM as the recommended 3:1:1:1 (ie 3 waits for the first access and then 1 wait for sequential accesses after that). By default it reads as 4:2:4:8 - your whole code goes a lot faster when this is enabled correctly. And in the games I wrote I never found any harm setting the ROM prefetch to on.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2180 - tepples - Thu Jan 30, 2003 4:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">Where do you think the cowbite spec. comes from, originally?</td> </tr></table><span class="postbody">
<br/>
I'd assume it came from the same place the publicly available NES documents came from: by running tests on the hardware and by documenting what you did to get dumped ROMs emulated.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2183 - col - Thu Jan 30, 2003 5:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Paradroid wrote:</b></span></td> </tr> <tr> <td class="quote">Ampz, Cols question was if the ROM prefetch is on will it help with sequential access when code is running in WRAM... </td> </tr></table><span class="postbody">
<br/>
<br/>
er.. actually Cols original question was:
<br/>
<br/>
If the code is running in/from IWRAM, and is _reading_ sequential _data_ from ROM, will those rom accesses be able to benifit from prefetch even though they are seperated by chunks of IWRAM code?
<br/>
<br/>
Another question:
<br/>
As (i now gather) the prefetch buffer is 8 bytes, can repeated reads from the *same* address benefit from pre-fetch, and can I skip a word or 2 words and still benifit from pre-fetch?, (and how long IS a piece of string?!)
<br/>
<br/>
Is it better (pre-fetch wise) to put rom reads together, or is it better to space them out:
<br/>
<br/>
ldr    r1, [ROM]
<br/>
ldr    r2, [ROM+1]
<br/>
ldr    r3, [ROM+2]
<br/>
<br/>
or
<br/>
<br/>
ldr    r1, [ROM]
<br/>
some iwram code
<br/>
...
<br/>
ldr    r2, [ROM+1]
<br/>
some more iwram code
<br/>
...
<br/>
ldr    r3, [ROM+2]
<br/>
...
<br/>
<br/>
<br/>
cheers
<br/>
<br/>
col.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2185 - Paradroid - Thu Jan 30, 2003 6:18 pm</h4>
    <div class="postbody"><span class="postbody">Spacing WRAM instructions out (as in your example) will be faster if you set register 0x04000204 to 0x14 - one instruction spacing (ie 1 cycle) should be enough. The wait states work with sequential accesses so if you skip 2 bytes it's the same as random access - which is a 3 cycle penalty.
<br/>
Not sure on the prefetch buffer being 8 bytes - there is a CPU instruction prefetch from ROM of 3 instructions but if your code is in WRAM and you're reading data from ROM this won't get used.
<br/>
<br/>
Easiest thing is to try the variations out on real hardware and time them...?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2190 - FluBBa - Thu Jan 30, 2003 10:48 pm</h4>
    <div class="postbody"><span class="postbody">Just a little question..
<br/>
Have they really made the prefetch buffer only buffer data when the CPU fetches instructions but not normal data reads? I don't say it's hard to do or stupid, but would really like to hear someone say one good reason to do so. And if anybody knows how they see the difference of a read vs a read from memory.
<br/>
Or am I totally out of my mind here ;-)
<br/>
<br/>
/FluBBa</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2194 - ampz - Fri Jan 31, 2003 1:01 am</h4>
    <div class="postbody"><span class="postbody">Don't confuse the CPU pipeline fetch stage with the ROM prefetch buffer. It's two totally different things.
<br/>
<br/>
Yes, the ROM prefetch will help all sequential ROM reads.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2218 - Maddox - Fri Jan 31, 2003 6:04 am</h4>
    <div class="postbody"><span class="postbody">ampz,
<br/>
  Sorry.  The prefetch flag only affects instructions.
<br/>
<br/>
When the memory subsystem has time and access to the bus, it prefetches INSTRUCTIONS.  "Prefetch" is even a word from the computer science lexicon and it refers to the pipeline stage of a processor.  You see, ampz, processors used to just "fetch" instructions, but now they "prefetch" before they need it 'cause it's better that way.  (This would have been easy for nintendo to add to the system as part of the ARM cpu core itself.)  This idea is further strengthened by the fact that, as certain docs say, IF the prefetch buffer does not hit, the WAIT STATE is THEN imposed on the instruction fetch.
<br/>
<br/>
The sequential ROM accesses are shorter because the nintendo carts have address counters on them that autoincrement every time they are strobed to do so.  When an address does not match, instruction or otherwise, the counters are relatched and the data must wait for the wait state amount before the data is valid on the bus.  The cpu prefetch IS taking advantage of this to do the prefetching at all, otherwise there probably would never be enough free bus time to do the prefetch.
<br/>
<br/>
Maddox strikes again!<br/>_________________<br/>You probably suck.  I hope you're is not a game programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2219 - tepples - Fri Jan 31, 2003 6:12 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maddox wrote:</b></span></td> </tr> <tr> <td class="quote">When the memory subsystem has time and access to the bus, it prefetches INSTRUCTIONS.</td> </tr></table><span class="postbody">
<br/>
Correct.  My tests on hardware show that setting the prefetch bit does NOT speed DMA copying from ROM to RAM.  Thus, the maximum data bandwidth of the cartridge interface is (16777216 cycles/s) / (3 cycles/transfer) * (2 bytes/transfer) = 10.66 MiB/s (11184810 bytes/s), not 16 MiB/s as I have previously erroneously claimed on this board.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2223 - ampz - Fri Jan 31, 2003 10:51 am</h4>
    <div class="postbody"><span class="postbody">tepples: The maximum bandwidth of the cart interface is 16777216 bytes/s (16MB/s) if the waitstate is set to 2, and that's the default waitstate setting for all commercial games.
<br/>
<br/>
Understand that the cart prefetch buffer would not speed up DMA transfers. The cart bus is separated from the internal bus, and thus the DMA transfers can utilize the full bandwidth of the cart bus when doing a transfer to internal RAM.
<br/>
If you want to test if the buffer speeds up data transfers, then you have to make a loop running in internal RAM that copies data from the cart to internal RAM.
<br/>
<br/>
Maddox: I know how GBA carts works. I build them, and I'am also the one who released the full cart bus spec. on the net in the first place. I'am also very well aware of computer architechtures.
<br/>
You are still confusing the cart prefetch with the CPU pipeline prefetch stage. It's two totally different but coexisting prefetch buffers.
<br/>
<br/>
Just because it's called "fetch" doesn't mean it's a intruction fetch, it may just as well be a data fetch.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2225 - zeuhl - Fri Jan 31, 2003 11:24 am</h4>
    <div class="postbody"><span class="postbody">just posting this message because nobody told about ldm**/stm**  ARM instructions.
<br/>
<br/>
the instruction : "ldmia r0!,{r1-r12}", for example, loads 12 words (ie, 48 bytes) from the address pointed by r0 and stores them to r1,r2,.....,r12. then it adds 48 to r0, in order to enable another consecutive load.
<br/>
<br/>
taking the ROM prefetch buffer into account, will this instruction be faster/slower/equivalent to a bunch of twelve "ldr r1,[r0],#4" consecutive instructions ? (obviously, supposing each instruction would load data to a different register)
<br/>
<br/>
and which is the fastest ? 
<br/>
- a bunch of ldmia/stmia instructions for copying data from ROM to IWRAM, or
<br/>
- a bunch of ldr/str instructions ?
<br/>
thanks for your help.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2235 - FluBBa - Fri Jan 31, 2003 2:44 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maddox wrote:</b></span></td> </tr> <tr> <td class="quote">When the memory subsystem has time and access to the bus, it prefetches INSTRUCTIONS.</td> </tr></table><span class="postbody">
<br/>
Correct.  My tests on hardware show that setting the prefetch bit does NOT speed DMA copying from ROM to RAM.</span></td> </tr></table><span class="postbody">
<br/>
How could it have done? It's only usefull when working with the CPU.
<br/>
It only allows you to do things _between_ the "fetches" of data.
<br/>
If this thing works for data also and not only instructions it will give you a nice speedboost for things like...
<br/>
ldr r0,[ROM]
<br/>
add r0,r1,r2,lsr#16
<br/>
sub r0,r0,r3
<br/>
str r0,[RAM]
<br/>
ldr r0[ROM+1]
<br/>
.....
<br/>
<br/>
If the prefetch is on you will get 0(?) waitstates on the second ldr...
<br/>
Instead of letting the processor wait for the waitstate the prefetch buffer does it for you, but if you do [buffer deep] number of consecutive reads the buffer will be empty (or soon to be empty) and then the wait states will kick in again.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2243 - tepples - Fri Jan 31, 2003 3:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">tepples: The maximum bandwidth of the cart interface is 16777216 bytes/s (16MB/s) if the waitstate is set to 2, and that's the default waitstate setting for all commercial games.</td> </tr></table><span class="postbody">
<br/>
But on my hardware, a DMA copy still takes two cycles to read each 16 bits from ROM and one cycle to write them to IWRAM, even at 3/1 wait state timing.  The cart prefetch hardware seems not to fetch data from the cart while the DMA hardware is writing to IWRAM.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">If you want to test if the buffer speeds up data transfers, then you have to make a loop running in internal RAM that copies data from the cart to internal RAM.</td> </tr></table><span class="postbody">
<br/>
How would this look?  A 'ldmia' instruction would read so much data from ROM that it would empty the cart prefetch buffer rather quickly, right?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2249 - ampz - Fri Jan 31, 2003 6:30 pm</h4>
    <div class="postbody"><span class="postbody">That's kinda strange..</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
