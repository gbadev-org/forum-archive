<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ARM Instruction Timing - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Hardware > ARM Instruction Timing</h2>
<div id="posts">
<div class="post">
    <h4>#18869 - nadia - Wed Apr 07, 2004 2:58 pm</h4>
    <div class="postbody"><span class="postbody">Hi everybody,
<br/>
<br/>
I am trying to learn how to calculate how long a sequential code will take to execute in cycles. In ARM docs, I found a timing table for all usual operations but when computing a global execution time on a piece of code, it wasn't accurate.
<br/>
<br/>
Someone can help me!!
<br/>
<br/>
if someone encountered a precise emulator that gives execution time, please send me th URL.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18870 - Lupin - Wed Apr 07, 2004 3:30 pm</h4>
    <div class="postbody"><span class="postbody">For me this smells like an ASM topic :P
<br/>
<br/>
Well, calculating cycle times is a bit tricky (I did not really understand the docs explanations about this).
<br/>
<br/>
If you only need it to "profile" your code you can also assume that each instruction takes 1-2 cycles (I think mul takes ~5 cycles), so basically every instruction takes the same time, there are no huge differences. I don't think that optimizing code cycle by cycle is very good, rather try to cut down the count of instructions in your code...<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18872 - torne - Wed Apr 07, 2004 4:12 pm</h4>
    <div class="postbody"><span class="postbody">The No$ documentation has the correct cycle timings for instructions in terms of S and N times, but these only work for single instructions in isolation. You need to consider pipelining effects to notice when instruction fetches collide with memory read/writes (which causes the instruction fetch to be delayed until the memory access has completed). Basically, you can't work it out by hand for any code longer than a few instructions (unless you are very patient) and there are no emulators which are cycle-accurate (none emulate the pipeline at all, so they never have memory bus collisions).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18880 - poslundc - Wed Apr 07, 2004 7:04 pm</h4>
    <div class="postbody"><span class="postbody">The length of a sequential cycle depends on what area of memory the instruction is being read from. From IWRAM this is 1 cycle, from EWRAM it's 3 cycles for Thumb instructions and 6 for ARM instructions, and from normal ROM it can vary depending on the type of instruction, waitstate settings, and whether the prefetch is turned on, but in the general case about 2 cycles for Thumb instructions and 4 for ARM instructions. (Note that those are sequential cycles; non-sequential cycles in ROM take a big performance hit.)
<br/>
<br/>
And as torne mentioned, there is also the pipeline to consider.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
