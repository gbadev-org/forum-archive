<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>THE XBOO PROTOCOL (LONG!) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Hardware > THE XBOO PROTOCOL (LONG!)</h2>
<div id="posts">
<div class="post">
    <h4>#3677 - arundel - Tue Mar 04, 2003 11:01 pm</h4>
    <div class="postbody"><span class="postbody">Hi everybody. This is my first post, so forgive me for doing some mistakes. I'm working for quite
<br/>
some time now on decrypting the send routine Martin used in his xboo.com. I was so lucky to be his
<br/>
beta tester for the newer versions which support CPUs &gt;100 MHz (credits should be in the readme).
<br/>
<br/>
Since I remember even Jeff saying that he doesn't fully understand what Martin actually did I
<br/>
<br/>
thought it would be interesting to find out what Martin actually has come up with. I've already
<br/>
wrote a little 16 bit ASSEMBLER program (uses some 32 bit code) to send and receive a few pieces of
<br/>
data between PC and AGB, but it's just doing the first one or two data exchange routines. After
<br/>
that I don't know how the protocol continues.
<br/>
<br/>
1) This is from the documentation of the protocol Martin uses, taken from his Gameboy Advance
<br/>
Technical Info (gbatek.htm).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Times  Send   Receive  Expl.
<br/>
 -----------------------Required Transfer Initiation in master program
<br/>
 ...    6200   FFFF     Slave not in multiplay/normal mode yet
<br/>
 1      6200   0000     Slave entered correct mode now
<br/>
 15     6200   720x     Repeat 15 times, if failed: delay 1/16s and restart
<br/>
 1      610y   720x     Recognition okay, exchange master/slave info
<br/>
 60h    xxxx   NN0x     Transfer C0h bytes header data in units of 16bits
<br/>
 1      6200   000x     Transfer of header data completed
<br/>
 1      620y   720x     Exchange master/slave info again
<br/>
 ...    63pp   720x     Wait until all slaves reply 73cc instead 720x
<br/>
 1      63pp   73cc     Send palette_data and receive client_data[1-3]
<br/>
 1      64hh   73uu     Send handshake_data for final transfer completion
<br/>
 -----------------------Below is SWI 37 MultiBoot handler in BIOS
<br/>
 DELAY  -      -        Wait 1/16 seconds at master side
<br/>
 1      llll   73rr     Send length information and receive random data[1-3]
<br/>
 LEN    yyyy   nnnn     Transfer main data block in units of 16 or 32 bits
<br/>
 1      0065   nnnn     Transfer of main data block completed, request CRC
<br/>
 ...    0065   0074     Wait until all slaves reply 0075 instead 0074
<br/>
 1      0065   0075     All slaves ready for CRC transfer
<br/>
 1      0066   0075     Signalize that transfer of CRC follows
<br/>
 1      zzzz   zzzz     Exchange CRC must be same for master and slaves
<br/>
 -----------------------Optional Handshake (NOT part of master/slave BIOS)
<br/>
 ...    ....   ....     Exchange whatever custom data
<br/>
<br/>
Legend for above Protocol
<br/>
<br/>
 y     client_bit, bit(s) 1-3 set if slave(s) 1-3 detected
<br/>
 x     bit 1,2,or 3 set if slave 1,2,or 3
<br/>
 xxxx  header data, transferred in 16bit (!) units (even in 32bit normal mode)
<br/>
 nn    response value for header transfer, decreasing 60h..01h
<br/>
 pp    palette_data
<br/>
 cc    random client_data[1..3] from slave 1-3, FFh if slave not exists
<br/>
 hh    handshake_data, 11h+client_data[1]+client_data[2]+client_data[3]
<br/>
 uu    random data, not used, ignore this value
<br/>
<br/>
Below automatically calculated by SWI 37 BIOS function (don't care about)
<br/>
<br/>
 llll  download length/4-34h
<br/>
 rr    random data from each slave for encryption, FFh if slave not exists
<br/>
 yyyy  encoded data in 16bit (multiplay) or 32bit (normal mode) units
<br/>
 nnnn  response value, lower 16bit of destadr in AGB memory (00C0h and up)
<br/>
 zzzz  16bit download CRC value, must be same for master and slaves</td> </tr></table><span class="postbody">
<br/>
<br/>
2) This is a small diagram of the XBOO cable. Thx to the xboo.txt and Randall's AoA 16 BIT EDITION:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">NAME             LPT PIN         DIRECTION       POLARITY(ACTIVE)        AGB
<br/>
-----------------------------------------------------------------------------------
<br/>
/ACK            10              INPUT           0                       /SO (PIN 2)
<br/>
/AUTOLF         14              OUTPUT          0                       /SI (PIN 3)
<br/>
/STROBE         1               OUTPUT          0                       /SC (PIN 5)
<br/>
/GND            18-25           -               -                       /GND (PIN 6)
<br/>
/SELECT         17              INPUT           0                       /SD (PIN 4)</td> </tr></table><span class="postbody">
<br/>
<br/>
I think we can leave out the /GND connection, because it doesn't transfer any data. And we can
<br/>
leave out the /SELECT PIN, because that is used for the so called Burst Speed Transfer which isn't
<br/>
mandatory. Martin's xboo.txt says that this cable can be left out without any problems, but with
<br/>
loosing the Burst Boot ability.
<br/>
<br/>
<span style="color: green"><span style="font-weight: bold">SO LET'S START:</span></span>
<br/>
<br/>
As you can read in the transfer protocol we need to transfer the integer value '6200' to the AGB
<br/>
until we receive '0000' and not 'FFFF' any longer. Now we have got 4 problems:
<br/>
<br/>
1. What kind of value is the AGB expecting? 8, 16 or 32bit?
<br/>
2. To which LPT PIN do we have to send the data? Either /AUTOLF or /STROBE!
<br/>
3. Since we know that our little ARM CPU works a lot slower than the average PC CPU we need to
<br/>
introduce some kind of delay (Martin used waitstates. I think he changed the bits of the data lines
<br/>
(PIN 2-9) which should take a few ms. But maybe he also used CPU waitstates. Maybe recursion, RDTSC
<br/>
or interrupts. Who knows.)
<br/>
4. Does the AGB BIOS routine for transferring data require start and stop bits?
<br/>
<br/>
<span style="color: green"><span style="font-weight: bold">SOLUTIONS:</span></span>
<br/>
1. To know which data type the AGB is expecting we need to know which SIO Mode it is using. The
<br/>
following modes are possible: Normal Mode, Multi-Player Mode, UART Mode, BUS Mode and
<br/>
General-Purpose Mode. Since the registers which the AGB reads out to find out which mode it should
<br/>
use (124h, 128h, ...) are all set to 0 I believe the AGB uses Normal Mode. the second reason for
<br/>
using Normal Mode is the fact that Martin describes in his gbatek.htm that the cable protocol for
<br/>
Normal Mode uses the PINS /SC, /SI and /SO. All the other Modes additional use the SD PIN. I
<br/>
believe Martin uses Normal Mode for standard transfer and Multi-Player Mode for Burst Boot
<br/>
communication, where he has an extra PIN for data transfer (/SD).
<br/>
<br/>
2. If we stick to the idea that all the I/O registers are set to 0 it should be obvious that the
<br/>
transfer type the AGB is expecting is 8 bit, because the register 128h (BIT 12) is set to 0
<br/>
(0=8bit, 1=32bit).
<br/>
<br/>
3. I haven't found an appropriate solution for this problem yet!
<br/>
<br/>
4. If all the stuff I wrote above is appropriate then we shouldn't need any start or stop bits.
<br/>
Martin describes the Cable Protocol for Normal Mode like this: "SC=Clock, SO=Data being send to PC,
<br/>
SI=Data being received from PC. On SC=low AGB and PC send data to /SO (AGB) and /ACK (PC). On
<br/>
SC=high AGB and PC receive data from /SI and /AUTOLF. After transfer SC is being kept high." I hope
<br/>
I got it right, because the on the standard transfer AGB to AGB cable the cables for SI and SO are
<br/>
switched, so that SO of AGB1 is connected to SI of AGB2 and the other way round also. Quite logical
<br/>
actually. My output is your input and your output is my input!
<br/>
<br/>
<span style="color: green"><span style="font-weight: bold">I'VE COME THIS FAR:</span></span>
<br/>
The little program I've wrote so far outputs '6200' currently in 32bit mode, so I have to change
<br/>
that. However then it gets back the '0000' from the AGB which means that the Multiboot BIOS routine
<br/>
sets the AGB to be slave and let's it enter Multiboot Mode. Then however I have a problem with
<br/>
receiving the 720x, which should be 7201, because the AGB is the only slave to our master (PC). The
<br/>
problem is that I'm trying to read out the /ACK PIN in order to receive the value. However I don't
<br/>
know the timing. Since we are working in 8 bit mode I hope to receive the following value: 1110010
<br/>
(72h). I believe the AGB is using MSB first here. I'm putting this 8 bit value into some register
<br/>
(al,ah,al,bh, whatever) and comparing it to some data I've defined. But if I'm reading too fast
<br/>
from the LPT PINS I might get: 11111000 or if I'm reading too slow I might get: 11000000. Of course
<br/>
I could calculate the exact processing speed at which the AGB and my PC output data, but I don't
<br/>
know the time the AGB BIOS routine needs to do it's stuff.
<br/>
Plus I'm not that much of a hardware guru.
<br/>
<br/>
If anybody is interested in doing some researches on this matter or already knows a solution for my
<br/>
problem please drop a note. If everything I wrote is complete crap or if the entire protocol is
<br/>
already been made public please forgive me and don't flame my pour soul. And please forgive me all
<br/>
the spelling errors and technical mistakes.
<br/>
<br/>
Thx in advance.
<br/>
<br/>
P.S.: If anybody wants to have a look at the piece of code I already wrote  (~500 lines of asm
<br/>
code) please drop a note or PM me.
<br/>
<br/>
<br/>
Have phun. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3678 - NEiM0D - Wed Mar 05, 2003 12:43 am</h4>
    <div class="postbody"><span class="postbody">Have you looked at Jeff's multiboot code?
<br/>
It has been nicely disassembled by the guys at godsmaze(http://ajo.thinknerd.com/gba), and I have their version in GARD (Gameboy Advance Realtime Debugger) aswell.
<br/>
<br/>
Sending the headers etc seems to be an exact copy of what Martin describes, but the timing issues in Jeff's code are handled by the MB chip in the MB cable.
<br/>
<br/>
I can't help you much about this, but I think reading the MB code would help some more.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3680 - ampz - Wed Mar 05, 2003 1:31 am</h4>
    <div class="postbody"><span class="postbody">I'am using the nocash xboo multiboot cable to program my flash cart designs.
<br/>
I use his command line program (the xboo program) to download a small GBA application of mine, then I start my own command line program to transfer the flash image from the PC to the GBA application.
<br/>
<br/>
Works very well, and the fact that I have to run two diffrent programs doesn't matter much, I just set up a bat file to execute the two programs in sequence, or I could execute the xboo program from within my program.
<br/>
<br/>
Kudos to Martin (no$) for his efforts in making the async. timing work in software.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
