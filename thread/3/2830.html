<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Doing something while waiting for EEPROM write to finish? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Hardware > Doing something while waiting for EEPROM write to finish?</h2>
<div id="posts">
<div class="post">
    <h4>#16139 - tepples - Mon Feb 09, 2004 6:37 pm</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://www.work.de/nocash/gbatek.htm#backupeeprom" target="_blank">The GBATEK page</a> describes how to access EEPROM.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Martin Korth wrote:</b></span></td> </tr> <tr> <td class="quote">After the DMA, keep reading from the chip, by normal LDRH [D000000h], until Bit 0 of the returned data becomes "1" (Ready). To prevent your program from locking up in case of malfunction, generate a timeout if the chip does not reply after 10ms or longer.</td> </tr></table><span class="postbody">
<br/>
In practice, does a program have to keep reading from that address continuously, or can it go do something useful during that time?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16145 - poslundc - Mon Feb 09, 2004 8:43 pm</h4>
    <div class="postbody"><span class="postbody">I don't know about in practice, but in theory, if it's recommended to generate a timeout in case of malfunction it would follow that you aren't constrained by the hardware while the EEPROM writer is in operation.
<br/>
<br/>
Otherwise, why would they operate in parallel? It should just suspend the CPU like the DMA does otherwise.
<br/>
<br/>
Of course, you were asking about behaviour in practice, and as far as that goes I have nothing useful to offer.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16151 - SmileyDude - Mon Feb 09, 2004 11:16 pm</h4>
    <div class="postbody"><span class="postbody">I believe I've seen Serial EEPROM based games do something while saving (like update an animation/play music), but I can't remember which game it was off the top of my head.  It seems like most just "lock up" until the save is finished.
<br/>
<br/>
I'll try to check again sometime to see which game it was.<br/>_________________<br/>dennis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16156 - torne - Tue Feb 10, 2004 12:05 am</h4>
    <div class="postbody"><span class="postbody">You can do anything you like that doesn't access EEPROM; most games just don't bother. The N backup library uses a callback for the timeout.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16178 - tepples - Tue Feb 10, 2004 4:45 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">in theory, if it's recommended to generate a timeout in case of malfunction it would follow that you aren't constrained by the hardware while the EEPROM writer is in operation.
<br/>
<br/>
Otherwise, why would they operate in parallel?</td> </tr></table><span class="postbody">
<br/>
What I was most unsure of was whether reading ROM during an EEPROM write would interfere with the write.
<br/>
<br/>
SmileyDude: Actually, "doing something" while updating EEPROM could be done even if EEPROM writing blocked ROM reading; according to GBATEK, an EEPROM write typically takes less than half a frame.
<br/>
<br/>
But if in fact, as torne implies, it's OK to read ROM during EEPROM write completion, I'll take the callback technique into account when I start experimenting on a GBA-side hex editor for savegames. (Or do most commercial games use some sort of complicated checksum?)
<br/>
<br/>
Now all I have to figure out is how to write to 512 Kbit flash, as GBATEK gives little or no guidance in this department.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16190 - torne - Tue Feb 10, 2004 2:38 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">What I was most unsure of was whether reading ROM during an EEPROM write would interfere with the write.</td> </tr></table><span class="postbody">
<br/>
Shouldn't do.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">But if in fact, as torne implies, it's OK to read ROM during EEPROM write completion, I'll take the callback technique into account when I start experimenting on a GBA-side hex editor for savegames. (Or do most commercial games use some sort of complicated checksum?)</td> </tr></table><span class="postbody">
<br/>
<br/>
The N backup library requires that you surrender a timer to it when you write; it sets that timer up to generate the timeout, and on the timer interrupt it checks the flag. Not exactly a callback, but similar. Games often use checksums as well as this; games that use flash almost always read/verify the data they write as well.
<br/>
<br/>
As I said in another post just now, I'm hopefully going to be able to clean-room the N backup library at some point soon. Flash is a pain as there are at least three or four different flash chips used in commercial carts, all of which have different access protocols. (but a standard 'identify' technique which tells you which is on a particular cart)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16233 - ampz - Wed Feb 11, 2004 1:36 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">What I was most unsure of was whether reading ROM during an EEPROM write would interfere with the write.</td> </tr></table><span class="postbody">
<br/>
Shouldn't do.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">But if in fact, as torne implies, it's OK to read ROM during EEPROM write completion, I'll take the callback technique into account when I start experimenting on a GBA-side hex editor for savegames. (Or do most commercial games use some sort of complicated checksum?)</td> </tr></table><span class="postbody">
<br/>
<br/>
The N backup library requires that you surrender a timer to it when you write; it sets that timer up to generate the timeout, and on the timer interrupt it checks the flag. Not exactly a callback, but similar. Games often use checksums as well as this; games that use flash almost always read/verify the data they write as well.
<br/>
<br/>
As I said in another post just now, I'm hopefully going to be able to clean-room the N backup library at some point soon. Flash is a pain as there are at least three or four different flash chips used in commercial carts, all of which have different access protocols. (but a standard 'identify' technique which tells you which is on a particular cart)</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Do you know how the N backup library handle the flash erase and program commands? Does it poll the flash memory continuously until the sector is erased/written, or does it use a timeout?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16244 - torne - Wed Feb 11, 2004 3:19 am</h4>
    <div class="postbody"><span class="postbody">I believe flash erase and write use the same timer mechanism; don't remember though. As soon as I start work on backup code again, I'll publish information. Been rather busy of late writing my high-level assembler due to scary deadlines =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16245 - ampz - Wed Feb 11, 2004 4:24 am</h4>
    <div class="postbody"><span class="postbody">Exactly what function calls does the N flash API have?
<br/>
<br/>
Interestingly enough, not all flash memories used in GBA games feature a sector erase command. They don't even have the same sector size.
<br/>
For example.. A Sanyo/SST flash memory have 4kB sectors, and it does have both a sector erase command and a programming command.
<br/>
On the other hand... the Atmel flash memory have 128byte sectors, and it has no sector erase command, only a "sector reprogram command". The sector is automatically erased before it is programmed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16271 - torne - Wed Feb 11, 2004 1:31 pm</h4>
    <div class="postbody"><span class="postbody">The flash API from backup lib 1.2.0 has:
<br/>
* identify chip
<br/>
* setup timer interrupt (for the timeouts)
<br/>
* erase chip
<br/>
* erase sector (called for you by the write routine, so normally not needed)
<br/>
* write sector
<br/>
* verify sector
<br/>
* read sector
<br/>
<br/>
No idea how the differences in chips are handled other than that there seem to be multiple implementations of the above functions in some (all?) roms, suggesting that they switch implementation dynamically depending on the result of the identify.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16273 - ampz - Wed Feb 11, 2004 1:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">The flash API from backup lib 1.2.0 has:
<br/>
* identify chip
<br/>
* setup timer interrupt (for the timeouts)
<br/>
* erase chip
<br/>
* erase sector (called for you by the write routine, so normally not needed)
<br/>
* write sector
<br/>
* verify sector
<br/>
* read sector
<br/>
<br/>
No idea how the differences in chips are handled other than that there seem to be multiple implementations of the above functions in some (all?) roms, suggesting that they switch implementation dynamically depending on the result of the identify.</td> </tr></table><span class="postbody">
<br/>
<br/>
The sector size must be fixed? 4kB?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16275 - torne - Wed Feb 11, 2004 3:04 pm</h4>
    <div class="postbody"><span class="postbody">Nope, sector size is detected by identify.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16280 - ampz - Wed Feb 11, 2004 4:50 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">Nope, sector size is detected by identify.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, but API to the game must be the same no matter the sector size, right? Or is it up to the game to handle all different sector sizes?
<br/>
<br/>
Let's say there is no flash memory with a sector size larger than 4kB... In that case, the library could make all sector operations work with 4kB blocks so that the game sees no difference..</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16281 - torne - Wed Feb 11, 2004 4:57 pm</h4>
    <div class="postbody"><span class="postbody">I don't know; I've not successfully analysed call sites in commercial ROMs that use flash. The API uses integers to select the sector number. I would guess that either the game has to handle all sector sizes, or the game only works with one sector size. You can't make all operations work with the largest block (well, technically you can, but not in any sane way) because the semantics of operations will break; a game which erases sector 3 in order to delete a temporary save might lose sectors 0-7, which could include all permanent saves =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16300 - ampz - Wed Feb 11, 2004 11:42 pm</h4>
    <div class="postbody"><span class="postbody">No, the other way around...
<br/>
Let's say there are flash memories with 4kB and 128byte sectors. But, to the programmer, the API only works with 4kB sectors.
<br/>
<br/>
So, if a flash memory with 4kB sectors is used, a "erase sector 0" command from the game will erase sector 0 in the flash memory. (4kB)
<br/>
<br/>
If a flash memory with 128Byte sectors is used, a "erase sector 0" command from the game will erase sector 0-31 in the flash memory. (128*32=4kB)
<br/>
<br/>
From the programmers point of view, all flash memories works the same way.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16301 - torne - Wed Feb 11, 2004 11:46 pm</h4>
    <div class="postbody"><span class="postbody">Ah yes; the other half of my cleanroom 'team' confirms that sectors are always 4kbytes from the client's POV.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16303 - ampz - Thu Feb 12, 2004 1:27 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">Ah yes; the other half of my cleanroom 'team' confirms that sectors are always 4kbytes from the client's POV.</td> </tr></table><span class="postbody">
<br/>
<br/>
Weee.. My guess was right :-)
<br/>
You say there is a sector erase function... The Atmel flash memory has no sector erase command. Of course, the library could write all 0xff's to the entire sector to emulate a erase command, but that would be kind of pointless..</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16305 - torne - Thu Feb 12, 2004 1:42 am</h4>
    <div class="postbody"><span class="postbody">Don't know, but will find out soon hopefully. Some games depend on the erase sector command working; FFTA definately does. There are both permanent and temporary save slots; you can only make permanent saves on the map, and they are kept, but you can make tempsaves during battles. The game exits after you save, and it deletes the save when you reload it. However, the delete is implemented in terms of erase sector, which means that when you SRAM patch the game to make it work on a flashcart (the normal SRAM patches map erase and erasechip to no-ops), the tempsaves are not deleted, which means you get to have semi-real saves during battles. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16319 - ampz - Thu Feb 12, 2004 10:52 am</h4>
    <div class="postbody"><span class="postbody">Oh? Do the flashcarts with flash savegame support do the same? The easiest way to emulate sector erase and chip erase commands in hardware is to ignore them..</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16321 - torne - Thu Feb 12, 2004 1:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">Oh? Do the flashcarts with flash savegame support do the same? The easiest way to emulate sector erase and chip erase commands in hardware is to ignore them..</td> </tr></table><span class="postbody">
<br/>
<br/>
Don't know; haven't got one. I just abuse that feature to cheat at FFTA. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17760 - caitsith2 - Sun Mar 14, 2004 8:26 am</h4>
    <div class="postbody"><span class="postbody">While flash writing is not all that well documented, this is what I have found out in doing so.
<br/>
<br/>
----- Check flash identity -----
<br/>
0xE005555 = 0xAA
<br/>
0xE002AAA = 0x55
<br/>
0xE005555 = 0x90
<br/>
Value 1 = 0xE000000
<br/>
Value 2 = 0xE000001
<br/>
0xE000000 = 0xF0
<br/>
<br/>
----- Switch bank number ----- (applies only to 1Mbit flash)
<br/>
0xE005555 = 0xAA
<br/>
0xE002AAA = 0x55
<br/>
0xE005555 = 0xB0
<br/>
0xE000000 = [bank number (0, 1)]
<br/>
<br/>
----- Write byte to flash ----- (xxxx = address to write to, yy = byte to write)
<br/>
----- This operation is essentially what write sector is more or less made up of,  just a whole bunch of these. -----
<br/>
0xE005555 = 0xAA
<br/>
0xE002AAA = 0x55
<br/>
0xE005555 = 0xA0
<br/>
0xE00xxxx = 0xyy
<br/>
writeloop:
<br/>
val1 = 0xE00xxxx
<br/>
val2 = 0xE00xxxx
<br/>
if val1 != val2 goto writeloop
<br/>
val1 = 0xE00xxxx
<br/>
val2 = 0xE00xxxx
<br/>
if val1 != val2 goto writeloop  (just in case the writing wasn't quite done yet)
<br/>
<br/>
----- Erase flash -----
<br/>
0xE005555 = 0xAA
<br/>
0xE002AAA = 0x55
<br/>
0xE005555 = 0x80
<br/>
0xE005555 = 0xAA
<br/>
0xE002AAA = 0x55
<br/>
0xE005555 = 0x10
<br/>
eraseloop:
<br/>
val1 = 0xE000000
<br/>
val2 = 0xE000000
<br/>
if val1 != val2 goto eraseloop
<br/>
val1 = 0xE000000
<br/>
val2 = 0xE000000
<br/>
if val1 != val2 goto eraseloop
<br/>
<br/>
<br/>
This covers pretty well everything to deal with macronix flash chips,  except for the erase sector command, which is also present, but I am unsure as to how it is done.  It is similar to erase chip, except the last address = val part differs,  and I never played around with it, as my multiboot flash writer simply erases the whole chip before reprogramming it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17764 - ampz - Sun Mar 14, 2004 1:44 pm</h4>
    <div class="postbody"><span class="postbody">caitsith2: Have you tried using the erase flash command on a flashcart with hardware flash support? Do they actually erase the flash, or do they ignore the erase commands?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17790 - caitsith2 - Sun Mar 14, 2004 7:40 pm</h4>
    <div class="postbody"><span class="postbody">I never really tried on an actual flash cart,  but on real game cartridges, like the e-reader, and Super mario advance 4,  (both are 1Mbit), and advance wars (512Kbit).  I don't know if the erase commands are ignored or not on flash carts with hardware flash support.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17855 - dagamer34 - Tue Mar 16, 2004 1:08 am</h4>
    <div class="postbody"><span class="postbody">Since we are on the topic, does anybody have a working example of writing to EEPROM?? The code I have doesn't work at all.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
