<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>keyboardGetString() function - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > keyboardGetString() function</h2>
<div id="posts">
<div class="post">
    <h4>#174021 - JackUzi - Thu May 13, 2010 4:54 am</h4>
    <div class="postbody"><span class="postbody">I've been playing around with getting the user to enter a text string using both keyboardGetString() and the scanf("%s", buffer) method demonstrated in the keyboard_stdin example. I prefer the keyboardGetString() function as it provides the ability to set a maximum number of characters to read but the function pointed to by OnKeyPressed doesn't seem to get called when using this function. Is there a way to have the users typing reflected on the screen when using keyboardGetString()?
<br/>
<br/>
Regards,
<br/>
Stuart</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174032 - JackUzi - Fri May 14, 2010 3:51 am</h4>
    <div class="postbody"><span class="postbody">I ended up using the keyboardUpdate() function and just writing a wrapper function that gave me the console echo and the overrun protection...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
void
<br/>
read_keyboard(char *input_buffer, int maxlen) {
<br/>
    int index = 0;
<br/>
<br/>
    while(index &lt; maxlen) {
<br/>
<br/>
        int key = keyboardUpdate();
<br/>
<br/>
        if(key &gt; 0) {
<br/>
            *(input_buffer + index++) = key;
<br/>
            printf("%c", key);
<br/>
            if (key == 13 || key == 10) break;
<br/>
<br/>
            swiWaitForVBlank();
<br/>
        }
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174047 - JackUzi - Sat May 15, 2010 1:31 am</h4>
    <div class="postbody"><span class="postbody">Just for the sake of completeness, this version of the function supports backspace, only prints printable characters and null terminates the string...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
void
<br/>
read_keyboard(char *input_buffer, int maxlen) {
<br/>
   int index = 0;
<br/>
<br/>
   while(index &lt; maxlen) {
<br/>
        
<br/>
      int key = keyboardUpdate();
<br/>
<br/>
      if(key &gt; 0) {
<br/>
         if (key == 8 &amp;&amp; index != 0) {
<br/>
            // DELETE THE PREVIOUS CHARACTER FROM THE BUFFER
<br/>
            *(input_buffer + --index) = 0;
<br/>
            printf("\x1b[1D \x1b[1D", key);
<br/>
         } else if (key == 10) {
<br/>
            printf("%c", key);
<br/>
            break;
<br/>
         } else if (key &gt; 31 &amp;&amp; key &lt; 123) {
<br/>
            // ADD THE KEY TO THE BUFFER AND DISPLAY IT
<br/>
            *(input_buffer + index++) = key;
<br/>
            printf("%c", key);
<br/>
         }
<br/>
<br/>
         // WAIT FOR THE VERTICAL BLANK INTERRUPT (SCREEN REFRESH)
<br/>
         swiWaitForVBlank();
<br/>
      }
<br/>
   }
<br/>
<br/>
        // NULL TERMINATE THE STRING
<br/>
       *(input_buffer + index) = 0;
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
