<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>sprites in dualis - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > sprites in dualis</h2>
<div id="posts">
<div class="post">
    <h4>#55856 - chrissieboy - Mon Oct 03, 2005 2:57 pm</h4>
    <div class="postbody"><span class="postbody">Hi, im just started again with ds development.
<br/>
<br/>
Everything seems to been changed a littlebit.
<br/>
<br/>
Im now trying to make a puzzle game with sprites, but 3 months before it was realy easy for me to make a game with sprites.
<br/>
<br/>
But now i can't even get sprites on the screen??
<br/>
<br/>
So i used an example named : Complex_2d from devoto.
<br/>
<br/>
Ok got the sprites working now! but only on hardware!!
<br/>
<br/>
When i start my compiled program on my hardware ds then it runs, but on the emulator it wont work anymore.
<br/>
<br/>
a few months ago i used it to test my codes, because writing it the whole time to my flashcard takes a lot of time.
<br/>
<br/>
But now it won't work anymore on dualis???
<br/>
<br/>
What's going wrong with the new development area???? I really don't know??
<br/>
<br/>
here's my code :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;nds.h&gt;
<br/>
<br/>
// these files are generated automatically by the bin2o rule
<br/>
#include "ballpalette_bin.h"
<br/>
#include "balldata_bin.h"
<br/>
<br/>
#define NUM_SPRITES 36   
<br/>
<br/>
sSpriteEntry OAMCopySub[128];
<br/>
<br/>
<br/>
//simple sprite struct
<br/>
typedef struct {
<br/>
   int x,y;            //location 
<br/>
   int dx, dy;         //speed
<br/>
   sSpriteEntry* oam;   
<br/>
   int gfxID;             //graphics lovation
<br/>
}Sprite;
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void MoveSprite(Sprite* sp) {
<br/>
//---------------------------------------------------------------------------------
<br/>
   int x = sp-&gt;x &gt;&gt; 8;
<br/>
   int y = sp-&gt;y &gt;&gt; 8;
<br/>
<br/>
   sp-&gt;oam-&gt;attribute[1] &amp;= 0xFE00;
<br/>
   sp-&gt;oam-&gt;attribute[1] |= (x &amp; 0x01FF);
<br/>
 
<br/>
   sp-&gt;oam-&gt;attribute[0] &amp;= 0xFF00;
<br/>
   sp-&gt;oam-&gt;attribute[0] |= (y &amp; 0x00FF);
<br/>
<br/>
} 
<br/>
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void initOAM(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
   int i;
<br/>
<br/>
   for(i = 0; i &lt; 128; i++) {
<br/>
      OAMCopySub[i].attribute[0] = ATTR0_DISABLED;
<br/>
   }   
<br/>
}
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void updateOAM(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
   unsigned int i;
<br/>
   
<br/>
   for(i = 0; i &lt; 128 * sizeof(sSpriteEntry) / 4 ; i++)
<br/>
   {
<br/>
      ((uint32*)OAM_SUB)[i] = ((uint32*)OAMCopySub)[i];
<br/>
   }
<br/>
}
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void irqVBlank(void) {   
<br/>
//---------------------------------------------------------------------------------
<br/>
    IF = IF;
<br/>
}
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
int main(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
   
<br/>
   uint16* back = VRAM_A;
<br/>
   uint16* front = VRAM_B;
<br/>
<br/>
   Sprite sprites[NUM_SPRITES];
<br/>
<br/>
   int i, j;
<br/>
   int ix = 0;
<br/>
   int iy = 0;
<br/>
   int screen = 1;
<br/>
   uint16* map0 = (uint16*)SCREEN_BASE_BLOCK_SUB(1);
<br/>
   uint16* map1 = (uint16*)SCREEN_BASE_BLOCK_SUB(2);
<br/>
   uint16 red;
<br/>
   
<br/>
   //turn on the power to the system
<br/>
   powerON(POWER_ALL);
<br/>
<br/>
   //set main display to render directly from the frame buffer
<br/>
   videoSetMode(MODE_FB1);
<br/>
   
<br/>
   //set up the sub display
<br/>
   videoSetModeSub(MODE_0_2D | 
<br/>
               DISPLAY_SPR_1D_LAYOUT | 
<br/>
               DISPLAY_SPR_ACTIVE | 
<br/>
               DISPLAY_BG0_ACTIVE |
<br/>
               DISPLAY_BG1_ACTIVE );
<br/>
   
<br/>
   //vram banks are somewhat complex
<br/>
   vramSetMainBanks(VRAM_A_LCD, VRAM_B_LCD, VRAM_C_SUB_BG, VRAM_D_SUB_SPRITE);
<br/>
   
<br/>
   //irqs are nice
<br/>
   irqInit();
<br/>
   irqSet(IRQ_VBLANK, irqVBlank);
<br/>
   
<br/>
   // Sprite initialisation
<br/>
   for(i = 0; i &lt; 256; i++)
<br/>
      SPRITE_PALETTE_SUB[i] = ((u16*)ballpalette_bin)[i];
<br/>
/*
<br/>
   for(i = 0; i&lt; 512; i++)
<br/>
      SPRITE_GFX_SUB[i] = ((u16*)balldata_bin)[i];
<br/>
   for(i = 512; i&lt; 1024; i++)
<br/>
      SPRITE_GFX_SUB[i] = ((u16*)balldata_bin)[i-256];      
<br/>
*/
<br/>
<br/>
   for(i=0; i&lt;1024*6; i++) { SPRITE_GFX_SUB[i] = ((u16*)balldata_bin)[i]; }
<br/>
<br/>
<br/>
   
<br/>
   //turn off sprites
<br/>
   initOAM();
<br/>
<br/>
   for(i = 0; i &lt; 6; i++) {
<br/>
      for(j = 0; j &lt; 6; j++) 
<br/>
      {
<br/>
         sprites[j].x = (0 &lt;&lt; 8);
<br/>
      }
<br/>
      for(j = 7; j &lt; 13; j++) 
<br/>
      {
<br/>
         sprites[j].x = (33 &lt;&lt; 8);
<br/>
      }      
<br/>
      sprites[i].y = (32*i &lt;&lt; 8);
<br/>
<br/>
<br/>
      sprites[i].oam = &amp;OAMCopySub[i];
<br/>
      sprites[i].gfxID = 0;
<br/>
   
<br/>
      //set up our sprites OAM entry attributes
<br/>
      sprites[i].oam-&gt;attribute[0] = ATTR0_COLOR_256 | ATTR0_SQUARE;  
<br/>
      sprites[i].oam-&gt;attribute[1] = ATTR1_SIZE_32;
<br/>
      sprites[i].oam-&gt;attribute[2] = i*32;
<br/>
      
<br/>
      }
<br/>
      
<br/>
      
<br/>
<br/>
<br/>
<br/>
   BG_PALETTE_SUB[0] = RGB15(10,10,10);
<br/>
   BG_PALETTE_SUB[1] = RGB15(0,16,0);
<br/>
   BG_PALETTE_SUB[2] = RGB15(0,0,31);
<br/>
<br/>
   while (1) {
<br/>
<br/>
      
<br/>
      //move the sprites
<br/>
      for(i = 0; i &lt; NUM_SPRITES; i++) {
<br/>
         sprites[i].x += sprites[i].dx;
<br/>
         sprites[i].y += sprites[i].dy;
<br/>
         
<br/>
         //check for collision with the screen boundries
<br/>
         if(sprites[i].x &lt; (1&lt;&lt;8) || sprites[i].x &gt; (247 &lt;&lt; 8))
<br/>
            sprites[i].dx = -sprites[i].dx;
<br/>
<br/>
         if(sprites[i].y &lt; (1&lt;&lt;8) || sprites[i].y &gt; (182 &lt;&lt; 8))
<br/>
            sprites[i].dy = -sprites[i].dy;
<br/>
         
<br/>
         //reposition the sprites
<br/>
         MoveSprite(&amp;sprites[i]);
<br/>
      }
<br/>
      
<br/>
<br/>
<br/>
      swiWaitForVBlank();
<br/>
      
<br/>
      updateOAM();
<br/>
/*
<br/>
      //flip screens
<br/>
      if(screen) {
<br/>
         videoSetMode(MODE_FB1);
<br/>
         front = VRAM_B;
<br/>
         back = VRAM_A;
<br/>
         screen = 0;
<br/>
      } else {
<br/>
         videoSetMode(MODE_FB0);   
<br/>
         front = VRAM_A;
<br/>
         back = VRAM_B;
<br/>
         screen = 1;
<br/>
      } */
<br/>
   }    
<br/>
   return 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
i only get a dark screen with a block on topleft???
<br/>
<br/>
Hope you guys know the problem??
<br/>
<br/>
thanx anyway!!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
