<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Moving image on 8-bit bgs leaving blended traces on bg - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Moving image on 8-bit bgs leaving blended traces on bg</h2>
<div id="posts">
<div class="post">
    <h4>#132171 - yellowstar - Sun Jun 24, 2007 1:10 am</h4>
    <div class="postbody"><span class="postbody"><span style="font-weight: bold">I am having a differen't problem now.(Differen't from this problems in this post and forward)
<br/>
See this <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=153830#153830" target="_blank">post</a> for details.</span>
<br/>
<br/>
I need some help with Double Buffers,
<br/>
for both screens.
<br/>
<br/>
The way I am doing it dosen't work.
<br/>
<br/>
What is the correct way to do it?
<br/>
<br/>
Here is the setup I am using:
<br/>
<br/>
On the main screen,
<br/>
I have a red background,
<br/>
which dosen't do anything yet.
<br/>
I am not having any problems
<br/>
with this screen.
<br/>
<br/>
On the sub screen,
<br/>
I have a red background,
<br/>
which displays the graphics.
<br/>
<br/>
<span style="font-weight: bold">The following is not the
<br/>
problems I am having right now.
<br/>
See my second post for my new problems.
<br/>
The source code has been deleted in this post,
<br/>
as it is old. The new source code is in my second post.</span>
<br/>
<br/>
Here are the problems I am having:
<br/>
<br/>
These problems are only on the sub screen.
<br/>
<br/>
1.
<br/>
<br/>
The graphic is flickering.
<br/>
Only part of the graphic is flickering.
<br/>
Only approx. 8 pixels of the graphic is flickering.
<br/>
The part that is flickering is from the bottom of the screen
<br/>
to appox. 8 pixels up.
<br/>
<br/>
2.
<br/>
<br/>
Most of the graphic has the background color(red)
<br/>
on it.
<br/>
It seems that the background color is only on
<br/>
one color on the image.(the image  is paletted.)
<br/>
That color is the main color,
<br/>
that is, that color is used more than the other colors.
<br/>
<br/>
<br/>
<br/>
Here's the code I am using:
<br/>
Note that this is the whole thing.
<br/>
taskbar2 and taskbar3 is the graphics,
<br/>
and bak is the red background
<br/>
which is used to clear the backgrounds.
<br/>
<br/>
The back buffers are cleared in the draw function.</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Fri Apr 11, 2008 8:54 pm; edited 17 times in total</span></div>    
</div>
<div class="post">
    <h4>#132173 - Cydrak - Sun Jun 24, 2007 4:04 am</h4>
    <div class="postbody"><span class="postbody">Ahh... VRAM mapping. Harbringer of many colorful adventures.
<br/>
<br/>
The main and subscreens are entirely separate, and can't share banks. Sub BGs can only use up to 128K--so there is no BMP_BG_BASE(8/9/etc), and the base is relative to C or H. Try using 0 and 3, just like your main ones.
<br/>
<br/>
Secondly, C and H map the same BG area, 0x06200000. If you try to combine them, you get... exactly what you asked for (roughly BGdata = Cdata | Hdata), but probably not what you want. I ran into this myself, by forgetting to unmap H--found it hilarious personally. :-)
<br/>
<br/>
Also you don't have to set up four BGs, unless you want all four buffers onscreen.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#132302 - yellowstar - Mon Jun 25, 2007 6:36 pm</h4>
    <div class="postbody"><span class="postbody">Thanks, Cydrak!
<br/>
<br/>
It works now!
<br/>
<br/>
But now I have a new problem.
<br/>
<br/>
When I tried copying some image data to
<br/>
a position in the sub screen back buffer,
<br/>
it dosen't work.
<br/>
<br/>
I am using 16 bit writes, not 8 bit writes.
<br/>
<br/>
<span style="font-weight: bold">I am not having the following problem anymore,
<br/>
but I am still having problems.
<br/>
<br/>
See my 4th post below this one for details.
<br/>
<br/>
The source in this post is for the current problems
<br/>
I am having.</span>
<br/>
<br/>
On the sub screen, it displays
<br/>
the background,
<br/>
and on top of it,
<br/>
instead of the image,
<br/>
it displays 2 red bars with lines through
<br/>
them.
<br/>
These bars conver the whole screen,
<br/>
except the middle of the screen.
<br/>
For example:
<br/>
(X is the bars,  ^ is the normal parts of the screen.)
<br/>
<br/>
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
^^^^^^^^^^^^^
<br/>
^^^^^^^^^^^^^
<br/>
^^^^^^^^^^^^^
<br/>
^^^^^^^^^^^^^
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
XXXXXXXXXXXXXX
<br/>
<br/>
Here's the code I am using:
<br/>
This code is the same code as the above,
<br/>
except the double buffers works.
<br/>
taskbar_raw is the image.
<br/>
<br/>
Here's the new code:
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u16 *src = (u16 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = *src++;
<br/>
}
<br/>
<br/>
<br/>
<br/>
void vcopy(u16* source, u16 *target, size_t s_offset, size_t t_offset, size_t size)
<br/>
{
<br/>
<br/>
   //Copys source starting at s_offset to target starting at t_offset with
<br/>
   //size size.
<br/>
   //This Copy works with VRAM, OAM, and backgrounds.
<br/>
   
<br/>
   if(copy_type == CT_SCPY)
<br/>
   scpy(&amp;target[(int)t_offset],&amp;source[(int)s_offset],(size_t)size);
<br/>
      
<br/>
      if(copy_type == CT_DMA)
<br/>
      dmaCopy(&amp;source[(int)s_offset],&amp;target[(int)t_offset],size);
<br/>
<br/>
}
<br/>
   
<br/>
void VCopy(u16* source, u16 *target, size_t s_offset, size_t t_offset, size_t size,size_t target_width, size_t source_width)
<br/>
{
<br/>
   
<br/>
   if(beforeVRAM)
<br/>
   {
<br/>
   
<br/>
      if(t_offset!=0)
<br/>
      {
<br/>
      
<br/>
      for(int i=0; i &lt; (int)t_offset; i++)
<br/>
      target[i] = target[i];
<br/>
      
<br/>
      }
<br/>
   
<br/>
   }
<br/>
   
<br/>
   if(linear)
<br/>
   {
<br/>
    for(size_t i=0; i &lt; size; i+= source_width)
<br/>
    vcopy(source,target,s_offset + i,t_offset + i,source_width);   
<br/>
   }
<br/>
   
<br/>
   if(!linear)
<br/>
   vcopy(source,target,s_offset,t_offset,size);
<br/>
   
<br/>
   if(afterVRAM)
<br/>
   {
<br/>
   
<br/>
      if((t_offset + size)!=256)
<br/>
      {
<br/>
      
<br/>
      for(int i=(int)(t_offset+size); i &lt; (int)256*256; i++)
<br/>
      target[i] = target[i];
<br/>
      }
<br/>
   
<br/>
   }
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This goes in the draw function:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if(section == S_TOP)
<br/>
VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,0,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
<br/>
if(section == S_MIDDLE)
<br/>
VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,256*32,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
<br/>
if(section == S_BOTTOM)
<br/>
VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,256*(192 - 96),(size_t)TASKBAR3_RAW_size,256,256);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Here is the whole thing:
<br/>
This is the same as the above,
<br/>
except the double buffers works,
<br/>
and it has my current problem in it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
#include &lt;nds.h&gt;
<br/>
<br/>
#include &lt;string.h&gt;
<br/>
<br/>
#include &lt;malloc.h&gt;
<br/>
<br/>
#include "PALETTE_RAW.h"
<br/>
<br/>
#include "TASKBAR_RAW.h"
<br/>
<br/>
#include "TASKBAR2_RAW.h"
<br/>
<br/>
#include "TASKBAR3_RAW.h"
<br/>
<br/>
#include "BAK_RAW.h"
<br/>
<br/>
#include "BAK2_RAW.h"
<br/>
<br/>
#define DEBUG
<br/>
<br/>
u16 *video_buffer_main = (u16*)BG_BMP_RAM(0);
<br/>
u16 *video_buffer_sub = (u16*)BG_BMP_RAM_SUB(0);
<br/>
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u16 *src = (u16 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = *src++;
<br/>
}
<br/>
<br/>
<br/>
<br/>
void vcopy(u16* source, u16 *target, size_t s_offset, size_t t_offset, size_t size)
<br/>
{
<br/>
<br/>
   //Copys source starting at s_offset to target starting at t_offset with
<br/>
   //size size.
<br/>
   //This Copy works with VRAM, OAM, and backgrounds.
<br/>
   
<br/>
   if(copy_type == CT_SCPY)
<br/>
   scpy(&amp;target[(int)t_offset],&amp;source[(int)s_offset],(size_t)size);
<br/>
      
<br/>
      if(copy_type == CT_DMA)
<br/>
      dmaCopy(&amp;source[(int)s_offset],&amp;target[(int)t_offset],size);
<br/>
<br/>
}
<br/>
   
<br/>
void VCopy(u16* source, u16 *target, size_t s_offset, size_t t_offset, size_t size,size_t target_width, size_t source_width)
<br/>
{
<br/>
   
<br/>
   if(beforeVRAM)
<br/>
   {
<br/>
   
<br/>
      if(t_offset!=0)
<br/>
      {
<br/>
      
<br/>
      for(int i=0; i &lt; (int)t_offset; i++)
<br/>
      target[i] = target[i];
<br/>
      
<br/>
      }
<br/>
   
<br/>
   }
<br/>
   
<br/>
   if(linear)
<br/>
   {
<br/>
    for(size_t i=0; i &lt; size; i+= source_width)
<br/>
    vcopy(source,target,s_offset + i,t_offset + i,source_width);   
<br/>
   }
<br/>
   
<br/>
   if(!linear)
<br/>
   vcopy(source,target,s_offset,t_offset,size);
<br/>
   
<br/>
   if(afterVRAM)
<br/>
   {
<br/>
   
<br/>
      if((t_offset + size)!=256)
<br/>
      {
<br/>
      
<br/>
      for(int i=(int)(t_offset+size); i &lt; (int)256*256; i++)
<br/>
      target[i] = target[i];
<br/>
      }
<br/>
   
<br/>
   }
<br/>
<br/>
}
<br/>
<br/>
void Init()
<br/>
{
<br/>
#ifdef DEBUG
<br/>
if(!fatInitDefault())
<br/>
return;
<br/>
<br/>
<br/>
#endif
<br/>
}
<br/>
<br/>
void Draw()
<br/>
{
<br/>
<br/>
dmaCopy(BAK_RAW,video_buffer_sub,256*256);
<br/>
<br/>
dmaCopy(BAK_RAW,video_buffer_main,256*256);
<br/>
<br/>
if(section == S_TOP)
<br/>
VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,0,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
<br/>
if(section == S_MIDDLE)
<br/>
VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,256*32,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
<br/>
if(section == S_BOTTOM)
<br/>
VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,256*(192 -28),(size_t)TASKBAR3_RAW_size,256,256);
<br/>
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
    
<br/>
    
<br/>
    
<br/>
   powerON(POWER_ALL);
<br/>
   
<br/>
   irqInit();
<br/>
    irqEnable(IRQ_VBLANK);
<br/>
   
<br/>
    videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
   videoSetModeSub(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
<br/>
    vramSetBankA(VRAM_A_MAIN_BG);
<br/>
    //Init main bg
<br/>
    BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0) | BG_PRIORITY(3);
<br/>
    //No rotation and no scale
<br/>
    BG3_XDX = 1 &lt;&lt; 8;
<br/>
    BG3_XDY = 0;
<br/>
    BG3_YDX = 0;
<br/>
    BG3_YDY = 1 &lt;&lt; 8;
<br/>
   BG3_CX = 0;
<br/>
   BG3_CY = 0;
<br/>
<br/>
   vramSetBankB(VRAM_B_MAIN_BG);
<br/>
   vramSetBankH(VRAM_H_SUB_BG);
<br/>
   vramSetBankI(VRAM_I_SUB_BG);
<br/>
<br/>
   vramSetBankC(VRAM_C_SUB_BG);
<br/>
    //Init sub
<br/>
    SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0) | BG_PRIORITY(3);
<br/>
    //No rotation and no scale
<br/>
    SUB_BG3_XDX = 1 &lt;&lt; 8;
<br/>
    SUB_BG3_XDY = 0;
<br/>
    SUB_BG3_YDX = 0;
<br/>
    SUB_BG3_YDY = 1 &lt;&lt; 8;
<br/>
   SUB_BG3_CX = 0;
<br/>
   SUB_BG3_CY = 0;
<br/>
   
<br/>
   BG_PALETTE_SUB[8] = RGB15(0,0,31) &amp; (~BIT(15));
<br/>
   
<br/>
   BG_PALETTE_SUB[0] = RGB15(0,0,0) | BIT(15);
<br/>
   BG_PALETTE[0] = RGB15(0,0,0) | BIT(15);
<br/>
   
<br/>
   //memcpy(BG_PALETTE,PALETTE_RAW,PALETTE_RAW_size);
<br/>
   memcpy(BG_PALETTE_SUB,PALETTE_RAW,PALETTE_RAW_size);
<br/>
   memcpy(BG_PALETTE,PALETTE_RAW,PALETTE_RAW_size);
<br/>
dmaCopy(BAK_RAW,video_buffer_main,256*256);
<br/>
<br/>
//memcpy(video_buffer_sub_buff,bak_raw,256*256);
<br/>
dmaCopy(BAK_RAW,video_buffer_sub,256*256);
<br/>
   
<br/>
Init();
<br/>
<br/>
   
<br/>
    
<br/>
    while(1)
<br/>
   {
<br/>
   
<br/>
   
<br/>
   
<br/>
   
<br/>
<br/>
   
<br/>
<br/>
   Draw();
<br/>
   
<br/>
   swiWaitForVBlank();
<br/>
   
<br/>
   
<br/>
   
<br/>
   }
<br/>
    
<br/>
    return 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:29 pm; edited 8 times in total</span></div>    
</div>
<div class="post">
    <h4>#132323 - Cydrak - Mon Jun 25, 2007 10:26 pm</h4>
    <div class="postbody"><span class="postbody">Look a bit closer--I mentioned my problem for a reason. Most probably you're using a launcher, either loading off the card or over wifi. When that starts your program, you can't assume it resets everything.
<br/>
<br/>
Particularly, unused banks need to be set VRAM_*_LCD. Not much else comes to mind, so that would be the first thing to try...
<br/>
<br/>
(Btw, it'd be vastly more helpful, if you posted the important excerpts and cleaned up your formatting. People are liable to skip what they can't or don't have time to read...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#132327 - yellowstar - Mon Jun 25, 2007 10:54 pm</h4>
    <div class="postbody"><span class="postbody">I am using a DS-X.
<br/>
I am using the Instant Boot
<br/>
feature, and it dosen't matter
<br/>
if I use it, or boot it normally,
<br/>
it still won't work.
<br/>
<br/>
I tried mapping all the VRAM banks to LCD,
<br/>
and clearing them, but that didn't work.</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:31 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#132334 - Cydrak - Mon Jun 25, 2007 11:49 pm</h4>
    <div class="postbody"><span class="postbody">Hunh. The vertical bars sound like 16bpp or maybe tilemap data, but you say you're overwriting it, so...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void VCopy(u16* source, u16 *target, size_t s_offset, size_t t_offset, size_t size)</td> </tr></table><span class="postbody">
<br/>
s_offset, t_offset, size ... what units did you mean these to be? 8 bits? 16 bits? (Pointer arithmetic goes by the size of the type.)
<br/>
<br/>
Also, is there some significance to using dmaCopy vs. VCopy?
<br/>
<br/>
What format is the raw data? (e.g. given the VIDMO #define, did you switch away from 16bpp at some point?)
<br/>
<br/>
I'd zero (SUB_)BG3_CX and CY, the scroll for the bitmaps, while you're at it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#132471 - yellowstar - Wed Jun 27, 2007 2:43 am</h4>
    <div class="postbody"><span class="postbody">The VCopy function is supposed to be like memcpy,
<br/>
except it is used to copy 16 bit data.
<br/>
<br/>
The raw data is paletted image data.
<br/>
It is 8 bit format in the file.
<br/>
<br/>
I removed the VIDMO define,
<br/>
as what I wanted to use it for
<br/>
wouldn't work.
<br/>
<br/>
I have quit using VCopy.
<br/>
I now using dmaCopy.(the new VCopy uses a buffer, in which dmaCopy is used for the copying.)
<br/>
<br/>
When I started using dmaCopy, the bars dissappeared!
<br/>
<br/>
I am now using a buffer.(see below)
<br/>
<br/>
I tried making a 256*256 buffer in VRAM.(doesen't matter were I put the buffer, VRAM or RAM, it still dosen't work.But I get
<br/>
different results.)
<br/>
The VCopy function, when called,
<br/>
would clear that buffer by copying a transparent image unto it.
<br/>
Then it would copy the source data onto that buffer.
<br/>
Next it would copy the buffer to the target.(VRAM)
<br/>
<br/>
<br/>
<br/>
<br/>
But I am still having problems.
<br/>
<br/>
I get different results when I put the buffer in VRAM and RAM.
<br/>
<br/>
These are still problems with the sub screen.
<br/>
<br/>
<br/>
Here are the results for RAM:
<br/>
<br/>
256x256 image(size of my backgrounds):
<br/>
It works.
<br/>
The one I am trying to get to work is below this one.
<br/>
<br/>
<br/>
none 256x256 image(256x256 is size of my backgrounds.)(actual size of image is 256x28.):
<br/>
<br/>
Only problems for this one.
<br/>
<br/>
1.
<br/>
<br/>
The whole screen is black, except part of the top of it.
<br/>
(Sub Palette index 0 is the black transparent color which is
<br/>
used to clear the buffer. There is also another non-transparent black color
<br/>
in the palette. Changing either of them dosen't do anything,
<br/>
so the black color being displayed isn't either of those colors
<br/>
in the palette.).
<br/>
<br/>
<br/>
2.
<br/>
<br/>
The part of the screen that isn't black is flickering.
<br/>
It is flickering fast.
<br/>
<br/>
<br/>
3.
<br/>
<br/>
The part of the screen that isn't black is the background color.(red)
<br/>
<br/>
This part of the screen is basicly the top bar, which got moved up to the top of the screen.(the bottom bar is gone.)
<br/>
<br/>
The bar is half of its original size.
<br/>
<br/>
I'm not sure if it has lines through it,
<br/>
as it is flickering to fast to tell.
<br/>
It appears it dosen't have lines through it,
<br/>
but it's flickering to fast to be sure.
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
Here are the results for VRAM:
<br/>
<br/>
<br/>
256x256 image(size of my backgrounds):
<br/>
<br/>
Problems:
<br/>
<br/>
1.
<br/>
<br/>
It is also displaying the top bar again,
<br/>
except its height is half of what was before.
<br/>
<br/>
<br/>
2.
<br/>
<br/>
The images, and the bar is flickering.
<br/>
<br/>
<br/>
3.
<br/>
<br/>
It is displaying 2 copies of my image,
<br/>
which it is not supposed to do.
<br/>
<br/>
For the first image,
<br/>
it is displaying half of it.
<br/>
The top of it is at the bottom of the bar.
<br/>
<br/>
This image is not supposed to be displayed.
<br/>
<br/>
4.
<br/>
<br/>
Both of the images are tinted the background color.(red)
<br/>
It appears that there are horizontal lines, colored the background color,(red)
<br/>
on both of the images.
<br/>
<br/>
<br/>
none 256x256 image(256x256 is size of my backgrounds.)(actual size of image is 256x28.):
<br/>
<br/>
<br/>
The results and problems for this one is similar to the
<br/>
one similar to this in the RAM section.
<br/>
<br/>
<br/>
Only problems for this one.
<br/>
<br/>
1.
<br/>
<br/>
The whole screen is black, except part of the top of it.
<br/>
(Sub Palette index 0 is the black transparent color which is
<br/>
used to clear the buffer. There is also another non-transparent black color
<br/>
in the palette. Changing either of them dosen't do anything,
<br/>
so the black color being displayed isn't either of those colors
<br/>
in the palette.).
<br/>
<br/>
<br/>
2.
<br/>
<br/>
The part of the screen that isn't black is flickering. This one is flickering
<br/>
alot slower than the other.
<br/>
<br/>
<br/>
3.
<br/>
<br/>
The part of the screen that isn't black is the background color.(red)
<br/>
<br/>
This part of the screen is basicly the top bar, which got moved up to the top of the screen.(the bottom bar is gone.)
<br/>
The bar is half of its original size.
<br/>
<br/>
<br/>
It has horizontal lines through it, colored the background color(red).
<br/>
<br/>
<br/>
<br/>
The new source is in the my second post.</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:31 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#135379 - yellowstar - Sun Jul 22, 2007 11:11 pm</h4>
    <div class="postbody"><span class="postbody">Does anybody know of any examples,
<br/>
or any open source applications,
<br/>
that uses backgrounds,
<br/>
for both screens,
<br/>
and double buffers?
<br/>
<br/>
That should help a lot,
<br/>
but looking at an app's source
<br/>
might not help much.</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:32 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#135727 - yellowstar - Wed Jul 25, 2007 8:38 pm</h4>
    <div class="postbody"><span class="postbody">I am now using a differen't method.
<br/>
<br/>
But it still won't work right.
<br/>
<br/>
Now,
<br/>
my VCopy function does the following:
<br/>
<br/>
1. Loops through the VRAM data that is before
<br/>
the target position, and reads the value at
<br/>
the current position, then it writes
<br/>
that value to the current position.
<br/>
<br/>
2. Copies the data.
<br/>
<br/>
3. Here, it does the same thing
<br/>
as in the first step,
<br/>
except in this step it loops through
<br/>
the data after the data that is copied.
<br/>
<br/>
My vcopy function handles copying
<br/>
in the data.(Second step.)
<br/>
<br/>
Here's my problems:
<br/>
(DMA is vcopy with the dmaCopy version, and 16 bit
<br/>
is vcopy with the 16 bit copying version.)
<br/>
<br/>
Top:(index 0)
<br/>
<br/>
DMA:
<br/>
<br/>
There appears to be red horizontal lines(background color)
<br/>
through the image.
<br/>
It also appears to be flickering.
<br/>
<br/>
The image is also colored red.(the background color)
<br/>
Only the color which is used the most in that image
<br/>
is colored red.
<br/>
<br/>
16 bit:
<br/>
<br/>
Same as DMA,
<br/>
except this one has a dark red bar below it,
<br/>
like the bars near the top of this topic,
<br/>
except this one's height is the same as the
<br/>
image's height.
<br/>
<br/>
<br/>
Middle:(Not index 0 index, 32 pixels down.)
<br/>
<br/>
DMA:
<br/>
<br/>
Fine,
<br/>
no problems.
<br/>
<br/>
16 bit:
<br/>
<br/>
Same as DMA,
<br/>
except there is a black
<br/>
bar the the same width
<br/>
and height as the image
<br/>
below where the image is displayed.
<br/>
<br/>
On that bar,
<br/>
there is a few non-black pixels on it.
<br/>
<br/>
Bottom:
<br/>
<br/>
DMA:
<br/>
<br/>
Same as the top for DMA,
<br/>
except it is on the bottom,
<br/>
and it is 28 pixels higher than
<br/>
it is supposed it be.(the hight of the image.)
<br/>
<br/>
16 bit:
<br/>
<br/>
Same as the top for 16 bit,
<br/>
except it is in the same spot as DMA.
<br/>
<br/>
<br/>
Source code
<br/>
is in my above post,
<br/>
which contains the source code.</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:33 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#135874 - yellowstar - Thu Jul 26, 2007 10:18 pm</h4>
    <div class="postbody"><span class="postbody">Does anybody know of any open source librarys,
<br/>
which handles paletted backgrounds?
<br/>
<br/>
I tried commenting out the
<br/>
code for the first and last steps in VCopy,
<br/>
but that didn't do anything.
<br/>
<br/>
I tried using a modified version of bytecpy,
<br/>
but that didn't work:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u16 *src = (u16 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = *src++;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:33 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#138579 - yellowstar - Sat Aug 25, 2007 10:50 pm</h4>
    <div class="postbody"><span class="postbody">I have finally found out what was wrong with it!
<br/>
<br/>
I must have been not mapping enough VRAM for the buffers!
<br/>
<br/>
I didn't test it, though.
<br/>
<br/>
Instead, I copyed the source, and started an new project/program.
<br/>
I removed the back buffering.
<br/>
<br/>
I also have it working on both screens.
<br/>
This is for screenshots,
<br/>
since the display capture can only capture
<br/>
on the main screen.
<br/>
<br/>
Now that I can take screenshots,
<br/>
I am going to post links(in this post)
<br/>
to images showing each of the problems,
<br/>
except the one on the sub screen,
<br/>
since I don't have the code for taking screenshots
<br/>
of the sub screen.
<br/>
<br/>
I also have made it easy testing.
<br/>
I have added code so that it easy to
<br/>
test and take screenshots of problems.
<br/>
Before which copying function used and ect,(dma or scpy)
<br/>
was hard coded.
<br/>
Now all I have to do to change that stuff is,
<br/>
press the assocated button.
<br/>
<br/>
I tried implementing a scanline-by-scanline copying method.
<br/>
It would copy each scanline in the image one-by-one,
<br/>
to the target. Each scanline copyed into the target
<br/>
is supposed to be below the one before it.
<br/>
But it won't work.
<br/>
<br/>
<br/>
The SCpy function won't work.
<br/>
<br/>
<br/>
<br/>
<br/>
Here's my problems:
<br/>
<br/>
When I try to display the image on the bottom part of the screen,
<br/>
it won't display the image anywhere.
<br/>
<br/>
When I try to use the SCpy copy function,
<br/>
I get a black bar below the image,
<br/>
with some stuff on it.
<br/>
Pic <a class="postlink" href="http://img520.imageshack.us/my.php?image=bxscpy00tscreenshotkk3.png" target="_blank">Top</a> <a class="postlink" href="http://img520.imageshack.us/my.php?image=bxscpy00mscreenshotrx3.png" target="_blank">middle</a>
<br/>
<br/>
When I try to use the scanline-by-scanline copying method,
<br/>
I get a black bar with stuff below it.(seems differen't than above)
<br/>
Also, there is red,(background color)
<br/>
horizontal lines through both the image and bar.
<br/>
They are vertically a pixel apart.
<br/>
Pic <a class="postlink" href="http://img520.imageshack.us/my.php?image=bxdmalin00tscreenshotnr8.png" target="_blank">Top</a> <a class="postlink" href="http://img520.imageshack.us/my.php?image=bxdmalin00mscreenshotao7.png" target="_blank">Middle</a>
<br/>
<br/>
When I try to use both the SCpy copying function,
<br/>
and the scanline-by-scanline copying function,
<br/>
I get the same result as for when I only use
<br/>
the SCpy copying function.
<br/>
<br/>
<br/>
For the sub screen,
<br/>
I get the same results as the main screen,(above)
<br/>
except there's this additional problem:
<br/>
<br/>
When the image is in the middle,
<br/>
there is a copy of it about 32 pixels down.
<br/>
<span style="font-weight: bold">UPDATE</span> Now the normal colored image is gone,
<br/>
and this wrong image is still there.<span style="font-weight: bold">UPDATE</span>
<br/>
The copy's main colors are red.(background color)
<br/>
(By main colors I mean the colors that are used the most.)
<br/>
Since this is on the sub screen,
<br/>
I can't take a screenshot of it,(this is because I don't have
<br/>
the code for this)
<br/>
but it probably isn't needed.
<br/>
<br/>
Source code is in the above post with the source code.
<br/>
<br/>
Here's the important pieces of code:
<br/>
<br/>
VRAM and backgrounds init
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//At top of main source code file
<br/>
u16 *video_buffer_main = (u16*)BG_BMP_RAM(0);
<br/>
u16 *video_buffer_sub = (u16*)BG_BMP_RAM_SUB(0);
<br/>
<br/>
..
<br/>
<br/>
vramSetBankA(VRAM_A_MAIN_BG);
<br/>
    //Init main bg
<br/>
    BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0) | BG_PRIORITY(3);
<br/>
    //No rotation and no scale
<br/>
    BG3_XDX = 1 &lt;&lt; 8;
<br/>
    BG3_XDY = 0;
<br/>
    BG3_YDX = 0;
<br/>
    BG3_YDY = 1 &lt;&lt; 8;
<br/>
   BG3_CX = 0;
<br/>
   BG3_CY = 0;
<br/>
<br/>
   vramSetBankB(VRAM_B_MAIN_BG);
<br/>
<br/>
vramSetBankD(VRAM_D_LCD);//For screenshots
<br/>
<br/>
    //Init sub
<br/>
    SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0) | BG_PRIORITY(3);
<br/>
    //No rotation and no scale
<br/>
    SUB_BG3_XDX = 1 &lt;&lt; 8;
<br/>
    SUB_BG3_XDY = 0;
<br/>
    SUB_BG3_YDX = 0;
<br/>
    SUB_BG3_YDY = 1 &lt;&lt; 8;
<br/>
   SUB_BG3_CX = 0;
<br/>
   SUB_BG3_CY = 0;
<br/>
   
<br/>
   BG_PALETTE_SUB[8] = RGB15(0,0,31) &amp; (~BIT(15));
<br/>
   
<br/>
   BG_PALETTE_SUB[0] = RGB15(0,0,0) | BIT(15);
<br/>
   BG_PALETTE[0] = RGB15(0,0,0) | BIT(15);
<br/>
   
<br/>
   //memcpy(BG_PALETTE,PALETTE_RAW,PALETTE_RAW_size);
<br/>
   memcpy(BG_PALETTE_SUB,PALETTE_RAW,PALETTE_RAW_size);
<br/>
   memcpy(BG_PALETTE,PALETTE_RAW,PALETTE_RAW_size);
<br/>
dmaCopy(BAK_RAW,video_buffer_main,256*256);
<br/>
<br/>
//memcpy(video_buffer_sub_buff,bak_raw,256*256);
<br/>
dmaCopy(BAK_RAW,video_buffer_sub,256*256);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
VCopy and ect:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u16 *src = (u16 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = *src++;
<br/>
}
<br/>
<br/>
<br/>
<br/>
void vcopy(u16* source, u16 *target, size_t s_offset, size_t t_offset, size_t size)
<br/>
{
<br/>
<br/>
   //Copys source starting at s_offset to target starting at t_offset with
<br/>
   //size size.
<br/>
   //This Copy works with VRAM, OAM, and backgrounds.
<br/>
   
<br/>
   if(copy_type == CT_SCPY)
<br/>
   scpy(&amp;target[(int)t_offset],&amp;source[(int)s_offset],(size_t)size);
<br/>
      
<br/>
      if(copy_type == CT_DMA)
<br/>
      dmaCopy(&amp;source[(int)s_offset],&amp;target[(int)t_offset],size);
<br/>
<br/>
}
<br/>
   
<br/>
void VCopy(u16* source, u16 *target, size_t s_offset, size_t t_offset, size_t size,size_t target_width, size_t source_width)
<br/>
{
<br/>
   
<br/>
   if(beforeVRAM)
<br/>
   {
<br/>
   
<br/>
      if(t_offset!=0)
<br/>
      {
<br/>
      
<br/>
      for(int i=0; i &lt; (int)t_offset; i++)
<br/>
      target[i] = target[i];
<br/>
      
<br/>
      }
<br/>
   
<br/>
   }
<br/>
   
<br/>
   if(linear)
<br/>
   {
<br/>
    for(size_t i=0; i &lt; size; i+= source_width)
<br/>
    vcopy(source,target,s_offset + i,t_offset + i,source_width);   
<br/>
   }
<br/>
   
<br/>
   if(!linear)
<br/>
   vcopy(source,target,s_offset,t_offset,size);
<br/>
   
<br/>
   if(afterVRAM)
<br/>
   {
<br/>
   
<br/>
      if((t_offset + size)!=256)
<br/>
      {
<br/>
      
<br/>
      for(int i=(int)(t_offset+size); i &lt; (int)256*256; i++)
<br/>
      target[i] = target[i];
<br/>
      }
<br/>
   
<br/>
   }
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Draw function:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
void Draw()
<br/>
{
<br/>
<br/>
dmaCopy(BAK_RAW,video_buffer_sub,256*256);
<br/>
<br/>
dmaCopy(BAK_RAW,video_buffer_main,256*256);
<br/>
<br/>
if(!screen)
<br/>
{
<br/>
<br/>
   if(section == S_TOP)
<br/>
   VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,0,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
   
<br/>
   if(section == S_MIDDLE)
<br/>
   VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,256*32,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
   
<br/>
   if(section == S_BOTTOM)
<br/>
   VCopy((u16*)TASKBAR3_RAW,video_buffer_main,0,256*(192 - 28),(size_t)TASKBAR3_RAW_size,256,256);
<br/>
<br/>
}
<br/>
else
<br/>
{
<br/>
   if(section == S_TOP)
<br/>
   VCopy((u16*)TASKBAR3_RAW,video_buffer_sub,0,0,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
   
<br/>
   if(section == S_MIDDLE)
<br/>
   VCopy((u16*)TASKBAR3_RAW,video_buffer_sub,0,256*32,(size_t)TASKBAR3_RAW_size,256,256);
<br/>
   
<br/>
   if(section == S_BOTTOM)
<br/>
   VCopy((u16*)TASKBAR3_RAW,video_buffer_sub,0,256*(192 - 28),(size_t)TASKBAR3_RAW_size,256,256);
<br/>
}
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:34 pm; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#138790 - yellowstar - Wed Aug 29, 2007 3:13 am</h4>
    <div class="postbody"><span class="postbody">I have fixed the source code.
<br/>
<br/>
Before the video buffer for the sub screen was wrong(the parameter was 1 instead of 0, fixed),
<br/>
and the sub background base was 1 instead of 0.(fixed)
<br/>
<br/>
Now, on the sub screen, at the bottom,
<br/>
it does the same thing, except the normal colored image is gone.
<br/>
<br/>
If nobody noticed,
<br/>
I have posted links to screenshots of the main screen.
<br/>
I don't have sub screen screenshots, because,
<br/>
I don't have the code for this.(Would somebody post
<br/>
a link or something with the code for this?)
<br/>
<br/>
<span style="font-weight: bold">
<br/>
Would somebody please reply in this topic?
<br/>
I can't make much homebrew until this program works. :(
<br/>
</span></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:34 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#139336 - yellowstar - Tue Sep 04, 2007 9:45 pm</h4>
    <div class="postbody"><span class="postbody">I got the sub screen to behave just like the main screen.
<br/>
So, now that extra problem is fixed.
<br/>
<br/>
I fixed it by not mapping the extra VRAM banks
<br/>
I was mapping.
<br/>
<br/>
<span style="font-weight: bold">Would somebody please help me?
<br/>
I can't make hardly any homebrew,
<br/>
until this is solved.</span></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:35 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#139354 - HyperHacker - Wed Sep 05, 2007 1:02 am</h4>
    <div class="postbody"><span class="postbody">That garbage below your image looks like you're copying twice as much data into VRAM as you should be. Make sure you're not passing number of bytes to something that expects number of words.
<br/>
The scanline copying method looks like it's advancing both the source and destination by 2 lines instead of one, skipping every second line. Again, this might be because you've used number of bytes where you should be using number of words.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#139419 - yellowstar - Thu Sep 06, 2007 12:50 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>HyperHacker wrote:</b></span></td> </tr> <tr> <td class="quote">That garbage below your image looks like you're copying twice as much data into VRAM as you should be. Make sure you're not passing number of bytes to something that expects number of words.
<br/>
The scanline copying method looks like it's advancing both the source and destination by 2 lines instead of one, skipping every second line. Again, this might be because you've used number of bytes where you should be using number of words.</td> </tr></table><span class="postbody">
<br/>
<br/>
When I tried changing SCpy to following,
<br/>
it still isn't correct. Click the link for a screenshot.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u8 *src = (u8 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = (u16)*src++;//It dosen't matter if I typecast
<br/>
//this or not, it still won't fix it. 
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<a class="postlink" href="http://img292.imageshack.us/my.php?image=bxscpymodifiedow8.png" target="_blank">Link</a>
<br/>
<br/>
My image is an paletted image.
<br/>
So, when copying the image,(only the source,
<br/>
target is always 16 bit)
<br/>
with 16 bit,
<br/>
it copys twice as much data than
<br/>
it should be.
<br/>
But, when I use the above,
<br/>
it dosen't.
<br/>
<br/>
So, after passing the end of the image data,
<br/>
it is using data that it shouldn't be,
<br/>
resulting in garbage.</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:36 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#139423 - nce - Thu Sep 06, 2007 1:13 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I haven't read all the thread but for this problem I think that you can do that easily with this 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u16 *src = (u16 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = *src++; 
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
of course working if your image has a width multiple of 2.  otherwise, you'll have to do something like
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  u8* src = (u8 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst;
<br/>
  u8* src1 = src+1;
<br/>
<br/>
  for...
<br/>
     *dst++ =( (*src1 )&lt;&lt;8) | (*src);
<br/>
     src+=2 ; src1+=2;
<br/>
<br/>
  //and the last one
<br/>
  *dst = ((*src )&lt;&lt;8) | (*dst &amp; 0xff );
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>-jerome-</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#139426 - yellowstar - Thu Sep 06, 2007 2:41 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>nce wrote:</b></span></td> </tr> <tr> <td class="quote">Hi,
<br/>
<br/>
I haven't read all the thread but for this problem I think that you can do that easily with this 
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u16 *src = (u16 *)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = *src++; 
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
of course working if your image has a width multiple of 2.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
My image is like that.
<br/>
<br/>
Thank's, it worked!</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Oct 01, 2007 7:24 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#141926 - yellowstar - Mon Oct 01, 2007 7:19 pm</h4>
    <div class="postbody"><span class="postbody">I have found out something.
<br/>
<br/>
Whenever I try to make it draw
<br/>
the image 1 pixel below the middle position,
<br/>
it won't draw it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#141940 - nce - Tue Oct 02, 2007 12:44 am</h4>
    <div class="postbody"><span class="postbody">If drawing on frame 0 2 4 s working but 1 3 5 not it's probably a probleme of accessing memory...
<br/>
<br/>
If destination buffer is a 8bit buffer you can map it as a 16bit only on pair bit...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
8bit :   0 1 2 3 4 5 6 7 8
<br/>
16bit :  0 - 1 - 2 - 3 - 4
<br/>
</td> </tr></table><span class="postbody">
<br/>
So you can say something like  (u16) 8bit0  or (u16) 8bit2
<br/>
but it's not possible to tell (u16) 8bit 1  because the 8bit1 is not align on 16bit.....
<br/>
<br/>
hope it help
<br/>
<br/>
<br/>
EDIT :: Sorry ; Why do I wrote "frame" here ?? I was probably sleeping ...
<br/>
I mean : working at pixel position 0 2 4 ... and not 1 2 3 ....<br/>_________________<br/>-jerome-</span><span class="gensmall"><br/><br/>Last edited by nce on Wed Oct 03, 2007 4:23 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#142002 - yellowstar - Tue Oct 02, 2007 11:31 pm</h4>
    <div class="postbody"><span class="postbody">I don't think it's an frame problem.
<br/>
There isn't any flickering, or anything like that.
<br/>
<br/>
I noticed another thing.
<br/>
<br/>
When I tried to make the image go down more,
<br/>
eventually the image was displayed on the bottom screen.
<br/>
(It's supposed to stay on the top screen.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#142010 - yellowstar - Wed Oct 03, 2007 2:53 am</h4>
    <div class="postbody"><span class="postbody">I have uploaded archives of the source and binary
<br/>
of this program.
<br/>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/BackgroundsXsrc.zip" target="_blank">Source</a> <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/BackgroundsXbin.zip" target="_blank">Binary</a>
<br/>
<br/>
There is debugging functions in this.
<br/>
See the controls.txt file for the keys.
<br/>
<br/>
Here's some controls which aren't in the archives:
<br/>
Press R and L to move the image(when in the last section)
<br/>
down and up, by one pixel.(dosen't work)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#142016 - nce - Wed Oct 03, 2007 4:41 am</h4>
    <div class="postbody"><span class="postbody">Sorry for the mistake about the "frame" word I've put there, while it's not at all what I wanted to say ....
<br/>
<br/>
It's a probably a problem of memory mapping ...
<br/>
<br/>
I read fastly your code ( I'm at work no much time ). 
<br/>
The only guess I have here is this :
<br/>
<br/>
Your image background is define as a 8bit buffer, and when copying your data you copy them as 16bit.... that means that if you try ( not sure you do ) to acces backgroundbuffer[1] and try to map it on u16, it's impossible. because backgroundbuffer[1] is not align to a 16bit format, while backgroundbuffer[0] and backgroundbuffer[2] (...) are.
<br/>
<br/>
I'm more clear here than my first time?<br/>_________________<br/>-jerome-</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#142047 - yellowstar - Wed Oct 03, 2007 8:42 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for the help.
<br/>
<br/>
I thought only 16 bit writes
<br/>
are allowed for VRAM.
<br/>
<br/>
Also,
<br/>
the 8-bit setting for the backgrounds are
<br/>
for palettes.
<br/>
<br/>
I tried changing scpy to the following,
<br/>
but that didn't do anything.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u8 *src = (u8*)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = (u16)*src++;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#142060 - nce - Thu Oct 04, 2007 12:46 am</h4>
    <div class="postbody"><span class="postbody">I don't remember if I have ever do any write with 8 bit map on vram, but I remember that I wrote some 'sprite' system on top of an extended background and I probably did that this way....
<br/>
<br/>
what you wrote is wrong because you are trying to copy 16bit into 8bit with you code, meaning that you'll lose half of your data.  what you can write is this ( but again maybe it will not work )
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u8 *src = (u8*)in_src; 
<br/>
  u8 *dst = (u8 *)in_dst; 
<br/>
 
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = *src++; 
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
twice slower of course... 
<br/>
but be sure that you never try to align on a 16bit before this call... I saw in your code that this function is called after some offset on memory and stuff like that... so the problem could come from this.
<br/>
<br/>
<br/>
If I find a little time, I'll look if I still have my own code somewhere on a backup, and if it's readable I'll post it here, so you can have a look....<br/>_________________<br/>-jerome-</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#142107 - nce - Thu Oct 04, 2007 2:54 pm</h4>
    <div class="postbody"><span class="postbody">I found what I've written when I was doing some test...
<br/>
<br/>
As you said, I'm mapping the data on a 16 bit, and I can set a sprite only on even position for x
<br/>
<br/>
( as I'm doing something like  ( buffer + ( x &gt;&gt; 1 ) ) , that's means that I 'll write the sprite only on position 0 2 4 .... )
<br/>
<br/>
<br/>
any way if you want to have a look at my code, feel free :
<br/>
( I usualy comment everything, knowing that if I want to come back on that 1 year later it's much easier to reenter in )
<br/>
<br/>
<a class="postlink" href="http://www.eippers.be/forumstuff/source.rar" target="_blank">source</a>
<br/>
<br/>
( not sure this can help you )
<br/>
<br/>
<br/>
if you realy need to be able to copy your data at position 1 , you'll be force to do something like reading the 16 bit buffer at position 0  changing the 8 bit you want and write back the 16 bit
<br/>
<br/>
<br/>
ps : this code will not compile as this, while some function are link to my thread system ...<br/>_________________<br/>-jerome-</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#142136 - yellowstar - Thu Oct 04, 2007 11:16 pm</h4>
    <div class="postbody"><span class="postbody">I changed the code so it uses 8-bit now.
<br/>
So, all the copying and ect. uses 8-bit now.
<br/>
<br/>
But, now in scpy mode,
<br/>
it won't display anything.
<br/>
<br/>
When scpy uses 16-bit,
<br/>
it displays the image,
<br/>
but, it is in the wrong position.
<br/>
<br/>
For the middle position,(both modes, DMA and SCPY)
<br/>
it is displaying the image
<br/>
so its top is near the top position
<br/>
image's bottom.
<br/>
<br/>
<span style="font-weight: bold">EDIT: I have updated the downloads.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145403 - yellowstar - Wed Nov 14, 2007 10:55 pm</h4>
    <div class="postbody"><span class="postbody">Anyone?
<br/>
<br/>
I tried changing (typecast)
<br/>
the target to 16-bit, and
<br/>
source to 8-bit.(image is 8-bit, in file)
<br/>
<br/>
But, that won't work either.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u8 *src = (u8*)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
<br/>
  for(; length &gt; 0; length--) 
<br/>
    *dst++ = (u16)*src++;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Any other examples and such?
<br/>
<br/>
What is the correct way to
<br/>
do this, with the SCpy
<br/>
and DMA methods?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145467 - yellowstar - Fri Nov 16, 2007 1:56 am</h4>
    <div class="postbody"><span class="postbody">Anybody?
<br/>
<br/>
I got it working again.(SCpy)
<br/>
(I never knew before that every 16-bit value
<br/>
for 8-bit BG BPP mode has values for 2 pixels.)(In VRAM,
<br/>
for BGs.)
<br/>
<br/>
As I said before,
<br/>
does anybody know
<br/>
of any examples on this?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
  u8 *src = (u8*)in_src; 
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  u16 temp=0;
<br/>
  u8 pix1;
<br/>
  u8 pix2;
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
<br/>
  for(; length &gt; 0; length--)
<br/>
  {
<br/>
  pix1=*src++;
<br/>
  pix2=*src++;
<br/>
        
<br/>
  temp= pix1 | (pix2&lt;&lt;8);
<br/>
  
<br/>
    *dst++ = temp;
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145469 - Lick - Fri Nov 16, 2007 2:28 am</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://forum.gbadev.org/viewforum.php?f=18" target="_blank">View topic</a>
<br/>
<br/>
8-bit bmp background!<br/>_________________<br/><a class="postlink" href="http://licklick.wordpress.com" target="_blank">http://licklick.wordpress.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145470 - yellowstar - Fri Nov 16, 2007 2:41 am</h4>
    <div class="postbody"><span class="postbody">That's the wrong URL.(it goes to the DS dev forum)
<br/>
Don't you mean this <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=14524" target="_blank">topic?</a>(The 512x512 8-bit BG topic)
<br/>
<br/>
That's where I found the
<br/>
correct way to do my scpy method.(I tried
<br/>
something similar to it,(before I saw the example posted there)
<br/>
But it didn't work right.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149412 - yellowstar - Sat Jan 19, 2008 9:35 pm</h4>
    <div class="postbody"><span class="postbody">I got this to work with this image. But, when I try a 32x32 image, otherwise...
<br/>
<br/>
The original downloads have been removed. Here's the new <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/BackgroundsX.zip" target="_blank">download</a>, which
<br/>
contains both the source and binaries.
<br/>
<br/>
The screen shot is included in the download. However, here's a <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/BGXscreenshot.bmp" target="_blank">mirror</a> of that screen shot. Also, here's an <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/Taskbar3.bmp" target="_blank">mirror</a> of the original image. The original image is in Data2/taskbar3.bmp(Note that this isn't a task bar anymore for this image)
<br/>
See the data directory for the palette and the RAW directories.
<br/>
<br/>
The displayed image is an ~4xSCREEN_WIDTH image.
<br/>
It doesn't matter if SCpy or DMA is used for copying, or if the scanline
<br/>
copying is used. It looks like it is doing the normal, non-scanline copying
<br/>
method. It seems to copy the first scanline onto the wanted scanline. But,
<br/>
it now copies the next line unto the <span style="font-weight: bold">same</span> scanline. It keeps targeting the same scanline until it reaches the edge of the screen, then
<br/>
it goes to the next scanline.
<br/>
<br/>
About the original issue:
<br/>
Indeed, it was an alignment problem. The image was u8*, while the bg
<br/>
ram was u16*. Once I switched the bg to u8* everywhere but SCpy,
<br/>
it worked. The image was disappearing because it was being put someplace in the bg VRAM, which could have been seen if the bg was position in the right place. The bg ram being u16* caused that.
<br/>
<br/>
EDIT: I solved this problem. But, the image is distorted whenever the image width is not a multiple of 2. I'll post about it after I try nce's code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149635 - yellowstar - Wed Jan 23, 2008 3:12 am</h4>
    <div class="postbody"><span class="postbody">I've solved the previous problem. Now, I'm having another problem.
<br/>
We're getting really close to 100% solving this for good!
<br/>
<br/>
The image is fine when the width is a multiple of 2. But, not so when
<br/>
otherwise. The results for <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/SCPYscreenshot.bmp" target="_blank">SCPY</a> and <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/DMAscreenshot.bmp" target="_blank">DMA</a> are significantly different.
<br/>
(These links are the new screen shots. The screen shot with the download has been removed. The <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/BackgroundsX.zip" target="_blank">download </a>has been updated)
<br/>
(The binaries have been removed from the download. That only has the source now. You must compile it to get the binaries.)
<br/>
<br/>
Look at the screen shots for the explanation.
<br/>
SCPY uses nce's code.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//Is I an multiple of 2? Used for scpy.
<br/>
bool IsM2(int I)
<br/>
{
<br/>
int i=2;
<br/>
if(I&lt;i)return 0;//It's not an multiple of 2 if it's smaller than 2!
<br/>
<br/>
 while(i&lt;I)
<br/>
 {
<br/>
 i+=2;
<br/>
 
<br/>
  if(i==I)return 1;
<br/>
 }
<br/>
 
<br/>
 return 0;
<br/>
<br/>
}
<br/>
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
<br/>
  if(0)//Only use the second block of code
<br/>
  {
<br/>
  //Multiple of 2 code
<br/>
  }
<br/>
  else
<br/>
  {
<br/>
  //Non-multiple of 2 code
<br/>
  //This is nce's code
<br/>
  
<br/>
  u8* src = (u8 *)in_src;
<br/>
  u16 *dst = (u16 *)in_dst;
<br/>
  u8* src1 = src+1;
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
<br/>
  for(; length &gt; 1; length--)
<br/>
  {
<br/>
     *dst++ =( (*src1 )&lt;&lt;8) | (*src);
<br/>
     src+=2 ; src1+=2;
<br/>
  }
<br/>
<br/>
  //and the last one
<br/>
  *dst = ((*src )&lt;&lt;8) | (*dst &amp; 0xff ); 
<br/>
  
<br/>
  }
<br/>
  
<br/>
}
<br/>
<br/>
<br/>
<br/>
void vcopy(u8* source, u8 *target, size_t s_offset, size_t t_offset, size_t size)
<br/>
{
<br/>
<br/>
   //Copys source starting at s_offset to target starting at t_offset with
<br/>
   //size size.
<br/>
   //This Copy works with VRAM, OAM, and backgrounds.
<br/>
   
<br/>
   if(copy_type == CT_SCPY)
<br/>
   scpy(&amp;target[(int)t_offset],&amp;source[(int)s_offset],(size_t)size);
<br/>
      
<br/>
      if(copy_type == CT_DMA)
<br/>
      dmaCopy(&amp;source[(int)s_offset],&amp;target[(int)t_offset],size);
<br/>
<br/>
}
<br/>
   
<br/>
void VCopy(u8* source, u16 *target, size_t s_offset, size_t t_offset, size_t size,size_t target_width, size_t source_width)
<br/>
{
<br/>
   
<br/>
   if(linear)
<br/>
   {
<br/>
   size_t I=0;
<br/>
    for(size_t i=0; i &lt; size; i+= source_width)
<br/>
    {
<br/>
    vcopy((u8*)source,(u8*)target,s_offset + i,t_offset + I,source_width);
<br/>
    I+=target_width;
<br/>
    }
<br/>
   }
<br/>
   
<br/>
   if(!linear)
<br/>
   vcopy((u8*)source,(u8*)target,s_offset,t_offset,size);
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Thu Jan 24, 2008 2:23 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#149644 - nce - Wed Jan 23, 2008 8:14 am</h4>
    <div class="postbody"><span class="postbody">Hi yellowstar,
<br/>
<br/>
When I gave you that small code back then it was more a way to think, I've never test it so I can't be sure it's correct :(
<br/>
<br/>
at first I was thinking about a casting probleme u16 = u8 A&lt;&lt;8 | u8 B ( there is a chance that it will do A&lt;&lt;8 = 0 (offset the 8 in a 8bits data). and 0 | B =  B )  But if it was like that you'll have one pixel correct one pixel unchanged...
<br/>
<br/>
the distortion part looks more like a bug I had myself once: I was wrongly computing the offset for the next scanline.  you may think of something like your image is 5pixels width but you wrote 6pixels
<br/>
<br/>
the fact that it looks like repeating twice the picture side to side is harder to understand.  maybe you set your length twice the size of the real image ? it looks like copying the first line then next to that copying the seconde line and then going to the next scanline ( don't forget that you are not incrementing by src++ but by src+=2 ) 
<br/>
but it should give you garbage after the middle of the picture....
<br/>
<br/>
I hope you'll find the problem :)<br/>_________________<br/>-jerome-</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149667 - elhobbs - Wed Jan 23, 2008 5:25 pm</h4>
    <div class="postbody"><span class="postbody">in scpy in nce's code you forgot to adjust length from u8 to u16. as evidence the image is twice as wide as it should be and the right image is shifted up one pixel - so you are drawing the next scan line next to the current scan line. as a note the current code does not properly handle unaligned destinations or odd width sizes properly.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  length &gt;&gt;= 1;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I am guessing that this is clipped from a larger project ( so I am seeing it out of context), but it seams rather complex for such a simple operation.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149694 - yellowstar - Thu Jan 24, 2008 2:52 am</h4>
    <div class="postbody"><span class="postbody">I have added the length code. The source has been updated.(In the previous post)
<br/>
<br/>
The SCPY result is almost the same as DMA, except for a red/background color vertical line through it. 
<br/>
<br/>
The screenshots have been updated: <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/SCPYscreenshot.bmp" target="_blank">SCPY</a> <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/DMAscreenshot.bmp" target="_blank">DMA</a>
<br/>
The <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/BackgroundsX.zip" target="_blank">download </a>has been updated
<br/>
<br/>
@elhobbs:
<br/>
??? Switching the length var's type wouldn't change anything... It's a unsigned int/size_t.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elhobb wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
length &gt;&gt;= 1; 
<br/>
</td> </tr></table><span class="postbody">
<br/>
but it seams rather complex for such a simple operation.
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
That's a fast way to do a division by 2 operation... Most compilers convert
<br/>
such divisions to this code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149706 - nce - Thu Jan 24, 2008 5:33 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elhobb wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
length &gt;&gt;= 1; 
<br/>
</td> </tr></table><span class="postbody">
<br/>
but it seams rather complex for such a simple operation.
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
That's a fast way to do a division by 2 operation... Most compilers convert
<br/>
such divisions to this code.</span></td> </tr></table><span class="postbody">
<br/>
elhobb was speaking about the code it self not the &gt;&gt;1 :)
<br/>
<br/>
not sure both screenshot have been updated :) scpy and dma looks quite different to me :)
<br/>
<br/>
the red line feel like we are copying stuff in the wrong order here (like writting 2 1 4 3 6 5) try doing this then :
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
for(; length &gt; 1; length--) 
<br/>
  { 
<br/>
     *dst++ =( (*src )&lt;&lt;8) | (*src1); 
<br/>
     src+=2 ; src1+=2; 
<br/>
  } 
<br/>
<br/>
  //and the last one 
<br/>
  *dst = (*src ) | ((*dst &amp; 0xff )&lt;&lt;8);
<br/>
  // OR
<br/>
  *dst = (*src ) | (*dst &amp; 0xff00 ); 
<br/>
</td> </tr></table><span class="postbody">
<br/>
I've inverted src and src1
<br/>
I told you I've never tested it :)<br/>_________________<br/>-jerome-</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149722 - elhobbs - Thu Jan 24, 2008 2:04 pm</h4>
    <div class="postbody"><span class="postbody">the vertical line is a result of improperly handling non-even destination and width horizontal values. the code should like somehing like his. obviously this is not complete code but the comments should make it clear what needs to happen.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u8 *src8;//source 8 bit pixels
<br/>
u8 *dest8;//unaligned destination 8 bit
<br/>
u16 *dest16//aligned destination 16 bit
<br/>
u16 pixel16;//temporary for holding two 8 bit pixels
<br/>
<br/>
dest16 = dest8;
<br/>
if (dest8 &amp; 1)
<br/>
{
<br/>
dest16 = dest8 -1;
<br/>
  //handle single pixel write
<br/>
//read both pixels from the destination
<br/>
pixel16 = *dest16
<br/>
//we want to keep the first byte
<br/>
pixel16 &amp;= 0xff;
<br/>
//and replace the second byte
<br/>
pixel16 |= ((*src8++)&lt;&lt;8);
<br/>
//and write both values back
<br/>
*dest16++ = pixel16;
<br/>
}
<br/>
<br/>
length16 = length&gt;&gt;1;
<br/>
//now the destination will be aligned to 16bit value
<br/>
//so handle all of the two pixel writes we can
<br/>
while(length16)
<br/>
{
<br/>
pixel16= *src8++;
<br/>
pixel16 |= ((*src8++)&lt;&lt;8);
<br/>
*dest16++ = pixel16;
<br/>
length16--;
<br/>
}
<br/>
<br/>
//if the length is odd then write the last byte
<br/>
if(length&amp;1)
<br/>
{
<br/>
  //handle single pixel write
<br/>
//read both pixels
<br/>
pixel16 = *dest16
<br/>
//we want to keep the second byte
<br/>
pixel16 &amp;= 0xff00;
<br/>
//and replace the first byte
<br/>
pixel16 |= *src8++;
<br/>
//and write both values back
<br/>
*dest16++ = pixel16;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149764 - yellowstar - Fri Jan 25, 2008 1:26 am</h4>
    <div class="postbody"><span class="postbody">The SCPY image is the same as <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/DMAscreenshot.bmp" target="_blank">DMA</a> when using nce's original code.(Multiple of 2 code)(Even though the image is not a power of 2)
<br/>
But, when using the non-power of 2 code, this <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/nSCPYscreenshot.bmp" target="_blank">happens.</a>
<br/>
(The new code)
<br/>
<br/>
This <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/eSCPYscreenshot.bmp" target="_blank">happens</a> with elhobbs code.(It's basicly the same code as he posted)
<br/>
As you can see, some of the right side of the image is chopped off, but still with the same distortion.
<br/>
<br/>
When decreasing the length by 2, the image resembles the wanted image better, but it's still wrong.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149774 - yellowstar - Fri Jan 25, 2008 4:22 am</h4>
    <div class="postbody"><span class="postbody">Here's some debugging data via FAT:(DMA)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Scanline 1 T 0x6000000 S 0x206bb6c Length 30
<br/>
Scanline 2 T 0x6000100 S 0x206bb8a Length 30
<br/>
Scanline 3 T 0x6000200 S 0x206bba8 Length 30
<br/>
Scanline 4 T 0x6000300 S 0x206bbc6 Length 30
<br/>
Scanline 5 T 0x6000400 S 0x206bbe4 Length 30
<br/>
Scanline 6 T 0x6000500 S 0x206bc02 Length 30
<br/>
Scanline 7 T 0x6000600 S 0x206bc20 Length 30
<br/>
Scanline 8 T 0x6000700 S 0x206bc3e Length 30
<br/>
Scanline 9 T 0x6000800 S 0x206bc5c Length 30
<br/>
Scanline 10 T 0x6000900 S 0x206bc7a Length 30
<br/>
Scanline 11 T 0x6000a00 S 0x206bc98 Length 30
<br/>
Scanline 12 T 0x6000b00 S 0x206bcb6 Length 30
<br/>
Scanline 13 T 0x6000c00 S 0x206bcd4 Length 30
<br/>
Scanline 14 T 0x6000d00 S 0x206bcf2 Length 30
<br/>
Scanline 15 T 0x6000e00 S 0x206bd10 Length 30
<br/>
Scanline 16 T 0x6000f00 S 0x206bd2e Length 30
<br/>
Scanline 17 T 0x6001000 S 0x206bd4c Length 30
<br/>
Scanline 18 T 0x6001100 S 0x206bd6a Length 30
<br/>
Scanline 19 T 0x6001200 S 0x206bd88 Length 30
<br/>
Scanline 20 T 0x6001300 S 0x206bda6 Length 30
<br/>
Scanline 21 T 0x6001400 S 0x206bdc4 Length 30
<br/>
Scanline 22 T 0x6001500 S 0x206bde2 Length 30
<br/>
Scanline 23 T 0x6001600 S 0x206be00 Length 30
<br/>
Scanline 24 T 0x6001700 S 0x206be1e Length 30
<br/>
Scanline 25 T 0x6001800 S 0x206be3c Length 30
<br/>
Scanline 26 T 0x6001900 S 0x206be5a Length 30
<br/>
Scanline 27 T 0x6001a00 S 0x206be78 Length 30
<br/>
Scanline 28 T 0x6001b00 S 0x206be96 Length 30
<br/>
Scanline 29 T 0x6001c00 S 0x206beb4 Length 30
<br/>
Scanline 30 T 0x6001d00 S 0x206bed2 Length 30
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The target is fine. So is the source...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149775 - yellowstar - Fri Jan 25, 2008 4:39 am</h4>
    <div class="postbody"><span class="postbody">I'm now using a new image. Here's the <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/newOriginal.bmp" target="_blank">original.</a>
<br/>
<br/>
Here's the new DMA <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/newDMAscreenshot.bmp" target="_blank">screenshot.</a>
<br/>
<br/>
EDIT:
<br/>
One thing I noticed is that the top part is 15 pixels, instead of the wanted 16.
<br/>
<br/>
I wonder where these black lines are coming from... This image doesn't even have black...(Neither does the palette)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150317 - yellowstar - Fri Feb 01, 2008 9:21 pm</h4>
    <div class="postbody"><span class="postbody">Anybody?
<br/>
<br/>
I'm going to PM several other members about this problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150328 - tepples - Sat Feb 02, 2008 3:53 am</h4>
    <div class="postbody"><span class="postbody">I think .bmp rounds the width of each scanline up to some even number of bytes, and that's where the black line is coming from.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150353 - yellowstar - Sat Feb 02, 2008 8:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">I think .bmp rounds the width of each scanline up to some even number of bytes, and that's where the black line is coming from.</td> </tr></table><span class="postbody">
<br/>
<br/>
That's the format I'm using. Looks like I need to use another format...
<br/>
<br/>
By the way, you are on the list of people I was going to PM, tepples.(But I'm still going to PM if the replies to this topic stops.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150360 - yellowstar - Sun Feb 03, 2008 2:21 am</h4>
    <div class="postbody"><span class="postbody">ALMOST done!
<br/>
<br/>
What you suggested tepples worked! Not only did it remove the black lines, it also fixed the distortion problem! Now, the image is drawn  almost perfectly!(But only one stationary)(But I had to use the original SCPY code.(nce's original code))
<br/>
(I switched from bmp to pcx. I wanted to use png or tga, but gfx2gba doesn't work with those formats. And I'm not using grit. I tried that, and I did NOT like it. gfx2gba readme says it supports tga, but it does not. I just get the unsupported format error with those formats.)
<br/>
<br/>
There's a minor problem with the background color being yellow, instead of the red I want... Hopefully that will be an easy-to-fix problem...
<br/>
<br/>
When I constantly move the image in any direction, some parts of the image
<br/>
are shifted.(SCPY/DMA copy mode doesn't matter)
<br/>
<br/>
Moving down = Down-right section of image is shifted down by about 2 pixels, with some white pixels drawn to the left of it.
<br/>
Moving up = Down-right section of image is shifted down by about 1 pixel, with some white pixels drawn to the left of it.
<br/>
Moving left = Top-left section of image is shifted left by about 2 pixels, without any white pixels.
<br/>
Moving right = N/A(The top-right section's color is the same as the background, making it hard to see if this movement is affected.)
<br/>
<br/>
Here's a <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/DMAscreenshot.bmp" target="_blank">screenshot.</a> This one doesn't contain any useful debugging info however. I am going to add screenshots of the all of the above movement graphic problems, after I I fix that background color problem. I had that problem before... I had to    do some hackery to fix it...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150708 - yellowstar - Mon Feb 11, 2008 2:12 am</h4>
    <div class="postbody"><span class="postbody">Anybody?
<br/>
<br/>
I can't show any screenshots... This problem only happens when the image is moving, and it can't move when taking a screenshot... I can't use any Emu, as this problem doesn't appear in them. This problem is in a old backup of this program, also.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#151495 - yellowstar - Wed Feb 27, 2008 9:55 pm</h4>
    <div class="postbody"><span class="postbody">Anybody?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#151507 - tepples - Thu Feb 28, 2008 4:34 am</h4>
    <div class="postbody"><span class="postbody">Camcorder?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#151586 - yellowstar - Sat Mar 01, 2008 12:04 am</h4>
    <div class="postbody"><span class="postbody">Didn't think about that. There's a new Vista laptop here,(Not mine :( )
<br/>
and it has a really good Web Cam built-in.(Capture video with it, if I'm get permission...)(And there's a new Vista desktop here, which replaced my old Compaq Win98. No Web Cam in that one though. No more anything about Win98 from me, here, anymore.)
<br/>
<br/>
And I'd have to wait on slow Dial-Up to upload...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#151680 - yellowstar - Mon Mar 03, 2008 5:20 am</h4>
    <div class="postbody"><span class="postbody">That camera didn't work. I couldn't see anything wrong when looking through it. I'll try the Web Cam soon.
<br/>
<br/>
I'm trying to capture screenshots  which work with moving images, but it won't work. Even with a still image. I get yellow on the top half of the shot, black on the bottom.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u8 capture_buffer[256];
<br/>
u16 capture_buffer2[256];
<br/>
bool taking_screenshot=0;
<br/>
u16 *screenshot_buffer = NULL;
<br/>
int screenshot_pos=0;
<br/>
<br/>
void TakeScreenshot()
<br/>
{
<br/>
if(screenshot_buffer==NULL)
<br/>
screenshot_buffer = (u16*)malloc(256*192*2);
<br/>
<br/>
screenshot_pos=0;
<br/>
<br/>
swiWaitForVBlank();
<br/>
taking_screenshot=1;//Start capturing.  The following function takes care of the rest.
<br/>
}
<br/>
<br/>
void HBlank_interrupt()
<br/>
{
<br/>
if(hblank_wait){hblank_wait=0;return;}
<br/>
<br/>
 if(taking_screenshot)
<br/>
 {
<br/>
 
<br/>
 dmaCopy(&amp;video_buffer_main[screenshot_pos],capture_buffer,256);
<br/>
 for(int i=0; i&lt;256; i++)capture_buffer2[i]=(u16)capture_buffer[i];
<br/>
 dmaCopy(capture_buffer2,&amp;(((u8*)screenshot_buffer)[screenshot_pos]),256);
<br/>
 
<br/>
 screenshot_pos+=256;
<br/>
 
<br/>
 if(screenshot_pos&gt;=192*256)taking_screenshot=0;
<br/>
 
<br/>
 if(!taking_screenshot)
<br/>
 {
<br/>
  
<br/>
  //dmaCopy(VRAM_D,screenshot_buffer,256*192*2);
<br/>
  
<br/>
  FILE *f = NULL;
<br/>
  char str[256];
<br/>
  char str2[256];
<br/>
  char str3[256];
<br/>
  strcpy(str,"");
<br/>
  strcpy(str2,"");
<br/>
  strcpy(str3,"");
<br/>
  
<br/>
  sprintf(str2,"%s",str3);//copy_type?"SCPY":"DMA"
<br/>
  
<br/>
  sprintf(str,"/%sscreenshot.bin",str2);
<br/>
  
<br/>
  f = fopen(str,"wb");
<br/>
  
<br/>
  fwrite(screenshot_buffer,2,256*192,f);
<br/>
  
<br/>
  fclose(f);
<br/>
  
<br/>
  sprintf(str,"/%sscreenshot.bmp",str2);
<br/>
  
<br/>
  screenshotbmp(str, screenshot_buffer);
<br/>
  
<br/>
  //if(screenshot_buffer)
<br/>
  //free(screenshot_buffer);
<br/>
  
<br/>
  //taking_screenshot=0;
<br/>
  
<br/>
  }
<br/>
 }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#151995 - yellowstar - Fri Mar 07, 2008 11:40 pm</h4>
    <div class="postbody"><span class="postbody">Tried both a camera and that Web Cam, but both failed. I heard somebody here has access to the Nitro screenshot kit.(Not sure if it can take videos)
<br/>
However, my graphics converter crashed,(gfx2gba)
<br/>
and I was forced to switch to something else.(GRIT)
<br/>
However, it doesn't work as I want. It doesn't merge the palettes. So,
<br/>
I can't use it right now. I'm working on a way to get around this.
<br/>
<br/>
BUT!
<br/>
<br/>
Even worse!
<br/>
<br/>
My DS-X, the only homebrew device that I have, BROKE. It fell on the floor, while it was in my DS.(USB cord connected and everything)
<br/>
It's about the same age as my backgrounds problem, 8-months. My DS-X is bent.  The lights on it doesn't stay on when connected to a computer. Those lights, in that case, means the DS-X is connected to the computer. It seems it still works after the light come on, then goes back off. But, my DS doesn't recognize it anymore. However, I managed to backup everything on it.
<br/>
<br/>
This DS-X cost me $130. Fortunately, the retailer is <span style="text-decoration: underline">supposed</span> to handle the warranty. When they don't, the DS-X team will take care of it. I haven't investigated this yet.(About whether they we take care of warranty)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#152012 - HyperHacker - Sat Mar 08, 2008 4:50 am</h4>
    <div class="postbody"><span class="postbody">The warranty covers you dropping it and breaking it? That's one heck of a warranty.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#152013 - yellowstar - Sat Mar 08, 2008 5:10 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>HyperHacker wrote:</b></span></td> </tr> <tr> <td class="quote">The warranty covers you dropping it and breaking it? That's one heck of a warranty.</td> </tr></table><span class="postbody">
<br/>
Hopefully. What I said about the warranty is about in most cases.
<br/>
<br/>
EDIT:
<br/>
I asked if the warranty covers a broken DS-X, on the DS-X support tracker. Time to wait...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#152378 - yellowstar - Fri Mar 14, 2008 4:44 pm</h4>
    <div class="postbody"><span class="postbody">Maybe it would work, or possiblely do something else, if I start using double-buffers again...
<br/>
<br/>
I recently tried emulating this with the latest DeSUme, and it the result look kindof like the problem on DS. I tried capturing a video of it.(Not built-in, some other software I found before this)
<br/>
The video is around 5 MB... And I'm stuck with Dial-Up... I might get around to it eventually... (It's on my other computer. This emu I used dosen't work on this XP I am using right now... I have WiFi setup on this XP, via the Nintendo dongle and official drivers. That is temporary. It will be replaced by another dongle, for homebrew. And with WiFi running on this computer, it's a bad idea to be downloading/uploading with Dial-Up and WiFi...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153682 - yellowstar - Thu Apr 03, 2008 10:03 pm</h4>
    <div class="postbody"><span class="postbody">I have found a trick to get my DS-X to work on DS.(Still waiting on a response from support tracker...)
<br/>
Here's the trick: I have the USB cord plugged into the DS-X, but not the computer. Next I push the end of the cord,(The end at the DS-X)
<br/>
towards the DS, then keep my finger in that position until it finishes loading the homebew.(It's like the Games 'n Music nightmare all over again...)
<br/>
<br/>
I have tested my new version of this problem, with Double Buffers. Now, all I see is the background, not the image that's supposed to be displayed...
<br/>
(I tried changing it to be similar to dovoto's tutorial, but nothing changed for the displayed images...)
<br/>
(I tried decreasing BG_MAX, but the displayed image was wrong, among other things. And since dovoto said that that's supposed to be 3, I decided not to post about what happened with that.)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define BG_MAX 4
<br/>
<br/>
u8 *video_buffer_main = (u8*)BG_BMP_RAM(0);
<br/>
u8 *video_buffer_sub = (u8*)BG_BMP_RAM_SUB(0);
<br/>
<br/>
bool which_buffer=1;
<br/>
<br/>
void SwapBuffers()
<br/>
{
<br/>
   if(which_buffer)
<br/>
   {
<br/>
   video_buffer_main = (u8*)BG_BMP_RAM(BG_MAX);
<br/>
   video_buffer_sub = (u8*)BG_BMP_RAM_SUB(BG_MAX);
<br/>
   
<br/>
   BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0) | BG_PRIORITY(3);
<br/>
   SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0) | BG_PRIORITY(3);
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
   video_buffer_main = (u8*)BG_BMP_RAM(0);
<br/>
   video_buffer_sub = (u8*)BG_BMP_RAM_SUB(0);
<br/>
   
<br/>
   BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX) | BG_PRIORITY(3);
<br/>
   SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX) | BG_PRIORITY(3);
<br/>
   }
<br/>
   
<br/>
   which_buffer = !which_buffer;
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   powerON(POWER_ALL);
<br/>
   
<br/>
   irqInit();
<br/>
    irqEnable(IRQ_VBLANK);
<br/>
   
<br/>
    videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
   videoSetModeSub(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
<br/>
    vramSetBankA(VRAM_A_MAIN_BG);
<br/>
    //Init main bg
<br/>
    BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX) | BG_PRIORITY(3);
<br/>
    //No rotation and no scale
<br/>
    BG3_XDX = 1 &lt;&lt; 8;
<br/>
    BG3_XDY = 0;
<br/>
    BG3_YDX = 0;
<br/>
    BG3_YDY = 1 &lt;&lt; 8;
<br/>
   BG3_CX = 0;
<br/>
   BG3_CY = 0;
<br/>
<br/>
   vramSetBankD(VRAM_D_LCD);//For screenshots
<br/>
<br/>
   vramSetBankC(VRAM_C_SUB_BG);
<br/>
    
<br/>
//Init sub
<br/>
   SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX) | BG_PRIORITY(3);
<br/>
    //No rotation and no scale
<br/>
    SUB_BG3_XDX = 1 &lt;&lt; 8;
<br/>
    SUB_BG3_XDY = 0;
<br/>
    SUB_BG3_YDX = 0;
<br/>
    SUB_BG3_YDY = 1 &lt;&lt; 8;
<br/>
   SUB_BG3_CX = 0;
<br/>
   SUB_BG3_CY = 0;
<br/>
   
<br/>
dmaCopy(BAK_RAW,video_buffer_main,256*256);
<br/>
dmaCopy(BAK_RAW,(u8*)BG_BMP_RAM(BG_MAX),256*256);
<br/>
dmaCopy(BAK_RAW,video_buffer_sub,256*256);
<br/>
dmaCopy(BAK_RAW,(u8*)BG_BMP_RAM_SUB(BG_MAX),256*256);
<br/>
<br/>
    while(1)
<br/>
   {
<br/>
   swiWaitForVBlank();
<br/>
   SwapBuffers();
<br/>
   Draw();
<br/>
   Step();
<br/>
   
<br/>
   }
<br/>
    
<br/>
    return 0;
<br/>
}
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153739 - yellowstar - Fri Apr 04, 2008 10:01 pm</h4>
    <div class="postbody"><span class="postbody">I got the Double Buffers working. But, now it's doing exactly the same thing that it was doing before.(The graphic problem when the image is moving)
<br/>
(By the way, I updated the code in the above post)
<br/>
<br/>
I tried changing the code so it only displays only one scanline, but had the same movement problem...
<br/>
<br/>
Help!
<br/>
<br/>
EDIT:
<br/>
Removed statement stating that the scanlines were cut in half. One of the squares in the image is the same color as the background, so the scanlines looked like they were cut in half.
<br/>
<br/>
EDIT2:
<br/>
I tried the following, but still NOTHING changed, even with only drawing one scanline! HELP!
<br/>
<br/>
Remember, whether or not the image's width is a power of 2 or not, doesn't change anything.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void VCopy(u8* source, u8 *target, size_t s_offset, size_t t_offset, size_t size,size_t target_width, size_t source_width)
<br/>
{
<br/>
   size_t so, to;
<br/>
   so=s_offset;
<br/>
   to=t_offset;
<br/>
   if(linear)
<br/>
   {
<br/>
   size_t I=0;
<br/>
   size_t i=0;
<br/>
    for(i=0; i &lt; size; i+= source_width)
<br/>
    {
<br/>
    //vcopy(source,target,so+i,to+I,source_width);
<br/>
         dmaCopy(&amp;source[(int)so+i],&amp;target[(int)to+I],(uint32)source_width);
<br/>
    I+=target_width;
<br/>
    }
<br/>
   }
<br/>
   
<br/>
   if(!linear)
<br/>
   vcopy(source,target,so,to,size);
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153830 - yellowstar - Mon Apr 07, 2008 12:37 am</h4>
    <div class="postbody"><span class="postbody">I tried changing the speed var to 2, instead of 1, but that didn't help anything. It must not be an alignment problem...(speed is a var that dictates the number of pixels the image moves every vblank if it's supposed to move)
<br/>
<br/>
Anybody?
<br/>
<br/>
<span style="font-weight: bold">EDIT:</span>
<br/>
I discovered something.
<br/>
<br/>
When I attempt to make it display only the first pixel of the image, that causes major chaos. Nothing appears on the main screen, where the pixel is supposed to appear.
<br/>
<br/>
On the sub screen, the whole screen is flickering. About 32 pixels down, there's this thin purple-ish bar stretching across the screen. At the bottom, there's this black bar that looks like the original image I was using at first,(The Win98 taskbar)
<br/>
except it's inverted.(Mainly black for most of the image)
<br/>
Above that is a short purple bar, stretching across the screen. And above that bar is some black stuff.
<br/>
<br/>
Nothing is displayed on either screen when I try to switch screens, or copy modes.
<br/>
<br/>
This buggy gfx2gba turned my background color from yellow to green...(This happened when I was editing the graphic files)
<br/>
(I can live with it)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154134 - yellowstar - Fri Apr 11, 2008 8:53 pm</h4>
    <div class="postbody"><span class="postbody">I fixed that one-pixel problem:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void vcopy(u8* source, u8 *target, size_t s_offset, size_t t_offset, size_t size)
<br/>
{
<br/>
<br/>
   //Copys source starting at s_offset to target starting at t_offset with
<br/>
   //size size.
<br/>
   //This Copy works with VRAM, OAM, and backgrounds.
<br/>
   
<br/>
   /*u16 *Tar = (u16*)&amp;target[(int)t_offset];
<br/>
   *Tar = 1 | 1 &gt;&gt; 8;
<br/>
   return; &lt;------ Tried this code, but same-old-same-old problem*/
<br/>
   
<br/>
   if((t_offset+1)%2==0)
<br/>
   {
<br/>
   u16 temp=0;
<br/>
   u16 *tar = (u16*)&amp;target[(int)t_offset];
<br/>
   temp = (u16)target[(int)t_offset];
<br/>
   temp |= ((u16)source[(int)s_offset]) &gt;&gt; 8;
<br/>
   
<br/>
   *tar = temp;
<br/>
   t_offset++;
<br/>
   s_offset++;
<br/>
   size--;
<br/>
   }
<br/>
   else if(size==1)
<br/>
   {
<br/>
   u16 temp=0;
<br/>
   u16 *tar = (u16*)&amp;target[(int)t_offset];
<br/>
   temp |= ((u16)source[(int)s_offset]);
<br/>
   temp |= (u16)target[(int)t_offset] &gt;&gt; 8;
<br/>
   
<br/>
   *tar = temp;
<br/>
   t_offset++;
<br/>
   s_offset++;
<br/>
   
<br/>
   return;
<br/>
   }
<br/>
   
<br/>
   if(copy_type == CT_SCPY)
<br/>
   scpy(&amp;target[(int)t_offset],&amp;source[(int)s_offset],size);
<br/>
      
<br/>
      if(copy_type == CT_DMA)
<br/>
      {
<br/>
      dmaCopy(&amp;source[(int)s_offset],&amp;target[(int)t_offset],(uint32)size);
<br/>
      }
<br/>
   }
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Is it legal for a homebrewer, to help another homebrewer by using the official Nitro Capture toolkit to capture a video of a 9-month-old problem?(Can that toolkit capture videos?)
<br/>
(In other words, would it be legal for another person here to help me, and capture a video with that toolkit of this problem?)
<br/>
<br/>
I tried using dmaCopy to capture screenshots of both the front and back buffers, but still nothing. I tried clearing the back buffer 10 times instead of once, but the program really slowed down, and the glitch still was there.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gbatek wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Capture provides a couple of interesting effects.
<br/>
Another example would be to capture Engine A output, the captured image can be displayed (via VRAM Display mode) in the following frames, simultaneously the new Engine A output can be captured, blended with the old captured image; in that mode moved objects will leave traces on the screen; this method works with a single LCDC-allocated VRAM block.
<br/>
</td> </tr></table><span class="postbody">
<br/>
That sounds alot like my backgrounds problem. It's leaving blended traces of the moving image on the background.(I haven't tried that example though)
<br/>
<br/>
EDIT:
<br/>
Here's the updated source, with the binary <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/BackgroundsX.zip" target="_blank">included.</a>
<br/>
Here's the .nds <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/backgroundsx.nds" target="_blank">binary.</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154333 - yellowstar - Mon Apr 14, 2008 10:32 pm</h4>
    <div class="postbody"><span class="postbody">My DS-X is done for. I finally got a response for DS-X support,(I was waiting on my support person, for a response from his superiors about fixing it)
<br/>
and they said no. It was my fault it broke, so, no.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154367 - yellowstar - Tue Apr 15, 2008 4:21 am</h4>
    <div class="postbody"><span class="postbody">I went through the Patater guide, and found some things about DMA:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Patater wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
When using DMA to copy from main memory, do not forget to flush main memory before using DMA. Another issue to consider would be that in the middle of a DMA, the main CPUs are prevented from using certain memory hardware.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I always thought DMA froze the processors while at work? If Patater is correct, that doesn't happen? Flush? He only flushed in OAM updating, unlike what he himself said. I attempted adding code to flush cache, and waiting for DMA to finish, at every DMA ocerance, but still nothing changed. What all would be locked during DMA?
<br/>
<br/>
Some wackiness with VRAM and numbers:
<br/>
To hold one 256x256 8-bit bg in VRAM, I need 65536 bytes of space. That's 4 blocks; Unlike what some examples say, they say index 3, I find 4. And examples say I only need Bank A, those numbers say I need another one, too. Double buffers take 131072 bytes, that more than what Bank A can handle. Mapping another bank to MAIN_BG doesn't help my problems; Why? Also, why do the examples say what the do, when they seem to be wrong? Or am I wrong?
<br/>
<br/>
I edited my code so the back buffer isn't cleared every frame. Here's the results: It still misbehaved with the same glitches as before, but with what you'd expect when not clearing buffers. Now for another wacky glitch: When moving the image to the right,(or +down/up to, so down-right/down-up)
<br/>
there is a 1-pixel wide gap left one pixel to the left of the image. And when the image stops moving, there's a 2-pixel gap to the left.(This gap's color is the background color)
<br/>
<br/>
Here's a <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/screenshot.bmp" target="_blank">screenshot.</a>(Note this only has the above glitches, not the main ones)
<br/>
<br/>
Here's the whole code, cut into differnt code blocks:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
#include &lt;malloc.h&gt;
<br/>
<br/>
#include "PALETTE_RAW.h"
<br/>
#include "TASKBAR3_RAW.h"
<br/>
#include "BAK_RAW.h"
<br/>
<br/>
#define DEBUG
<br/>
<br/>
#define CT_DMA 0
<br/>
#define CT_SCPY 1
<br/>
<br/>
bool copy_type = CT_DMA;
<br/>
bool linear = 1;//If true, copy the image in by
<br/>
//copying the each scanline(horizontal line) in the
<br/>
//image to the target one-by-one.
<br/>
<br/>
bool screen = 0;//screen to which the image is copyed to.
<br/>
//0 for top, 1 for bottom.
<br/>
<br/>
int x = 0;
<br/>
int y = 0;
<br/>
int speed=1;
<br/>
<br/>
#include "debug.h"
<br/>
<br/>
#define BG_MAX 4
<br/>
<br/>
u8 *video_buffer_main = (u8*)BG_BMP_RAM(0);
<br/>
//u8 *video_buffer_main_buf = (u8*)BG_BMP_RAM(0);
<br/>
u8 *video_buffer_sub = (u8*)BG_BMP_RAM_SUB(0);
<br/>
//u8 *video_buffer_sub_buf = (u8*)BG_BMP_RAM_SUB(0);
<br/>
<br/>
bool which_buffer=1;
<br/>
<br/>
//Section moved to next section of code in post
<br/>
<br/>
void Init()
<br/>
{
<br/>
fatInitDefault();
<br/>
}
<br/>
<br/>
void Draw()
<br/>
{
<br/>
u8 *target=NULL;
<br/>
u8 *image = (u8*)TASKBAR3_RAW;
<br/>
size_t image_size = (size_t)TASKBAR3_RAW_size;
<br/>
size_t target_width, source_width;
<br/>
target_width=SCREEN_WIDTH; source_width=30;
<br/>
<br/>
if(!screen)target=video_buffer_main;
<br/>
if(screen)target=video_buffer_sub;
<br/>
<br/>
//This block right here is commented out for when not clearing the buffers
<br/>
DC_FlushAll();
<br/>
dmaCopy((u16*)BAK_RAW,video_buffer_main,256*256);
<br/>
while(dmaBusy(3));DC_FlushAll();
<br/>
dmaCopy((u16*)BAK_RAW,video_buffer_sub,256*256);
<br/>
while(dmaBusy(3));DC_FlushAll();   
<br/>
   VCopy(image,target,0,(size_t)((256*y)+x),image_size,target_width,source_width);
<br/>
<br/>
}
<br/>
<br/>
void SwapBuffers()
<br/>
{
<br/>
   if(which_buffer)
<br/>
   {
<br/>
   video_buffer_main = (u8*)BG_BMP_RAM(BG_MAX);
<br/>
   video_buffer_sub = (u8*)BG_BMP_RAM_SUB(BG_MAX);
<br/>
   
<br/>
   BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0);
<br/>
   SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0);
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
   video_buffer_main = (u8*)BG_BMP_RAM(0);
<br/>
   video_buffer_sub = (u8*)BG_BMP_RAM_SUB(0);
<br/>
   
<br/>
   BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX);
<br/>
   SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX);
<br/>
   }
<br/>
   
<br/>
   which_buffer = !which_buffer;
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
    
<br/>
    
<br/>
    
<br/>
   powerON(POWER_ALL);
<br/>
   
<br/>
   irqInit();
<br/>
    irqEnable(IRQ_VBLANK);
<br/>
   
<br/>
    videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
   videoSetModeSub(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
<br/>
    vramSetBankA(VRAM_A_MAIN_BG);
<br/>
    //Init main bg
<br/>
    BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX);
<br/>
    //No rotation and no scale
<br/>
    BG3_XDX = 1 &lt;&lt; 8;
<br/>
    BG3_XDY = 0;
<br/>
    BG3_YDX = 0;
<br/>
    BG3_YDY = 1 &lt;&lt; 8;
<br/>
   BG3_CX = 0;
<br/>
   BG3_CY = 0;
<br/>
   
<br/>
<br/>
   vramSetBankB(VRAM_B_MAIN_BG);
<br/>
<br/>
          //vramSetBankH(VRAM_H_SUB_BG);
<br/>
          //vramSetBankI(VRAM_I_SUB_BG);
<br/>
<br/>
   vramSetBankD(VRAM_D_LCD);//For screenshots
<br/>
<br/>
   vramSetBankC(VRAM_C_SUB_BG);
<br/>
    //Init sub
<br/>
    
<br/>
   SUB_BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(BG_MAX);
<br/>
    //No rotation and no scale
<br/>
    SUB_BG3_XDX = 1 &lt;&lt; 8;
<br/>
    SUB_BG3_XDY = 0;
<br/>
    SUB_BG3_YDX = 0;
<br/>
    SUB_BG3_YDY = 1 &lt;&lt; 8;
<br/>
   SUB_BG3_CX = 0;
<br/>
   SUB_BG3_CY = 0;
<br/>
   
<br/>
   DC_FlushAll();
<br/>
   memcpy(BG_PALETTE_SUB, PALETTE_RAW, PALETTE_RAW_size);
<br/>
   DC_FlushAll();
<br/>
   memcpy(BG_PALETTE, PALETTE_RAW, PALETTE_RAW_size);
<br/>
   
<br/>
DC_FlushAll();
<br/>
dmaCopy(BAK_RAW,video_buffer_main,256*256);
<br/>
while(dmaBusy(3));
<br/>
DC_FlushAll();
<br/>
dmaCopy(BAK_RAW,(u8*)BG_BMP_RAM(BG_MAX),256*256);while(dmaBusy(3));DC_FlushAll();
<br/>
dmaCopy(BAK_RAW,video_buffer_sub,256*256);while(dmaBusy(3));DC_FlushAll();
<br/>
dmaCopy(BAK_RAW,(u8*)BG_BMP_RAM_SUB(BG_MAX),256*256);while(dmaBusy(3));DC_FlushAll();
<br/>
<br/>
Init();
<br/>
<br/>
   
<br/>
    
<br/>
    while(1)
<br/>
   {
<br/>
   swiWaitForVBlank();
<br/>
   Step();
<br/>
   SwapBuffers();
<br/>
   Draw();
<br/>
   
<br/>
   }
<br/>
    
<br/>
    return 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//n=nce's
<br/>
//e=elhobbs
<br/>
inline void nscpy(void* in_dst, const void *in_src, unsigned int length);
<br/>
inline void escpy(void* in_dst, const void *in_src, unsigned int length);
<br/>
<br/>
__attribute__((section (".ewram"),long_call)) 
<br/>
inline void scpy(void* in_dst, const void *in_src, unsigned int length) 
<br/>
{ 
<br/>
<br/>
//escpy(in_dst,in_src,length);
<br/>
nscpy(in_dst,in_src,length);
<br/>
  
<br/>
}
<br/>
<br/>
inline void nscpy(void* in_dst, const void *in_src, unsigned int length)
<br/>
{
<br/>
<br/>
if(1)
<br/>
  {
<br/>
  u8 *src = (u8*)in_src;
<br/>
  u16 *dst = (u16 *)in_dst; 
<br/>
<br/>
  u16 temp=0;
<br/>
  u8 pix1;
<br/>
  u8 pix2;
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
<br/>
  for(; length &gt; 0; length--)
<br/>
  {
<br/>
  pix1=*src++;
<br/>
  pix2=*src++;
<br/>
        
<br/>
  temp= pix1 | (pix2&lt;&lt;8);
<br/>
  
<br/>
    *dst++ = temp;
<br/>
  }
<br/>
  
<br/>
  }
<br/>
  else
<br/>
  {
<br/>
  //This is nce's code
<br/>
  
<br/>
  u8* src = (u8 *)in_src;
<br/>
  u16 *dst = (u16 *)in_dst;
<br/>
  u8* src1 = src+1;
<br/>
<br/>
  length &gt;&gt;= 1;
<br/>
<br/>
  for(; length &gt; 1; length--)
<br/>
  {
<br/>
     *dst++ =( (*src )&lt;&lt;8) | (*src1);
<br/>
     src+=2 ; src1+=2;
<br/>
  }
<br/>
<br/>
  //and the last one
<br/>
  //*dst = (*src ) | ((*dst &amp; 0xff )&lt;&lt;8);
<br/>
  // OR
<br/>
  //*dst = (*src ) | (*dst &amp; 0xff00 ); 
<br/>
  //*dst = (*src ) | ((*dst&lt;&lt;8));
<br/>
  
<br/>
  }
<br/>
<br/>
}
<br/>
inline void escpy(void* in_dst, const void *in_src, unsigned int length)
<br/>
{
<br/>
u8 *src8=(u8*)in_src;//source 8 bit pixels
<br/>
u8 *dest8=(u8*)in_dst;//unaligned destination 8 bit
<br/>
u16 *dest16;//aligned destination 16 bit
<br/>
u16 pixel16=0;//temporary for holding two 8 bit pixels
<br/>
bool is_odd=0;
<br/>
<br/>
dest16 = (u16*)dest8;
<br/>
is_odd=(length &amp; 1)?1:0;
<br/>
if (is_odd)
<br/>
{
<br/>
/*dest16 = ((u16*)(dest8-1));
<br/>
  //handle single pixel write
<br/>
//read both pixels from the destination
<br/>
pixel16 = *dest16;
<br/>
//we want to keep the first byte
<br/>
pixel16 &amp;= 0xff;
<br/>
//and replace the second byte
<br/>
pixel16 |= ((*src8++)&lt;&lt;8);
<br/>
//and write both values back
<br/>
*dest16++ = pixel16;
<br/>
length--;*/
<br/>
}
<br/>
<br/>
length = length&gt;&gt;1;
<br/>
//now the destination will be aligned to 16bit value
<br/>
//so handle all of the two pixel writes we can
<br/>
for(; length &gt; 1; length--)
<br/>
{
<br/>
pixel16= *src8++;
<br/>
pixel16 |= ((*src8++)&lt;&lt;8);
<br/>
*dest16++ = pixel16;
<br/>
}
<br/>
<br/>
/*for(; length &gt; 1; length--)
<br/>
  {
<br/>
     *dst++ =( (*src )&lt;&lt;8) | (*src1);
<br/>
     src+=2 ; src1+=2;
<br/>
  }*/
<br/>
<br/>
//if the length is odd then write the last byte
<br/>
if(is_odd)
<br/>
{
<br/>
  //handle single pixel write
<br/>
//read both pixels
<br/>
pixel16 = *dest16;
<br/>
//we want to keep the second byte
<br/>
pixel16 &amp;= 0xff00;
<br/>
//and replace the first byte
<br/>
pixel16 |= *src8++;
<br/>
//and write both values back
<br/>
*dest16++ = pixel16;
<br/>
}
<br/>
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline void vcopy(u8* source, u8 *target, size_t s_offset, size_t t_offset, size_t size)
<br/>
{
<br/>
<br/>
   //Copys source starting at s_offset to target starting at t_offset with
<br/>
   //size size.
<br/>
   //This Copy works with VRAM, OAM, and backgrounds.
<br/>
   DC_FlushAll();
<br/>
   
<br/>
   if((t_offset+1)%2==0)
<br/>
   {
<br/>
   u16 temp=0;
<br/>
   u16 *tar = (u16*)&amp;target[(int)t_offset];
<br/>
   temp = (u16)target[(int)t_offset];
<br/>
   temp |= ((u16)source[(int)s_offset]) &gt;&gt; 8;
<br/>
   
<br/>
   *tar = temp;
<br/>
   t_offset++;
<br/>
   s_offset++;
<br/>
   size--;
<br/>
   }
<br/>
   else if(size==1)
<br/>
   {
<br/>
   u16 temp=0;
<br/>
   u16 *tar = (u16*)&amp;target[(int)t_offset];
<br/>
   temp |= ((u16)source[(int)s_offset]);
<br/>
   temp |= (u16)target[(int)t_offset] &gt;&gt; 8;
<br/>
   
<br/>
   *tar = temp;
<br/>
   t_offset++;
<br/>
   s_offset++;
<br/>
   
<br/>
   return;
<br/>
   }
<br/>
   
<br/>
   if(copy_type == CT_SCPY)
<br/>
   scpy(&amp;target[(int)t_offset],&amp;source[(int)s_offset],size);
<br/>
      
<br/>
      if(copy_type == CT_DMA)
<br/>
      {
<br/>
      dmaCopy(&amp;source[(int)s_offset],&amp;target[(int)t_offset],(uint32)size);
<br/>
      while(dmaBusy(3));
<br/>
      }
<br/>
      
<br/>
      DC_FlushAll();
<br/>
<br/>
}
<br/>
   
<br/>
void VCopy(u8* source, u8 *target, size_t s_offset, size_t t_offset, size_t size,size_t target_width, size_t source_width)
<br/>
{
<br/>
   //Is it an odd length?
<br/>
   size_t so, to;
<br/>
   so=s_offset;
<br/>
   to=t_offset;
<br/>
   if(linear)
<br/>
   {
<br/>
   size_t I=0;
<br/>
   size_t i=0;
<br/>
    for(i=0; i &lt; size; i+= source_width)
<br/>
    {
<br/>
    vcopy(source,target,so+i,to+I,source_width);
<br/>
    //dmaCopy(&amp;source[(int)so+i],&amp;target[(int)to+I],(uint32)source_width);
<br/>
    I+=target_width;
<br/>
    }
<br/>
   }
<br/>
   
<br/>
   if(!linear)
<br/>
   vcopy(source,target,so,to,size);
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Wed Apr 16, 2008 8:25 pm; edited 3 times in total</span></div>    
</div>
<div class="post">
    <h4>#154414 - yellowstar - Tue Apr 15, 2008 10:58 pm</h4>
    <div class="postbody"><span class="postbody">I feel like people are ignoring this topic... Nobody has replied to the actual problems in a long time...(The graphical problems)
<br/>
(My patience is wearing extremely thin in case nobody noticed...)
<br/>
Anyway:
<br/>
<br/>
DeSmume reports that DISPCNT is contantly changing, why, and what is that register? Is it the old DISPLAY_CR?
<br/>
<br/>
I tried changing the Flush command in vcopy to Invalidate, but still nothing changed.
<br/>
<br/>
Everybody, if anybody is reading this, how would you do this? How would you write code to draw a 8-bit image on a bg when the image doesn't fill the whole bg?(Whole demo please, if possible)
<br/>
<br/>
Now I know why people hate the PAlib source code... I downloaded the source, and I hate it too. One of the sick things I noticed right away that he hit enter twice for each line. I tried to have Windows search for the function used for writing 8-bit pixels, but I couldn't find it anywhere! Arghh... As in:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int a;
<br/>
<br/>
int b;
<br/>
<br/>
int c;
<br/>
<br/>
void mycode()
<br/>
{
<br/>
<br/>
a=0;
<br/>
<br/>
b=1;
<br/>
<br/>
c=a+b;
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154508 - yellowstar - Thu Apr 17, 2008 2:43 am</h4>
    <div class="postbody"><span class="postbody">I mentioned elsewhere I was going to do a rewrite of this thing. I have finished the rewrite. But, this monster of a problem STILL exists! Argghhh!(I'm going nuts!)(That's only with this bg thing)
<br/>
<br/>
Perhaps it has to do with how I'm clearing the video buffer...
<br/>
The way I'm doing it right now, is: I have a 8-bit image that has palette index 0. When I clear, I copy this image to the video buffer:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
dmaCopy((u8*)BAK_RAW,video_buffer_main,256*256);
<br/>
</td> </tr></table><span class="postbody">
<br/>
What's the usual/normal way of clearing video buffers? How would you do it, fellow DS devs?
<br/>
Hmmm... These glitches prevail even when not clearing... I still want to know the above however.
<br/>
<br/>
The code is MUCH simpler, and yet, still bugged:
<br/>
(SCpy code removed, that was backed up in the old versions)
<br/>
(Double buffers removed too)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
#include &lt;malloc.h&gt;
<br/>
<br/>
#include "PALETTE_RAW.h"
<br/>
#include "TASKBAR3_RAW.h"
<br/>
#include "BAK_RAW.h"
<br/>
<br/>
#include "debug.h"
<br/>
<br/>
u8 *video_buffer_main = (u8*)BG_BMP_RAM(0);
<br/>
<br/>
int speed = 1;
<br/>
int x=0;
<br/>
int y=0;
<br/>
<br/>
void VCopy(u8 *source, u8 *target, int position, int size, int source_width, int target_width)
<br/>
{
<br/>
int i, I;
<br/>
i=0; I=0;
<br/>
//target = &amp;target[position];
<br/>
<br/>
<br/>
//((u16*)target)[position] = 2 | 2 &gt;&gt; 8; //Even this line won't work!
<br/>
<br/>
    for(i=0; i&lt;size; i+=source_width)
<br/>
   {
<br/>
   DC_FlushAll();
<br/>
   dmaCopy(&amp;source[i],&amp;target[position+I],(u32)source_width);
<br/>
   while(dmaBusy(3));
<br/>
   I+=target_width;
<br/>
   }
<br/>
<br/>
}
<br/>
<br/>
<br/>
<br/>
void Draw()
<br/>
{
<br/>
DC_FlushAll();
<br/>
dmaCopy((u8*)BAK_RAW,video_buffer_main,256*256);
<br/>
while(dmaBusy(3));
<br/>
<br/>
VCopy((u8*)TASKBAR3_RAW,video_buffer_main,(y*256)+x, (int)TASKBAR3_RAW_size, 30, 256);
<br/>
}
<br/>
<br/>
<br/>
<br/>
void Step()
<br/>
{
<br/>
 scanKeys();
<br/>
<br/>
 if(keysHeld() &amp; KEY_RIGHT)x+=speed;
<br/>
 if(keysHeld() &amp; KEY_LEFT)x-=speed;
<br/>
 if(keysHeld() &amp; KEY_DOWN)y+=speed;
<br/>
 if(keysHeld() &amp; KEY_UP)y-=speed;
<br/>
}
<br/>
<br/>
<br/>
<br/>
int main(void)
<br/>
{
<br/>
    
<br/>
   powerON(POWER_ALL);
<br/>
   
<br/>
   irqInit();
<br/>
    irqEnable(IRQ_VBLANK);
<br/>
   
<br/>
   videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
   
<br/>
   vramSetMainBanks(VRAM_A_MAIN_BG, VRAM_B_MAIN_BG,
<br/>
                     VRAM_C_LCD , VRAM_D_LCD);
<br/>
   
<br/>
   BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0);
<br/>
   // these are rotation backgrounds so you must set the rotation attributes:
<br/>
    // these are fixed point numbers with the low 8 bits the fractional part
<br/>
    // this basicaly gives it a 1:1 translation in x and y so you get a nice flat bitmap
<br/>
        BG3_XDX = 1 &lt;&lt; 8;
<br/>
        BG3_XDY = 0;
<br/>
        BG3_YDX = 0;
<br/>
        BG3_YDY = 1 &lt;&lt; 8;
<br/>
    // our bitmap looks a bit better if we center it so scroll down (256 - 192) / 2
<br/>
        BG3_CX = 0;
<br/>
        BG3_CY = 0;
<br/>
   
<br/>
   DC_FlushAll();
<br/>
   dmaCopy((u8*)BAK_RAW,video_buffer_main,256*256);
<br/>
   while(dmaBusy(3));
<br/>
   DC_FlushAll();
<br/>
   dmaCopy((u8*)PALETTE_RAW,BG_PALETTE,256*2);
<br/>
   while(dmaBusy(3));
<br/>
   
<br/>
    while(1)
<br/>
   {
<br/>
   
<br/>
   swiWaitForVBlank();
<br/>
   Draw();
<br/>
   Step();
<br/>
   
<br/>
   }
<br/>
    
<br/>
    return 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154559 - yellowstar - Fri Apr 18, 2008 3:34 am</h4>
    <div class="postbody"><span class="postbody">Here's some videos.
<br/>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/Untitled%2010.wmv" target="_blank">1</a>
<br/>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/Untitled%2011.wmv" target="_blank">2</a>
<br/>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/Untitled%2012.wmv" target="_blank">3</a>
<br/>
<br/>
There's other videos, but those aren't done...(Dial-Up)
<br/>
(And two are corrupted on the server)
<br/>
<br/>
How am I supposed to do this? That is, what is the normal way of drawing images on 8-bit bgs, when the image doesn't fill the entire bg? And/Or, how do you do it, fellow ds devs?</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Fri Apr 18, 2008 7:59 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#154592 - Lord Graga - Fri Apr 18, 2008 7:53 pm</h4>
    <div class="postbody"><span class="postbody">Broken links.
<br/>
<br/>
should be: <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/Untitled%2010.wmv" target="_blank">http://members.iglide.net/ticeandsons/yellowstar/Untitled%2010.wmv</a>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/Untitled%2011.wmv" target="_blank">http://members.iglide.net/ticeandsons/yellowstar/Untitled%2011.wmv</a>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/Untitled%2012.wmv" target="_blank">http://members.iglide.net/ticeandsons/yellowstar/Untitled%2012.wmv</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154593 - yellowstar - Fri Apr 18, 2008 8:06 pm</h4>
    <div class="postbody"><span class="postbody">Fixed. The url tag won't work right when there's spaces in the url. And I guess I tried removing the space, and that produced the 404.
<br/>
<br/>
These videos were taken the same way I mentioned eariler. The videos have graphic glitches. One issue is that Desmume leaves stuff on the image that shouldn't be there, and that doesn't happen on hw. Notice the junk/disturbance trailing the image when it's moving; that's the problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154598 - yellowstar - Fri Apr 18, 2008 10:53 pm</h4>
    <div class="postbody"><span class="postbody">I discovered when I skip frames, those glitches seem to disappear, as long as I skip at least 8 frames. Also, I discovered that dmaCopy automatically waits for dma to finish - so no need for dma waiting code. This is a general VRAM/BG problem. It doesn't matter what I use - dma or a simple 16 bit write, it is glitched. Does VRAM have a cache? If so, how do I disable it, if possible?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int frame_skip=0;
<br/>
<br/>
void main()
<br/>
{
<br/>
<br/>
 while(1)
<br/>
 {
<br/>
 swiWaitForVBlank();
<br/>
   
<br/>
   frame_skip++;
<br/>
   if(frame_skip&lt;8)continue;
<br/>
   
<br/>
   frame_skip=0;//Set it to zero when we have skipped 8 frames
<br/>
<br/>
 ...
<br/>
 }
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154639 - yellowstar - Sat Apr 19, 2008 5:41 pm</h4>
    <div class="postbody"><span class="postbody">I have discovered that VRAM doesn't have cache activated by default. Activating it would only cause more problems. But still, how would I activate the cache?
<br/>
<br/>
Is there anybody out there that's doing what I'm doing, or has successfully written such code?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154659 - yellowstar - Sun Apr 20, 2008 12:52 am</h4>
    <div class="postbody"><span class="postbody">I successfully followed a tutorial on tile map bgs. And I attempted to write code to use tile map bgs as framebuffers/ext rot bgs. And course that failed. Same graphic glitches as this. Plus a distorted image, and slow framerate.
<br/>
<br/>
How do the official games/SDK draw stuff on the screen? How do you guys do it? How am I supposed to do it? What am I supposed to use for this?(What kind of bgs?)
<br/>
<br/>
Here's the code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;unistd.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
<br/>
#include "palette_raw.h"
<br/>
#include "bak_raw.h"
<br/>
#include "taskbar3_raw.h"
<br/>
<br/>
#include "debug.h"
<br/>
<br/>
u8 *tilememory = (u8*)BG_TILE_RAM(1);
<br/>
u16 *mapmemory = (u16*)BG_MAP_RAM(0);
<br/>
u8 *video_buffer_main;
<br/>
int x, y, speed;
<br/>
//u8 redTile[64]
<br/>
<br/>
void Init()
<br/>
{
<br/>
 for(int i=0; i&lt;32*32; i++)
<br/>
 mapmemory[i]=i;
<br/>
 
<br/>
 u16 *tilem = (u16*)tilememory;
<br/>
 for(int i=0; i&lt;2048; i++)
<br/>
 tilem[i]=0;
<br/>
}
<br/>
<br/>
void Update()
<br/>
{
<br/>
int si, oi, tilew, tileh, line;
<br/>
si=0; oi=0; tilew=0; tileh=0; line=0;
<br/>
<br/>
DC_FlushAll();
<br/>
<br/>
 for(tileh=0; tileh&lt;32; tileh++)
<br/>
 {
<br/>
    for(tilew=0; tilew&lt;32; tilew++)
<br/>
    {
<br/>
       for(line=0; line&lt;8; line++)
<br/>
       {
<br/>
       dmaCopy(&amp;video_buffer_main[si],&amp;tilememory[oi],8);
<br/>
       si+=256; oi+=8;
<br/>
       }
<br/>
    si-=256*8; si+=8;
<br/>
    }
<br/>
   //si-=8;
<br/>
   si+=256*8;
<br/>
 }
<br/>
}
<br/>
<br/>
void VCopy(u8 *source, u8 *target, int position, int size, int source_width, int target_width)
<br/>
{
<br/>
int i, I;
<br/>
i=0; I=0;
<br/>
//target = &amp;target[position];
<br/>
<br/>
DC_FlushAll();
<br/>
//((u16*)target)[position] = 2 | 2 &gt;&gt; 8;
<br/>
//DC_FlushAll();
<br/>
<br/>
    for(i=0; i&lt;size; i+=source_width)
<br/>
   {
<br/>
   dmaCopy(&amp;source[i],&amp;target[position+I],(u32)source_width);
<br/>
   I+=target_width;
<br/>
   }
<br/>
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   irqInit();
<br/>
   irqEnable(IRQ_VBLANK);
<br/>
   int i=0;
<br/>
   
<br/>
   videoSetMode(MODE_0_2D | DISPLAY_BG0_ACTIVE);
<br/>
   vramSetBankA(VRAM_A_MAIN_BG);
<br/>
   vramSetBankD(VRAM_D_LCD);
<br/>
   fatInitDefault();
<br/>
   
<br/>
   video_buffer_main = (u8*)malloc(256*256);
<br/>
   x=0; y=0; speed=1;
<br/>
   Init();
<br/>
   
<br/>
   BG0_CR = BG_COLOR_256 | BG_MAP_BASE(0) | BG_TILE_BASE(1);
<br/>
   
<br/>
   DC_FlushAll();
<br/>
   dmaCopy(palette_raw,BG_PALETTE,256*2);
<br/>
   
<br/>
   DC_FlushAll();
<br/>
   dmaCopy((u8*)bak_raw,video_buffer_main,256*256);
<br/>
   //dmaCopy(redTile, tilememory, 64);
<br/>
   //dmaCopy(greenTile, tilememory + 64, 64);
<br/>
   
<br/>
   while(1)
<br/>
   {
<br/>
      swiWaitForVBlank();
<br/>
      
<br/>
      
<br/>
      
<br/>
      DC_FlushAll();
<br/>
      dmaCopy((u8*)bak_raw,video_buffer_main,256*256);
<br/>
      DC_FlushAll();
<br/>
      VCopy((u8*)taskbar3_raw,video_buffer_main,(y*256)+x,(int)taskbar3_raw_size,30,256);
<br/>
      
<br/>
      Update();
<br/>
      
<br/>
      scanKeys();
<br/>
      if(keysHeld() &amp; KEY_DOWN)y+=speed;
<br/>
      if(keysHeld() &amp; KEY_UP)y-=speed;
<br/>
      if(keysHeld() &amp; KEY_RIGHT)x+=speed;
<br/>
      if(keysHeld() &amp; KEY_LEFT)x-=speed;
<br/>
      
<br/>
      if(x&lt;0)x=0;
<br/>
      if(y&lt;0)y=0;
<br/>
      if(x&gt;256-30)x=256-30;
<br/>
      if(y&gt;192-30)y=192-30;
<br/>
      
<br/>
      Step();
<br/>
      
<br/>
      //dmaCopy(redTile, tilememory, 64);
<br/>
      //dmaCopy(greenTile, tilememory + 64, 64);
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155184 - yellowstar - Sat Apr 26, 2008 3:32 am</h4>
    <div class="postbody"><span class="postbody">Sorry for all this ranting, anger, and such. I really shouldn't be posting with such things residing in those posts. Starting now, I'll try to remain calm.
<br/>
<br/>
Desmume, the latest one, correctly emulates this problem. The last version released by YopYop, before he had to quit, did it correctly also. I have yet to try the oldest version available on the web site, but I have a feeling whatever is causing this, was correctly emulated from the start. I'd like to know what that is...
<br/>
<br/>
EDIT:
<br/>
My hunch was wrong, fortunately. Desmume 0.3.0 doesn't do it right, 0.3.3 does. Now how to contact him... That's really convenient, right on the front page of the web site. Hopefully he still checks that E-Mail address...
<br/>
<br/>
EDIT2:
<br/>
Well, I sent him an E-Mail. Hopefully he still checks that address...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155775 - yellowstar - Sun May 04, 2008 1:54 am</h4>
    <div class="postbody"><span class="postbody">I have discovered something.
<br/>
<br/>
Expert from a PM to another member:
<br/>
The moving image is jumpy on emus - wonder if that's an issue on hw? That's only visible when your looking at it up close with magnification. And the results look about the same in emus as emulators, so maybe it's being jumping for whatever reason is the problem?
<br/>
(Would be nice if I could capture videos on hardware... I could check if it's jumpy on hw also...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156124 - yellowstar - Wed May 07, 2008 12:45 am</h4>
    <div class="postbody"><span class="postbody">Another member offered to take some captures of this problem, on both emulator and hardware. The emu capture seems to be more accurate then the hardware, however. Web cam's fault, that's all.
<br/>
<br/>
Emulator <a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/capture_backgroundsx.avi" target="_blank">capture</a>
<br/>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/capture_hw1.avi" target="_blank">Hw capture 1</a>
<br/>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/capture_hw2avi" target="_blank">Hw capture 2</a>
<br/>
<br/>
<a class="postlink" href="http://members.iglide.net/ticeandsons/yellowstar/hw.jpg" target="_blank">Snapshot of the moving image</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156237 - TwentySeven - Wed May 07, 2008 11:15 pm</h4>
    <div class="postbody"><span class="postbody">Please don't tell me you're refering to the crappy lcd response time on the DS.. and the "ghosting" you get from it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156246 - yellowstar - Thu May 08, 2008 1:04 am</h4>
    <div class="postbody"><span class="postbody">?
<br/>
<br/>
You mean you've been tortured by this kind of problem too? Do you know of any work arounds? Any idea how long it takes it respond? (My tests say that might be the next-to-impossible-to-use-rate-of-7-frames)
<br/>
<br/>
OpenTTD uses 8-bit bgs without a problem...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156252 - DensitY - Thu May 08, 2008 1:20 am</h4>
    <div class="postbody"><span class="postbody">um yeah..
<br/>
<br/>
the ghosting isn't a code bug, its just the response time on the LCD screen on the DS is really low, possibly 25ms or higher. Back when LCD monitors first started coming out on PC, they were virtually useless for first person perspective shooters because of the slow response time. you guessed it ghosting. these days most LCD monitor's have response time of 8ms to 2ms, so ghosting is pretty much non existant.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156255 - yellowstar - Thu May 08, 2008 1:47 am</h4>
    <div class="postbody"><span class="postbody">Don't you mean high? :-)
<br/>
I googled and found some info... Big difference between DS and the normal LCD... How would refresh rate and response time, tie together? Wonder how long a DS vblank is...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156320 - tepples - Thu May 08, 2008 9:53 pm</h4>
    <div class="postbody"><span class="postbody">GBATEK says the DS video signal is 355x263 pixels, and the video hardware renders one pixel every 6 FSB cycles. (The DS's FSB is 33.5 MHz.) Of course, only 256x192 pixels are visible on each screen; the rest are blanking.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156333 - yellowstar - Thu May 08, 2008 10:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">GBATEK says the DS video signal is 355x263 pixels, and the video hardware renders one pixel every 6 FSB cycles. (The DS's FSB is 33.5 MHz.) Of course, only 256x192 pixels are visible on each screen; the rest are blanking.</td> </tr></table><span class="postbody">
<br/>
I guess the defination of FSB would fit with <a class="postlink" href="http://en.wikipedia.org/wiki/Front_side_bus" target="_blank">this?</a> How long does it take the DS to render one whole frame?(From the top scanline to bottom, excluding the vblank time)
<br/>
What I really want to know, is, does the pixels completely change from the old to new colors, by the time the video hardware gets to rendering that pixel again?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156340 - Maxxie - Thu May 08, 2008 10:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">GBATEK says the DS video signal is 355x263 pixels, and the video hardware renders one pixel every 6 FSB cycles. (The DS's FSB is 33.5 MHz.) Of course, only 256x192 pixels are visible on each screen; the rest are blanking.</td> </tr></table><span class="postbody">
<br/>
I guess the defination of FSB would fit with <a class="postlink" href="http://en.wikipedia.org/wiki/Front_side_bus" target="_blank">this?</a> How long does it take the DS to render one whole frame?(From the top scanline to bottom, excluding the vblank time)
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
1/60th second * 192/355
<br/>
(if tepples numbers are correct)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
What I really want to know, is, does the pixels completely change from the old to new colors, by the time the video hardware gets to rendering that pixel again?</td> </tr></table><span class="postbody">
<br/>
<br/>
It should. Reaction times should be somewhere at 10th of ms. Each pixel however is driven once every 1/60th (~16.7ms). 
<br/>
<br/>
However our eyes do not only determinate the intensity of a pixel by the actual level the pixel is driven too, but also by the timefraction it drives this level. This leads - unlike crts which pixels allways are only active a very short  time - that the previous color mixes with the new color in our view.
<br/>
Modern displays (for PCs and TVs) reduce this by over or underdriving a pixel depending on the previous color before adjusting to the requested brightness.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156349 - yellowstar - Thu May 08, 2008 11:05 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<span style="font-style: italic">that the previous color mixes with the new color in our view</span>
<br/>
<br/>
Modern displays (for PCs and TVs) reduce this by over or underdriving a pixel depending on the previous color before adjusting to the requested brightness.</td> </tr></table><span class="postbody">
<br/>
So it's our human eyes that create this effect, and I need to figure out a way to hide this. Sounds like I should try to do that with my code. But how? This is 8-bit bgs, and code would get complicated &amp; expensive with using palette... Perhaps I could fiddle with BLEND_CR and similar things...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156352 - silent_code - Thu May 08, 2008 11:10 pm</h4>
    <div class="postbody"><span class="postbody">ghosting is pretty bad in locco rocco on the psp (obviously it's on the psp...).
<br/>
but i haven't seen it as bad as in yellowstar's test on the nds. looks like motion blur!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156355 - Maxxie - Thu May 08, 2008 11:18 pm</h4>
    <div class="postbody"><span class="postbody">While it is theoretical possible to hide that effect per software (by inverse filtering) if you have exact knowledge on the timings and enough calculation time per pixel it remains a problem on the physical layer. (Other hw solutions would be backlight scattering, black striping, or scanning backlights)
<br/>
<br/>
Since on the NDS you do not have the resource to calculate the needed adjustments in time, no there is no real way  to prevent the movement blur by software means.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156362 - yellowstar - Thu May 08, 2008 11:47 pm</h4>
    <div class="postbody"><span class="postbody">So 8-bit bgs are useless for what I want, so you say... In my opinion, that would mean don't use them at all... Don't the official games use 8-bit bgs? How do they fix this?(I was thinking before this is an hw issue. But why even have 8-bit bgs in the hw if you can't use it right? GBA compatibility maybe...)
<br/>
<br/>
I read that with BLEND_CR, I could only blend two bgs. So I would have two bgs: The first one would be the new, the other the old. The first frame would only render to the old bg. After that, it would always render to the the new, then on the following frames, it would copy the bg to the old bg, before rendering. Now I just need to code and try it...
<br/>
<br/>
EDIT:
<br/>
That didn't work... Looks like I'm stuck with 16-bit bgs... If anybody has any ideas on hiding this, please say so.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156372 - Maxxie - Fri May 09, 2008 12:25 am</h4>
    <div class="postbody"><span class="postbody">The mode you use has nothing at all to do with the problem.
<br/>
<br/>
You can try to conceal it, but it will still remain. The less contrast you use i.e. the less you will notice it. The slower movement the less you will notice it and so on.
<br/>
<br/>
BUT you CAN NOT influence the physical limits of the display or your eyes which are responsible for the motion blur on a LCD Display</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156377 - yellowstar - Fri May 09, 2008 3:20 am</h4>
    <div class="postbody"><span class="postbody">Well, the problem shows even when only moving at 1 pixel per vblank. So if the scene would be dark, or would have similar colors, it would be fine... That still wouldn't work for me very often.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156394 - silent_code - Fri May 09, 2008 11:59 am</h4>
    <div class="postbody"><span class="postbody">have you tried to use "real world" data? because your example data is rather "synthetic", it exaggerates the effect pretty much.
<br/>
i've got a suggestion: download megaETK and check if that suffers from the effect as much as your example. :^)</span><span class="gensmall"><br/><br/>Last edited by silent_code on Fri May 09, 2008 2:23 pm; edited 3 times in total</span></div>    
</div>
<div class="post">
    <h4>#156397 - Lazy1 - Fri May 09, 2008 12:37 pm</h4>
    <div class="postbody"><span class="postbody">LCD Ghosting is quite noticeable on the secret level in episode 1 of Wolfenstein 3D.
<br/>
The teal doors and purple walls combine to make a weird blue smearing effect.
<br/>
<br/>
Oddly enough this only seems to happen on the DSLite.
<br/>
Why did they go with a screen with a higher response time anyway?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156411 - silent_code - Fri May 09, 2008 2:24 pm</h4>
    <div class="postbody"><span class="postbody">EDIT: corrected to BGR and bottom -&gt; top. yes, tepples, you're right. thanks!
<br/>
<br/>
@ Lazy1: production cost maybe? or they have selected another manufacturer?
<br/>
<br/>
(disclaimer: i don't have an ndsl myself, but iirc:)  the ndsl screens are both BGR now. the ("phat") nds' screens were technically identical, the top one was just rotated 180?, thus making it RGB - looking closely at the border regions of the nds' screens, you will see it easily.
<br/>
that indicates a rather "big" change in technical design (think of the hacks some have made to display subpixel fonts correctly, which needed adjustment for the top screen!)
<br/>
<br/>
has anyone info about the rgb/bgr issue? i might be wrong on this (it's from year old memory and as we all know, memory fails us quite often!) ;^p i guess looking closely at an ndsl would do the trick. :^)
<br/>
<br/>
the reasons for such a move are not known to me. "and still, i wonder..." :^)</span><span class="gensmall"><br/><br/>Last edited by silent_code on Fri May 09, 2008 8:54 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#156439 - tepples - Fri May 09, 2008 8:25 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">Oddly enough this only seems to happen on the DSLite.
<br/>
Why did they go with a screen with a higher response time anyway?</td> </tr></table><span class="postbody">
<br/>
In cheap LCDs, sometimes there's a tradeoff between contrast and response time. The PSP LCD response time is slow, and so is that of the DS Lite, but the colors are a lot brighter than on the original DS.
<br/>
<br/>
As for RGB vs. BGR: The GBC, GBA, and DS Lite are BGR. The original DS is BGR on the touch screen and RGB on the top screen. I haven't checked the Game Boy micro.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156440 - yellowstar - Fri May 09, 2008 9:08 pm</h4>
    <div class="postbody"><span class="postbody">@silent: Well, all I have is emulators, but I couldn't see any effect with Desmume, or no$gba.(Those emus emulate the effect correctly)(broken card) (If it uses 8-bit bgs like how I want, wonder if there's source code...)(Couldn't find any source when I googled though.)
<br/>
<br/>
@all: Which screen the image is displayed on, and whether it's on a phat or Lite doesn't help anything. It shows up better on a Lite however.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
