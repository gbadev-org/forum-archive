<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Unloading textures - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Unloading textures</h2>
<div id="posts">
<div class="post">
    <h4>#77030 - Chris Holmes - Mon Mar 27, 2006 4:26 pm</h4>
    <div class="postbody"><span class="postbody">Quick 2 questions.
<br/>
<br/>
If you're working with a large number of textures, is there a way to unload textures from the unit, or does that get handled automatically in hardware?  Also, is there a way to query the amount of available texture memory?
<br/>
<br/>
Thanks,
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77062 - Webez - Mon Mar 27, 2006 9:39 pm</h4>
    <div class="postbody"><span class="postbody">You can use glResetTextures to unload all textures. Still no function to unload only one
<br/>
<br/>
To know how much memory is available you could have a counter that can be increased by the size of the texture that you load ( a 128x128 8 bit texture is 128x128x1 bytes) or you can try to use the variable nextBlock  that libnds uses to point where it should put next texture.</span><span class="gensmall"><br/><br/>Last edited by Webez on Tue Mar 28, 2006 8:01 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#77067 - Payk - Mon Mar 27, 2006 11:31 pm</h4>
    <div class="postbody"><span class="postbody">hey i got same problem... i want to draw at textures. its ok and runs fine but if i try to update texture with that it doesnt make that update anymore.
<br/>
if i use glResetTextures and draw again it runs a view times again. So i wanted to reset each time but while it resets all textures, the screen is black for a short moment. dont like that of course...any ideas?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77069 - Chris Holmes - Mon Mar 27, 2006 11:33 pm</h4>
    <div class="postbody"><span class="postbody">You shouldn't be "updating" textures at all.  OpenGL wasn't designed
<br/>
to work that way.  Loading a texture is a relatively slow operation and
<br/>
isn't something that you want to do every frame.
<br/>
<br/>
If there are some extra textures in memory, that's fine.  Don't worry about that unless you start running out of texture memory.  The better question is why are you editting textures on the fly?  You can probably change what you're doing so that you don't need to edit textures on the fly.
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77081 - tepples - Tue Mar 28, 2006 2:16 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote">The better question is why are you editting textures on the fly?  You can probably change what you're doing so that you don't need to edit textures on the fly.</td> </tr></table><span class="postbody">
<br/>
Put your mouse pointer on this window's scrollbar and drag the box up and down. Now do this while turning your head in random directions.
<br/>
<br/>
I want to draw a television set that displays a moving image. In the simplest case, the quad representing the screen needs to use a different texture for each frame of video. This video is generated on the fly, either from decompression of a compressed video bitstream (yay DPG) or algorithmically from what is going on elsewhere in the game world. And I may want to use more than one quad for the screen so that I can simulate the distortions of bad reception until the player drags the on-screen rabbit ear antenna into the proper position or until the player leaves the tunnel or until the player sobers up.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77114 - Payk - Tue Mar 28, 2006 11:21 am</h4>
    <div class="postbody"><span class="postbody">ok i want to chnage that on fly. The reason is that i need a 128x128 texture for the ground and want to draw flowers and shadows on it.on that way i gonna need just 2 polygons for entiry ground. other reason would be an animated water texture...ok the water could be animated by swapping its texture but for the ground i really need that! now it runs fine but just in that moment of refresh the screen gets black for a very short moment. but i gonna save the renderrimage to a bg-layer before refreshing texture so that black must be invisible...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77115 - Payk - Tue Mar 28, 2006 11:22 am</h4>
    <div class="postbody"><span class="postbody">and also i never said that i gonna refresh textures each frame...it just happens in some moments which isnt often...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77123 - masscat - Tue Mar 28, 2006 1:35 pm</h4>
    <div class="postbody"><span class="postbody">Yes you can edit textures on the fly. The tricky bit is finding where they are in the VRAM memory. You could keep track of this as you load textures (similar to tracking the amount of memory described above - you can see how libnds allocates texture memory by downloading its source).
<br/>
Then to update the texture you lock the bank the texture is in, allowing the ARM access to the memory, write to the VRAM memory and then restore the bank to VRAM_?_TEXTURE. The next time you use the texture it will be updated.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">vramSetBankA(VRAM_A_LCD);
<br/>
VRAM_A[100] = count++;
<br/>
vramSetBankA(VRAM_A_TEXTURE);</td> </tr></table><span class="postbody">
<br/>
<br/>
You must access the VRAM as 16 or 32 bit words as I do not believe VRAM is byte addressable.
<br/>
<br/>
<span style="font-weight: bold">EDIT:</span>
<br/>
For a short term solution you could use the following code which is a hack of the libnds glTextImage2D function to pass the address of the texture back. The bit in the extern "C" braces is declarations for private, i.e. not declared in the header file, function used in libnds. The extern "C" is needed if you are using the C++ compiler.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">extern "C" {
<br/>
/* Out come some private GL functions */
<br/>
uint32* getNextTextureSlot(int size);
<br/>
void glTexParameter( uint8 sizeX, uint8 sizeY,
<br/>
           uint32* addr,
<br/>
           uint8 mode,
<br/>
           uint32 param);
<br/>
}
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
// Similer to glTextImage2D from gl it takes a pointer to data
<br/>
//  Empty fields and target are unused but provided for code compatibility.
<br/>
//  type is simply the texture type (GL_RGB, GL_RGB8 ect...)
<br/>
//---------------------------------------------------------------------------------
<br/>
int glTexImage2D_retAddr( int target, int empty1, int type,
<br/>
           int sizeX, int sizeY,
<br/>
           int empty2, int param,
<br/>
           uint8* texture, uint32 **addr) {
<br/>
//---------------------------------------------------------------------------------
<br/>
  uint32 size = 0;
<br/>
  //  uint32* addr;
<br/>
  uint32 vramTemp;
<br/>
<br/>
  size = 1 &lt;&lt; (sizeX + sizeY + 6);
<br/>
<br/>
  switch (type) {
<br/>
    case GL_RGB:
<br/>
    case GL_RGBA:
<br/>
      size = size &lt;&lt; 1;
<br/>
      break;
<br/>
    case GL_RGB4:
<br/>
      size = size &gt;&gt; 2;
<br/>
      break;
<br/>
    case GL_RGB16:
<br/>
      size = size &gt;&gt; 1;
<br/>
      break;
<br/>
<br/>
    default:
<br/>
      break;
<br/>
  }
<br/>
  
<br/>
  *addr = getNextTextureSlot(size);
<br/>
  
<br/>
  if(!*addr)
<br/>
    return 0;
<br/>
<br/>
  // unlock texture memory
<br/>
  vramTemp = vramSetMainBanks(VRAM_A_LCD,VRAM_B_LCD,VRAM_C_LCD,VRAM_D_LCD);
<br/>
<br/>
  if (type == GL_RGB) {
<br/>
    // We do GL_RGB as GL_RGBA, but we set each alpha bit to 1 during the copy
<br/>
    u16 * src = (u16*)texture;
<br/>
    u16 * dest = (u16*)(*addr);
<br/>
    
<br/>
    glTexParameter(sizeX, sizeY, *addr, GL_RGBA, param);
<br/>
    
<br/>
    while (size--) {
<br/>
      *dest++ = *src | (1 &lt;&lt; 15);
<br/>
      src++;
<br/>
    }
<br/>
  } else {
<br/>
    // For everything else, we do a straight copy
<br/>
    glTexParameter(sizeX, sizeY, *addr, type, param);
<br/>
    swiCopy((uint32*)texture, *addr , size / 4 | COPY_MODE_WORD);
<br/>
  }
<br/>
<br/>
  vramRestoreMainBanks(vramTemp);
<br/>
<br/>
  return 1;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77141 - Payk - Tue Mar 28, 2006 5:15 pm</h4>
    <div class="postbody"><span class="postbody">dirty methods...but i like that idea i will sit down and code a bit... Thanx for giving me such a clear dirrection. Perhaps u saved my project...THANX UR GREAT</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77148 - Payk - Tue Mar 28, 2006 6:07 pm</h4>
    <div class="postbody"><span class="postbody">just watched ur homepage </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">DSLinux - if it has got a processor stick Linux on it. </td> </tr></table><span class="postbody"> hehe funny... hey but another thing: That term u gave us just returns (0 || 1)...Ok should be solved easily... But if i know how many textures i will add (and their size,type and other things) would it be easy to say: First texture is mapped to 0x6000000 (i know its a bg address just an example). So if i add my textures in a specified order i could also know where my texture is... I mean they wont map textures to addresses by randomnumbers... So if i set up vrambank_a to a texturebank. Where would be the first texture i add? Could i then initialize an array to that adress and after binding texture just modify that array? (Like framebuffermode...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77151 - Payk - Tue Mar 28, 2006 6:28 pm</h4>
    <div class="postbody"><span class="postbody">Did u watched "getNextTextureSlot(size);"? so that should be the adress i think... So it would be possible to return that addres intead of returning a bool value... But if i use that modified function to add textures,it will also need the rest of videoGl.h. Or more bad it would need the rest of ndslib/libnds... So that wouldnt be that easy to find out where the texture was putten in...Best would be VRAM_A_TEXTURE begins at 0x6.....
<br/>
VRAM_A_TEXTURE is a #define i think. So if we know the correct address and unlock the vram we can map to texture dirrect. then we have to lock rambanks again...(I think that was that what u meaned...) Yes its an great idea... and that extern "c" means that this function is a modified version and has to be called instead..But that modified calls other functions(which perhaps arent accesable from outside of libnds) too.</span><span class="gensmall"><br/><br/>Last edited by Payk on Tue Mar 28, 2006 6:31 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#77152 - Webez - Tue Mar 28, 2006 6:31 pm</h4>
    <div class="postbody"><span class="postbody">If you need the texture address get the one in nextBlock before allocating the texture.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77153 - masscat - Tue Mar 28, 2006 6:31 pm</h4>
    <div class="postbody"><span class="postbody">You use the function in the same way as glTexImage2D which returns 1 if successful or zero otherwise. What I added was the "uint32 **addr" parameter. It is through this parameter that the address is returned. For example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">uint32 *my_texture_address;
<br/>
<br/>
/* setup your textures */
<br/>
glTexImage2D_retAddr( 0, 0, GL_RGB4, TEXTURE_SIZE_128, TEXTURE_SIZE_128, 0, TEXGEN_TEXCOORD, texture_data, &amp;my_texture_address);
<br/>
<br/>
/* do some other stuff */
<br/>
<br/>
/* change the texture in VRAM */
<br/>
uint32 vram_temp = vramSetMainBanks( VRAM_A_LCD, VRAM_B_LCD, VRAM_C_LCD, VRAM_D_LCD);
<br/>
for ( i = 0; i &lt; texture_size; i++) {
<br/>
  my_texture_address[i] = new_data;
<br/>
}
<br/>
vramRestoreMainBanks( vram_temp);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Note that I am using vramSetMainBanks to lock all the VRAM banks.
<br/>
You could work out which bank your texture has been stored in from the address and only lock and unlock that bank.
<br/>
<br/>
<span style="font-weight: bold">EDIT:</span> Or as Webez said, just read nextBlock before you call glTexImage2D. All you need to do is declare the following in your source.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">extern uint32* nextBlock;</td> </tr></table><span class="postbody">
<br/>
The problem with all these methods is that they rely on the internal workings of libnds and this will change in the future and your code will break, hence the "short term fix" I said in my first post.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77160 - Payk - Tue Mar 28, 2006 7:55 pm</h4>
    <div class="postbody"><span class="postbody">thanx that all works for me...But it doesnt help me. while i update that textures, the models which have that texture dissapears untill next frame (very short moment but i hate that). And also the texture now has black parts (i got an idea why rgb and rgba..). So do the textures get black for short in ur projects too? or do i call that function at wrong time?
<br/>
<br/>
<a href="http://payk2005.pa.funpic.de/4.jpg">[Images not permitted - Click here to view it]</a>
<br/>
and do u like that?
<br/>
<br/>
<span style="font-weight: bold">Edit:</span>I have to say that this short moment in that the screen gets black, is much shorter on hardware then my method before...so thanx!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77162 - tepples - Tue Mar 28, 2006 8:02 pm</h4>
    <div class="postbody"><span class="postbody">Have you tried double-buffering the texture that must be rewritten? Allocate two textures and modify the one that isn't being displayed.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77165 - Payk - Tue Mar 28, 2006 8:14 pm</h4>
    <div class="postbody"><span class="postbody">yes sure first i wanted to do that. But its seems like while VRAMBANKS are unlocked (to acces it) the textures cant be displayed. So best would be to make that timer interval between unlock and locking as small as possible... So i going to try dmacopy instead putting it pixel_by_pixel with a loop. But the problem is that dmacopy doesnt support changing each bit. That is neccesary if u look at my picture. That should make it better. And i watched that sources of libnds some minuts ago...
<br/>
<br/>
0x06800000&lt;&lt;Here the first texture will be. its the address. I have no clue for which ram bank but i think its for rambank_a (just a feeling that they dont begin with VRambank_b)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77166 - Payk - Tue Mar 28, 2006 8:33 pm</h4>
    <div class="postbody"><span class="postbody">ok did u saw my picture i posted? There are black lines all over the texture...i thought its the alphabit but it wasnt...i have no idea why. does anybody knows why?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77167 - Payk - Tue Mar 28, 2006 9:23 pm</h4>
    <div class="postbody"><span class="postbody">something new:
<br/>
That black lines appaers because memory wants a 32 bit pixel. So i tried that </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   for(yy=0;yy&lt;256;yy++){
<br/>
      for(xx=0;xx&lt;256;xx++){
<br/>
         my_texture_address[xx+(yy*256)] = BodenImage[xx+(yy*256)] | (BodenImage[xx+(yy*256)] &lt;&lt; 16); 
<br/>
      }
<br/>
   }
<br/>
   </td> </tr></table><span class="postbody"> And guess what? the black lines arent there anymore but the texture is still wrong. Now where all black lines were, a completly wrong pixel appeared which should be somewhere else in the texture...So u just need a loop which makes 2 16bit pixels become one 32bit-pixel-group. i am tired so i m not going to make that loop today... So thanx all u guys for helping me with that. I think i would never had found out what u told me. Thanx ur great devers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77172 - Webez - Tue Mar 28, 2006 9:35 pm</h4>
    <div class="postbody"><span class="postbody">A pixel can't be 32 bit</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77174 - Payk - Tue Mar 28, 2006 9:56 pm</h4>
    <div class="postbody"><span class="postbody">i know. i didnt meaned that one pixel has 32 bit. I meaned that u have to put 2 pixels in a 32bitWord. dont know how to explain u all see that i am bad at english...
<br/>
<br/>
But that should show u what i mean:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">my_texture_address[i]=BodenImage[i] | (BodenImage[i] &lt;&lt; 16);</td> </tr></table><span class="postbody">
<br/>
<br/>
So in that u32 we would see: 1010 0101 0110 0001
<br/>
________________________^Pixel1___^Pixel2
<br/>
<br/>
Ok actually vice versa (u no Last Significant Bit is first bit we would read)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77177 - masscat - Tue Mar 28, 2006 10:27 pm</h4>
    <div class="postbody"><span class="postbody">You could access each pixel individually (assuming you are using GL_RGB or GL_RGBA format textures which has a 16bit pixel) by casting my_texture_address to a uint16 pointer:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">uint16 *pixel_pointer = (uint16 *)my_texture_address;</td> </tr></table><span class="postbody">
<br/>
<br/>
What you cannot do is access each byte of VRAM individual as VRAM is not byte addressable (I am not sure if this is correct mind).
<br/>
<br/>
As for VRAM banks being locked for ARM access and the texture not being displayed then, yep, this is what happens. To cope with this you either will have to update your textures and release the VRAM bank before redrawing your screen or implement double buffering as tepples suggested.
<br/>
For double buffering you could, for example, store a copy of the texture in VRAM A and another in VRAM B. This way you could lock VRAM A for ARM access whilst the graphics hardware is happily accessing the texture in VRAM B. Then switch over when you have updated the texture.
<br/>
The problem with double buffering is that the texture management in libnds, today, does not make it easy to support as you cannot force a texture into a specific VRAM bank. Another limitation of libnds textures is the subject of this topic, i.e. you cannot free a single texture.
<br/>
The good thing is that libnds will improve and/or somebody will come along and write some texture management code that can live along side it. I have been thinking about doing some sort of texture management as I want to implement a window system using the 3D hardware. Only initial thoughts at the moment whilst I learn more about the hardware.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77180 - Payk - Tue Mar 28, 2006 11:40 pm</h4>
    <div class="postbody"><span class="postbody">yeah ur like me...
<br/>
my first thought when i read source of videogl.c was : "Can i change entiry system so its possible to move textures arround in memory or change the bank..." and i aslo thought about a window based system for 3D. But damn u know that we just have about 640 kb... So i would recommand to render a single window and map that to bg before rendering next one. On that way u could have as much wins as u need...
<br/>
And that thing with that vrambank that u cant choose where the texture is located...I think shouldnt be that hard to solve. I found out that the rambank_a_texture starts at 0x06800000. and we know which size the banks have so i can calculate where the others are...Ok i really think a new managment must appear and i am going to work for that. as i see u gonna start soon, too. Better would be teamwork... Interessted? send me a pm... and i got some functions for a api ready to use.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77241 - tepples - Wed Mar 29, 2006 6:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>masscat wrote:</b></span></td> </tr> <tr> <td class="quote">As for VRAM banks being locked for ARM access and the texture not being displayed then, yep, this is what happens. To cope with this you either will have to update your textures and release the VRAM bank before redrawing your screen or implement double buffering as tepples suggested.
<br/>
For double buffering you could, for example, store a copy of the texture in VRAM A and another in VRAM B. This way you could lock VRAM A for ARM access whilst the graphics hardware is happily accessing the texture in VRAM B. Then switch over when you have updated the texture.</td> </tr></table><span class="postbody">
<br/>
Either that or put them in the same bank and then copy them in during blanking time. That worked on the NES, Game Boy, and GBA; does it work on Nintendo DS as well?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#77268 - Payk - Wed Mar 29, 2006 9:06 pm</h4>
    <div class="postbody"><span class="postbody">real? when exactly is that time? after swiWaitForVBlank or before?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
