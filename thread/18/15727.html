<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>dldipatch code help (Renamed) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > dldipatch code help (Renamed)</h2>
<div id="posts">
<div class="post">
    <h4>#159192 - cornaljoe - Thu Jun 26, 2008 6:03 pm</h4>
    <div class="postbody"><span class="postbody">Here is the code I'm using:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*---------------------------------------------------------------------------------
<br/>
<br/>
   Quick DLDI chaining example
<br/>
   Loads "/fat3.dldi" from the first device, then uses that to read from a 
<br/>
   second device.
<br/>
   This is quickly written, messy code. No warranty is given.
<br/>
   
<br/>
   Copyright 2007 by Michael "Chishm" Chisholm
<br/>
<br/>
---------------------------------------------------------------------------------*/
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;unistd.h&gt;
<br/>
#include &lt;fat.h&gt;
<br/>
#include &lt;malloc.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
#include &lt;sys/dir.h&gt;
<br/>
#include &lt;sys/stat.h&gt;
<br/>
<br/>
#include "dldi_chain.h"
<br/>
<br/>
#ifdef __cplusplus
<br/>
extern "C" {
<br/>
#endif
<br/>
<br/>
#define MAGIC_TOKEN 0xBF8DA5ED
<br/>
<br/>
#define FIX_ALL   0x01
<br/>
#define FIX_GLUE   0x02
<br/>
#define FIX_GOT   0x04
<br/>
#define FIX_BSS   0x08
<br/>
<br/>
#define DLDI_VERSION 1
<br/>
<br/>
enum DldiOffsets {
<br/>
   DO_magicString = 0x00,         // "\xED\xA5\x8D\xBF Chishm"
<br/>
   DO_magicToken = 0x00,         // 0xBF8DA5ED
<br/>
   DO_magicShortString = 0x04,      // " Chishm"
<br/>
   DO_version = 0x0C,
<br/>
   DO_driverSize = 0x0D,
<br/>
   DO_fixSections = 0x0E,
<br/>
   DO_allocatedSpace = 0x0F,
<br/>
<br/>
   DO_friendlyName = 0x10,
<br/>
<br/>
   DO_text_start = 0x40,         // Data start
<br/>
   DO_data_end = 0x44,            // Data end
<br/>
   DO_glue_start = 0x48,         // Interworking glue start   -- Needs address fixing
<br/>
   DO_glue_end = 0x4C,            // Interworking glue end
<br/>
   DO_got_start = 0x50,         // GOT start               -- Needs address fixing
<br/>
   DO_got_end = 0x54,            // GOT end
<br/>
   DO_bss_start = 0x58,         // bss start               -- Needs setting to zero
<br/>
   DO_bss_end = 0x5C,            // bss end
<br/>
<br/>
   DO_driverStart = 0x60,
<br/>
   // IO_INTERFACE data
<br/>
   DO_ioType = 0x60,
<br/>
   DO_features = 0x64,
<br/>
   DO_startup = 0x68,   
<br/>
   DO_isInserted = 0x6C,   
<br/>
   DO_readSectors = 0x70,   
<br/>
   DO_writeSectors = 0x74,
<br/>
   DO_clearStatus = 0x78,
<br/>
   DO_shutdown = 0x7C,
<br/>
   DO_code = 0x80
<br/>
};
<br/>
<br/>
const u8 dldiMagicString[] = "\xED\xA5\x8D\xBF Chishm";
<br/>
<br/>
#define READ_ADDR(d,o) (*(u32*)((d)+(o)))
<br/>
#define WRITE_ADDR(d,o,v) *(u32*)((d)+(o)) = (v)
<br/>
<br/>
int dldiPatch (u8* data, u32 len) {
<br/>
   unsigned int memOffset, ddmemOffset, relocationOffset;
<br/>
   unsigned int ddmemStart, ddmemSize, ddmemEnd;
<br/>
   unsigned int addrIter;
<br/>
<br/>
   // Make sure the DLDI file is valid and usable
<br/>
   if (strcmp ((char*)dldiMagicString, (char*)&amp;data[DO_magicString]) != 0) {
<br/>
      return -1;
<br/>
   }
<br/>
   if (data[DO_version] != DLDI_VERSION) {
<br/>
      return -1;
<br/>
   }
<br/>
<br/>
   memOffset = (u32)data;
<br/>
<br/>
   ddmemOffset = READ_ADDR (data, DO_text_start);
<br/>
   relocationOffset = memOffset - ddmemOffset;
<br/>
<br/>
   ddmemStart = READ_ADDR (data, DO_text_start);
<br/>
   ddmemSize = (1 &lt;&lt; data[DO_driverSize]);
<br/>
   ddmemEnd = ddmemStart + ddmemSize;
<br/>
<br/>
   // Fix the section pointers in the header
<br/>
   WRITE_ADDR (data, DO_text_start, READ_ADDR (data, DO_text_start) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_data_end, READ_ADDR (data, DO_data_end) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_glue_start, READ_ADDR (data, DO_glue_start) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_glue_end, READ_ADDR (data, DO_glue_end) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_got_start, READ_ADDR (data, DO_got_start) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_got_end, READ_ADDR (data, DO_got_end) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_bss_start, READ_ADDR (data, DO_bss_start) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_bss_end, READ_ADDR (data, DO_bss_end) + relocationOffset);
<br/>
   // Fix the function pointers in the header
<br/>
   WRITE_ADDR (data, DO_startup, READ_ADDR (data, DO_startup) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_isInserted, READ_ADDR (data, DO_isInserted) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_readSectors, READ_ADDR (data, DO_readSectors) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_writeSectors, READ_ADDR (data, DO_writeSectors) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_clearStatus, READ_ADDR (data, DO_clearStatus) + relocationOffset);
<br/>
   WRITE_ADDR (data, DO_shutdown, READ_ADDR (data, DO_shutdown) + relocationOffset);
<br/>
<br/>
   if (data[DO_fixSections] &amp; FIX_ALL) { 
<br/>
      // Search through and fix pointers within the data section of the file
<br/>
      for (addrIter = (READ_ADDR(data, DO_text_start) - ddmemStart); addrIter &lt; (READ_ADDR(data, DO_data_end) - ddmemStart); addrIter++) {
<br/>
         if ((ddmemStart &lt;= READ_ADDR(data, addrIter)) &amp;&amp; (READ_ADDR(data, addrIter) &lt; ddmemEnd)) {
<br/>
            WRITE_ADDR (data, addrIter, READ_ADDR(data, addrIter) + relocationOffset);
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
<br/>
   if (data[DO_fixSections] &amp; FIX_GLUE) { 
<br/>
      // Search through and fix pointers within the glue section of the file
<br/>
      for (addrIter = (READ_ADDR(data, DO_glue_start) - ddmemStart); addrIter &lt; (READ_ADDR(data, DO_glue_end) - ddmemStart); addrIter++) {
<br/>
         if ((ddmemStart &lt;= READ_ADDR(data, addrIter)) &amp;&amp; (READ_ADDR(data, addrIter) &lt; ddmemEnd)) {
<br/>
            WRITE_ADDR (data, addrIter, READ_ADDR(data, addrIter) + relocationOffset);
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
<br/>
   if (data[DO_fixSections] &amp; FIX_GOT) { 
<br/>
      // Search through and fix pointers within the Global Offset Table section of the file
<br/>
      for (addrIter = (READ_ADDR(data, DO_got_start) - ddmemStart); addrIter &lt; (READ_ADDR(data, DO_got_end) - ddmemStart); addrIter++) {
<br/>
         if ((ddmemStart &lt;= READ_ADDR(data, addrIter)) &amp;&amp; (READ_ADDR(data, addrIter) &lt; ddmemEnd)) {
<br/>
            WRITE_ADDR (data, addrIter, READ_ADDR(data, addrIter) + relocationOffset);
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
<br/>
   if (data[DO_fixSections] &amp; FIX_BSS) { 
<br/>
      // Initialise the BSS to 0
<br/>
      memset (&amp;data[READ_ADDR(data, DO_bss_start) - ddmemStart] , 0, READ_ADDR(data, DO_bss_end) - READ_ADDR(data, DO_bss_start));
<br/>
   }
<br/>
   
<br/>
   return 0;
<br/>
}
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void CustomFatInit() {
<br/>
//---------------------------------------------------------------------------------
<br/>
<br/>
   fatInitDefault();
<br/>
   
<br/>
   FILE* customDriver = fopen ("/fat3.dldi", "rb");
<br/>
   if (customDriver == NULL) {
<br/>
      while(1) swiWaitForVBlank();
<br/>
   }
<br/>
   fseek (customDriver, 0, SEEK_END);
<br/>
   size_t driverSize = ftell (customDriver);
<br/>
   fseek (customDriver, 0, SEEK_SET);
<br/>
   u8* driverData = malloc (driverSize);
<br/>
   fread (driverData, 1, driverSize, customDriver);
<br/>
   fclose (customDriver);
<br/>
   
<br/>
   if (dldiPatch (driverData, driverSize) &lt; 0) {
<br/>
      while(1) swiWaitForVBlank();
<br/>
   }
<br/>
<br/>
   fatMountCustomInterface ((struct IO_INTERFACE_STRUCT*) (driverData + DO_driverStart), 8);
<br/>
}
<br/>
<br/>
#ifdef __cplusplus
<br/>
}
<br/>
#endif</td> </tr></table><span class="postbody">
<br/>
<br/>
It's a modified version of Chishm dldi_chain demo posted <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=12001&amp;start=278" target="_blank">here</a>.    I use this function in place of fatInitDefault() in order to load 2 FAT systems.
<br/>
<br/>
Everything seems fine only the custom interface thats loaded from 'fat0:/fat3.dldi' is only readable.  When attempting to write to the disk (fat3:/) it writes a 0 byte file and freezes the DS.  Anyone know how I can fix this?  Thanks for the help.</span><span class="gensmall"><br/><br/>Last edited by cornaljoe on Sat Jul 05, 2008 3:25 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#159210 - cornaljoe - Fri Jun 27, 2008 1:35 am</h4>
    <div class="postbody"><span class="postbody">Ok I browsed over the source of libnds and even though I have no idea what I'm looking at I think I've found something that may help.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct {
<br/>
   const IO_INTERFACE* disc;
<br/>
   CACHE* cache;
<br/>
   // Info about the partition
<br/>
   bool readOnly;      // If this is set, then do not try writing to the disc             &lt;- This is the key
<br/>
   FS_TYPE filesysType;
<br/>
   u32 totalSize;
<br/>
   u32 rootDirStart;
<br/>
   u32 rootDirCluster;
<br/>
   u32 numberOfSectors;
<br/>
   u32 dataStart;
<br/>
   u32 bytesPerSector;
<br/>
   u32 sectorsPerCluster;
<br/>
   u32 bytesPerCluster;
<br/>
   FAT fat;
<br/>
   // Values that may change after construction
<br/>
   u32 cwdCluster;         // Current working directory cluser
<br/>
   u32 openFileCount;
<br/>
} PARTITION;
<br/>
<br/>
and
<br/>
<br/>
// Check if this disc is writable, and set the readOnly property appropriately
<br/>
   partition-&gt;readOnly = !(_FAT_disc_features(disc) &amp; FEATURE_MEDIUM_CANWRITE);</td> </tr></table><span class="postbody">
<br/>
<br/>
Looking at that I've come to find using this should fix my problem:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">_FAT_partitions[PI_CUSTOM]-&gt;readOnly = false;</td> </tr></table><span class="postbody">
<br/>
<br/>
But I can't use that in my source because none of the variables exist except PI_CUSTOM.  Any ideas?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159425 - cornaljoe - Mon Jun 30, 2008 5:54 pm</h4>
    <div class="postbody"><span class="postbody">I recompiled libfat for test purposes and found the problem in the dldiPatch function.  It seems to patch in a way that only allows read access to the disk.  Anyone understand how the patching code works?  I can't get ahold of chishm atm, he would be great help.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159428 - elhobbs - Mon Jun 30, 2008 6:36 pm</h4>
    <div class="postbody"><span class="postbody">has anyone tried adding print statments for data[DO_features] at various stages of the reloacation code? I think the bss section is for uninitialized data, but it does get forced to 0. could it be happening there? maybe you could try saving the data[DO_features] value before the relocation and then puting it back afterwords - this would at least tell you if the relocation code is the problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159471 - cornaljoe - Tue Jul 01, 2008 6:53 pm</h4>
    <div class="postbody"><span class="postbody">It seems that the relocation code works fine.  I also tried initializing BSS normally with no luck aswell.  Thanks for the suggestions but I'm still puzzled on what the problem could be.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159475 - elhobbs - Tue Jul 01, 2008 7:40 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>cornaljoe wrote:</b></span></td> </tr> <tr> <td class="quote">It seems that the relocation code works fine.  I also tried initializing BSS normally with no luck aswell.  Thanks for the suggestions but I'm still puzzled on what the problem could be.</td> </tr></table><span class="postbody">so, the FEATURE_MEDIUM_CANWRITE bit is set at data[DO_features] before and after relocation? that should be the determination for being able to write.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159503 - cornaljoe - Wed Jul 02, 2008 2:45 am</h4>
    <div class="postbody"><span class="postbody">Sorry I have very little knowledge of memory management but I'll give it a try.  Here is the code I used to display the value of data[DO_features] before and after the relocation.  I got the same result.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">printf ("Features:          0x%08X\n", data[DO_features]);
<br/>
<br/>
Result:    0x00000013</td> </tr></table><span class="postbody">
<br/>
<br/>
According to disc_io.h</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define FEATURE_MEDIUM_CANREAD      0x00000001
<br/>
#define FEATURE_MEDIUM_CANWRITE      0x00000002
<br/>
#define FEATURE_SLOT_GBA         0x00000010
<br/>
#define FEATURE_SLOT_NDS         0x00000020</td> </tr></table><span class="postbody">
<br/>
<br/>
So its being detected as Slot-2 but the last bit is set to 3 instead of 1/2.  Cool I guess I did it right!  Thanks I'm actually learning alot here.  Can I just change the value to get it to work?
<br/>
<br/>
Edit:  Wait 1 + 2 = 3 so does that mean its the value for reading and writing?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159536 - fluff - Wed Jul 02, 2008 1:07 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>cornaljoe wrote:</b></span></td> </tr> <tr> <td class="quote">the last bit is set to 3 instead of 1/2</td> </tr></table><span class="postbody">
<br/>
<br/>
That's a pretty powerful bit! :P
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>cornaljoe wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Edit:  Wait 1 + 2 = 3 so does that mean its the value for reading and writing?</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159539 - silent_code - Wed Jul 02, 2008 1:17 pm</h4>
    <div class="postbody"><span class="postbody">Quantum bits can "store" 3 states with 1bit: Yes, No, Maybe ;^)<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159541 - elhobbs - Wed Jul 02, 2008 1:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>silent_code wrote:</b></span></td> </tr> <tr> <td class="quote">Quantum bits can "store" 3 states with 1bit: Yes, No, Maybe ;^)</td> </tr></table><span class="postbody">off topic but I think you may be wrong. binary bits can store 8 states with 3 bits. a single quantum bit has three states. so wouldn't that mean it could store 27 states with 3 bits?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159542 - silent_code - Wed Jul 02, 2008 1:31 pm</h4>
    <div class="postbody"><span class="postbody">I am not an expert, but qbits have two states and a (range) superstate inbetween.
<br/>
<br/>
But I remember (may not be accurate, it's been a while) you could store 8bit worth of information in just 3qbits. That's because these qbits don't count as single bits in a qbit set, but rather all as an unit. That makes it not pow(2, 8) = 256, but pow(2, pow(2, 3)) = 256 for qbits. (The formula may be bogus for anything else than 3qbits, though.)
<br/>
It's due to the parallel storage of multiple states in the qbit set (through "maybe"s)... Well, something like that. ;^)
<br/>
<br/>
Wikipedia says: One qbyte can not only store the numbers 0 to 255, it can also store them all, at the same time. Actually, non trivial sets (includes the qbit) can represent an infinite set of numbers, due to the non discrete nature of the superstate and qbit entanglement (I'm not sure about that, though - I'm not an expert.)
<br/>
Brain hurt.<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
