<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Optimizing normal calculations - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Optimizing normal calculations</h2>
<div id="posts">
<div class="post">
    <h4>#135430 - DiscoStew - Mon Jul 23, 2007 8:39 am</h4>
    <div class="postbody"><span class="postbody">Something I just recently got into when working on my Maya exporter, but it seems that the code I used and converted to calculating normals looks to be so CPU intensive, that the entire program is slowing down by it, and I was wondering if anyone has any suggestions.
<br/>
<br/>
As far as calculating the normals, I basically used the method found here....
<br/>
<br/>
<a href="http://www.spacesimulator.net/tut5_vectors_and_lighting.html" target="_blank">http://www.spacesimulator.net/tut5_vectors_and_lighting.html</a>
<br/>
<br/>
....but edited all the floats out, used 20.12 fixed point math and functions (crossf32 and normalizef32 in libnds), made modifications so quads were added, and allowed polygons using the same vertex to possibly not use the same normal value (imagine a box). Everything works out fine, except it seems to be going pretty slow compared to not doing any normal calculation.
<br/>
<br/>
At first I thought it could just be the emulator (using no$gba), as not everything is perfected enough for full emulation and speed, but just commenting out the normal calculations made a world of difference from pretty slow to full speed, as far as the  program goes. As of this moment, I don't have anything to test this out of hardware, but it's leaning me towards making a purchase.
<br/>
<br/>
Any suggestions for improving the normal calculations?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135431 - DekuTree64 - Mon Jul 23, 2007 8:56 am</h4>
    <div class="postbody"><span class="postbody">I don't know any specific tricks to speed up the normal calculation process itself, but you can get better rendering speed if you use display lists with normals included. And since I'm assuming you're generating all the normals when loading the model on the DS anyway, then all you're saving compared to doing it in the exporter is a bit of ROM space.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135437 - kusma - Mon Jul 23, 2007 10:51 am</h4>
    <div class="postbody"><span class="postbody">I usually only generate normals the general way (your link- minus the bugs they have, that is) for static objects, and transform it. For dynamic objects, it depends a bit.
<br/>
<br/>
For skinned meshes, you can skin the normals in the same way as you skin the positions.
<br/>
<br/>
For other deformations, you *could* construct tangent-space information, and deform a very small triangle constructed by position, position + binormal and position + tangent. Then just use the triangle-normal for that vertex. I'm not sure if this is faster or not for nds-games, but it fits a programmable vertex shader a lot better ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135450 - silent_code - Mon Jul 23, 2007 1:37 pm</h4>
    <div class="postbody"><span class="postbody">i reccomend doing it offline when exporting. i had a quite fast implementation (on pc) that turned out dead slow on thends. too slow. i prefer sacrificing a few bytes and instead gaining shorter loading times (from tens of seconds to tenths of a second).
<br/>
<br/>
good luck.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135470 - Ant6n - Mon Jul 23, 2007 7:06 pm</h4>
    <div class="postbody"><span class="postbody">for the dynamic stuff (i.e. runtime normals), assuming you do it exaclty like the way described by your linke, you could try
<br/>
1) doing the normals in arm instead of thumb (long long multiplies are faster), maybe in itcm (although with caching enabled by default this should'nt do much)
<br/>
2) instead of counting polygons and dividing to get the averaged normals, you could use a switch statement on the number of polygons and multiply by a const, i.e.
<br/>
case (numpolygons) of
<br/>
  3: normalx  *=  fixed(0.333), normaly *= fixed(0.333), normalz *= fixed(0.333)
<br/>
  4: normalx *= fixed(0.25) ... etc.
<br/>
up to maybe 7, do a divide for the rest</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135471 - DiscoStew - Mon Jul 23, 2007 7:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">I don't know any specific tricks to speed up the normal calculation process itself, but you can get better rendering speed if you use display lists with normals included. And since I'm assuming you're generating all the normals when loading the model on the DS anyway, then all you're saving compared to doing it in the exporter is a bit of ROM space.</td> </tr></table><span class="postbody">
<br/>
<br/>
Hehe, I knew display lists were gonna be brought up. The fact is, I'm not using display lists. For the past few months, I have been on and off creating my own exporter that takes information of a 3D model (polygons, materials, joints, etc), dumps them into a custom file, and under my code, it generates a real-time poseable model, and all that is needed to pose it is to send in an array that contains joint data. The whole reason for needing to generate normals each frame is because as the joints move, the polygons affected by those joints will move with them.
<br/>
<br/>
Since I last posted, I made a slight modification to when dividing the collection of normals by the number of polygons each normal will affect, by replacing the divide with a small reciprocal LUT. However, I barely saw any improvement, but an improvement nonetheless. The main time sink is with normalizing the 2 vectors, and then normalizing the overall normal for each polygon, and with a 300 triangle model, that's roughly 900 Sqrt calls and 2700 divide calls, not to mention everything else involved like calculations and storing that data. Not very pretty if you ask me.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135472 - sajiimori - Mon Jul 23, 2007 7:43 pm</h4>
    <div class="postbody"><span class="postbody">Sounds like pretty intense stuff -- I might consider making some quality sacrifices.  For instance, you could update only a half or a third of the normals on each frame, causing a slight delay in lighting updates.
<br/>
<br/>
Another sacrifice would be to animate at half frame rate (or less) and use linear interpolation to fill in the missing frames, using the extra cycles on the in-between frames to partially calculate the upcoming keyframe.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135475 - Ant6n - Mon Jul 23, 2007 8:40 pm</h4>
    <div class="postbody"><span class="postbody">"900 Sqrt calls and 2700 divide"
<br/>
instead of calculating
<br/>
k = sqrt(x^2+y^2+z^2)
<br/>
x = x/k; y= y/k; z = z/k
<br/>
try
<br/>
k = 1/sqrt(x^2+y^2+z^2)
<br/>
x *= k;y *= k;z *= k;
<br/>
<br/>
do you know about fast inverse square approximations?
<br/>
given some initial approximation x' on sqrt(x), you can find a better approximation x" with
<br/>
x" = x'*(1.5-(x/2)*x'*x');
<br/>
The initial approximation could be found with a lookup table on clz(x), or maybe a small lookup table for each clz(x).
<br/>
Again there are tons of long long multiplies, and I read somewhere that long long multiplies in thumb are expanded by gcc into something 'ugly', so try making these routines arm.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135512 - DiscoStew - Tue Jul 24, 2007 2:26 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote">"900 Sqrt calls and 2700 divide"
<br/>
instead of calculating
<br/>
k = sqrt(x^2+y^2+z^2)
<br/>
x = x/k; y= y/k; z = z/k
<br/>
try
<br/>
k = 1/sqrt(x^2+y^2+z^2)
<br/>
x *= k;y *= k;z *= k;</td> </tr></table><span class="postbody">
<br/>
<br/>
Oh boy, do I feel dumb. I used the normalizef32 function provided by libnds, but didn't give a single thought that I could take the basics of that function and optimize it for this purpose.  Very similar to the reciprocal LUT I used to replace the end portion of the normal calculations from multiple polygons, but never came to mind for this. This will reduce the number of divisions from 9 per triangle to 3 easily.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote">do you know about fast inverse square approximations?
<br/>
given some initial approximation x' on sqrt(x), you can find a better approximation x" with
<br/>
x" = x'*(1.5-(x/2)*x'*x');
<br/>
The initial approximation could be found with a lookup table on clz(x), or maybe a small lookup table for each clz(x).
<br/>
Again there are tons of long long multiplies, and I read somewhere that long long multiplies in thumb are expanded by gcc into something 'ugly', so try making these routines arm.</td> </tr></table><span class="postbody">
<br/>
<br/>
Sadly, I don't know much about inverse square approximations. Guess I've got some reading to do.
<br/>
<br/>
As far as making the routines arm-based, I haven't dived into that yet. I know with my past GBA projects, I edited the Make files to allow code to be in Arm if the code file has the ".iwram" extension on it, as IWRAM code was best as ARM, and ROM code as THUMB. Because all the ARM9 code is being put into RAM (am I correct on this?), is it best to make it all ARM-based? From the Make file I have for combining Arm7 and Arm9, I see this for C-files in the Arm9 Make file...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ARCH   :=   -mthumb -mthumb-interwork</td> </tr></table><span class="postbody">
<br/>
Was thinking -marm would work instead, but it didn't work. This isn't the GBA  :P<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135517 - Ant6n - Tue Jul 24, 2007 4:21 am</h4>
    <div class="postbody"><span class="postbody">code is in fact put in ram, but the 4mb ram is actually pretty slow; I found it takes 6 cycles for a 1 cycle arm instruction. Thumb instructions should run about twice as fast, but considering thumb can do less per instruction, its actually only 60% faster.
<br/>
Main ram is cached both with an instruction (8K) and data cache (4K). so running thumb from main ram is not only faster, but since its smaller there is more code that can stay cached. Instructions that are in cache run at full speed (afaik). Thus your overall code should stay thumb.
<br/>
the internal working fram of the DS is the tcm, again there is instruction and data tcm (itcm, dtcm). Again code runs at full speed. Instead of extention iwram, try extention dtcm.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135546 - kusma - Tue Jul 24, 2007 12:38 pm</h4>
    <div class="postbody"><span class="postbody">another thing to keep in mind is that you can (and it's generally more correct, explanation later) generate non-normalized polygon-normals, accumulate them, and normalize in the end. This has the advantage that a large polygon next to a small one will contribute more to the normal (since the area of the polygon is larger, it's non-normalized normal is bigger).
<br/>
<br/>
Also, dividing by the number of polygons contributing to a vertex is wrong. You can (and will) end up with non-normalized vectors that way. Normalizing is the way to go, and when you normalize any divides prior will only lead to rounding-errors.
<br/>
<br/>
edit: here's some pseudo-code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
vector calcNormal(p)
<br/>
{
<br/>
   return cross(...);
<br/>
}
<br/>
<br/>
for (p in polygon list)
<br/>
{
<br/>
   vector face_normal = calcNormal(p);
<br/>
   for (v in p)
<br/>
   {
<br/>
      v.normal += face_normal;
<br/>
   }
<br/>
}
<br/>
<br/>
for (v in vertex list)
<br/>
{
<br/>
   v.normal = normalize(v.normal);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
[/code]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135571 - DiscoStew - Tue Jul 24, 2007 6:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote">code is in fact put in ram, but the 4mb ram is actually pretty slow; I found it takes 6 cycles for a 1 cycle arm instruction. Thumb instructions should run about twice as fast, but considering thumb can do less per instruction, its actually only 60% faster.
<br/>
Main ram is cached both with an instruction (8K) and data cache (4K). so running thumb from main ram is not only faster, but since its smaller there is more code that can stay cached. Instructions that are in cache run at full speed (afaik). Thus your overall code should stay thumb.
<br/>
the internal working fram of the DS is the tcm, again there is instruction and data tcm (itcm, dtcm). Again code runs at full speed. Instead of extention iwram, try extention dtcm.</td> </tr></table><span class="postbody">
<br/>
<br/>
Interesting, I guess I can see why in the Make file it was set to Thumb mode. Maybe after a little examining, I'll edit the Arm9 Make file so tcm can be taken advantage of. It's basically comparable to iwram on the GBA, just more to it and slightly called differently?
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">another thing to keep in mind is that you can (and it's generally more correct, explanation later) generate non-normalized polygon-normals, accumulate them, and normalize in the end. This has the advantage that a large polygon next to a small one will contribute more to the normal (since the area of the polygon is larger, it's non-normalized normal is bigger).
<br/>
<br/>
Also, dividing by the number of polygons contributing to a vertex is wrong. You can (and will) end up with non-normalized vectors that way. Normalizing is the way to go, and when you normalize any divides prior will only lead to rounding-errors.
<br/>
<br/>
edit: here's some pseudo-code:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
vector calcNormal(p)
<br/>
{
<br/>
   return cross(...);
<br/>
}
<br/>
<br/>
for (p in polygon list)
<br/>
{
<br/>
   vector face_normal = calcNormal(p);
<br/>
   for (v in p)
<br/>
   {
<br/>
      v.normal += face_normal;
<br/>
   }
<br/>
}
<br/>
<br/>
for (v in vertex list)
<br/>
{
<br/>
   v.normal = normalize(v.normal);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
You've got my attention, not just because the normalizing is relocated to the ending part, but because the overall amount of code within the polygon processing is reduced. After seeing your example compared to the method by the "other guy", I decided to do a bit more searching around on the internet for polygon normalizing, and many sources, if not all, reference doing it the same way you've shown.
<br/>
<br/>
So, I gave your pseudo code a whirl, and I must say, everything is running at least 2 times faster because of that reduced calculation, and I haven't even gone with Ant6n's suggestion yet. The normals themselves look a bit different compared to the previous method. A bit brighter, and in one of my test models, some of the small polygons that are surrounded by bigger polygons look like the light isn't really reaching them, making them dark (the light is from the viewer's direction). I guess I'm just used to the look of the previous method, but I'm sure I'll get out of that phase  :P
<br/>
<br/>
Thanks again for all the help given. I really appreciate it. Maybe one of these days soon I'll put out a small demonstration of what I've done so far.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135573 - Ant6n - Tue Jul 24, 2007 7:30 pm</h4>
    <div class="postbody"><span class="postbody">oh right, adding and dividing is crap didnt even think about it.
<br/>
I.e. ((1,0) + (0,1))/2 gives (0.5.0.5) has a magnitude of 0.5.
<br/>
If you think that your answer is too much off, you can try an approximate normalization before adding the vectors. Especially since you normalize for reel later anyway.
<br/>
For example a very approximate magnitude (that surely is in the right order of magnitude ;-) is 
<br/>
|v| = x+y+z
<br/>
or 
<br/>
|v| = max(x,y,z).
<br/>
Then if you have 3 vectors a,b,c you could use
<br/>
||(a/|a| + b/|b| + c/|c|)||
<br/>
where ||v|| is the actual normalization. In order to get rid of the divisions, you could also write
<br/>
||(a*|b|*|c| + b*|a|*|c| + c*|a|*|b|)||
<br/>
The vector inside the || || differs from the above one only by a factor |a|*|b|*|c|, which gets sucked up by the normalization in the end.
<br/>
if you do this in the smart way, you also dont have to do that many multiplies, i.e.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
c = 1
<br/>
for all vectors v[i]
<br/>
  k = |v[i]|
<br/>
  for all previous vectors v[j] with j&lt;i
<br/>
     v[j] = k*v[j]
<br/>
  v[i] = c*v[j]
<br/>
  c = k*c
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135576 - kusma - Tue Jul 24, 2007 7:39 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote">If you think that your answer is too much off, you can try an approximate normalization before adding the vectors.</td> </tr></table><span class="postbody">
<br/>
But you shouldn't! The triangle's contribution to the vertex normal should be proportional to the triangle's area, and skipping the normalization does just this. If you are worried about the accumulation overflowing in fixed-point maths, you could always do something like tracking a separate exponent for each vector and do some cheap pseudo-float additions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135577 - Ant6n - Tue Jul 24, 2007 7:50 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">The triangle's contribution to the vertex normal should be proportional to the triangle's area</td> </tr></table><span class="postbody">
<br/>
Why?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135581 - kusma - Tue Jul 24, 2007 8:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">The triangle's contribution to the vertex normal should be proportional to the triangle's area</td> </tr></table><span class="postbody">
<br/>
Why?</span></td> </tr></table><span class="postbody">
<br/>
<br/>
because when you gouraud-shade your mesh afterwards, the bigger polygon is more visible, and correctness of it's lighting is more important. Play around with it a bit, and you'll quickly see that it makes perfect sense.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135690 - jonnyhilly - Wed Jul 25, 2007 5:00 pm</h4>
    <div class="postbody"><span class="postbody">how about pre-calculating all the normals, sort them into bone groups to match the polygon groups assiciated with each bone on the skeleton, then just rotate them by your character's local bone matrix.
<br/>
I haven't calculated it, but it might be faster to just rotate them, than to generate them each time.
<br/>
You can probably skip normalization, so no square roots or divides needed at all.  Just multiply and adds.
<br/>
<br/>
<br/>
Have pre allocated space for the target normals, have pre allocated pointers in the polygons pointing to the targets so they also dont need to be updated .
<br/>
<br/>
<br/>
You can also time-slice which bones to update, bases on how much each bone moves. (this can also be pre-calculated in your animation data)
<br/>
if a bone doesn't move at all (or much) in a frame then don't rotate the normals for that bone, just use the ones from the last frame. (and same lighting values from last frame, dont do the lighting calculations either)
<br/>
<br/>
this assumes your lights aren't moving
<br/>
<br/>
if you wanna take it further....
<br/>
if you are rendering multiple characters.... time slice the whole animation update to be less often when the characters are far away... one every 2 frames for moderate... once every 4 frames for far away... its amazing what you can get away with, especially if they aren't moving terribly fast.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135731 - DiscoStew - Wed Jul 25, 2007 9:25 pm</h4>
    <div class="postbody"><span class="postbody">As far as the inverse square root is concerned, I remember this bit of code....
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">float InvSqrt (float x)
<br/>
{
<br/>
   float xhalf = 0.5f*x;
<br/>
   INT i = *(INT*)&amp;x;
<br/>
   i = 0x5f3759df - (i &gt;&gt; 1); // This line hides a LOT of math!
<br/>
   x = *(float*)&amp;i;
<br/>
   x = x*(1.5f - xhalf*x*x);
<br/>
   RETURN x;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
...and thought about if there was a way to convert this for fixed-point inverse sqrts, but considering that the "special line" is tied in with the float format, I doubt I'll ever find a good method by this. I had thought about just taking the fixed-point value, converting it to float, then getting this mix of stuff done (other than the extra approximation), then convert back to fixed-point and doing the extra approximation, but I fear that just converting to float and back will require too many cycles vs just going by the hardware method of sqrt and divide.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135732 - sajiimori - Wed Jul 25, 2007 9:30 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, especially when you can do a sqrt, a divide, and other math all in parallel on the DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135735 - DiscoStew - Wed Jul 25, 2007 11:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Yeah, especially when you can do a sqrt, a divide, and other math all in parallel on the DS.</td> </tr></table><span class="postbody">
<br/>
<br/>
Hmm, by this, do you mean that while I'm doing, say a hardware divide, while that is processing, I could get a hardware sqrt going too?
<br/>
<br/>
That could potentially save me some time, as I could have done the sqrt for the first normal, and while the divide for that is taking place, I could get started on the sqrt part of the 2nd normal, instead of waiting for everything of the first normal to finish before starting the 2nd normal.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135738 - DiscoStew - Wed Jul 25, 2007 11:31 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>jonnyhilly wrote:</b></span></td> </tr> <tr> <td class="quote">how about pre-calculating all the normals, sort them into bone groups to match the polygon groups assiciated with each bone on the skeleton, then just rotate them by your character's local bone matrix.
<br/>
I haven't calculated it, but it might be faster to just rotate them, than to generate them each time.
<br/>
You can probably skip normalization, so no square roots or divides needed at all.  Just multiply and adds.
<br/>
<br/>
<br/>
Have pre allocated space for the target normals, have pre allocated pointers in the polygons pointing to the targets so they also dont need to be updated .</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm trying to imagine this in my head, but wouldn't that be more for polygon groups that are only influenced by a single bone, and the vertices from one poly group aren't being used by another?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135740 - Ant6n - Wed Jul 25, 2007 11:46 pm</h4>
    <div class="postbody"><span class="postbody">I was referring to this 'trick' earlier.
<br/>
As i was suggesting, one could use a lookup table for clz(x) Instead of the magic floating line. Clz is the asm instruction that finds the position of the most significant 1 in an integer.
<br/>
I.e. find out how many significant bits are zero, and then have a lookup table that gives some average/median of all the values in that range. One would only have one entry for 1,1x,1xx,1xxx,1xxxx,1xxxxx.., but it should give a good initial approximation, like +/- 50%ish.
<br/>
Then Doing 2 or 3 of the iteration steps should probably give a sufficient approximation.
<br/>
One could also have a bunch of tiny lookup tables instead of one value, or two values which give a linear approximation.
<br/>
Although in the end of the day I don't know whether this can compete with a 36 cycle division and 26 cycle sqrt.
<br/>
Maybe this kinda common math will make it into libnds in some optimized manner.
<br/>
<br/>
EDIT: since 1/sqrt(x) and 1/sqrt(2*x) always differ by a factor of sqrt(2) ~ 1.44, The range of values covered by any 1xx..xx is from some number a to 1.44*a, so by choosing 1.19*a, the initial approximation would only be 19% off (18.9207115%), and that with only 32 look up values.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135746 - jonnyhilly - Thu Jul 26, 2007 12:13 am</h4>
    <div class="postbody"><span class="postbody">Yes you are correct...
<br/>
it would assume you are either not using weighted vertex groups, or you dont care that the lighting would be slightly off at the locations with multiple weights 
<br/>
might be difficult to see any difference
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DiscoStew wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>jonnyhilly wrote:</b></span></td> </tr> <tr> <td class="quote">how about pre-calculating all the normals, sort them into bone groups to match the polygon groups assiciated with each bone on the skeleton, then just rotate them by your character's local bone matrix.
<br/>
I haven't calculated it, but it might be faster to just rotate them, than to generate them each time.
<br/>
You can probably skip normalization, so no square roots or divides needed at all.  Just multiply and adds.
<br/>
<br/>
<br/>
Have pre allocated space for the target normals, have pre allocated pointers in the polygons pointing to the targets so they also dont need to be updated .</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm trying to imagine this in my head, but wouldn't that be more for polygon groups that are only influenced by a single bone, and the vertices from one poly group aren't being used by another?</span></td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135753 - sajiimori - Thu Jul 26, 2007 1:11 am</h4>
    <div class="postbody"><span class="postbody">Yeah DiscoStew, for bulk operations like this, you can probably save lots of time by carefully threading sqrts, divs, and other work so each unit will stay busy as often as possible.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135783 - a128 - Thu Jul 26, 2007 8:18 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DiscoStew wrote:</b></span></td> </tr> <tr> <td class="quote">As far as the inverse square root is concerned, I remember this bit of code....
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
I posted here InvSin instead of invSqrt
<br/>
<br/>
anyway here is a link to the origins of the above inverse sqrt code
<br/>
<br/>
<a class="postlink" href="http://www.beyond3d.com/content/articles/8/" target="_blank">http://www.beyond3d.com/content/articles/8/</a></span><span class="gensmall"><br/><br/>Last edited by a128 on Fri Jul 27, 2007 11:04 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#135835 - sajiimori - Thu Jul 26, 2007 7:04 pm</h4>
    <div class="postbody"><span class="postbody">Uh... that says inverse sine.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135861 - DiscoStew - Thu Jul 26, 2007 9:18 pm</h4>
    <div class="postbody"><span class="postbody">I was about to say that myself. Didn't think that 1.0 - fValue with a Sqrt function made much sense for finding the InvSqrt.
<br/>
<br/>
Anyways, after doing some of these other optimizations, things are going pretty good. One thing I completely forgot was a problem I had before making most of these adjustments. It involves a normal that lays straight down an axis (or close to it), because one of the values of the normal computed could possibly turn out to be 1/-1, of which the DS is unable to work with properly.
<br/>
<br/>
I've tried a few hacks to fix this, but the only one that seemed to really work was checking if the normal was &gt;= 1 or &lt;= -1, and adjust it, but having to check all 3 values per normal felt like it was bogging down the whole process.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135870 - Ant6n - Thu Jul 26, 2007 10:06 pm</h4>
    <div class="postbody"><span class="postbody">if the maximum value of your components cannot be bigger than, say, 0.98, you could multiply your inverse squareroot with it
<br/>
i.e.
<br/>
c = 0.98/sqrt(x^2+y^2+z^2)
<br/>
x = c*c .. etc..
<br/>
but considering how many operations you have per normal anyway, and that multiplication is not blazing fast either, it could be faster to just check in the end, after converting to fixed point.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135948 - DiscoStew - Fri Jul 27, 2007 7:57 pm</h4>
    <div class="postbody"><span class="postbody">Well, after a lot of improvements to the normal code, this is what I have so far...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//   (s16*)VertStore -&gt; The storage array for the vertices after alterations from the joints has been done
<br/>
//   (s32*)NormalStore -&gt; The storage array for our processed normals
<br/>
<br/>
//   (u16*)TriIndices -&gt; The index list for each triangle (3 indexes each)
<br/>
//   (u16*)QuadIndices -&gt; The index list for each quad (4 indexes each)
<br/>
//   (u16*)TriNormInfo -&gt; The normal index list for each triangle (3 indexes each)
<br/>
//   (u16*)QuadNormInfo -&gt; The normal index list for each quad (4 indexes each)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   // Does the model have even one normal in it?
<br/>
   //
<br/>
   if(NormalCount)
<br/>
   {
<br/>
<br/>
      // Set up vector variables to process the poly normals
<br/>
      //
<br/>
      s32 vect_b1[3], vect_b2[3], vect_b3[3], normal[3];
<br/>
      u32 CurPoly;
<br/>
<br/>
      // Start with the triangles
<br/>
      //
<br/>
      for(CurPoly = 0; CurPoly &lt; TriCount; CurPoly++)
<br/>
      {
<br/>
<br/>
         // Retrieve the indexes that our triangle references to
<br/>
         //
<br/>
         u32 PolyIndex = CurPoly * 3;
<br/>
         u32 TriIndex1 = *(TriIndices + PolyIndex) * 3;
<br/>
         u32 TriIndex2 = *(TriIndices + PolyIndex + 1) * 3;
<br/>
         u32 TriIndex3 = *(TriIndices + PolyIndex + 2) * 3;
<br/>
         
<br/>
         // Create the two vectors of the triangle
<br/>
         //
<br/>
         vect_b1[0] = VertStore[TriIndex2] - VertStore[TriIndex1];
<br/>
         vect_b1[1] = VertStore[TriIndex2 + 1] - VertStore[TriIndex1 + 1];
<br/>
         vect_b1[2] = VertStore[TriIndex2 + 2] - VertStore[TriIndex1 + 2];
<br/>
         vect_b2[0] = VertStore[TriIndex3] - VertStore[TriIndex1];
<br/>
         vect_b2[1] = VertStore[TriIndex3 + 1] - VertStore[TriIndex1 + 1];
<br/>
         vect_b2[2] = VertStore[TriIndex3 + 2] - VertStore[TriIndex1 + 2];
<br/>
<br/>
         // Get the cross product of the two vectors
<br/>
         //
<br/>
         normal[0] = ((vect_b1[1] * vect_b2[2]) - (vect_b2[1] * vect_b1[2])) &gt;&gt; 12;
<br/>
         normal[1] = ((vect_b1[2] * vect_b2[0]) - (vect_b2[2] * vect_b1[0])) &gt;&gt; 12;   // long long used to be casted here
<br/>
         normal[2] = ((vect_b1[0] * vect_b2[1]) - (vect_b2[0] * vect_b1[1])) &gt;&gt; 12;
<br/>
<br/>
         // Get the address of the indexes where the triangle's normal will reference to
<br/>
         //
<br/>
         u16 *TriNormal = (TriNormInfo + PolyIndex);
<br/>
<br/>
         // Store the normal in the designated areas
<br/>
         //
<br/>
         u32 TriNormIndex = *TriNormal * 3;
<br/>
         NormalStore[TriNormIndex] += normal[0];
<br/>
         NormalStore[TriNormIndex + 1] += normal[1];
<br/>
         NormalStore[TriNormIndex + 2] += normal[2];
<br/>
         TriNormIndex = *(TriNormal + 1) * 3;
<br/>
         NormalStore[TriNormIndex] += normal[0];
<br/>
         NormalStore[TriNormIndex + 1] += normal[1];
<br/>
         NormalStore[TriNormIndex + 2] += normal[2];
<br/>
         TriNormIndex = *(TriNormal + 2) * 3;
<br/>
         NormalStore[TriNormIndex] += normal[0];
<br/>
         NormalStore[TriNormIndex + 1] += normal[1];
<br/>
         NormalStore[TriNormIndex + 2] += normal[2];
<br/>
      }
<br/>
<br/>
      // Now with the quads
<br/>
      //
<br/>
      for(CurPoly = 0; CurPoly &lt; QuadCount; CurPoly++)
<br/>
      {
<br/>
<br/>
         // Retrieve the indexes that our quad references to
<br/>
         //
<br/>
         u32 PolyIndex = CurPoly * 4;
<br/>
         u32 QuadIndex1 = *(QuadIndices + PolyIndex) * 3;
<br/>
         u32 QuadIndex2 = *(QuadIndices + PolyIndex + 1) * 3;
<br/>
         u32 QuadIndex3 = *(QuadIndices + PolyIndex + 2) * 3;
<br/>
         u32 QuadIndex4 = *(QuadIndices + PolyIndex + 3) * 3;
<br/>
         
<br/>
         // Create the three vectors of the quad
<br/>
         //
<br/>
         vect_b1[0] = VertStore[QuadIndex2] - VertStore[QuadIndex1];
<br/>
         vect_b1[1] = VertStore[QuadIndex2 + 1] - VertStore[QuadIndex1 + 1];
<br/>
         vect_b1[2] = VertStore[QuadIndex2 + 2] - VertStore[QuadIndex1 + 2];
<br/>
         vect_b2[0] = VertStore[QuadIndex3] - VertStore[QuadIndex1];
<br/>
         vect_b2[1] = VertStore[QuadIndex3 + 1] - VertStore[QuadIndex1 + 1];
<br/>
         vect_b2[2] = VertStore[QuadIndex3 + 2] - VertStore[QuadIndex1 + 2];
<br/>
         vect_b3[0] = VertStore[QuadIndex4] - VertStore[QuadIndex1];
<br/>
         vect_b3[1] = VertStore[QuadIndex4 + 1] - VertStore[QuadIndex1 + 1];
<br/>
         vect_b3[2] = VertStore[QuadIndex4 + 2] - VertStore[QuadIndex1 + 2];
<br/>
<br/>
         // Get the cross product from the first two vectors of the quad
<br/>
         //
<br/>
         normal[0] = ((vect_b1[1] * vect_b2[2]) - (vect_b2[1] * vect_b1[2])) &gt;&gt; 12;
<br/>
         normal[1] = ((vect_b1[2] * vect_b2[0]) - (vect_b2[2] * vect_b1[0])) &gt;&gt; 12;   // long long used to be casted here
<br/>
         normal[2] = ((vect_b1[0] * vect_b2[1]) - (vect_b2[0] * vect_b1[1])) &gt;&gt; 12;
<br/>
<br/>
         // Get the address of the indexes where the triangle's normal will reference to
<br/>
         //
<br/>
         u16 *QuadNormal = (QuadNormInfo + PolyIndex);
<br/>
<br/>
         // Store the normal in the designated areas
<br/>
         //
<br/>
         u32 QuadNormIndex = *QuadNormal * 3;
<br/>
         NormalStore[QuadNormIndex] += normal[0];
<br/>
         NormalStore[QuadNormIndex + 1] += normal[1];
<br/>
         NormalStore[QuadNormIndex + 2] += normal[2];
<br/>
         QuadNormIndex = *(QuadNormal + 1) * 3;
<br/>
         NormalStore[QuadNormIndex] += normal[0];
<br/>
         NormalStore[QuadNormIndex + 1] += normal[1];
<br/>
         NormalStore[QuadNormIndex + 2] += normal[2];
<br/>
         QuadNormIndex = *(QuadNormal + 2) * 3;
<br/>
         NormalStore[QuadNormIndex] += normal[0];
<br/>
         NormalStore[QuadNormIndex + 1] += normal[1];
<br/>
         NormalStore[QuadNormIndex + 2] += normal[2];
<br/>
<br/>
         // Get the cross product from the last two vectors of the quad
<br/>
         //
<br/>
         normal[0] = ((vect_b2[1] * vect_b3[2]) - (vect_b3[1] * vect_b2[2])) &gt;&gt; 12;
<br/>
         normal[1] = ((vect_b2[2] * vect_b3[0]) - (vect_b3[2] * vect_b2[0])) &gt;&gt; 12;   // long long used to be casted here
<br/>
         normal[2] = ((vect_b2[0] * vect_b3[1]) - (vect_b3[0] * vect_b2[1])) &gt;&gt; 12;
<br/>
<br/>
         // Store the normal in the designated areas
<br/>
         //
<br/>
         QuadNormIndex = *QuadNormal * 3;
<br/>
         NormalStore[QuadNormIndex] += normal[0];
<br/>
         NormalStore[QuadNormIndex + 1] += normal[1];
<br/>
         NormalStore[QuadNormIndex + 2] += normal[2];
<br/>
         QuadNormIndex = *(QuadNormal + 2) * 3;
<br/>
         NormalStore[QuadNormIndex] += normal[0];
<br/>
         NormalStore[QuadNormIndex + 1] += normal[1];
<br/>
         NormalStore[QuadNormIndex + 2] += normal[2];
<br/>
         QuadNormIndex = *(QuadNormal + 3) * 3;
<br/>
         NormalStore[QuadNormIndex] += normal[0];
<br/>
         NormalStore[QuadNormIndex + 1] += normal[1];
<br/>
         NormalStore[QuadNormIndex + 2] += normal[2];
<br/>
      }
<br/>
<br/>
      // A few variables to work with for normalizing our......normals
<br/>
      //
<br/>
      u32 TotalNorm = NormalCount * 3, CurNormalIndex = 3, FinNormalIndex = 0;
<br/>
      s32 MagCalc = 0;
<br/>
<br/>
      // Set up the divide and sqrt hardware, and get set up for the first sqrt while hardware gets ready
<br/>
      //
<br/>
      SQRT_CR = SQRT_64;
<br/>
      DIV_CR = DIV_64_32;
<br/>
      s32 Val1 = (NormalStore[0] * NormalStore[0]) &gt;&gt; 12;
<br/>
      s32 Val2 = (NormalStore[1] * NormalStore[1]) &gt;&gt; 12;      // long long used to be casted here
<br/>
      s32 Val3 = (NormalStore[2] * NormalStore[2]) &gt;&gt; 12;
<br/>
      while(SQRT_CR &amp; SQRT_BUSY);
<br/>
      while(DIV_CR &amp; DIV_BUSY);
<br/>
<br/>
      // Set in the numerator for the divide for all normals processed, and start our first sqrt calculation
<br/>
      //
<br/>
      DIV_NUMERATOR64 = ((s64)4096) &lt;&lt; 12;
<br/>
      SQRT_PARAM64 = ((s64)Val1 + Val2 + Val3) &lt;&lt; 12;
<br/>
<br/>
      // Go through each of the normal
<br/>
      //
<br/>
      for(; CurNormalIndex &lt; TotalNorm; CurNormalIndex += 3, FinNormalIndex += 3)
<br/>
      {
<br/>
<br/>
         // Get set up for the next sqrt while the current one is being processed
<br/>
         //
<br/>
         Val1 = (NormalStore[CurNormalIndex] * NormalStore[CurNormalIndex]) &gt;&gt; 12;
<br/>
         Val2 = (NormalStore[CurNormalIndex + 1] * NormalStore[CurNormalIndex + 1]) &gt;&gt; 12;   // long long used to be casted here
<br/>
         Val3 = (NormalStore[CurNormalIndex + 2] * NormalStore[CurNormalIndex + 2]) &gt;&gt; 12;
<br/>
         while(SQRT_CR &amp; SQRT_BUSY);
<br/>
<br/>
         // Spit out the sqrt result into the denominator of the divide to get it going, and start the next sqrt calc
<br/>
         //
<br/>
         DIV_DENOMINATOR32 = SQRT_RESULT32;
<br/>
         SQRT_PARAM64 = ((s64)Val1 + Val2 + Val3) &lt;&lt; 12;
<br/>
         while(DIV_CR &amp; DIV_BUSY);
<br/>
<br/>
         // Retrieve the divide result, and multiply by .98, because the hardware can't handle values of 1/-1
<br/>
         // Multiple the inverse magnitude, and shift the value within the correct limits
<br/>
         //
<br/>
         MagCalc = (((s32)DIV_RESULT32) * 4014) &gt;&gt; 12;
<br/>
         NormalStore[FinNormalIndex] = (NormalStore[FinNormalIndex] * MagCalc) &gt;&gt; 15;
<br/>
         NormalStore[FinNormalIndex + 1] = (NormalStore[FinNormalIndex + 1] * MagCalc) &gt;&gt; 15;
<br/>
         NormalStore[FinNormalIndex + 2] = (NormalStore[FinNormalIndex + 2] * MagCalc) &gt;&gt; 15;
<br/>
      }
<br/>
<br/>
      // Finish off the last normal with the same procedure as above
<br/>
      //
<br/>
      while(SQRT_CR &amp; SQRT_BUSY);
<br/>
      DIV_DENOMINATOR32 = SQRT_RESULT32;
<br/>
      while(DIV_CR &amp; DIV_BUSY);
<br/>
      MagCalc = (((s32)DIV_RESULT32) * 4014) &gt;&gt; 12;
<br/>
      NormalStore[FinNormalIndex] = (NormalStore[FinNormalIndex] * MagCalc) &gt;&gt; 15;
<br/>
      NormalStore[FinNormalIndex + 1] = (NormalStore[FinNormalIndex + 1] * MagCalc) &gt;&gt; 15;
<br/>
      NormalStore[FinNormalIndex + 2] = (NormalStore[FinNormalIndex + 2] * MagCalc) &gt;&gt; 15;
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm still know very little about TCM, but this code is within my main model process function, which is set with the attribute ITCM_CODE. But, the thing is that of the storage arrays, only NormalStore is assigned with DTCM_DATA, as for some reason my model gets all crazy on me if I put VertStore into it, even if I didn't have NormalStore in there. As it is right now, each have 1500 elements, resulting in ~9KB worth of data, and the only thing my program is doing is loading the model, and processing it. Nothing else is happening.
<br/>
<br/>
There are still a few tweaks that can be done, but that's mainly for such things like getting the PolyIndex, which can be changed from a multiply to addition.
<br/>
<br/>
If you notice, there are places where it says "long long used to be casted here". They used to be casted, until I found out that even in ITCM, if those are removed, my programs runs much better. Unfortunately, making the change would result in problems "if" the meshes/polygons are large, or turn out large after the joints have manipulated them. For now, I'll keep them off.
<br/>
<br/>
So, here is my code. If by chance you see anything that could potentially increase performance, or you have any questions/information that could do the same, please let me know through this thread.
<br/>
<br/>
I still think that one reason why the programs is running slower than intended is because I'm still using emulators for testing (no$gba to be exact), and emulators are still not up to snuff. I was planning on getting the R4DS (or it's twin, the M3 Simply) so that I could truly test this.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135950 - sajiimori - Fri Jul 27, 2007 8:19 pm</h4>
    <div class="postbody"><span class="postbody">Waiting for the division unit is painful.  I'd suggest rearranging the loop to have the divide span more code.  This may involve skipping ahead to calculating Val1-3 for the next normal while waiting for the divide to finish, then backtracking to finish writing to NormalStore.
<br/>
<br/>
I'd also suggest eliminating the 'while' loops that wait for the square root and divide units to finish.  If they span enough code, they are guaranteed to be finished already.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135957 - Ant6n - Fri Jul 27, 2007 9:48 pm</h4>
    <div class="postbody"><span class="postbody">isn't it dangerous to make these kind of assumptions (i.e. order of execution) in code that gets o3ptimized by gcc?
<br/>
<br/>
i can't see from the code whether you took the advice and only run this code every couple of frames for each model.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135958 - DiscoStew - Fri Jul 27, 2007 10:03 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote">isn't it dangerous to make these kind of assumptions (i.e. order of execution) in code that gets o3ptimized by gcc?
<br/>
<br/>
i can't see from the code whether you took the advice and only run this code every couple of frames for each model.</td> </tr></table><span class="postbody">
<br/>
<br/>
That is just the general code for a one-shot at calculating all the normals on a model. For your method, I'll have to evolve it to take those calculated results, and store them with the model it is calculating from. Shouldn't be too hard, but just for the moment, I'm focusing on optimizing the code that calculates those normals.
<br/>
<br/>
EDIT:
<br/>
<br/>
This is gonna sound really silly, well, to me anyways, but considering I'm grabbing the poly info, which is segmented by "halfwords" each, wouldn't grabbing that same data, but in "word" segments, be better? As it is right now, I'm basically just grabbing information in it's compiled format, whereas if I were to make a loading function for the models, expand some of those halfword arrays into word arrays, would that increase overall performance?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135965 - sajiimori - Sat Jul 28, 2007 12:39 am</h4>
    <div class="postbody"><span class="postbody">If I understand what you're saying, no, LDRH instructions (to load 16 bits) are just as fast as LDR instructions (to load 32 bits).
<br/>
<br/>
Padding out the values with zeroes would hurt performance a lot due to increased cache misses.  Compact data is very important.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135970 - tepples - Sat Jul 28, 2007 1:58 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">I'd also suggest eliminating the 'while' loops that wait for the square root and divide units to finish.  If they span enough code, they are guaranteed to be finished already.</td> </tr></table><span class="postbody">
<br/>
But can you guarantee that GCC won't get too clever when it reorders your instructions?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135975 - DekuTree64 - Sat Jul 28, 2007 2:57 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">I'd also suggest eliminating the 'while' loops that wait for the square root and divide units to finish.  If they span enough code, they are guaranteed to be finished already.</td> </tr></table><span class="postbody">
<br/>
But can you guarantee that GCC won't get too clever when it reorders your instructions?</span></td> </tr></table><span class="postbody">
<br/>
For a critical calculation, I would say wait for it always. But since a bad normal would just cause a slight visual glitch for one frame, it's probably safe to assume that execution time is consistent enough that if things have been reordered too much, it will be very obviously broken.
<br/>
<br/>
Another thing to watch out for with the divider/square root unit is using them in interrupt handlers. Even if you back up/restore the values, that restarts the calculation so it could appear to take longer than it should to outside code. Plus the interrupt could happen between checking the busy flag and fetching the result. So probably the best solution is just to wait for the calculations to finish before returning from the interrupt.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135990 - DiscoStew - Sat Jul 28, 2007 8:16 am</h4>
    <div class="postbody"><span class="postbody">I was thinking of a little hack that might increase performance, but it would deviate from the normal method somewhat, of which optimization from there may be hindered. The same amount of processing will probably happen, but where that processing happens will be changed, to take advantage of the divide and sqrt running alongside everything else.
<br/>
<br/>
It would require that I make many changes to both my exporter and my code, but the concept is pretty much that not only do I get which vertices go to which normal group, but I order those particular normal groups, so that the normals connected to the least number of polygons will be first, and the most last. With that, add a bool marker to each vertex index of each polygon. The only vertices that will have a non-0 value will be those vertices that will add last to a normal group, of which the normalizing of that normal will begin, getting the sqrt and divide going. By this, the actual normalizing of the final normal values will be going even while the cross products of the polygons are still being processed, and any remaining normals needing to be processed will be done after.
<br/>
<br/>
A problem with this though would be if a polygon has more than 2 vertices that are ready for normalizing. Perhaps making a queue the size of the number of normals the model has, and placing ready normals for processing into it, and after a polygon is processed, it checks the queue to see if another normal is ready, and gets that stuff going.
<br/>
<br/>
I hope I'm making sense with this idea. If you understand this, you think it's a good idea? It wouldn't really interfere with only processing these normals every few frames, and can possibly be split so that a certain number of normals are processed per frame.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136117 - sajiimori - Sun Jul 29, 2007 11:42 am</h4>
    <div class="postbody"><span class="postbody">You can eliminate waits for divides and square roots even using your current scheme -- you don't need to go to great lengths for that purpose.
<br/>
<br/>
Moving the divides and square roots earlier just means they will overlap other work, without saving any time.
<br/>
<br/>
At this point, I'd focus on simplifying the triangle and quad loops.  Try to eliminate unnecessary variables, and make sure the rest fit in registers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136128 - DiscoStew - Sun Jul 29, 2007 3:17 pm</h4>
    <div class="postbody"><span class="postbody">Looking at my loops for the triangles and quads, I couldn't really see any more optimization I could do, until I reread what Ant6n has said earlier.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote">code is in fact put in ram, but the 4mb ram is actually pretty slow; I found it takes 6 cycles for a 1 cycle arm instruction. Thumb instructions should run about twice as fast, but considering thumb can do less per instruction, its actually only 60% faster.
<br/>
Main ram is cached both with an instruction (8K) and data cache (4K). so running thumb from main ram is not only faster, but since its smaller there is more code that can stay cached. Instructions that are in cache run at full speed (afaik). Thus your overall code should stay thumb.
<br/>
the internal working fram of the DS is the tcm, again there is instruction and data tcm (itcm, dtcm). Again code runs at full speed. Instead of extention iwram, try extention dtcm.</td> </tr></table><span class="postbody">
<br/>
<br/>
If code executed in main RAM is that slow, would that same effect also affect retrieving and writing data in the main RAM? If so, then I think I see where I can optimize my code. Although I have my normal-processing code in ITCM, VertStore is, for the moment, in main RAM, because of a problem that I couldn't figure out, but after reading a little bit, it seems I can't use DMA to copy data from the main RAM to DTCM, right?
<br/>
<br/>
As it is right now, if my model has joints, the vertices of the model will get processed through that, and stored into VertStore, which in that case, that array shouldn't have problems being in DTCM, and any optimizations will need to be focused on that part of my code, not my normal-processing code. For models that don't have joints, I'll just have to rig up my exporter and my program code to put those models into a more "display-list" friendly form, as nothing is changing on them, so nothing needs to be processed, just executed.
<br/>
<br/>
I'll get working on that before making any other changes, but in any case, if I need to get an array or something into DTCM, is there a faster way than to copy one element at a time (or more, depending on the element size)?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136137 - tepples - Sun Jul 29, 2007 4:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DiscoStew wrote:</b></span></td> </tr> <tr> <td class="quote">I'll get working on that before making any other changes, but in any case, if I need to get an array or something into DTCM, is there a faster way than to copy one element at a time (or more, depending on the element size)?</td> </tr></table><span class="postbody">
<br/>
memcpy() of an area at least 32 bytes should be fast. Profile it to be sure.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136164 - sajiimori - Sun Jul 29, 2007 9:09 pm</h4>
    <div class="postbody"><span class="postbody">One likely way to simplify your loops is to avoid calculating array indexes, and instead try to increment pointers as you go.  This will decrease register usage because you don't need to remember the base address of the array in addition to an index.
<br/>
<br/>
For instance, if you find yourself accessing array[i], array[i+1], then array[i+2], try to eliminate i and do *ptr++, *ptr++, *ptr++ instead.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136170 - tepples - Sun Jul 29, 2007 9:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">One likely way to simplify your loops is to avoid calculating array indexes, and instead try to increment pointers as you go.  This will decrease register usage because you don't need to remember the base address of the array in addition to an index.</td> </tr></table><span class="postbody">
<br/>
So you're suggesting <a class="postlink" href="http://en.wikipedia.org/wiki/Strength_reduction" target="_blank">strength reduction</a> by hand. Before you try this, try using <span style="font-weight: bold">arm-eabi-gcc -S (rest of flags) mysourcefile.c -o mysourcefile.s</span> to get a disassembly and then seeing if the compiler isn't already doing this for you. (The -S instead of -c tells GCC not to pass the file to the assembler.)<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136173 - sajiimori - Sun Jul 29, 2007 9:49 pm</h4>
    <div class="postbody"><span class="postbody">In the context of this code, I strongly doubt the compiler will figure out how to eliminate all the indexing, but you never know.
<br/>
<br/>
And yes, I would suggest doing the optimization by hand, <span style="font-style: italic">if</span> you intend to make further low-level optimizations afterwards.  If the code doesn't visually correspond to the work being done, it's very hard to find additional optimizations.
<br/>
<br/>
In essence, automatic code transformations add an extra level of indirection between you and the assembler output.  When you're concerned about the assembler output, it's helpful to stay within reach of it.
<br/>
<br/>
It's not impossible to write code that's both fast and abstract, but it can be rather like trying to make a marionette control another marionette.
<br/>
<br/>
(Incidentally, I think cutting down on the indexing would also make the code easier to understand, but that's subjective.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136189 - tepples - Sun Jul 29, 2007 11:06 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">It's not impossible to write code that's both fast and abstract, but it can be rather like trying to make a marionette control another marionette.</td> </tr></table><span class="postbody">
<br/>
Geppetto has to teach his "son" a trade sometime, doesn't he?
<br/>
<br/>
<span style="font-size: 8px; line-height: normal">If you need it explained, wait for me to show up on AIM.</span><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136338 - DiscoStew - Tue Jul 31, 2007 7:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DiscoStew wrote:</b></span></td> </tr> <tr> <td class="quote">I'll get working on that before making any other changes, but in any case, if I need to get an array or something into DTCM, is there a faster way than to copy one element at a time (or more, depending on the element size)?</td> </tr></table><span class="postbody">
<br/>
memcpy() of an area at least 32 bytes should be fast. Profile it to be sure.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Hmm, was trying to get memcpy into my project, but for some reason, it can't seem to locate the &lt;memory.h&gt; file (under Visual Studio). &lt;string.h&gt; has it through, so I included it that way for now.
<br/>
<br/>
memcpy works fine, and I'll get to profiling it in time when copying from main RAM to DTCM. A problem I now have involves some adjustments I've made for models that can just have their contents copied to DTCM (that have no bone structure), and accessed for rendering them. While the normals that have to be calculated are done in a signed word array, if the model doesn't need to do calculating, it will grab an premade array within itself for the normals. Problem though is that they are in signed halfword form, not signed word, and so I can't simply copy from one array to the other via copy functions like memcpy, unless the destination array were to be casted as signed halfword too. Because the resulting calculation of the normals fit into signed halfword format anyways, I decided to make a pointer that pointed to the main normal array, but under the half-word type.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">DTCM_DATA s32 NormalStore[...];
<br/>
s16 *NormalGrab = (s16*)NormalStore;</td> </tr></table><span class="postbody">
<br/>
<br/>
but, when I try this, I get this warning....
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">warning: dereferencing type-punned pointer will break strict-aliasing rules</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not quite sure what's going on, but I do know it isn't because of adding that attribute, because I removed it, and I still got the warning. Any thoughts?
<br/>
<br/>
EDIT:
<br/>
<br/>
Actually, after typing this, I did a little browsing, and found that I could use "-fno-strict-aliasing" to fix it. Good idea?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#136340 - tepples - Tue Jul 31, 2007 7:46 pm</h4>
    <div class="postbody"><span class="postbody">Consider using a <a class="postlink" href="http://en.wikipedia.org/wiki/Union_%28computer_science%29" target="_blank">union</a>, C's counterpart to C++'s reinterpret_cast:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
union {
<br/>
  s16 *s16_pointer;
<br/>
  s32 *s32_pointer;
<br/>
} s;
<br/>
<br/>
s.s32_pointer = NormalStore;
<br/>
NormalGrab = s.s16_pointer;
<br/>
</td> </tr></table><span class="postbody">
<br/>
The result of this is defined by each application binary interface (ABI), but in ARM EABI, it should do what you expect as long as both areas are aligned to a 4-byte boundary.
<br/>
<br/>
The aliasing rules determine what optimizations the compiler is allowed to make on pointer dereferences. Stricter rules may lead to faster code.
<br/>
<br/>
<a class="postlink" href="http://mail-index.netbsd.org/tech-kern/2003/08/11/0001.html" target="_blank">This post to the NetBSD mailing list</a> has more information.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
