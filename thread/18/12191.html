<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Rotating background around the center - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Rotating background around the center</h2>
<div id="posts">
<div class="post">
    <h4>#115702 - HyperHacker - Thu Jan 18, 2007 1:54 pm</h4>
    <div class="postbody"><span class="postbody">From what I've read about the GBA, its affine backgrounds would rotate around their center. However, when I use rotation on the DS, they rotate around the top left corner. How can I rotate them around the center instead?<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"><br/><br/>Last edited by HyperHacker on Mon Jan 22, 2007 7:02 am; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#115811 - tepples - Fri Jan 19, 2007 7:27 am</h4>
    <div class="postbody"><span class="postbody">Affine backgrounds always rotate about the top left corner. You'll need to move the top left corner so as to make them appear to rotate about the center. To rotate where the texel (scrollX, scrollY) is placed at pixel (centerX, centerY), once you've computed the rotation matrix, try something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">x_origin = scrollX - centerX * pa - centerY * pb;
<br/>
y_origin = scrollY - centerX * pc - centerY * pd;
<br/>
</td> </tr></table><span class="postbody">
<br/>
EDIT: corrected y_origin formula<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"><br/><br/>Last edited by tepples on Tue Jan 23, 2007 2:38 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#116127 - HyperHacker - Mon Jan 22, 2007 4:11 am</h4>
    <div class="postbody"><span class="postbody">I'm not sure I understand you. How do I move the top left corner? I was thinking of a method along the lines of turning BG wrap on, and "rotate" the image (much like one "rotates" a byte), so that EG instead of <a class="postlink" href="http://hypernova.amarok-shadow.com/MyStuff/dsbg1.jpg" target="_blank">this</a>, I have <a class="postlink" href="http://hypernova.amarok-shadow.com/MyStuff/dsbg2.jpg" target="_blank">this</a>, which would tile the same way. Seems a bit of a hack though; is this what you meant?<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116128 - tepples - Mon Jan 22, 2007 4:30 am</h4>
    <div class="postbody"><span class="postbody">There are six values in the struct that defines an affine matrix. PA, PB, PC, PD, X origin, Y origin. To make a background rotate about a point other than the top left corner of the screen, you set the values of X origin and Y origin as needed based on PA, PB, PC, and PD.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116129 - HyperHacker - Mon Jan 22, 2007 6:06 am</h4>
    <div class="postbody"><span class="postbody">OK, well that's not entirely working:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">i = fixed2int(fixed_mult(Rot, float2fixed(1.4222222))); //convert 360ths to 512ths
<br/>
if(i &gt;= 512) i = 512; else if(i &lt; 0) i = 0;
<br/>
<br/>
BGMatrix[0][0] = fixed_div(COS[i], Zoom) &gt;&gt; 4; //convert 12bit fraction to 8bit
<br/>
BGMatrix[0][1] = fixed_div(-SIN[i], Zoom) &gt;&gt; 4;
<br/>
BGMatrix[1][0] = fixed_div(SIN[i], Zoom) &gt;&gt; 4;
<br/>
BGMatrix[1][1] = fixed_div(COS[i], Zoom) &gt;&gt; 4;
<br/>
BG3_CX = (XPos - 128 * BGMatrix[0][0] - 96 * BGMatrix[0][1]) &lt;&lt; 8;
<br/>
BG3_CY = (YPos - 128 * BGMatrix[1][0] - 96 * BGMatrix[1][1]) &lt;&lt; 8;
<br/>
<br/>
BG3_XDX = BGMatrix[0][0];
<br/>
BG3_XDY = BGMatrix[0][1];
<br/>
BG3_YDX = BGMatrix[1][0];
<br/>
BG3_YDY = BGMatrix[1][1];</td> </tr></table><span class="postbody">
<br/>
I tried 128,96 as the center point (center of the screen) and 256,256 (center of the background which is 512x512), in either case the image just jumps around the screen randomly as it rotates. Adjusting Zoom (1.0 by default) also causes this. It rotates just fine around 0,0 if I don't adjust BG3_CX or BG3_CY.
<br/>
<br/>
When you say this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">x_origin = scrollX - centerX * pa - centerY * pb;
<br/>
y_origin = scrollX - centerX * pc - centerY * pd;</td> </tr></table><span class="postbody">
<br/>
I assume you meant <span style="font-style: italic">y_origin = scroll<span style="font-weight: bold">Y</span></span>?
<br/>
<br/>
<br/>
[edit] Nevermind! Just had to kill the "&lt;&lt; 8" writing to BG3_Cx, since the values were already fixed point. Doh!
<br/>
<br/>
(For those just tuning in, yes, centerX and centerY are screen coords, not BG coords.)
<br/>
<br/>
<br/>
[whee more editing] OK, I had to make a few tweaks to get scrolling working. Otherwise the image's top left corner would be in the center of the screen and the center point would move as I scrolled. This resolves the problem, so the image starts in the corner of the screen like normal and always rotates around the center of the screen no matter the scroll position:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">BG3_CX = ((XPos &lt;&lt; 8) - 128 * BGMatrix[0][0] - 96 * BGMatrix[0][1]) + (128 &lt;&lt; 8);
<br/>
BG3_CY = ((YPos &lt;&lt; 8) - 128 * BGMatrix[1][0] - 96 * BGMatrix[1][1]) + (96 &lt;&lt; 8);</td> </tr></table><span class="postbody">
<br/>
<br/>
Also, refresh my memory, how do I go about compensating for the rotation when scrolling? As it is now, if the image is rotated 90?, then when I adjust the X position, it moves up and down instead of left and right. I did this once before to implement a proper camera system in 3D, but I didn't really understand what I'd done very well (just tinkering and hey it works). I understand you multiply through the matrix? EG TrueScrollX = BGMatrix[?][?] * ScrollX? Hopefully I can work this out tomorrow, right now I need to sleep.
<br/>
<br/>
Thanks for the help BTW. I should have paid more attention in math class, maybe then all this matrix stuff wouldn't be such a pain for me. &gt;_&gt;<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"><br/><br/>Last edited by HyperHacker on Mon Jan 22, 2007 7:20 am; edited 3 times in total</span></div>    
</div>
<div class="post">
    <h4>#116199 - tepples - Tue Jan 23, 2007 2:41 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>HyperHacker wrote:</b></span></td> </tr> <tr> <td class="quote">Also, refresh my memory, how do I go about compensating for the rotation when scrolling? As it is now, if the image is rotated 90?, then when I adjust the X position, it moves up and down instead of left and right.</td> </tr></table><span class="postbody">
<br/>
How are you currently implementing your character's motion on the map?
<br/>
<br/>
Try adding (PA, PC) to the camera position when the player presses right, and add (PB, PD) to the camera position when the player presses down.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116206 - HyperHacker - Tue Jan 23, 2007 4:37 am</h4>
    <div class="postbody"><span class="postbody">There is no character. This is just a demo; all it does is scroll a bitmap around. It's to show off the NDS Motion Card, so there isn't really an up/down/left/right but rather an X and Y acceleration.
<br/>
<br/>
[edit] I adapted the code I used in my 3D camera system (just removed the Z axis references):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">BGMatrix[0][0] = fixed_div(COS[i], Zoom) &gt;&gt; 4; //convert 12bit fraction to 8bit
<br/>
BGMatrix[0][1] = fixed_div(-SIN[i], Zoom) &gt;&gt; 4;
<br/>
BGMatrix[1][0] = fixed_div(SIN[i], Zoom) &gt;&gt; 4;
<br/>
BGMatrix[1][1] = fixed_div(COS[i], Zoom) &gt;&gt; 4;
<br/>
<br/>
XPos += ((XAcc / XYSpeedFactor) * BGMatrix[0][0]) + ((YAcc / XYSpeedFactor) * BGMatrix[0][1]);
<br/>
YPos -= ((XAcc / XYSpeedFactor) * BGMatrix[1][0]) + ((YAcc / XYSpeedFactor) * BGMatrix[1][1]);
<br/>
<br/>
BG3_CX = ((XPos &lt;&lt; 8) - 128 * BGMatrix[0][0] - 96 * BGMatrix[0][1]) + (128 &lt;&lt; 8);
<br/>
BG3_CY = ((YPos &lt;&lt; 8) - 128 * BGMatrix[1][0] - 96 * BGMatrix[1][1]) + (96 &lt;&lt; 8);</td> </tr></table><span class="postbody">
<br/>
It seems right, but since I don't have the motion card right now it'd be quite difficult to test. Does it look right to you? (The use of -= for YPos is intentional, as the sensor's X axis is the same as the screen's, but its Y axis is inverse to the screen's.)
<br/>
<br/>
XAcc and YAcc are the acceleration values returned from the sensor, XYSpeedFactor is a constant (currently 64) simply there to slow down the motion to a reasonable rate (else the image would be jumping all over the place just from the slight jitter from holding it in your hand).<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116217 - tepples - Tue Jan 23, 2007 7:25 am</h4>
    <div class="postbody"><span class="postbody">When you divide by SpeedFactor, it may be better to multiply before dividing so that as much precision remains in the numbers as long as possible.
<br/>
<br/>
Does your code work with the acceleration controlled by touch? If so, it should work with the accelerometer.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
