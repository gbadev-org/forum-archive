<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>nearly finished collision code please help - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > nearly finished collision code please help</h2>
<div id="posts">
<div class="post">
    <h4>#50815 - omaremad - Sat Aug 13, 2005 1:07 pm</h4>
    <div class="postbody"><span class="postbody">Hello, i have ported some directx collision code to nds opengl. it returns true if a point(position of the camera) intersects a triangle; using this method i am making a maze game called maze of doom which will incorporate metroid like controls but no strafe to make it hard for the player to avoid walls. So the aim of the game is to escape the maze without touching the walls. Feel free to use the code but before any one does please make sure i ported it correctly (there is a problem with fabs since it not in the ds math lib). So please help me completely port this code(see directx code below as well).
<br/>
<br/>
thank you
<br/>
<br/>
(for interesting stuff read from the bool part the first bit is just making acos since it not in the ndslib)
<br/>
<br/>
//a,b,c are vertices of a triangle being scanned
<br/>
nintendo ds arm9 version
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define PI  3.14159265358979323846
<br/>
#define HALF_PI 1.5707963267948966192313216916398;
<br/>
static const float ACOS_C0 = HALF_PI; 
<br/>
static const float ACOS_C1 = -0.213300989f; 
<br/>
static const float ACOS_C2 = 0.077980478f; 
<br/>
static const float ACOS_C3 = -0.02164095f; 
<br/>
<br/>
float rr_poly_acos( float x ) 
<br/>
{ 
<br/>
//Worst-case error ~= 0.002 degrees 
<br/>
//Function is exact at -1, 0 and 1 
<br/>
<br/>
if( x &gt;= 0.0f ) 
<br/>
{ 
<br/>
const float sx = SQRT( 1.0f - x ); 
<br/>
const float px = ACOS_C0 + x*(ACOS_C1 + x*(ACOS_C2 + x*ACOS_C3)); 
<br/>
ASSERT( SANE(sx) ); 
<br/>
return( sx * px ); 
<br/>
} 
<br/>
else 
<br/>
{ 
<br/>
const float sx = SQRT( 1.0f + x ); 
<br/>
const float px = ACOS_C0 - x*(ACOS_C1 - x*(ACOS_C2 - x*ACOS_C3)); 
<br/>
ASSERT( SANE(sx) ); 
<br/>
return( PI - (sx * px) ); 
<br/>
} 
<br/>
} 
<br/>
<br/>
#define ACOS(x) rr_poly_acos(x) 
<br/>
#define ASIN(x) (HALF_PI - ACOS(x))
<br/>
<br/>
<br/>
<br/>
BOOL CheckPointInTriangle(vector* point ,vector* a, vector* b, vector* c) {
<br/>
  
<br/>
  double total_angles = 0.0f;
<br/>
       
<br/>
  // make the 3 vectors
<br/>
  vector* v1 = point-a;
<br/>
  vector* v2 = point-b;
<br/>
  vector* v3 = point-c;
<br/>
  //convert v1 to a f32 array to be accepted into normalisation and dot funcs.
<br/>
  f32 v1f[2];
<br/>
  v1f[0]=v1.x;
<br/>
  v1f[1]=v1.y;
<br/>
  v1f[2]=v1.z;
<br/>
//convert v2 to a f32 array to be accepted into normalisation and dot funcs.
<br/>
  f32 v1f[2];
<br/>
  v2f[0]=v2.x;
<br/>
  v2f[1]=v2.y;
<br/>
  v2f[2]=v2.z;
<br/>
//convert v3 to a f32 array to be accepted into normalisation and dot funcs.
<br/>
  f32 v1f[2];
<br/>
  v3f[0]=v3.x;
<br/>
  v3f[1]=v3.y;
<br/>
  v3f[2]=v3.z;
<br/>
<br/>
  normalizef32(v1f);
<br/>
  normalizef32(v2f);
<br/>
  normalizef32(v3f);
<br/>
<br/>
  total_angles += ACOS(dot(v1f,v2f));   
<br/>
  total_angles += ACOS(dot(v2f,v3f));
<br/>
  total_angles += ACOS(dot(v3f,v1f)); 
<br/>
    
<br/>
  // allow a small margin because of the limited precision of
<br/>
  // floating point math.
<br/>
  if (fabs(total_angles-2*PI) &lt;= 0.005)//there is no fabs in the ds lib math(what should i do?)
<br/>
   return (TRUE);
<br/>
     
<br/>
  return(FALSE);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
pc direct x version
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
BOOL CheckPointInTriangle(D3DVECTOR point ,D3DVECTOR a, D3DVECTOR b, D3DVECTOR c) {
<br/>
  
<br/>
  double total_angles = 0.0f;
<br/>
       
<br/>
  // make the 3 vectors
<br/>
  D3DVECTOR v1 = point-a;
<br/>
  D3DVECTOR v2 = point-b;
<br/>
  D3DVECTOR v3 = point-c;
<br/>
  
<br/>
  normalizeVector(v1);
<br/>
  normalizeVector(v2);
<br/>
  normalizeVector(v3);
<br/>
<br/>
  total_angles += acos(dot(v1,v2));   
<br/>
  total_angles += acos(dot(v2,v3));
<br/>
  total_angles += acos(dot(v3,v1)); 
<br/>
    
<br/>
  // allow a small margin because of the limited precision of
<br/>
  // floating point math.
<br/>
  if (fabs(total_angles-2*PI) &lt;= 0.005)
<br/>
   return (TRUE);
<br/>
     
<br/>
  return(FALSE);
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50822 - ecurtz - Sat Aug 13, 2005 4:56 pm</h4>
    <div class="postbody"><span class="postbody">You really shouldn't be taking all those arc cosines, there is a much better test based on matrix algebra. Even if that sounds scary it is really a very simple idea.
<br/>
<br/>
See <a class="postlink" href="http://mcraefamily.com/MathHelp/GeometryPointAndTriangle2.htm" target="_blank">http://mcraefamily.com/MathHelp/GeometryPointAndTriangle2.htm</a> for a decent description or google something like "matrix point in triangle determinant"</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50829 - omaremad - Sat Aug 13, 2005 5:59 pm</h4>
    <div class="postbody"><span class="postbody">Thanks exurtz
<br/>
that way is easier but i am trying to calculate things in a 3d space rater than on a 2d plane.
<br/>
<br/>
im not sure what my one does but im sure it checks collision on a 3d space.
<br/>
<br/>
now is there a workaround the missing fabs function?
<br/>
<br/>
I am sure the ds isnt that weak.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50832 - omaremad - Sat Aug 13, 2005 6:23 pm</h4>
    <div class="postbody"><span class="postbody">Ahh i just realised that there  is a major flaw inn the code snippet. What if the camera moves by 1 unit every time and thus never actually hit the triangle and just passes through it?
<br/>
<br/>
has any one done collision detection for opengl or ds? The Nehe tutorial checks against predefined shape , while i want detection againts an array of trinagles loaded from a file.
<br/>
<br/>
if we cooperate and manage to do this we can all start making 3d games not 3d demos ;).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50837 - octopusfluff - Sat Aug 13, 2005 7:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>omaremad wrote:</b></span></td> </tr> <tr> <td class="quote">Thanks exurtz
<br/>
that way is easier but i am trying to calculate things in a 3d space rater than on a 2d plane.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
It's just adding another axis. That algorithm is fairly trivial to extend.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50882 - omaremad - Sun Aug 14, 2005 6:09 am</h4>
    <div class="postbody"><span class="postbody">i found this really good collision detection library (the simplest ever)
<br/>
it accepts triangles simlar to those of the open gl and has only one system dependent function the time function.
<br/>
<br/>
i am going to stufy the source and see if it is portable or not
<br/>
<br/>
If you are interested please help.
<br/>
<br/>
Here it is: <a href="http://www.photoneffect.com/coldet/" target="_blank">http://www.photoneffect.com/coldet/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50988 - Ethos - Mon Aug 15, 2005 3:20 am</h4>
    <div class="postbody"><span class="postbody">Hmmm...I've heard there is hardware collision detection
<br/>
<br/>
So this might be a waste of time.<br/>_________________<br/><a class="postlink" href="http://ethos.oddigytitanium.com" target="_blank">Ethos' Homepage (Demos/NDS 3D Tutorial)</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50992 - tepples - Mon Aug 15, 2005 5:50 am</h4>
    <div class="postbody"><span class="postbody">Hardware collision detection is not present in any Nintendo game system that I know about.
<br/>
<br/>
What real games do involves considering each pair of sprites and testing their bounding rectangles or circles for overlap. <a class="postlink" href="http://forum.gbadev.org/search.php" target="_blank">Search the forum</a> for "collision".<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#55618 - DeaneGainey - Fri Sep 30, 2005 1:24 am</h4>
    <div class="postbody"><span class="postbody">Full phasic collision detection in a 3d environ:
<br/>
<br/>
1. "Bounding sphere" check.
<br/>
Centred on the median of the width, length, and height of each object, with a radius or the longest edge, the bounding sphere is a hard rule. The checks are from largest bounding spheres against smaller. If two bounding spheres do not overlap, there is no way for the 2 objects to be hitting and a more complex test can be skipped.
<br/>
<br/>
Then the friend triangle test, to see if 2 triangles are inside one another.
<br/>
<br/>
And depending, maybe an intermediary test.<br/>_________________<br/>--- Posts say it all, nothing to see here ---</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#55629 - sajiimori - Fri Sep 30, 2005 3:43 am</h4>
    <div class="postbody"><span class="postbody">Most real games don't test polys versus polys, especially not on a 66MHz system.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#56154 - oxymen - Thu Oct 06, 2005 7:57 pm</h4>
    <div class="postbody"><span class="postbody">The best way in may cases is to just test collision with a simple sircle which is barely surrounding the object. this way you will have no issues with movement, because often if every pixel in fairly complex shapes is checked, the object will in many cases end up stuck with other objects. this is a method which is commonly used in many commersial games, and it is often very hard to notice that it is not pixel-correct check</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#56786 - omaremad - Tue Oct 11, 2005 4:07 pm</h4>
    <div class="postbody"><span class="postbody">I have some good news!
<br/>
<br/>
I constructed a small 3d engine for the nds its has sevral classes for loading maps and adding a camera and lights and models in an easy way.
<br/>
<br/>
It make rotations easy and does all the matrix stuff for you.
<br/>
<br/>
<br/>
It also generate textures automatically.
<br/>
<br/>
And It has collison detection!!!!!!!!!(sphere to triangle mesh)
<br/>
<br/>
But i have a question before i release it.
<br/>
<br/>
I am using floating points for my math so it runs fast on the ds but do i have to operate on the floating points like this to take advantage of the ds's hardware.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
divf32(num, den);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
or can i just do this and it would still run fast and accurately
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
result=num/den;
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#56799 - omaremad - Tue Oct 11, 2005 5:39 pm</h4>
    <div class="postbody"><span class="postbody">just found the answer thanks.
<br/>
<br/>
I will get working.
<br/>
btw any one good at python here? i need help writting a blender blugin.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58119 - SevenString - Fri Oct 21, 2005 12:40 am</h4>
    <div class="postbody"><span class="postbody">For character collisions, one trick i've used in the distant past is to tag particular vertices of a meshed character as spherical "colliders" with a unique radius.  For instance, the torso has a sphere, the head has a smaller sphere, the legs and arms even smaller, and finally the hands and feet.
<br/>
<br/>
For a more advanced implementation, in the 3D animation package, you could create tagged (named) collision spheres that animate with the geometry or skeleton, but only get exported along with the original character mesh data as a series of sphere locations and radii.
<br/>
<br/>
So as the character moves and animates, the attached spheres move along with the character parts.  What you get is an internal virtual representation of the character that looks like the "Michellin Man".
<br/>
<br/>
<a href="http://www.annotatedmst.com/episodes/eyecreatures/michman.gif">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
But for each game tick, you can do collision of this set of spheres with other objects or the environment, yet that collision comes across to the player as detailed because it is more than just a single sphere representing the whole character.
<br/>
<br/>
And if you do your collision comparisons using the square of the radius, the cost of using multiple spheres is pretty negligible, even on a handheld.[/img]<br/>_________________<br/><span style="font-style: italic">"Artificial Intelligence is no match for natural stupidity."</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61900 - Cupcakus - Thu Nov 24, 2005 7:28 pm</h4>
    <div class="postbody"><span class="postbody">You are really overcomplicating collision quite a bit... 
<br/>
<br/>
Assuming your character is a ball? And the maze consists of flat walls, you have very simple sphere vs. oriented bounding box collision.
<br/>
<br/>
Even if your character is not a ball, you can still give it a sphere and have very decent collision vs. walls.
<br/>
<br/>
If your walls are curved enough that bounding boxes are impractical, you're probably using too many poly's for a DS anyway :-)
<br/>
<br/>
I can't think of any reason to have poly v. poly collision in a DS game.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#62062 - sajiimori - Sun Nov 27, 2005 1:04 am</h4>
    <div class="postbody"><span class="postbody">Cupcakus, you must think Mario 64 is overcomplicated because it doesn't use axis-aligned walls and floors.  Also, colliding a sphere versus a set of boxes is linear time.  Faster methods are often needed for real life as levels grow beyond arena-size.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83881 - blaow - Fri May 19, 2006 6:45 am</h4>
    <div class="postbody"><span class="postbody">following this topic, In an example im working on I have bounding box collisions working on all objects and was thinking of applying further triangle to triangle collision check only to those objects that actually collide. Is there a more efficient way not mentioned here to check collisions in a deeper level once the bounding boxes collide, something less processor consumming?
<br/>
<br/>
<br/>
Thanks<br/>_________________<br/>blaow~~</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83948 - sajiimori - Fri May 19, 2006 9:34 pm</h4>
    <div class="postbody"><span class="postbody">Continue to subdivide the model into smaller parts, like boxes or spheres.
<br/>
<br/>
If at least one of the shapes does not animate, a BSP tree might be a good way to represent its collision shape.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84610 - blaow - Tue May 23, 2006 6:18 pm</h4>
    <div class="postbody"><span class="postbody">Not focussing on collisions but more on the Orientation,
<br/>
<br/>
Should these deeper-level bounding boxes/spheres be actual models (drawn in 3d prog, not calculated) that i map to the target model areas, so that when the target model rotates or is scaled, i can have a procedure that rotates/scales all bounding objects asigned to that model in the same manner (just using opengl calls since they are models as well).  
<br/>
<br/>
Right now what i have is a bounding box mechanism based on a structure (not drawn in 3d prog) that stores the min and max height&amp;width&amp;depth of each model, and i use that to check collisions of any 2 models. I am doubting however if this approach can be as scalable and as easy to make it "Oriented bounding box" based as it doesnt use opengl calls to rotate, scale etc..
<br/>
<br/>
any suggestions would be great
<br/>
<br/>
forgive my noobness to 3D :)
<br/>
<br/>
thanks<br/>_________________<br/>blaow~~</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84619 - sajiimori - Tue May 23, 2006 7:13 pm</h4>
    <div class="postbody"><span class="postbody">When you say "actual models," I'm assuming you mean triangle meshes.  They are not usually a good bounding volume to use because they are expensive to collide against.  Bounding volume tests should be inexpensive.  Boxes and spheres are cheaper than triangle meshes, both in terms of CPU and memory usage.
<br/>
<br/>
But we're getting ahead of ourselves.  Bounding volume hierarchies are an optimization, and optimizations should only be done after you have the functionality working (that is, per-poly collision).  Get that working, then we'll talk about optimizing it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84820 - tepples - Wed May 24, 2006 10:18 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Bounding volume hierarchies are an optimization, and optimizations should only be done after you have the functionality working (that is, per-poly collision).</td> </tr></table><span class="postbody">
<br/>
That's like saying "hitboxes in a 2D sprite based fighting game are an optimization, and optimizations should only be done after you have the functionality working (that is, per-pixel collision)." But does any major 2D fighting game use anything but hitboxes?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84847 - sajiimori - Thu May 25, 2006 12:13 am</h4>
    <div class="postbody"><span class="postbody">It's not analogous.  His goal was to do accurate collision.  I know you often suggest to people that they avoid doing things that are probably unnecessary from a gameplay standpoint, but I tend to just answer questions.  The fact of the matter is that hardly any hobbyist work gets published, so doing something that's probably overkill can nevertheless be a good way to learn new skills.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84918 - blaow - Thu May 25, 2006 6:44 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">When you say "actual models," I'm assuming you mean triangle meshes.</td> </tr></table><span class="postbody">
<br/>
Yes.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Boxes and spheres are cheaper than triangle meshes</td> </tr></table><span class="postbody">
<br/>
By that you mean spheres and boxes that are calculated( based on a given vertex and radius/box dimension) and that are not actually drawn on top of the 3dmodel as "invisible" triangle meshes?
<br/>
<br/>
what i was thinking was to draw these collision zones(spheres, boxes) as meshes that lay on top of the model but that are not visible to the user. I could do simple sphere, bounding box collision tests with any of these areas (by using their dimensions/radii only) if and only if the "Main bounding box" that sorrounds the whole visible model has collided. keeping the collision check at 2 levels only.
<br/>
<br/>
Since they are meshes, i could then use opengl calls
<br/>
to rotate and scale these collision zones in the same direction/proportion as the visible model. (if i follow this approach i will forget about poly vs poly collisions, since in my oppinion it should be accurate enough but probably more memory consumming since extra meshes are drawn for collision purposes).
<br/>
<br/>
<br/>
I just cant see a way to pick point special areas of an existing model, and calculate the size, orientation of collision areas during runtime without previuos mapping of these zones.
<br/>
<br/>
Thats more less whats troubeling me at the moment.
<br/>
<br/>
Cheers<br/>_________________<br/>blaow~~</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#84921 - sajiimori - Thu May 25, 2006 7:08 pm</h4>
    <div class="postbody"><span class="postbody">By boxes and spheres, I do not mean triangle meshes of boxes and spheres.
<br/>
<br/>
By a sphere, I mean a center point and a radius.
<br/>
<br/>
By a box, I mean a center point and the extent on each axis.  If the box is rotated, add a vector for the 3 local axes.
<br/>
<br/>
(Spheres are easier to work with.)
<br/>
<br/>
Storing basic collision primitives as triangle meshes is weird and extremely inefficient, but whatever works for you.  I recommend that you do not design your collision code around OpenGL because OpenGL is a graphics library.
<br/>
<br/>
Generating bounding volume hierarchies at runtime is a very advanced topic.  Start with hand-made hierarchies.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#85058 - blaow - Fri May 26, 2006 9:06 pm</h4>
    <div class="postbody"><span class="postbody">^^ Thanks, now i have a point of direction more less, i will read up on ways to "tag" collision primitives to the 3d-model desired zones without using triangle meshes.<br/>_________________<br/>blaow~~</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
