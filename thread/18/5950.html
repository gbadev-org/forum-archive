<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>IRQ vector fun :) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > IRQ vector fun :)</h2>
<div id="posts">
<div class="post">
    <h4>#44855 - DekuTree64 - Mon Jun 06, 2005 2:10 am</h4>
    <div class="postbody"><span class="postbody">Since you can use bit13 of P15.c1 to set the exception vector base to either 0xFFFF0000 (where it normally is, in the BIOS) or 0x00000000, and you can map ITCM to address 0x00000000 if you want, I couldn't help but wonder if that meant I could bypass the default BIOS handler altogether.
<br/>
<br/>
I finally decided to give it a try just now and lo and behold, it works!
<br/>
Then you can put a direct branch to your handler at address 0x18 (the IRQ vector) and save the ordeal the BIOS goes through of getting the DTCM address and loading the handler address first.
<br/>
<br/>
And if that's not enough fun for you, you can even go so far as to use an msr instruction to switch into FIQ mode to avoid having to store any registers before doing anything. Of course, that means you have to write all your interrupt functions in assembly since normal functions expect r0-r3 and r12 to be free, and FIQ mode bankswaps r8-r14, but anything worthy of shaving off a few cycles this way should be in assembly anyway.
<br/>
Then when you're all done, just msr back to IRQ, and bx lr to your caller.
<br/>
<br/>
This concludes today's issue of How to Waste Your Time.
<br/>
<br/>
EDIT: Oops, make that subs pc, lr, #4 instead of bx lr to return to the caller, which swaps back spsr_irq to cpsr, and returns to the right address.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#132084 - Ant6n - Sat Jun 23, 2007 5:56 am</h4>
    <div class="postbody"><span class="postbody">while searching this forum for fiq, i came across this. This is pretty cool stuff. Other thoughts on top of this.
<br/>
I think it might be possible to keep all code in FIQ mode and have the interrupts in IRQ mode. then one could save switching back and forth between three modes (user, irq, fiq), but two instead (fiq as normal, irq as irq).
<br/>
Another idea:
<br/>
Have all your regular code in itcm, consider data abort. The exception vector is 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  BASE+00h   Reset                      Supervisor (_svc)  I=1, F=1
<br/>
  BASE+04h   Undefined Instruction      Undefined  (_und)  I=1, F=unchanged
<br/>
  BASE+08h   Software Interrupt (SWI)   Supervisor (_svc)  I=1, F=unchanged
<br/>
  BASE+0Ch   Prefetch Abort             Abort      (_abt)  I=1, F=unchanged
<br/>
  BASE+10h   Data Abort                 Abort      (_abt)  I=1, F=unchanged
<br/>
  BASE+14h   (Reserved)                 -          -       -
<br/>
  BASE+18h   Normal Interrupt (IRQ)     IRQ        (_irq)  I=1, F=unchanged
<br/>
  BASE+1Ch   Fast Interrupt (FIQ)       FIQ        (_fiq)  I=1, F=1</td> </tr></table><span class="postbody">
<br/>
now make sure the interrupt following the one considered never occurs. in this case its reserved anyway. now you have 2 instructions free in your exception vector. you can do something like this
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
1)  reg &lt;- 1FFF &amp; (r14&gt;&gt;2) 
<br/>
2)  pc  &lt;- byte@[base + reg]
<br/>
</td> </tr></table><span class="postbody">
<br/>
here 1FFF and 'base' is in a banked register. base specifies the address to a list of 8192 entries. That way one can jump to a location in tcm based on what instruction in the itcm caused the abort exception. Here I assume that the list has 8bit values, so you can jump only 256 bytes away from 0.
<br/>
One could also do 16bit or 32bit pointers. One could also, instead of specifying a jump location for every excepted instruction, specify one for every 2,4... instructions by shifting more to the left in 1).
<br/>
anton</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
