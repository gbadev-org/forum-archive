<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Need help with button input, main and sub screen programs - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > Need help with button input, main and sub screen programs</h2>
<div id="posts">
<div class="post">
    <h4>#176595 - Squeakychu - Tue Aug 23, 2011 7:22 am</h4>
    <div class="postbody"><span class="postbody">Hello. I'm new to DS programming, though I have had programming experience before. I hope to get along with everyone and make some cool games and programs for the DS. Anyways, I have a few problems and questions on some programs I'm trying to make with devkitpro, and I hope this is the right place to get help.
<br/>
<br/>
In my first program, I'm trying to display moving stars using random colors in random positions and random speed. I'm also trying to get the DS to read inputs and change the message if a button is inputted. The stars are rendered on the top screen while the button information is on the bottom. Here's the full code for the program.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;nds.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
#define NUM_STARS 60
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   int x;
<br/>
   int y;
<br/>
   int speed;
<br/>
   int speed2;
<br/>
   int xpixle;
<br/>
   unsigned short color;
<br/>
}Star;
<br/>
<br/>
Star star[NUM_STARS];
<br/>
<br/>
void ClearScreen(void)
<br/>
{
<br/>
   int i;
<br/>
   for(i = 0; i &lt; 256 * 192; i++)
<br/>
      VRAM_A[i] = RGB15(0,0,0);
<br/>
}
<br/>
void InitStars(void)
<br/>
{
<br/>
   int i;
<br/>
   for(i = 0; i &lt; NUM_STARS; i++)
<br/>
   {
<br/>
      star[i].color = RGB15(rand() % 15 + 16, rand() % 20 + 11, rand() % 25 + 16);
<br/>
      star[i].speed = rand() % 90 + 20;
<br/>
      star[i].speed2 = 0;
<br/>
      star[i].x = rand() % 256;
<br/>
      star[i].y = rand() % 192;
<br/>
      star[i].xpixle = 0;
<br/>
   }
<br/>
}
<br/>
<br/>
void EraseStar(Star* star)
<br/>
{
<br/>
   VRAM_A[(int)star-&gt;x + star-&gt;y * SCREEN_WIDTH] = RGB15(0,0,0);
<br/>
}
<br/>
<br/>
void MoveStar(Star* star)
<br/>
{
<br/>
   star-&gt;speed2 += star-&gt;speed;
<br/>
<br/>
   if(star-&gt;speed2 &gt;= 100)
<br/>
   {
<br/>
      while(star-&gt;speed2 &gt;= 100)
<br/>
      {
<br/>
         star-&gt;xpixle++;
<br/>
         star-&gt;speed2 -= 100;
<br/>
      }
<br/>
   star-&gt;x += star-&gt;xpixle;
<br/>
   star-&gt;xpixle = 0;
<br/>
   }
<br/>
   
<br/>
   if(star-&gt;x &gt;= SCREEN_WIDTH)
<br/>
   {
<br/>
      star-&gt;color = RGB15(rand() % 15 + 16, rand() % 20 + 11, rand() % 25 + 16);
<br/>
      star-&gt;x = 0;
<br/>
      star-&gt;y = rand() % 192;
<br/>
      star-&gt;speed = rand() % 90 + 20;
<br/>
   }
<br/>
}
<br/>
<br/>
void DrawStar(Star* star)
<br/>
{
<br/>
   VRAM_A[(int)star-&gt;x + star-&gt;y * SCREEN_WIDTH] = star-&gt;color;
<br/>
}
<br/>
<br/>
int main(void) 
<br/>
{
<br/>
   int i;
<br/>
<br/>
   irqInit();
<br/>
   irqEnable(IRQ_VBLANK);
<br/>
<br/>
   videoSetMode(MODE_FB0);
<br/>
   vramSetBankA(VRAM_A_LCD);
<br/>
<br/>
   ClearScreen();
<br/>
   InitStars();
<br/>
   
<br/>
   consoleDemoInit();
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
   scanKeys();
<br/>
<br/>
   if (keysHeld() &amp; KEY_A)
<br/>
      printf("Button A is pressed\n");
<br/>
   else
<br/>
      printf("Button A is released\n");
<br/>
<br/>
   if (keysHeld() &amp; KEY_X)
<br/>
      printf("Button X is pressed\n");
<br/>
   else
<br/>
      printf("Button X is released\n");
<br/>
<br/>
   if (keysHeld() &amp; KEY_B)
<br/>
      printf("Button B is pressed\n");
<br/>
   else
<br/>
      printf("Button B is released\n");
<br/>
<br/>
   if (keysHeld() &amp; KEY_Y)
<br/>
      printf("Button Y is pressed\n");
<br/>
   else
<br/>
      printf("Button Y is released\n");
<br/>
<br/>
   if (keysHeld() &amp; KEY_L)
<br/>
      printf("Button L is pressed\n");
<br/>
   else
<br/>
      printf("Button L is released\n");
<br/>
   
<br/>
   if (keysHeld() &amp; KEY_R)
<br/>
      printf("Button R is pressed\n");
<br/>
   else
<br/>
      printf("Button R is released\n");
<br/>
<br/>
   if (keysHeld() &amp; KEY_START)
<br/>
      printf("Start button is pressed\n");
<br/>
   else
<br/>
      printf("Start button is released\n");
<br/>
      
<br/>
   if (keysHeld() &amp; KEY_SELECT)
<br/>
      printf("Select button is pressed\n");
<br/>
   else
<br/>
      printf("Select button is released\n");
<br/>
<br/>
   if (keysHeld() &amp; KEY_TOUCH)
<br/>
      printf("The Touch screen is touched\n");
<br/>
   else
<br/>
      printf("The touch screen is not touched\n");
<br/>
<br/>
   swiWaitForVBlank();
<br/>
<br/>
   for(i = 0; i &lt; NUM_STARS; i++)
<br/>
      {
<br/>
         EraseStar(&amp;star[i]);
<br/>
<br/>
         MoveStar(&amp;star[i]);
<br/>
<br/>
         DrawStar(&amp;star[i]);
<br/>
      }
<br/>
   consoleClear();
<br/>
   }
<br/>
   return 0;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
The program compiles and runs just fine, but the X, Y, and touch buttons don't seem to register, even though it works just fine on it's own. I'm curious what the issue with that is. Also, I don't want stars to move at an integer speed per frame, but ARM9 doesn't handle floating point integers well from what I hear. So I used this code in order to have greater control over my speed without using floating-point variables.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void MoveStar(Star* star)
<br/>
{
<br/>
   star-&gt;speed2 += star-&gt;speed;
<br/>
<br/>
   if(star-&gt;speed2 &gt;= 100)
<br/>
   {
<br/>
      while(star-&gt;speed2 &gt;= 100)
<br/>
      {
<br/>
         star-&gt;xpixle++;
<br/>
         star-&gt;speed2 -= 100;
<br/>
      }
<br/>
   star-&gt;x += star-&gt;xpixle;
<br/>
   star-&gt;xpixle = 0;
<br/>
   }
<br/>
   
<br/>
   if(star-&gt;x &gt;= SCREEN_WIDTH)
<br/>
   {
<br/>
      star-&gt;color = RGB15(31,31,31);
<br/>
      star-&gt;x = 0;
<br/>
      star-&gt;y = rand() % 192;
<br/>
      star-&gt;speed = rand() % 90 + 20;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm curious if this is the correct way of moving a star less than 1 pixel at a time, or if there's a better or less CPU-intensive method of doing what's intended in this code.
<br/>
<br/>
Lastly, I'm trying to get to grips with control of the Main and Sub Displays, so I'm trying to make a program that displays the moving stars on the top screen, while having a simple drawing program run on the bottom screen. I'm trying to set the drawing program to the main display, while setting the moving stars to the sub display, and as you can maybe see in this code, I'm having great difficulty trying to achieve that. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;nds.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
#define NUM_STARS 60
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   int x;
<br/>
   int y;
<br/>
   int speed;
<br/>
   int speed2;
<br/>
   int xpixle;
<br/>
   unsigned short color;
<br/>
}Star;
<br/>
<br/>
Star star[NUM_STARS];
<br/>
<br/>
void ClearScreen(void)
<br/>
{
<br/>
   int i;
<br/>
   for(i = 0; i &lt; 256 * 192; i++)
<br/>
      VRAM_B[i] = RGB15(0,0,0);
<br/>
}
<br/>
void InitStars(void)
<br/>
{
<br/>
   int i;
<br/>
   for(i = 0; i &lt; NUM_STARS; i++)
<br/>
   {
<br/>
      star[i].color = RGB15(31,31,31);
<br/>
      star[i].speed = rand() % 90 + 20;
<br/>
      star[i].speed2 = 0;
<br/>
      star[i].x = rand() % 256;
<br/>
      star[i].y = rand() % 192;
<br/>
      star[i].xpixle = 0;
<br/>
   }
<br/>
}
<br/>
<br/>
//code for drawing a line between two points
<br/>
void DrawLine(int x1, int y1, int x2, int y2, unsigned short color)
<br/>
{
<br/>
   int yStep = SCREEN_WIDTH;
<br/>
   int xStep = 1;
<br/>
   int xDiff = x2 - x1;
<br/>
   int yDiff = y2 - y1;
<br/>
<br/>
   int errorTerm = 0;
<br/>
   int offset = y1 * SCREEN_WIDTH + x1;
<br/>
   int i;
<br/>
<br/>
   if(xDiff &lt; 0)
<br/>
   {
<br/>
      xDiff = -xDiff;
<br/>
      xStep = -xStep;
<br/>
   }
<br/>
<br/>
   if(yDiff &lt; 0)
<br/>
   {
<br/>
      yDiff = -yDiff;
<br/>
      yStep = -yStep;
<br/>
   }
<br/>
<br/>
   if (xDiff &gt; yDiff)
<br/>
   {
<br/>
      for(i = 0; i &lt; xDiff + 1; i++)
<br/>
      {
<br/>
         VRAM_A[offset] = color;
<br/>
<br/>
         offset += xStep;
<br/>
<br/>
         errorTerm += yDiff;
<br/>
<br/>
         if (errorTerm &gt; xDiff)
<br/>
         {
<br/>
            errorTerm -= xDiff;
<br/>
            offset += yStep;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
      for(i = 0; i &lt; yDiff + 1; i++)
<br/>
      {
<br/>
         VRAM_A[offset] = color;
<br/>
<br/>
         offset += yStep;
<br/>
<br/>
         errorTerm += xDiff;
<br/>
<br/>
         if (errorTerm &gt; yDiff)
<br/>
         {
<br/>
            errorTerm -= yDiff;
<br/>
            offset += xStep;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
}
<br/>
<br/>
void EraseStar(Star* star)
<br/>
{
<br/>
   VRAM_B[(int)star-&gt;x + star-&gt;y * SCREEN_WIDTH] = RGB15(0,0,0);
<br/>
}
<br/>
<br/>
void MoveStar(Star* star)
<br/>
{
<br/>
   star-&gt;speed2 += star-&gt;speed;
<br/>
<br/>
   if(star-&gt;speed2 &gt;= 100)
<br/>
   {
<br/>
      while(star-&gt;speed2 &gt;= 100)
<br/>
      {
<br/>
         star-&gt;xpixle++;
<br/>
         star-&gt;speed2 -= 100;
<br/>
      }
<br/>
   star-&gt;x += star-&gt;xpixle;
<br/>
   star-&gt;xpixle = 0;
<br/>
   }
<br/>
   
<br/>
   if(star-&gt;x &gt;= SCREEN_WIDTH)
<br/>
   {
<br/>
      star-&gt;color = RGB15(31,31,31);
<br/>
      star-&gt;x = 0;
<br/>
      star-&gt;y = rand() % 192;
<br/>
      star-&gt;speed = rand() % 90 + 20;
<br/>
   }
<br/>
}
<br/>
<br/>
void DrawStar(Star* star)
<br/>
{
<br/>
   VRAM_B[(int)star-&gt;x + star-&gt;y * SCREEN_WIDTH] = star-&gt;color;
<br/>
}
<br/>
<br/>
int main(void) 
<br/>
{
<br/>
   touchPosition touch;
<br/>
<br/>
   int oldX = 0;
<br/>
   int oldY = 0;
<br/>
   int i;
<br/>
        
<br/>
 // trying to set drawing(VRAM_A) to the bottom(main) screen and the moving stars(VRAM_B) to the top(sub).
<br/>
   videoSetMode(MODE_FB0);
<br/>
   videoSetModeSub(MODE_FB1);
<br/>
   vramSetBankA(VRAM_A_LCD);
<br/>
   vramSetBankB(VRAM_B_LCD);
<br/>
<br/>
   lcdMainOnBottom();
<br/>
<br/>
   ClearScreen();
<br/>
   InitStars();
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
      scanKeys();
<br/>
<br/>
      if(keysHeld() &amp; KEY_START)
<br/>
      {
<br/>
         for(i = 0; i &lt; 256 * 192; i++)
<br/>
         {
<br/>
            VRAM_A[i] = RGB15(0,0,0);
<br/>
         }
<br/>
      }
<br/>
<br/>
<br/>
      touchRead(&amp;touch);
<br/>
<br/>
      if(!(keysDown() &amp; KEY_TOUCH) &amp;&amp; (keysHeld() &amp; KEY_TOUCH))
<br/>
      {
<br/>
         DrawLine(oldX, oldY, touch.px, touch.py, rand());
<br/>
      }
<br/>
      oldX = touch.px;
<br/>
      oldY = touch.py;
<br/>
<br/>
      swiWaitForVBlank();
<br/>
<br/>
   for(i = 0; i &lt; NUM_STARS; i++)
<br/>
      {
<br/>
         EraseStar(&amp;star[i]);
<br/>
<br/>
         MoveStar(&amp;star[i]);
<br/>
<br/>
         DrawStar(&amp;star[i]);
<br/>
      }
<br/>
   consoleClear();
<br/>
   }
<br/>
   return 0;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
With this program as it is, the drawing part works just fine, but the top screen displays nothing but white. I have no idea how to correct this issue. If anyone has suggestions, that would be just fantastic!
<br/>
<br/>
Anyway, these are my major concerns. Thanks for bearing with me, and I hope to have a good experience on these forums. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#176596 - sverx - Tue Aug 23, 2011 11:03 am</h4>
    <div class="postbody"><span class="postbody">ARM9 has no support for floating point, but you can use <a class="postlink" href="http://en.wikipedia.org/wiki/Fixed-point_arithmetic" target="_blank">fixed point</a> with no problem.
<br/>
The NDS SUB Engine has no frame buffer mode. You could use a BG in BMP mode. VRAM_B can't be used with SUB Engine, you can use VRAM_C. Check this example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;nds.h&gt;
<br/>
<br/>
int main(void) {
<br/>
<br/>
  vramSetBankC (VRAM_C_SUB_BG);
<br/>
  
<br/>
  videoSetModeSub (MODE_4_2D | DISPLAY_BG3_ACTIVE);
<br/>
  
<br/>
  REG_BG3CNT_SUB = BG_BMP16_256x256 | BG_BMP_BASE(0);
<br/>
  
<br/>
  REG_BG3PA_SUB = 1 &lt;&lt; 8;
<br/>
  REG_BG3PB_SUB = 0;
<br/>
  REG_BG3PC_SUB = 0;
<br/>
  REG_BG3PD_SUB = 1 &lt;&lt; 8;
<br/>
  
<br/>
  lcdMainOnTop ();
<br/>
  
<br/>
  while(1) {
<br/>
  
<br/>
    scanKeys();
<br/>
    
<br/>
    if (keysHeld() &amp; KEY_TOUCH) {
<br/>
     
<br/>
      touchPosition touch; touchRead(&amp;touch);
<br/>
      
<br/>
      BG_GFX_SUB [touch.py * SCREEN_WIDTH + touch.px] = RGB5(31,31,31) | BIT (15);
<br/>
    }
<br/>
<br/>
    swiWaitForVBlank();
<br/>
  }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
edit: with current dkA/libnds, you no longer need to add:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">irqInit(); 
<br/>
irqEnable(IRQ_VBLANK);</td> </tr></table><span class="postbody">
<br/>
to your code. Remove them.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#176598 - Squeakychu - Tue Aug 23, 2011 5:03 pm</h4>
    <div class="postbody"><span class="postbody">Awesome! All of my problems have been resolved. Removing irqInit() and irqEnable() fixed my input problem, and now X, Y, and touch register just fine. My stars/drawing program also works like a charm now setting it in Mode4/BG3. Thanks for the advice sverx!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#176602 - Squeakychu - Wed Aug 24, 2011 6:47 am</h4>
    <div class="postbody"><span class="postbody">I'm not sure if I should create another help topic in so little time, and this is related to my original post, so I guess I should post this here. Now that my program works perfectly, I'm trying to optimize it to use as little resources as possible. I'm trying to make my program so that the stars only move a decimal amount (speed) via fixed-point arithmetic. However, I'm having a hard time coming to heads with fixed-point and the concept of shifting bits. 
<br/>
I know that something like '1 &lt;&lt; 8' would equal 256, or 100000000 in binary, but I'm still lost on how to apply this to dividing numbers that don't completely go into the divisor.  In the mean time, I have used this code to move X by .37 by dividing by 100 instead.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void InitStars(void)
<br/>
{
<br/>
   unsigned short i;
<br/>
   for(i = 0; i &lt; NUM_STARS; i++)
<br/>
   {
<br/>
      star[i].color = RGB15(31,31,31);
<br/>
// need speed divided by fixed point
<br/>
      star[i].speed = 37;
<br/>
      star[i].speed2 = 0;
<br/>
      star[i].x = rand() % 256;
<br/>
      star[i].y = rand() % 192;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void MoveStar(Star* star)
<br/>
{
<br/>
   star-&gt;speed2 += star-&gt;speed;
<br/>
   if(star-&gt;speed2 &gt;= 100)
<br/>
   {
<br/>
      while(star-&gt;speed2 &gt;= 100)
<br/>
      {
<br/>
         star-&gt;x++;
<br/>
         star-&gt;speed2 -= 100;
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   if(star-&gt;x &gt;= SCREEN_WIDTH)
<br/>
   {
<br/>
      star-&gt;color = RGB15(31,31,31);
<br/>
      star-&gt;x = 0;
<br/>
      star-&gt;y = rand() % 192;
<br/>
// same as above
<br/>
      star-&gt;speed = rand() 37;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm tend to learn by example, but I can't find many examples of fixed-point numbers in C.  Would anyone know how to divide something like 37 by 100 via fixed point arithmetic, or is there any example code that divides by fixed point numbers? Again, thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#176603 - Dwedit - Wed Aug 24, 2011 8:15 am</h4>
    <div class="postbody"><span class="postbody">37/100 is about 95/256.  So if you want a fixed point number that gets shifted back 8 bits, you use 256 as your fraction denominator.
<br/>
<br/>
A popular fixed point format is 16.16, so you have a 16-bit integer part, and a 16-bit fractional part, but you can use any convention you want to separate the 32-bit numbers into an integer and fractional part.  Other formats include 24.8, or 8.24.  0.32 (0 bits for integer part, 32 bits for fractional part) is also useful for pure fractions, since the ARM processor can just do a 32-bit * 32-bit long multiply to get a 64 bit answer, then discard the low word to get the integer result.
<br/>
<br/>
When you use fixed point numbers, you have to deal with precision loss.  Many fractions that would be fine in decimal do not divide evenly into a power of 2.  For example, 1/3, 1/5 and 1/10 are infinitely repeating fractions when expressed in binary.  1/10 = 0.0001100110011001100...
<br/>
As a hex number with 32 bits of fraction, it's 0x19999999.  Multiply that by 10 (0x0A), and you get 0xFFFFFFFA, which is not quite 1.  But if you add 1 to your fraction, you get 0x100000004 when you multiply by 10.  So your integer part is correct, but your fractional part is a tad too high.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#176608 - Azenris - Wed Aug 24, 2011 1:55 pm</h4>
    <div class="postbody"><span class="postbody"><a href="http://www.coranac.com/tonc/text/fixed.htm" target="_blank">http://www.coranac.com/tonc/text/fixed.htm</a><br/>_________________<br/>&lt;Robert Morley&gt;
<br/>
<a class="postlink" href="http://sacredpotion.blogspot.com/" target="_blank"><span style="color: red">My Homebrew Games</span></a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
