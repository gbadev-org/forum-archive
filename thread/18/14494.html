<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ARM7 exceptions and debugging - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > ARM7 exceptions and debugging</h2>
<div id="posts">
<div class="post">
    <h4>#145025 - simonjhall - Sat Nov 10, 2007 5:31 pm</h4>
    <div class="postbody"><span class="postbody">Yo.
<br/>
<br/>
I'm trying to extend my debugger by adding support for ARM7 debugging. All the infrastructure's in place to 'just add a second processor', but I can't actually seem to stop the thing from running in the usual way!
<br/>
<br/>
With the ARM9 debugger after trying many breakpoint schemes (each with varying success) I settled on the complicated CPU exception method, as it provided the most advantages. To summarise, you point 0x27ffd9c at your carefully hand-crafted function and once you set this address to this function, the exception handling system starts to work. eg if have a data/prefetch abort, illegal or breakpoint instructions will all get relayed through this function.
<br/>
<br/>
Gbatek says that the ARM7 has the same setup in that you can use 0x380ffdc as the exception vector, but I can't get it to do anything. I write the address of my dummy handler to this address and go nuts, but I just can't seem to get it to get called! Neither data aborts, breakpoint instructions or illegal instructions trip this function up. However, doing stuff with CP15 (which apparently causes exceptions) does crash the CPU with or without the handler installed. Err...
<br/>
<br/>
Anyone done anything with exceptions on the ARM7? Wanna share :-)<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145026 - Mighty Max - Sat Nov 10, 2007 5:38 pm</h4>
    <div class="postbody"><span class="postbody">The arm7 only calls it on undefined instructions or calls to the bios (undefined swi vector, softreset) afaik.
<br/>
<br/>
Due to the missing cp15, it doesn't fire on data/code aborts &amp; such. The stack is most likely looking different on the arm7 too (i.e. no cp15 state saves)<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145027 - simonjhall - Sat Nov 10, 2007 5:43 pm</h4>
    <div class="postbody"><span class="postbody">Wow that was fast :-)
<br/>
Undefined instructions didn't seem to give me anything (I've tried 0x0 and 0xffffffff), I'm not surprised about data aborts tbh but wouldn't the CPU 'know' that it was getting data from an address that doesn't exist? Also is there anyway to command an undefined swi call? Swi's designed for user-mode code to call an operating system, right? So it's got to be overridable, I'd imagine...
<br/>
<br/>
/ot: I've noticed that on the ARM9 even though GBA slot RAM has it's own section defined in the PU, reads/writes to those addresses will cause data aborts. But as soon as you plug in slot-2 RAM those aborts go away. Cool huh?<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145028 - Mighty Max - Sat Nov 10, 2007 5:51 pm</h4>
    <div class="postbody"><span class="postbody">The undefined instruction is not really anny not defined instruction.
<br/>
<br/>
It should work for 0x#6000010 
<br/>
with # beeing the condition to execute the undef<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145029 - simonjhall - Sat Nov 10, 2007 6:15 pm</h4>
    <div class="postbody"><span class="postbody">Yar, thar be crashes!
<br/>
<br/>
Well 0x6000010 seems to do the trick! 0xf6000010 won't do it (even though f is an invalid condition code), but 0 and e are fine :-)
<br/>
<br/>
Also didn't help that the thing I was doing inside the actual exception function was a bit too heavyweight so it was actually happing - but I couldn't tell! Score...
<br/>
<br/>
Ok, to summarise:
<br/>
- bkpt doesn't work
<br/>
- *(int *)0 = 0 doesn't work
<br/>
- mcr 15,0,r0,c0,c0,0 does work
<br/>
- .word 0xe6000010 does work
<br/>
<br/>
...shame when exceptions do happen they don't seem to stop! One step at a time I guess :-)
<br/>
<br/>
Ta :-D<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145053 - simonjhall - Sun Nov 11, 2007 1:23 am</h4>
    <div class="postbody"><span class="postbody">Yo, just a quick update - yeah, despite what I originally thought using in exception vector sufficient to make a debugger. Stuff IS different to the ARM9, but not dramatically so.
<br/>
In case this can help anyone out, here's the result of a wasted Saturday afternoon!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ARM7EnterException:
<br/>
      bic r13, r13, #3
<br/>
      ldr r14,=MyReg
<br/>
      stmia r14,{r0-r7}
<br/>
      
<br/>
      ldr r0,=OrigSP
<br/>
      str sp,[r0]
<br/>
      
<br/>
      ldr r0,=CurrCPSR
<br/>
      mrs r1,cpsr
<br/>
      str r1,[r0]
<br/>
      
<br/>
      ldmia   sp!, {lr}
<br/>
      msr     CPSR_fsxc, lr
<br/>
      
<br/>
      ldr r0,=MyReg+32
<br/>
      stmia r0,{r8-r15}
<br/>
      
<br/>
      LDR r12,=ExceptionStack
<br/>
      LDR r13,[r12]
<br/>
      bl Exception
<br/>
<br/>
      ldr r0,=ProperCPSR
<br/>
      ldr r1,[r0]
<br/>
      mrs r1,cpsr
<br/>
      
<br/>
      ldr r0,=MyReg
<br/>
      ldm r0,{r0-r15}
<br/>
</td> </tr></table><span class="postbody">It's a heavily-modified version of the version I pinched (and then modified) from Mighty Max back when I did the ARM9 version.
<br/>
<br/>
MyReg is an array of sixteen 32-bit words, and this is where the registers from the 'calling code' will live.
<br/>
OrigSP is the stack pointer that the exception handler gives you when you start this function. Note: it's not always aligned!
<br/>
Once aligned, the CPSR of the original function is at $sp, the original $r12 is at $sp+4 and the return program counter (not the link register) is at $sp+8.
<br/>
<br/>
I get back the banked registers by picking out the saved CPSR and moving it to the current CPSR, exposing the original r8,9,10,11,13,14.
<br/>
<br/>
ExceptionStack is set to a malloc'd bit of memory, to be used by the breakpoint function (Exception). The final ldm will restore the code to the original execution position and state.
<br/>
<br/>
The original version had a bit of code (in .word format, not assembly) which used CP15. Obv this ain't gonna work! Also it loaded the original CPSR back into SPSR_fsxc, but this didn't seem to do anything in the ARM7 version. CPSR_fsxc luckily did though!
<br/>
<br/>
EDIT: this one restores the CPSR properly<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
