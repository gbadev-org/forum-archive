<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Problem with software sprite emulation via 3D engine - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Problem with software sprite emulation via 3D engine</h2>
<div id="posts">
<div class="post">
    <h4>#79508 - NEiM0D - Fri Apr 14, 2006 1:48 am</h4>
    <div class="postbody"><span class="postbody">Hello all,
<br/>
<br/>
I'm trying to figure out how to fix a problem which occurs when trying to draw a sprite (textured polygon) using the DS's 3D engine .
<br/>
<br/>
First I start with setting up the orthogonal projection matrix.
<br/>
This orthogonal projection matrix sets up the camera and 3D system so that the X/Y coordinates of the 3D space (regardless of Z) are the same as the screen X/Y coordinates, which makes it very easy for 2D sprites to be drawn on the DS.
<br/>
<br/>
However, there is a slight problem with the texture mapping used by the 3D engine with DS:
<br/>
<br/>
<span style="font-weight: bold">When rotating the polygon, the polygon can be one texel off!</span>
<br/>
<br/>
Consider drawing a sprite which is 32x32 in size.
<br/>
For the polygon's vertex coordinates you give it these 4 points:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
(0.0, 0.0)         (32.0, 0.0)
<br/>
(0.0, 32.0)       (32.0, 32.0)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And for texture coordinates the same.
<br/>
<br/>
For example, see these two pictures:
<br/>
Polygon which is not rotated (note the 4 differently coloured pixels) :
<br/>
<a href="http://www.neimod.com/normal.png">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
Now when you rotate this 90 degrees (see [1]) using the DS's 3D engine, you get:
<br/>
<a href="http://www.neimod.com/ninetyrot.png">[Images not permitted - Click here to view it]</a>
<br/>
(zoom in to see the problem clearly)
<br/>
<br/>
In the last image, the result you get which the 3D engine displays, is obviously not correct. It looks like the texture went up by 1 pixel!
<br/>
<br/>
I should mention that this texture was drawn with the "texture repeat" flags enabled. If this would not be the case, then the "1-pixel incorrect left side" of the polygon would simply not be drawn.
<br/>
<br/>
A possible correction would be to move the texture one pixel down when you know you are going to rotate 90 degrees, which would then display a correct image.
<br/>
<br/>
But consider a rotation of any degree, how does one fix it?
<br/>
This is where I am stuck at the moment, maybe someone can enlighten me?
<br/>
<br/>
[1]: The matrix used to perform the rotation on the polygon is:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
      
<br/>
P = [cos(a)   sin(a)]
<br/>
      [-sin(a)   cos(a)]
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79517 - ecurtz - Fri Apr 14, 2006 2:36 am</h4>
    <div class="postbody"><span class="postbody">A couple things you could try:
<br/>
<br/>
Check to make sure your sin and cosine values are accurate (or just test with 0 and 1 to make sure the problem is the same.)
<br/>
<br/>
Offset the texel values slightly, try 0.5-32.5 or 0.1-32.1. Depending on how it determines what texel to use on border cases this may help.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79736 - NEiM0D - Sat Apr 15, 2006 5:53 pm</h4>
    <div class="postbody"><span class="postbody">No that seems not to have much effect.  The result is still the same.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79871 - blaisef01 - Sun Apr 16, 2006 5:18 pm</h4>
    <div class="postbody"><span class="postbody">I don't know if this will help:
<br/>
<br/>
Keep vertex coordintes values between (-7, -7, -7) and (7, 7, 7) or things go screwed. If you need quads bgger than that use a glScale to increase the size of the object. 
<br/>
<br/>
Here's a matrix that i was using to rotate things around the z-axis
<br/>
<br/>
P = [ca  sa]
<br/>
      [-sa ca]
<br/>
<br/>
where ca = COS[a] and sa = SIN[a]
<br/>
<br/>
a = ((ang) + 2048) % LUT_SIZE
<br/>
<br/>
LUT_SIZE is 512, thats's how big the cosine and sine tables with libnds are
<br/>
<br/>
COS[a] and SIN[a] reference the sine and cosine tables shipped with libnds and the angles range from 0 to 4095 where 0 is 0 degress and 4095 is about 359.1 degrees
<br/>
<br/>
This isn't the best way to do this and this explanation probably makes no sense if you're still confused as i am now. find me on yahoo messenger  at <a href="mailto:sevenforce_control@yahoo.co.uk">sevenforce_control@yahoo.co.uk</a> or on msn messenger at <a href="mailto:blaisef01@hotmail.com">blaisef01@hotmail.com</a> and i'll attempt to explain it better</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79874 - NEiM0D - Sun Apr 16, 2006 5:30 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for the tip, but the vertex coordinates I use are 0.0 and 1.0. (multiplied by 4096 because of fixed point).
<br/>
<br/>
The elements of the internal matrix of the 3D engine is 32bits: 1bit sign, 19bits integer and 12bits decimal.
<br/>
<br/>
So yes, I use the scale command which scales the internal matrix by a factor of 32 because that's the size of my sprite.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79945 - Chris Holmes - Mon Apr 17, 2006 1:39 pm</h4>
    <div class="postbody"><span class="postbody">Are you actually rotating the sprite's vertices, or are you rotating the texture vertices?  Generally speaking, if you're rendering sprites in 3d, your best bet is to leave the object vertices alone and only change the texture vertices.
<br/>
<br/>
It looks like the error you're getting is because you're using fixed/floating point math.  If you're just trying to rotate by 90 degrees, then don't count on a lookup table working.  Floating point math (and fixed point especially) is imprecise.  The more you rotate things with fixed/floating point, the more the error builds up.
<br/>
<br/>
One easy way to fix this problem is to just keep an array of your current texture coordinates and your current rotation angle.  Whenever you change the sprites rotation, reset the values in the texture coordinate array.  
<br/>
<br/>
Assuming that you render your quad like this:
<br/>
0 1
<br/>
3 2
<br/>
<br/>
Then if you're rotating 90 degrees clockwise, then texcoord[0] = texcoord[3], [1] = [2], [2] = [1], and [3] = [2].  
<br/>
<br/>
Since you're only copying values and not doing imprecise multiplication, then you're set and you won't see any graphical glitches.
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79948 - Mighty Max - Mon Apr 17, 2006 2:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote">It looks like the error you're getting is because you're using fixed/floating point math.  If you're just trying to rotate by 90 degrees, then don't count on a lookup table working.  Floating point math (and fixed point especially) is imprecise.  The more you rotate things with fixed/floating point, the more the error builds up.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Multiplication by 0 or 1 (90? rotation) should not have loss at all, they are fully enclosed in every mathematical group:
<br/>
  a * 0 = 0 with 0 existing, for every existing a
<br/>
  a * 1 = a with 1 existing, for every existing a exists a :D
<br/>
<br/>
The only possible loss is the overflow at multiplying the greatest possible negative value with -1 (i.e. in 16 bit fixed point: 0x8000 * (-1) gives 0x8000 [~value +1 gives 0x7FFF +1 = 0x8000] , which is again the greatest possible negative value.
<br/>
<br/>
<br/>
<br/>
For rotating the texture instead of the quads vertices, it woudl really look odd when rotating in steps other then 90? later on. I.e. on 45? you'd get something like
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
    /\
<br/>
  +----+
<br/>
  |    |
<br/>
 /|    |\
<br/>
 \|    |/
<br/>
  |    |
<br/>
  +----+
<br/>
    \/
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
where the texture does not have any ground to show its edges and it falsely repeated where the quad extends the texture<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79960 - tepples - Mon Apr 17, 2006 6:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mighty Max wrote:</b></span></td> </tr> <tr> <td class="quote">Multiplication by 0 or 1 (90? rotation) should not have loss at all, they are fully enclosed in every mathematical group:
<br/>
  a * 0 = 0 with 0 existing, for every existing a
<br/>
  a * 1 = a with 1 existing, for every existing a exists a :D</td> </tr></table><span class="postbody">
<br/>
Groups do not have a multiplicative zero, but rings do.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79969 - Mighty Max - Mon Apr 17, 2006 8:20 pm</h4>
    <div class="postbody"><span class="postbody">you'r right. 
<br/>
I was first about to say "R?ume" but as i don't know the correct english term, i reduced it a bit :p<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79981 - NEiM0D - Mon Apr 17, 2006 11:02 pm</h4>
    <div class="postbody"><span class="postbody">Mighty Max is right.
<br/>
<br/>
And my SIN/COS look up tables are precisely defined at 90 degrees, 180 degrees, etc.
<br/>
<br/>
Rotating the texture coordinates is not a good idea, because of what Mighty Max said.
<br/>
<br/>
Your polygon would *always* be an unrotated square, and only the texture on it would rotate. Definitely not what you want.
<br/>
<br/>
I've found an article by Chris Hecker which explains the problem better (but not necessarily more accurately): <a class="postlink" href="http://www.d6.com/users/checker/pdfs/gdmtex3.pdf" target="_blank">http://www.d6.com/users/checker/pdfs/gdmtex3.pdf</a>
<br/>
<br/>
The problem is that the 3D engine of the DS does not behave exactly like Chris Hecker's texture mapper.
<br/>
<br/>
The difference from the top of my head at the moment is that in Chris Hecker's texture mapper, a "pixel" is representing a box with the coordinate of the pixel being the center.
<br/>
On DS the coordinate of the pixel is not the center, but the top-left corner of the "pixel box".</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80024 - gladius - Tue Apr 18, 2006 3:36 am</h4>
    <div class="postbody"><span class="postbody">I'm surprised (can't try it right now) that something like ecurtz suggested doesn't work:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
fixed xoffset = fixedDiv(1, spriteWidth) / 2;
<br/>
fixed yoffset = fixedDiv(1, spriteHeight) / 2;
<br/>
<br/>
// do rotation to sprite here
<br/>
<br/>
texture.topLeft.x -= xoffset; texture.topLeft.y -= yoffset;
<br/>
topRight, bottomLeft, bottomRight, etc.
<br/>
</td> </tr></table><span class="postbody">
<br/>
An alternative if it's only having a problem in the vertical direction is to do a vertical offset proportional to the angle of rotation.  Something similar to this.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
vector offsetVector = sin(angle) * vector2d(0, (1.0/spriteHeight) / 2.0);
<br/>
texcoord.x += offsetvector.x;
<br/>
texcoord.y += offsetvector.y;
<br/>
</td> </tr></table><span class="postbody">
<br/>
This will have no effect when it is at 0 degrees, but will smoothly adjust the texture coordinates to be offset by 1.0/spriteHeight / 2.0 at 90 degree rotation.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80058 - keldon - Tue Apr 18, 2006 11:55 am</h4>
    <div class="postbody"><span class="postbody">Yes, I was thinking of that too but didn't like it as an implementation. Besides there is a specific point at which you will have to adjust the pixel, so why not precalculate it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80095 - gladius - Tue Apr 18, 2006 7:51 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">Besides there is a specific point at which you will have to adjust the pixel, so why not precalculate it.</td> </tr></table><span class="postbody">
<br/>
I'm not sure what you mean.  The point of smoothly adjusting the offset is that so as you rotate, the image doesn't all of a sudden "pop" as you hit 90 degrees, or 180 degrees, etc.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80105 - keldon - Tue Apr 18, 2006 8:43 pm</h4>
    <div class="postbody"><span class="postbody">I was under the impression that the hardware was not handling inbetween pixels and would pop anyway since ecurtz's suggestion didn't work.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80135 - NEiM0D - Wed Apr 19, 2006 2:54 am</h4>
    <div class="postbody"><span class="postbody">I've uploaded a demo which shows the problem better (should have done this this first post): 
<br/>
<a class="postlink" href="http://neimod.com/softsprite.nds" target="_blank">http://neimod.com/softsprite.nds</a>
<br/>
<br/>
L/R rotate, A+SELECT/START zoom
<br/>
<br/>
This is with no corrections whatsoever.
<br/>
When moving from 0-&gt;45-&gt;90 degrees for example, you can see that the texture slips one texel up very noticable at certain points.
<br/>
<br/>
gladius: The first correction seems to mess up the rotation at 0 degrees, and the second correction is not much different from without texture correction.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80148 - Payk - Wed Apr 19, 2006 6:28 am</h4>
    <div class="postbody"><span class="postbody">I have same problem. There are some "ways" to work arround.
<br/>
If u want to make a complete field with different textures, be sure to "draw" first all squarez with same texture. So that bug just apperes between squares with different texture. Next thing: U could have a Backgroungcolor which matchs to the texture so its hard to see the gab (that method is used in Infinity 3D World Generator). But in my project it couldnt be done because of that reflexions i want to use...They would look shity with a green bg-color behind the water...
<br/>
And last dirty way: Make that squares a bit bigger. So they are "Over" EACHOTHER...Hmhm but then it flickers a bit on rotation like in that commercial 3D Helicopter game..I forget that name of it but the ground isnt still there, too.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80184 - NEiM0D - Wed Apr 19, 2006 6:39 pm</h4>
    <div class="postbody"><span class="postbody">Those workarounds don't do the quality good when you do have perfect texture display.
<br/>
<br/>
I'm still a firm believer that this is just a mathematical problem and it should certainly be possible to solve it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80193 - dovoto - Wed Apr 19, 2006 9:50 pm</h4>
    <div class="postbody"><span class="postbody">Could you perhaps take ecurtz/gladius idea and use the texture matrix to shift the texture verticaly (you have a bit more bit depth using the matrix vs the coordinates iirc) in proportion to the angle of rotation?<br/>_________________<br/><a href="http://www.drunkencoders.com" target="_blank">www.drunkencoders.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80194 - gladius - Wed Apr 19, 2006 9:55 pm</h4>
    <div class="postbody"><span class="postbody">Doh, for my method #2, you shouldn't divide the offset by 2.  Perhaps try that?  I'll give this a shot sometime today or later on this week.  Can you post your source?  I don't mind writing up my own little texture example if neccesary, but no need to overwork myself ;).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80201 - NEiM0D - Wed Apr 19, 2006 11:02 pm</h4>
    <div class="postbody"><span class="postbody">This code is for my own custom library I have written for DS. Should be possible to convert this to libnds.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;ds_types.h&gt;
<br/>
#include &lt;ds_io.h&gt;
<br/>
#include &lt;ds_g2d.h&gt;
<br/>
#include &lt;ds_g3d.h&gt;
<br/>
#include &lt;ds_pm.h&gt;
<br/>
#include &lt;ds_debug.h&gt;
<br/>
#include &lt;ds_sys.h&gt;
<br/>
#include &lt;ds_pad.h&gt;
<br/>
#include &lt;ds_irq.h&gt;
<br/>
#include &lt;ds_swi.h&gt;
<br/>
#include &lt;ds_card.h&gt;
<br/>
#include &lt;ds_dma.h&gt;
<br/>
#include &lt;ds_ipc.h&gt;
<br/>
#include &lt;ds_rtc.h&gt;
<br/>
#include &lt;ds_math.h&gt;
<br/>
<br/>
<br/>
void VBlankVector(void)
<br/>
{
<br/>
<br/>
}
<br/>
<br/>
extern u8 texgfx[16384];
<br/>
extern u16 texpal[256];
<br/>
<br/>
static int vtxtab[][2]=
<br/>
{
<br/>
   {-2048, -2048},
<br/>
   {-2048, 2048},
<br/>
   {2048, 2048},
<br/>
   {2048, -2048},
<br/>
};
<br/>
<br/>
static int textab[][2]=
<br/>
{
<br/>
   {0, 0},
<br/>
   {0, 512},
<br/>
   {512, 512},
<br/>
   {512, 0},
<br/>
};
<br/>
<br/>
<br/>
int main()
<br/>
{
<br/>
   int i,j;
<br/>
<br/>
<br/>
   // enable VRAM bank A, 128KB
<br/>
   void *VRAM_A = G2D_EnableVRAM_A(VRAM_A_BG_A, 0);
<br/>
   // enable VRAM bank C, 128KB
<br/>
   void *VRAM_C = G2D_EnableVRAM_C(VRAM_C_BG_B, 0);
<br/>
   // enable VRAM bank B, 128KB
<br/>
   void *VRAM_B = G2D_EnableVRAM_B(VRAM_B_BITMAP, 0);
<br/>
   // enable VRAM bank E, 64KB
<br/>
   void *VRAM_E = G2D_EnableVRAM_E(VRAM_E_BITMAP, 0);
<br/>
   
<br/>
   // copy textures to vram (only way to map textures to arm9)
<br/>
   SWI_CpuSet(texgfx, VRAM_B, CPUSET_MODE_WORD | CPUSET_MODE_COPY | (sizeof(texgfx)/4));   
<br/>
   SWI_CpuSet(texpal, VRAM_E, CPUSET_MODE_WORD | CPUSET_MODE_COPY | (sizeof(texpal)/4));
<br/>
<br/>
   G2D_EnableVRAM_B(VRAM_B_TEXIMG, 0);
<br/>
   G2D_EnableVRAM_E(VRAM_E_TEXPAL, 0);
<br/>
<br/>
<br/>
   // enable power to these devices (and engine A should be at top screen)
<br/>
   PM_Powerup(POWER_LCD | POWER_2D_ALL | POWER_3D_ALL | POWER_2D_A_TOP);
<br/>
<br/>
<br/>
   // init interrupts
<br/>
   IRQ_Init();
<br/>
   IPC_Init();
<br/>
<br/>
   // enable ipc fifo recv interrupt
<br/>
   IRQ_SetVector(IRQ_IPCRECV, IPC_RecvDispatcher, IRQ_SINGLE);
<br/>
   IRQ_Enable(IRQ_IPCRECV);
<br/>
<br/>
   // enable ipc fifo recv interrupt
<br/>
   IRQ_SetVector(IRQ_VBLANK, VBlankVector, IRQ_NESTED);
<br/>
   IRQ_Enable(IRQ_VBLANK);
<br/>
<br/>
   // enable arm9 access to the gba and ds slot
<br/>
   SYS_SetCartPriority(PROCESSOR_ARM9);
<br/>
   SYS_SetCardPriority(PROCESSOR_ARM9);
<br/>
<br/>
   // let ARM7 know cartridge right is set to ARM7.
<br/>
   IPC_SetState(0);
<br/>
   // wait for ARM7 ack...
<br/>
   IPC_Synchronize(0);
<br/>
<br/>
   REG_DISPCNT_A = A_DISPMODE_NORMAL | A_DISP_BG0_AS_3D | A_DISP_BG0;
<br/>
<br/>
   G3D_InitMatrixStack();
<br/>
   G3D_Viewport(0, 0, 255, 191);
<br/>
   G3D_ClearColor(makergb(01, 1, 1), 31, 0, CLEARIMAGE_FOG_OFF);
<br/>
   G3D_ClearDepth(0x7FFF);
<br/>
<br/>
   for(;;)
<br/>
   {
<br/>
<br/>
      REG_DISP3DCNT |= 1;
<br/>
<br/>
<br/>
      G3D_Reset();
<br/>
<br/>
      G3D_MatrixMode(MTX_PROJECTION);
<br/>
      G3D_LoadIdentity();
<br/>
<br/>
      static f32 zoom = makef32(32.0f);
<br/>
<br/>
      G3D_Ortho(makef32(0.0f), makef32(256.0f), makef32(192.0f), makef32(0.0f), makef32(-1024.0f), makef32( 1024.0f));
<br/>
<br/>
      G3D_MatrixMode(MTX_TEXTURE);
<br/>
      G3D_LoadIdentity();
<br/>
<br/>
      // Do rotation/scaling/translation of texture here
<br/>
      //G3D_RotateZInv(zrot)
<br/>
<br/>
      // Prepare current texture matrix for 3D engine
<br/>
      
<br/>
      m4x4 m;
<br/>
<br/>
      m[0][0] = makef32(1.0f);
<br/>
      m[0][1] = 0;
<br/>
      m[0][2] = 0;
<br/>
      m[0][3] = 0;
<br/>
<br/>
      m[1][0] = 0;
<br/>
      m[1][1] = makef32(1.0f);
<br/>
      m[1][2] = 0;
<br/>
      m[1][3] = 0;
<br/>
<br/>
      m[2][0] = 0;
<br/>
      m[2][1] = 0;
<br/>
      m[2][2] = makef32(16.0f);
<br/>
      m[2][3] = 0;
<br/>
<br/>
      m[3][0] = 0;
<br/>
      m[3][1] = 0;
<br/>
      m[3][2] = 0;
<br/>
      m[3][3] = makef32(16.0f);
<br/>
<br/>
      G3D_MatrixMultiply4x4(&amp;m);
<br/>
<br/>
      G3D_MatrixMode(MTX_POSITION);
<br/>
      G3D_LoadIdentity();
<br/>
<br/>
      static f32 xtrans = makef32(100.0f);
<br/>
      static f32 ytrans = makef32(60.0f);
<br/>
<br/>
      G3D_Translate(xtrans, ytrans, makef32(0.0f));
<br/>
<br/>
      G3D_RotateZ(zrot);
<br/>
      
<br/>
      G3D_Scale(zoom, zoom, makef32(1.0f));
<br/>
<br/>
      
<br/>
<br/>
      G3D_PolygonAttr(0, 31, RENDER_ALL, POLYMODE_MODULATION, POLYLIGHT_NONE, POLYATTR_NONE);
<br/>
      G3D_TexPalette(0);
<br/>
      G3D_TexImage(TEXSOURCE_COORD, TEXTRANS_PALETTE, TEXFORMAT_256COL, TEXWIDTH_128, TEXHEIGHT_128, TEXATTR_REPEAT_S | TEXATTR_REPEAT_T /*| TEXATTR_FLIP_S | TEXATTR_FLIP_T*/, 0);
<br/>
      G3D_Color(makergb(31, 31, 31));
<br/>
<br/>
      if (!(REG_KEY &amp; KEY_A))
<br/>
      {
<br/>
<br/>
         if (!(REG_KEY &amp; KEY_DOWN))
<br/>
            ytrans += makef32(1.0f);
<br/>
<br/>
         if (!(REG_KEY &amp; KEY_UP))
<br/>
            ytrans -= makef32(1.0f);
<br/>
<br/>
         if (!(REG_KEY &amp; KEY_LEFT))
<br/>
            xtrans -= makef32(1.0f);
<br/>
<br/>
         if (!(REG_KEY &amp; KEY_RIGHT))
<br/>
            xtrans += makef32(1.0f);
<br/>
<br/>
         if (!(REG_KEY &amp; KEY_START))
<br/>
            zoom += 4096;
<br/>
<br/>
         if (!(REG_KEY &amp; KEY_SELECT))
<br/>
            zoom -= 4096;
<br/>
<br/>
      }
<br/>
      else if (!(REG_KEY &amp; KEY_B))
<br/>
      {
<br/>
      } else
<br/>
      {
<br/>
      }
<br/>
<br/>
      if (!(REG_KEY &amp; KEY_L))
<br/>
         zrot++;
<br/>
      if (!(REG_KEY &amp; KEY_R))
<br/>
         zrot--;
<br/>
<br/>
      DEBUG("zrot = %d\r\n", zrot)
<br/>
<br/>
      G3D_Begin(POLY_QUADS);
<br/>
<br/>
      for(i=0; i&lt;4; i++)
<br/>
      {
<br/>
         G3D_TexCoord(textab[i][0], textab[i][1]);
<br/>
         G3D_Vertex(vtxtab[i][0], vtxtab[i][1], makef32( 0.0f));
<br/>
      }
<br/>
<br/>
      G3D_End();
<br/>
<br/>
<br/>
<br/>
      G3D_SwapBuffers(BUFFER_W, SORT_AUTO);
<br/>
<br/>
<br/>
      // wait for vblank
<br/>
      SWI_VBlankIntrWait();
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
As for the offsetting without the divide by 2, the result is semi-same again.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80202 - gladius - Wed Apr 19, 2006 11:14 pm</h4>
    <div class="postbody"><span class="postbody">Cool, thanks.  One thing I notice right off the bat is your viewport is using (0,0,255,191).  Try changing that to (0,0,256,192) and see if that makes a difference.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80204 - Dark Knight ez - Thu Apr 20, 2006 12:00 am</h4>
    <div class="postbody"><span class="postbody">Actually, that is correct. Most (if not all) NDS 3D programs have that.
<br/>
0 to 255 equals 256 (since you also count 0).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80214 - gladius - Thu Apr 20, 2006 1:35 am</h4>
    <div class="postbody"><span class="postbody">I realize that 0 is counted :).  I wanted to see what happened when it was changed to 256 to see if the hardware is interpolating from the top left of the first pixel to the top left of the last pixel on the scanline.  Or, instead if it was interpolating from the first pixel to one past the last pixel.  In which case 255 would be incorrect.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80226 - Payk - Thu Apr 20, 2006 6:36 am</h4>
    <div class="postbody"><span class="postbody">Hey another solucion...Like i said the gab disappears if the naighbour squares have same texture... So each glBind isnt good for "field" of squares... So easy solucion if u want to have one ground with different gfx and no gab:
<br/>
Use one texture including 16 textures. Then make for that square a function which uses only the wanted part of texture....
<br/>
For me it runs perfectly...my opinion is also that its a mathicaly problem. But that doesnt mean u cant work arround it hehehe.
<br/>
The hole ground in my projoect now doesnt have any gaps!! The ground looks like it should and doesnt flicker arround or something: Exactly like it should look like hehe fine for me...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150384 - TwentySeven - Sun Feb 03, 2008 3:32 pm</h4>
    <div class="postbody"><span class="postbody">I addressed exactly this in another post.. just trying to find it.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
