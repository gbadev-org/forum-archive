<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>double screen 3D & motion blur using display capture[sol - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > double screen 3D & motion blur using display capture[sol</h2>
<div id="posts">
<div class="post">
    <h4>#154410 - Noda - Tue Apr 15, 2008 8:51 pm</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
<br/>
since I already use the display capture to use 3D on both screens, I though this should be easy to add a motion blur effect just by blending the new display with the old one on each screen, using the display capture register.
<br/>
<br/>
I don't really know why, but it doesn't work (flickers like hell on DS, and no trace of blending).
<br/>
<br/>
Here's my config:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void setRegCapture(bool enable, uint8 srcBlend, uint8 destBlend, uint8 bank, uint8 offset, uint8 size, uint8 source, uint8 srcOffset)
<br/>
{
<br/>
   uint32 value = 0;
<br/>
   if (enable)
<br/>
      value |= 1 &lt;&lt; 31; // 31 is enable
<br/>
   value |= 3 &lt;&lt; 29; // 29-30 seems to have something to do with the blending
<br/>
   value |= (srcOffset &amp; 0x3) &lt;&lt; 26; // capture source offset is 26-27
<br/>
   value |= (source &amp; 0x3) &lt;&lt; 24; // capture source is 24-25
<br/>
   value |= (size &amp; 0x3) &lt;&lt; 20; // capture data write size is 20-21
<br/>
   value |= (offset &amp; 0x3) &lt;&lt; 18; // write offset is 18-19 
<br/>
   value |= (bank &amp; 0x3) &lt;&lt; 16; // vram bank select is 16-17 
<br/>
   value |= (srcBlend &amp; 0xFF) &lt;&lt; 8; // graphics blend evb is 8..12
<br/>
   value |= (destBlend &amp; 0xFF) &lt;&lt; 0; // ram blend EVA is bits 0..4 
<br/>
   
<br/>
   REG_CAPTURE = value;
<br/>
}
<br/>
<br/>
void endFrame()      {
<br/>
   if (ul_screenClippingChanged)
<br/>
      ulResetScreenClipping();
<br/>
<br/>
   if (ul_dualScreenMode)         {
<br/>
      if (ul_frameNumber &amp; 1)         {
<br/>
         vramSetBankC(VRAM_C_SUB_BG);
<br/>
         vramSetBankD(VRAM_D_LCD);
<br/>
         setRegCapture(true, 7, 8, 3, 0, 3, 0, 0);
<br/>
      }
<br/>
      else   {
<br/>
         vramSetBankC(VRAM_C_LCD);
<br/>
         vramSetBankD(VRAM_D_SUB_SPRITE);
<br/>
         setRegCapture(true, 7, 8, 2, 0, 3, 0, 0);
<br/>
      }
<br/>
      
<br/>
      lcdSwap();
<br/>
      dmaCopy(ulDualScreenSprites, OAM_SUB, 128 * sizeof(SpriteEntry));
<br/>
   }
<br/>
   ul_frameNumber++;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
The problem I think lies with the source A I'm trying to blend with. On gbatek, if it's set to 0 it said that the source is VRAM, but which one? the current one used for the capture (obviously)? 
<br/>
<br/>
And I don't really get from where the flicker comes: if source B blending is &lt; 15, the flickering occurs (seems like 1 frame on 2, screen is black).
<br/>
<br/>
Any idea?</span><span class="gensmall"><br/><br/>Last edited by Noda on Wed Apr 16, 2008 10:27 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#154445 - elhobbs - Wed Apr 16, 2008 1:29 pm</h4>
    <div class="postbody"><span class="postbody">is VRAM_C_SUB_BG and VRAM_D_SUB_SPRITE correct?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154450 - Noda - Wed Apr 16, 2008 3:18 pm</h4>
    <div class="postbody"><span class="postbody">Yes, as it displays the screens correctly when I don't try to blend.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154457 - elhobbs - Wed Apr 16, 2008 7:10 pm</h4>
    <div class="postbody"><span class="postbody">gbatek mentions that you need to use VRAM display mode for this to work. would you need to be alternating display mode each frame - MODE_FB2/MODE_FB3 each frame? source A is fairly easy to set, but source B is where I start to get confused reading the documentation.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154462 - Noda - Wed Apr 16, 2008 7:33 pm</h4>
    <div class="postbody"><span class="postbody">Yes, that's the problem, gbatek info is quite unclear on the source B of the blending. But the VRAM display mode thing is just to say that the VRAM must be LCD (writable) mode, which is done.
<br/>
<br/>
I remember having seen motion blur demos using the capture using in the past, but I can't find those threads (damn search engine :/).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154463 - Cydrak - Wed Apr 16, 2008 7:53 pm</h4>
    <div class="postbody"><span class="postbody">The capture source is different than the write offset. See the GBATEK capture notes: bits 27-26 hold the low half, while the high bits are in DISPLAY_CR:19-18 (yes, that's the display source!). This gives the full A..D range.
<br/>
<br/>
Once you've got this, there's another problem: REG_CAPTURE doesn't actually display anything! In a dual-screen setup, it doesn't matter since the render is unchanged. But for blur, the blend only goes to VRAM, and you won't see it on the main screen. This can flicker subtly as it swaps with the sub every frame. (The other, worse cause of flicker is probably the capture just failing, where the sub is black as you said.)
<br/>
<br/>
Like elhobbs said the easiest fix is framebuffer mode. The idea is, you don't show any rendering at all--it happens behind the scenes, but you just see the final blend. As it happens, display and capture share the same VRAM source mentioned above. Fortunately, for a blur that's exactly what you want.
<br/>
<br/>
Here's about what I'm using (minus DMA and debug checks for brevity, hopefully I didn't break it):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define dispSrcNone     0
<br/>
#define dispSrcLayers   ((u16*)1)
<br/>
#define capSize128x128  0
<br/>
#define capSize256x64   1
<br/>
#define capSize256x128  2
<br/>
#define capSize256x192  3
<br/>
#define capSrcNone      0
<br/>
#define capSrcLayers    1
<br/>
#define capSrc3D        2
<br/>
<br/>
void grSetDisplayTransfer(
<br/>
    u16* displaySrc, u16* writeTo, int writeSize,
<br/>
    int renderSrcA, u16* readSrcB, int evA, int evB)
<br/>
{
<br/>
    // Convert pointers - hw uses 32k steps from VRAM_A
<br/>
    int dispOffset  = (int)(displaySrc - VRAM_A) / 0x4000;
<br/>
    int writeOffset = (int)(writeTo - VRAM_A) / 0x4000;
<br/>
    int srcOffset   = (int)(memSrcB - VRAM_A) / 0x4000;
<br/>
    
<br/>
    // Determine the intended display source..
<br/>
    int dispMode = 0;  // None
<br/>
    if(displaySrc == dispSrcLayers)
<br/>
        dispMode = 1;  // 2D engine
<br/>
    else if(0 &lt;= dispOffset &amp;&amp; dispOffset &lt; 16)
<br/>
        dispMode = 2;  // VRAM (framebuffer)
<br/>
    
<br/>
    // And what was chosen to blend..
<br/>
    int blendMode = 2;
<br/>
    if(!readSrcB)    blendMode = 0, cfB = 0;
<br/>
    if(!renderSrcA) blendMode = 1, cfA = 0;
<br/>
    else renderSrcA--;  // we have 1/2, hw wants 0/1
<br/>
    
<br/>
    // More bit arrangement for Nintendo's charming hw.. :b
<br/>
    dispMode   |= (dispMode == 2 ? dispOffset : srcOffset) &amp; 0xc;
<br/>
    writeOffset = (writeOffset&lt;&lt;2 | writeOffset&gt;&gt;2) &amp; 0xf;
<br/>
    srcOffset  &amp;= 3;
<br/>
    
<br/>
    DISPLAY_CR = (DISPLAY_CR &amp; ~0xf0000) | dispMode&lt;&lt;16;
<br/>
    if(!writeTo) return;
<br/>
    
<br/>
    REG_DISPCAPCNT = DCAP_ENABLE | blendMode&lt;&lt;29 | srcOffset&lt;&lt;26 
<br/>
        | renderSrcA&lt;&lt;24 | writeSize&lt;&lt;20 | writeOffset&lt;&lt;16 | evB&lt;&lt;8 | evA;
<br/>
}
<br/>
<br/>
// Blur usage:
<br/>
grSetDisplayTransfer(VRAM_C, VRAM_C, capSize256x192, capSrcLayers, VRAM_C, 12, 4);
<br/>
<br/>
// Restore normal 2D/3D output:
<br/>
grSetDisplayTransfer(dispSrcLayers, 0, 0, 0, 0, 0, 0);</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154483 - Noda - Wed Apr 16, 2008 10:26 pm</h4>
    <div class="postbody"><span class="postbody">Thanks a lot, after little modifications it worked :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
