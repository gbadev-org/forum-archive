<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How avoid nasty gimbal lock for correct rotations? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > How avoid nasty gimbal lock for correct rotations?</h2>
<div id="posts">
<div class="post">
    <h4>#157852 - muKO - Fri May 30, 2008 6:43 pm</h4>
    <div class="postbody"><span class="postbody">Hi all,
<br/>
First things first, my name is muKO and I'm a new DS coder.
<br/>
I'm trying to implement a very basic 3D engine for my first DS game.
<br/>
It's a basic 3D puzzle game, based on cubes rotations (on all axis)...
<br/>
<br/>
Now to my BIG question: "How avoid nasty gimbal lock for correct rotations?"
<br/>
Even thought I've ported a Quaternion class to my engine I can't avoid that nasty Gimbal Lock error. And I can't understand where I'm wrong... or better how correctly use Quaternions...
<br/>
<br/>
I've cleaned my code a bit and here it is, ok it's a lot of code but I think the error is in the <span style="color: red">SceneGraph drawRecursive</span> method... Where is the error?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//------------------------------------------------------------------------------
<br/>
<br/>
/* includes */
<br/>
#include &lt;cmath&gt;
<br/>
#include &lt;cstdio&gt;
<br/>
#include &lt;cstdlib&gt;
<br/>
#include &lt;sstream&gt;
<br/>
#include &lt;string&gt;
<br/>
<br/>
#include &lt;nds.h&gt;
<br/>
<br/>
//------------------------------------------------------------------------------
<br/>
<br/>
/* defines */
<br/>
const float PI = 3.14159265358979323846f; // pi greco
<br/>
const float   EPSILON   = 0.005f; // error tolerance for check
<br/>
#define String std::string
<br/>
#define   DEGTORAD(x) ( ((x) * PI) / 180.0 ) // conversion from degree to radius
<br/>
#define   RADTODEG(x) ( ((x) * 180.0) / PI ) // conversion from radius to degree
<br/>
#define FLOAT_EQ(x, v) ( ((v) - EPSILON) &lt; (x) &amp;&amp; (x) &lt; ((v) + EPSILON) ) // float equality test with tollerance
<br/>
#define ZERO_CLAMP(x) ( (EPSILON &gt; fabs (x)) ? 0.0f : (x) ) // set float to 0 if within tolerance
<br/>
#define   SQR(x) ( (x) * (x) ) // square operation
<br/>
<br/>
//------------------------------------------------------------------------------
<br/>
class Vector3D
<br/>
{
<br/>
public:
<br/>
   Vector3D ( float xp = 0.0, float yp = 0.0, float zp = 0.0 ) : x (xp), y (yp), z (zp) { }
<br/>
<br/>
   Vector3D &amp; operator = ( const Vector3D &amp; vp )
<br/>
   {
<br/>
      x = vp.x, y = vp.y, z = vp.z;
<br/>
      return *this;
<br/>
   }
<br/>
<br/>
   Vector3D operator + ( const Vector3D &amp; vp )
<br/>
   {
<br/>
      return Vector3D (x+vp.x, y+vp.y, z+vp.z);
<br/>
   }
<br/>
<br/>
   Vector3D operator - ( const Vector3D &amp; vp )
<br/>
   {
<br/>
      return Vector3D (x-vp.x, y-vp.y, z-vp.z);
<br/>
   }
<br/>
<br/>
   float getLength ( void )
<br/>
   {
<br/>
      return (sqrt (SQR (x) + SQR (y) + SQR (z)));
<br/>
   }
<br/>
<br/>
   float normalize ( void )
<br/>
   {
<br/>
      float length = getLength ();
<br/>
<br/>
      if (FLOAT_EQ (0.0f, length)) // if length is zero
<br/>
      {
<br/>
         x =   0.0f;
<br/>
         y =   0.0f;
<br/>
         z =   0.0f;
<br/>
      }
<br/>
      else // normalize
<br/>
      {
<br/>
         x = x / length;
<br/>
         y = y / length;
<br/>
         z = z / length;
<br/>
<br/>
         zeroClamp ();
<br/>
      }
<br/>
<br/>
      return length;
<br/>
   }
<br/>
<br/>
   void zeroClamp ( void )
<br/>
   {
<br/>
      x = ZERO_CLAMP (x);
<br/>
      y = ZERO_CLAMP (y);
<br/>
      z = ZERO_CLAMP (z);
<br/>
   }
<br/>
<br/>
   bool isNormalized ( void )
<br/>
   {
<br/>
      return (FLOAT_EQ (1.0f, getLength ()) == true);
<br/>
   }
<br/>
<br/>
   String toString ( void )
<br/>
   {
<br/>
      std::ostringstream oss;
<br/>
      oss &lt;&lt; "x = " &lt;&lt; x &lt;&lt; " u, y = " &lt;&lt; y &lt;&lt; " u, z = " &lt;&lt; z &lt;&lt; " u";
<br/>
      return oss.str ();
<br/>
   }
<br/>
<br/>
public:
<br/>
   float x; // in units
<br/>
   float y; // in units
<br/>
   float z; // in units
<br/>
};
<br/>
   
<br/>
//------------------------------------------------------------------------------
<br/>
class Quaternion
<br/>
{
<br/>
public:
<br/>
   Quaternion ( float wp = 1.0, float xp = 0.0, float yp = 0.0, float zp = 0.0 ) : w (wp), x (xp), y (yp), z (zp) { }
<br/>
<br/>
   Quaternion &amp; operator = ( const Quaternion &amp; qp )
<br/>
   {
<br/>
      w = qp.w, x = qp.x, y = qp.y, z = qp.z;
<br/>
      return *this;
<br/>
   }
<br/>
<br/>
   Quaternion operator * ( const Quaternion &amp; q )
<br/>
   {
<br/>
      Quaternion res;
<br/>
<br/>
      res.x = w * q.x + x * q.w + y * q.z - z * q.y;
<br/>
      res.y = w * q.y + y * q.w + z * q.x - x * q.z;
<br/>
      res.z = w * q.z + z * q.w + x * q.y - y * q.x;
<br/>
      res.w = w * q.w - x * q.x - y * q.y - z * q.z;
<br/>
<br/>
      // make sure the resulting quaternion is a unit quat.
<br/>
      res.normalize ();
<br/>
<br/>
      return res;
<br/>
   }
<br/>
<br/>
   float getLength ( void )
<br/>
   {
<br/>
      return (sqrt (SQR (x) + SQR (y) + SQR (z) + SQR (w)));
<br/>
   }
<br/>
<br/>
   void normalize ( void )
<br/>
   {
<br/>
      float dist, square;
<br/>
<br/>
      square = SQR (x) + SQR (y) + SQR (z) + SQR (w);
<br/>
      
<br/>
      if (square &gt; 0.0)
<br/>
         dist = (float)(1.0 / sqrt (square));
<br/>
      else dist = 1;
<br/>
<br/>
      x *= dist;
<br/>
      y *= dist;
<br/>
      z *= dist;
<br/>
      w *= dist;
<br/>
   }
<br/>
<br/>
   m4x4 toMatrix ( void )
<br/>
   {
<br/>
      m4x4 matrix;
<br/>
      float wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;
<br/>
<br/>
      x2 = x + x; y2 = y + y; z2 = z + z;
<br/>
      xx = x * x2;   xy = x * y2;   xz = x * z2;
<br/>
      yy = y * y2;   yz = y * z2;   zz = z * z2;
<br/>
      wx = w * x2;   wy = w * y2;   wz = w * z2;
<br/>
<br/>
      matrix.m[0] = floattof32(1.0 - (yy + zz));
<br/>
      matrix.m[1] = floattof32(xy - wz);
<br/>
      matrix.m[2] = floattof32(xz + wy);
<br/>
      matrix.m[3] = floattof32(0.0);
<br/>
<br/>
      matrix.m[4] = floattof32(xy + wz);
<br/>
      matrix.m[5] = floattof32(1.0 - (xx + zz));
<br/>
      matrix.m[6] = floattof32(yz - wx);
<br/>
      matrix.m[7] = floattof32(0.0);
<br/>
<br/>
      matrix.m[8] = floattof32(xz - wy);
<br/>
      matrix.m[9] = floattof32(yz + wx);
<br/>
      matrix.m[10] = floattof32(1.0 - (xx + yy));
<br/>
      matrix.m[11] = floattof32(0.0);
<br/>
<br/>
      matrix.m[12] = floattof32(0);
<br/>
      matrix.m[13] = floattof32(0);
<br/>
      matrix.m[14] = floattof32(0);
<br/>
      matrix.m[15] = floattof32(1);
<br/>
<br/>
      return matrix;
<br/>
   }
<br/>
<br/>
   void eulerToQuat ( float xp, float yp, float zp )
<br/>
   {
<br/>
      float ex, ey, ez; // temp half euler angles
<br/>
      float cr, cp, cy, sr, sp, sy, cpcy, spsy; // temp vars in roll, pitch and yaw
<br/>
<br/>
      ex = DEGTORAD (xp) / 2.0; // convert to rads and half them
<br/>
      ey = DEGTORAD (yp) / 2.0;
<br/>
      ez = DEGTORAD (zp) / 2.0;
<br/>
<br/>
      cr = cos(ex);
<br/>
      cp = cos(ey);
<br/>
      cy = cos(ez);
<br/>
<br/>
      sr = sin(ex);
<br/>
      sp = sin(ey);
<br/>
      sy = sin(ez);
<br/>
      
<br/>
      cpcy = cp * cy;
<br/>
      spsy = sp * sy;
<br/>
<br/>
      this-&gt;w = cr * cpcy + sr * spsy;
<br/>
      this-&gt;x = sr * cpcy - cr * spsy;
<br/>
      this-&gt;y = cr * sp * cy + sr * cp * sy;
<br/>
      this-&gt;z = cr * cp * sy - sr * sp * cy;
<br/>
   }
<br/>
<br/>
   String toString ( void )
<br/>
   {
<br/>
      std::ostringstream oss;
<br/>
      oss &lt;&lt; "w = " &lt;&lt; w &lt;&lt; " u,\n x = " &lt;&lt; x &lt;&lt; " u,\n y = " &lt;&lt; y &lt;&lt; " u,\n z = " &lt;&lt; z &lt;&lt; " u\n";
<br/>
      return oss.str ();
<br/>
   }
<br/>
<br/>
public:
<br/>
   float w;
<br/>
   float x;
<br/>
   float y;
<br/>
   float z;
<br/>
};
<br/>
   
<br/>
//------------------------------------------------------------------------------
<br/>
class SceneNode
<br/>
{
<br/>
public:
<br/>
   SceneNode ( String idp, Vector3D posp = Vector3D (0, 0, 0), Vector3D rotp = Vector3D (0, 0, 0) )
<br/>
      : id (idp), pos (posp), rot (rotp), father (NULL), brother (NULL), child (NULL) {
<br/>
   }
<br/>
   virtual ~SceneNode ( void ) { }
<br/>
<br/>
   virtual bool update ( int timeCount ) { return true; }
<br/>
   virtual void draw ( void ) { }
<br/>
<br/>
   SceneNode * getFather ( void ) { return father; }
<br/>
   SceneNode * getBrother ( void ) { return brother; }
<br/>
   SceneNode * getChild ( void ) { return child; }
<br/>
   bool hasFather ( void ) { return father != NULL; }
<br/>
   bool hasBrother ( void ) { return brother != NULL; }
<br/>
   bool hasChild ( void ) { return child != NULL; }
<br/>
<br/>
   bool addChild ( SceneNode * child )
<br/>
   {
<br/>
      if (child == NULL)
<br/>
         return false;
<br/>
      if (child-&gt;hasFather () == true)
<br/>
         return false;
<br/>
      if (child-&gt;hasBrother () == true)
<br/>
         return false;
<br/>
<br/>
      if (this-&gt;hasChild () == false)
<br/>
      {
<br/>
         this-&gt;setChild (child);
<br/>
         child-&gt;setFather (this);
<br/>
      }
<br/>
      else
<br/>
      {
<br/>
         SceneNode* tmp = this-&gt;getChild ();
<br/>
         while (tmp-&gt;hasBrother () == true)
<br/>
            tmp = tmp-&gt;getBrother ();
<br/>
         tmp-&gt;setBrother (child);
<br/>
         child-&gt;setFather (this);
<br/>
      }
<br/>
      return true;
<br/>
   }
<br/>
<br/>
   bool deleteChildren ()
<br/>
   {
<br/>
      bool result = deleteChildrenRecursive (this-&gt;getChild ());
<br/>
      this-&gt;setChild (NULL);
<br/>
      return result;
<br/>
   }
<br/>
private:
<br/>
   bool deleteChildrenRecursive (SceneNode* node)
<br/>
   {
<br/>
      if (node==NULL)
<br/>
         return true;
<br/>
<br/>
      if (node-&gt;hasChild () == true)
<br/>
         if (deleteChildrenRecursive (node-&gt;getChild ()) == false)
<br/>
            return true;
<br/>
<br/>
      if(node-&gt;hasBrother () == true)
<br/>
         if (deleteChildrenRecursive (node-&gt;getBrother ()) == false)
<br/>
            return true;
<br/>
<br/>
      delete node;
<br/>
      return true;
<br/>
   }
<br/>
   
<br/>
public:
<br/>
   const String id;
<br/>
   Vector3D pos; // contains OBJECT translations
<br/>
   Vector3D rot; // contains OBJECT rotations in eurelian angles
<br/>
<br/>
private:
<br/>
   void setFather (SceneNode* fatherp) { father = fatherp; }
<br/>
   void setBrother (SceneNode* brotherp) { brother = brotherp;}
<br/>
   void setChild (SceneNode* childp) { child = childp; }
<br/>
<br/>
   SceneNode* father;
<br/>
   SceneNode* brother;
<br/>
   SceneNode* child;
<br/>
};
<br/>
   
<br/>
//------------------------------------------------------------------------------
<br/>
class SceneGraph
<br/>
{
<br/>
public:
<br/>
   SceneGraph ( void )
<br/>
      : root (NULL)
<br/>
   {
<br/>
      root = new SceneNode ("root");
<br/>
   }
<br/>
<br/>
   ~SceneGraph ( void )
<br/>
   {
<br/>
      if (root != NULL)
<br/>
      {
<br/>
         clear ();
<br/>
         delete root;
<br/>
         root = NULL;
<br/>
      }
<br/>
   }
<br/>
<br/>
   bool clear ( void )
<br/>
   {
<br/>
      return root-&gt;deleteChildren ();
<br/>
   }
<br/>
<br/>
   bool update ( int timeCount )
<br/>
   {
<br/>
      return updateRecursive (root, timeCount);
<br/>
   }
<br/>
private:
<br/>
   bool updateRecursive ( SceneNode* node, int timeCount )
<br/>
   {
<br/>
      if (node == NULL)
<br/>
         return false;
<br/>
<br/>
      if (node-&gt;update (timeCount) == false)
<br/>
         return false;
<br/>
<br/>
      if (node-&gt;hasChild () == true)
<br/>
         if (updateRecursive (node-&gt;getChild (), timeCount) == false)
<br/>
            return false;
<br/>
<br/>
      if (node-&gt;hasBrother () == true)
<br/>
         if (updateRecursive (node-&gt;getBrother (), timeCount) == false)
<br/>
            return false;
<br/>
<br/>
      return true;
<br/>
   }
<br/>
<br/>
public:
<br/>
   void draw ( void )
<br/>
   {
<br/>
      drawRecursive (root);
<br/>
      return;
<br/>
   }
<br/>
private:
<br/>
   void drawRecursive (SceneNode* node)
<br/>
   {
<br/>
      if (node == NULL)
<br/>
         return;
<br/>
<br/>
      glPushMatrix ();
<br/>
<br/>
      // translations
<br/>
      glTranslatef (node-&gt;pos.x, node-&gt;pos.y, node-&gt;pos.z);
<br/>
<br/>
      // rotations
<br/>
      m4x4 mRotation;
<br/>
      Quaternion qRotation;
<br/>
<br/>
      qRotation.eulerToQuat (node-&gt;rot.x, node-&gt;rot.y, node-&gt;rot.z);
<br/>
      mRotation = qRotation.toMatrix ();
<br/>
      glMultMatrix4x4 (&amp;mRotation);
<br/>
<br/>
      // drawing
<br/>
      node-&gt;draw();
<br/>
<br/>
      if(node-&gt;hasChild()==true)
<br/>
         drawRecursive(node-&gt;getChild());
<br/>
<br/>
      glPopMatrix(1);
<br/>
<br/>
      if(node-&gt;hasBrother()==true)
<br/>
         drawRecursive(node-&gt;getBrother());
<br/>
   }
<br/>
<br/>
public:
<br/>
   SceneNode* root;
<br/>
};
<br/>
   
<br/>
//------------------------------------------------------------------------------
<br/>
class Cube : public SceneNode
<br/>
{
<br/>
public:
<br/>
   Cube(String idp, Vector3D posp = Vector3D(0, 0, 0), Vector3D rotp = Vector3D(0, 0, 0), float sidep = DEFAULT_SIDE)
<br/>
      : SceneNode(idp, posp, rotp), side(sidep) { }
<br/>
   virtual ~Cube(void) {}
<br/>
<br/>
   void draw(void)
<br/>
   {
<br/>
      float midSide = side / 2.0;
<br/>
<br/>
      // set the first outline color to white border color
<br/>
      glSetOutlineColor (0, RGB15 (50, 50, 50));
<br/>
      // set a poly ID for outlining
<br/>
      glPolyFmt (POLY_ALPHA (31) | POLY_CULL_BACK | POLY_ID (1));
<br/>
      // enable edge outlining
<br/>
      glEnable (GL_OUTLINE);
<br/>
<br/>
      glBegin (GL_QUADS);
<br/>
      {
<br/>
         // back face (blue)
<br/>
         glColor3f (0.0, 0.0, 1.0);
<br/>
         glVertex3f (-midSide, +midSide, -midSide);
<br/>
         glVertex3f (+midSide, +midSide, -midSide);
<br/>
         glVertex3f (+midSide, -midSide, -midSide);
<br/>
         glVertex3f (-midSide, -midSide, -midSide);
<br/>
<br/>
         // front face (green)
<br/>
         glColor3f (0.0, 1.0, 0.0);
<br/>
         glVertex3f (+midSide, -midSide, +midSide);
<br/>
         glVertex3f (+midSide, +midSide, +midSide);
<br/>
         glVertex3f (-midSide, +midSide, +midSide);
<br/>
         glVertex3f (-midSide, -midSide, +midSide);
<br/>
<br/>
         // left face (red)
<br/>
         glColor3f (1.0, 0.0, 0.0);
<br/>
         glVertex3f (-midSide, -midSide, +midSide);
<br/>
         glVertex3f (-midSide, +midSide, +midSide);
<br/>
         glVertex3f (-midSide, +midSide, -midSide);
<br/>
         glVertex3f (-midSide, -midSide, -midSide);
<br/>
<br/>
         // right face (yellow)
<br/>
         glColor3f (1.0, 1.0, 0.0);
<br/>
         glVertex3f (+midSide, +midSide, -midSide);
<br/>
         glVertex3f (+midSide, +midSide, +midSide);
<br/>
         glVertex3f (+midSide, -midSide, +midSide);
<br/>
         glVertex3f (+midSide, -midSide, -midSide);
<br/>
<br/>
         // bottom face (violet)
<br/>
         glColor3f (1.0, 0.0, 1.0);
<br/>
         glVertex3f (+midSide, -midSide, -midSide);
<br/>
         glVertex3f (+midSide, -midSide, +midSide);
<br/>
         glVertex3f (-midSide, -midSide, +midSide);
<br/>
         glVertex3f (-midSide, -midSide, -midSide);
<br/>
<br/>
         // top face (light blue)
<br/>
         glColor3f (0.0, 1.0, 1.0);
<br/>
         glVertex3f (-midSide, +midSide, +midSide);
<br/>
         glVertex3f (+midSide, +midSide, +midSide);
<br/>
         glVertex3f (+midSide, +midSide, -midSide);
<br/>
         glVertex3f (-midSide, +midSide, -midSide);
<br/>
      }
<br/>
      glEnd ();
<br/>
   }
<br/>
<br/>
public:
<br/>
   static const int DEFAULT_SIDE = 1;
<br/>
   float side;
<br/>
};
<br/>
   
<br/>
//---------------------------------------------------------------------------------
<br/>
void init(void)
<br/>
{
<br/>
   // enable the 3D core
<br/>
   powerON(POWER_3D_CORE | POWER_MATRIX);
<br/>
<br/>
   // put 3D (Main Screen) on bottom
<br/>
   lcdMainOnBottom();
<br/>
<br/>
   // setup the sub screen for basic printing
<br/>
   consoleDemoInit();
<br/>
<br/>
   // setup the Main screen for 3D
<br/>
   videoSetMode(MODE_6_3D /*| DISPLAY_BG3_ACTIVE*/);
<br/>
<br/>
   // set the first bank as background memory and the third as sub background memory
<br/>
   // B and D are not used
<br/>
   vramSetMainBanks(VRAM_A_MAIN_BG_0x06000000, VRAM_B_LCD, VRAM_C_SUB_BG , VRAM_D_LCD);
<br/>
<br/>
   // by default font will be rendered with color 255
<br/>
   BG_PALETTE_SUB[255] = RGB15(31,31,31);
<br/>
<br/>
   // IRQ basic setup
<br/>
   irqInit();
<br/>
   irqEnable(IRQ_VBLANK);
<br/>
<br/>
   // initialize gl
<br/>
   glInit();
<br/>
<br/>
   // enable antialiasing
<br/>
   glEnable(GL_ANTIALIAS);
<br/>
<br/>
   // setup the (trasparent) rear plane
<br/>
   glClearColor(0, 0, 0, 0); // BG is totally trasparent to allow 2D / 3D merging (should be opaque for AA to work)
<br/>
   glClearPolyID(63); // BG must have a unique polygon ID for AA to work
<br/>
   glClearDepth(0x7FFF);
<br/>
<br/>
   // set our view port to be the same size as the screen
<br/>
   glViewport(0, 0, 255, 191);
<br/>
}
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
int main(void)
<br/>
{
<br/>
   init ();
<br/>
<br/>
   // objects init
<br/>
   SceneGraph sceneGraph;
<br/>
   Cube * cube1;
<br/>
   Cube * cube2;
<br/>
   Cube * cube3;
<br/>
<br/>
   cube1 = new Cube("cube1", Vector3D(-2, 0, 0));
<br/>
   sceneGraph.root-&gt;addChild(cube1);
<br/>
<br/>
   cube2 = new Cube("cube2", Vector3D( 2, 0, 0));
<br/>
   sceneGraph.root-&gt;addChild(cube2);
<br/>
<br/>
   cube3 = new Cube("cube3", Vector3D( 0, -2, 0));
<br/>
   cube1-&gt;addChild(cube3);
<br/>
<br/>
   //change ortho vs perspective
<br/>
   glMatrixMode(GL_PROJECTION);
<br/>
   glLoadIdentity();
<br/>
   gluPerspective(70, 256.0 / 192.0, 0.1, 10);
<br/>
<br/>
   // main loop
<br/>
   while (1) {
<br/>
<br/>
      // handle input
<br/>
      scanKeys();
<br/>
      int held = keysHeld();
<br/>
      if( held &amp; KEY_LEFT) cube1-&gt;rot.y++;
<br/>
      if( held &amp; KEY_RIGHT) cube1-&gt;rot.y--;
<br/>
      if( held &amp; KEY_UP) cube1-&gt;rot.x++;
<br/>
      if( held &amp; KEY_DOWN) cube1-&gt;rot.x--;
<br/>
<br/>
      // Set the current matrix to be the model matrix
<br/>
      glMatrixMode(GL_MODELVIEW);
<br/>
      glLoadIdentity();
<br/>
<br/>
      // handle camera
<br/>
      glTranslatef(0, 0, -6);
<br/>
<br/>
      sceneGraph.draw();
<br/>
<br/>
      // console messages
<br/>
      consoleClear ();
<br/>
      printf("use directional pad to rotate...\n");
<br/>
      printf("rotate down 90 degrees and then rotate left and...\n");
<br/>
      printf("NASTY GIMBAL LOCK!\n");
<br/>
<br/>
      while (GFX_STATUS &amp; (1&lt;&lt;27)); // wait until the geometry engine is not busy
<br/>
<br/>
      // flush to the screen
<br/>
      glFlush(0);
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
P.S. I know it's not very optimized for a DS but for now I'm focusing on make it work! Any suggestion is welcome... 2 weeks are passed since I'm reading stuff about OpenGL rotations and gimbal lock... and gimbal lock is winning me... :(<span style="color: red"></span><span style="color: red"></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157857 - sajiimori - Fri May 30, 2008 11:23 pm</h4>
    <div class="postbody"><span class="postbody">Sticking with matrices will simplify things.  Quaternions can be seen as an optimization of matrices, and they're only faster in some cases (especially if you have to concatenate a lot of rotations in series).
<br/>
<br/>
Angles should only be used in very high-level code, e.g. a Character class that has a 'yaw' angle.  Angles should be "compiled down" to matrices before you get anywhere near rendering.
<br/>
<br/>
At any rate, converting Euler angles to matrices (or quaternions) doesn't make gimbal lock magically go away.  =)  If the lock happened before switching to matrices, you can't really fix it after the fact.
<br/>
<br/>
For cubes that rotate based on physics, don't use angles at all: use matrices top to bottom!  You might even be able to use the same matrix for rendering and physics.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157860 - silent_code - Fri May 30, 2008 11:56 pm</h4>
    <div class="postbody"><span class="postbody">this might help: <a class="postlink" href="http://www.sjbrown.co.uk/?article=quaternions" target="_blank">http://www.sjbrown.co.uk/?article=quaternions</a>
<br/>
<br/>
good luck and happy coding! :^)<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157868 - zeruda - Sat May 31, 2008 6:32 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
      qRotation.eulerToQuat (node-&gt;rot.x, node-&gt;rot.y, node-&gt;rot.z);
<br/>
      mRotation = qRotation.toMatrix ();
<br/>
      glMultMatrix4x4 (&amp;mRotation); </td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, here's your problem. You are doing your rotations as a Euler rotation. You are converting the euler rotation to quaternion, and from quaternion to matrix.  Neither of the last two had anything to do with rotation. Only the first one did, and that of course is subject to gimbal lock.
<br/>
<br/>
You could do something like as follows(with a few alterations).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">CMatrix4x4 InitialMatrix;
<br/>
<br/>
void AppendRotationToInitalMatrix(float CurrentRotation, CVector Axis)
<br/>
{
<br/>
    float CurrentRotation;
<br/>
    CMatrix4x4 AppendMatrix;
<br/>
    CQuaternion CurrentQuaternion;
<br/>
<br/>
    CurrentQuaternion.CreateFromAxisAngle(-CurrentRotation, Axis);
<br/>
    CurrentQuaternion.CreateMatrix(AppendMatrix.matrix);
<br/>
    InitialMatrix = AppendMatrix * InitialMatrix;
<br/>
}
<br/>
<br/>
CVector SetAxisToRotate(int i)
<br/>
{
<br/>
    CVector CurrentAxis;
<br/>
    if (i == 1) {
<br/>
        CurrentAxis = CVector(InitialMatrix.matrix[0], InitialMatrix.matrix[1], InitialMatrix.matrix[2]);
<br/>
    }
<br/>
    if (i == 2) {
<br/>
        CurrentAxis = CVector(InitialMatrix.matrix[4], InitialMatrix.matrix[5], InitialMatrix.matrix[6]);
<br/>
    }
<br/>
    if (i == 3) {
<br/>
        CurrentAxis = CVector(InitialMatrix.matrix[8], InitialMatrix.matrix[9], InitialMatrix.matrix[10]);
<br/>
    }
<br/>
    return CurrentAxis;
<br/>
}
<br/>
<br/>
void main ()
<br/>
{
<br/>
    while (1) {
<br/>
        int whichaxis = DoIWantXYorZAxis();
<br/>
        CVector Axis = SetAxisToRotate(whichaxis)
<br/>
        if( held &amp; KEY_LEFT) cube1-&gt;rot.y++;
<br/>
        AppendRotationToInitalMatrix(cube1-&gt;rot.y, Axis)
<br/>
        glMultMatrixf(InitialMatrix.matrix);
<br/>
        ...
<br/>
        ...
<br/>
        ...
<br/>
        Profit();
<br/>
    }
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
