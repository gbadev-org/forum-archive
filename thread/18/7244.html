<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Pixel-Perfect collisions? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Pixel-Perfect collisions?</h2>
<div id="posts">
<div class="post">
    <h4>#58232 - Extreme Coder - Fri Oct 21, 2005 8:31 pm</h4>
    <div class="postbody"><span class="postbody">I've been looking for a way to do pixel-perfect collisions on the ds(yeah I know, it wont be different from the pc), and this is what I've been able to get to:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
short int Collide(object1,object2) {
<br/>
<br/>
    int left1, left2, over_left;
<br/>
    int right1, right2, over_right;
<br/>
    int top1, top2, over_top;
<br/>
    int bottom1, bottom2, over_bottom;
<br/>
    int over_width, over_height;
<br/>
    int i, j;
<br/>
    unsigned char *pixel1, *pixel2;
<br/>
<br/>
    left1 = object1-&gt;x;
<br/>
    left2 = object2-&gt;x;
<br/>
    right1 = object1-&gt;x + object1-&gt;width;
<br/>
    right2 = object2-&gt;x + object2-&gt;width;
<br/>
    top1 = object1-&gt;y;
<br/>
    top2 = object2-&gt;y;
<br/>
    bottom1 = object1-&gt;y + object1-&gt;height;
<br/>
    bottom2 = object2-&gt;y + object2-&gt;height;
<br/>
<br/>
<br/>
    // Trivial rejections:
<br/>
    if (bottom1 &lt; top2) return(0);
<br/>
    if (top1 &gt; bottom2) return(0);
<br/>
  
<br/>
    if (right1 &lt; left2) return(0);
<br/>
    if (left1 &gt; right2) return(0);
<br/>
<br/>
<br/>
    // Ok, compute the rectangle of overlap:
<br/>
    if (bottom1 &gt; bottom2) over_bottom = bottom2;
<br/>
    else over_bottom = bottom1;
<br/>
 
<br/>
    if (top1 &lt; top2) over_top = top2;
<br/>
    else over_top = top1;
<br/>
<br/>
    if (right1 &gt; right2) over_right = right2;
<br/>
    else over_right = right1;
<br/>
<br/>
    if (left1 &lt; left2) over_left = left2;
<br/>
    else over_left = left1;
<br/>
<br/>
<br/>
    // Now compute starting offsets into both objects' bitmaps:
<br/>
    i = ((over_top - object1\1-&gt;y) * object1-&gt;width) + over_left;
<br/>
    pixel1 = object1-&gt;frames[object1-&gt;curr_frame] + i;
<br/>
<br/>
    j = ((over_top - object2-&gt;y) * object2-&gt;width) + over_left;
<br/>
    pixel2 = object2-&gt;frames[object2-&gt;curr_frame] + j;
<br/>
<br/>
  
<br/>
    // Now start scanning the whole rectangle of overlap,
<br/>
    // checking the corresponding pixel of each object's
<br/>
    // bitmap to see if they're both non-zero:
<br/>
<br/>
    for (i=0; i &lt; over_height; I++) {
<br/>
        for (j=0; j &lt; over_width; j++) {
<br/>
            if (*pixel1 != 0xFFFF) &amp;&amp; (*pixel2 != 0xFFFF) return(1);
<br/>
            pixel1++;
<br/>
            pixel2++;
<br/>
        }
<br/>
        pixel1 += (object1-&gt;width - over_width);
<br/>
        pixel2 += (object2-&gt;width - over_width);
<br/>
    }
<br/>
<br/>
    return(0);
<br/>
<br/>
};
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
So basically this is a for loop checking on the gfx data of both objects, to see if any other color other than transparent is colliding.
<br/>
<br/>
But, this is VERY cpu extensive, and even once or twice in the game loop, it could slow down the game heavily.
<br/>
Is there any other possible ways to detect collision detection? If not, how can this one be sped up?
<br/>
<br/>
Thanks in advance</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58235 - Mighty Max - Fri Oct 21, 2005 8:36 pm</h4>
    <div class="postbody"><span class="postbody">You could make 1bit map of the objects (transparent or not) and then logical and their values (shifted to match their relations to each other)
<br/>
<br/>
As soon as you get a value other then zero, you have a collision. This way you can check several pixels in one step by a simple &amp;.
<br/>
<br/>
<br/>
:edit:
<br/>
If you don't do it by pixel, i suggest defining surrounding lines, which you can then check to cross each other. Gauss made some nice n^3 complex algorithm for this :p
<br/>
<br/>
This howere does not detect objects that are complete covered by the second object.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58238 - tepples - Fri Oct 21, 2005 8:56 pm</h4>
    <div class="postbody"><span class="postbody">Go with multiple hitboxes on each sprite cel. These can be rectangles or circles, as those are easy to test against each other. You might want to make one for the head, one for the torso, one for the legs, and one for the attacking arm or leg; that's what 2D fighters seem to do.
<br/>
<br/>
What specifically did you need pixel-perfect collisions for? In many cases, pixel-perfect collisions are a bad idea for game design because things get caught on walls too easily.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58244 - alex - Fri Oct 21, 2005 9:15 pm</h4>
    <div class="postbody"><span class="postbody">More often than not, and especially in a portable platform, a simple bounding sphere or bounding box will do the job for collision detection.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58302 - Extreme Coder - Sat Oct 22, 2005 1:17 pm</h4>
    <div class="postbody"><span class="postbody">tepples &amp; alex:
<br/>
Well, I need pixel-perfect collisions for a game that really needs them, and wont work without it coughsoniccough
<br/>
<br/>
Mighty Max:
<br/>
Could you clarify a bit please?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58305 - Mighty Max - Sat Oct 22, 2005 1:33 pm</h4>
    <div class="postbody"><span class="postbody">yeah sure, (i think you mean the first one)
<br/>
<br/>
Lets say you got a 1bit map of the transparency. 0 for transparent, 1 for solid. 
<br/>
<br/>
For each line you have to check the collision. Within one line you can simply
<br/>
<br/>
object1-&gt;line[#] &amp; (object1-&gt;line[# + VerticalOffset] &lt;&lt; HorizontalOffset)
<br/>
<br/>
If it results in anything other then 0, you have at least one pixel collision.
<br/>
<br/>
The ARM however does only 32Bit bool operations, so you have to scale it to your needs (objectWidth). As they are bitwise, it is a simple linear thing.
<br/>
<br/>
As an example:
<br/>
<br/>
Object1 line is 011000000100000011111010001
<br/>
Object2 line is 000000000001111111100000000
<br/>
<br/>
Object1 is 3 pixels left to object 2, so you do
<br/>
<br/>
011000000100000011111010001 &amp; 
<br/>
(000000000001111111100000000&lt;&lt; 3)
<br/>
<br/>
= 011000000100000011111010001 
<br/>
&amp; 000000001111111100000000000
<br/>
<br/>
= 000000000100000000000000000
<br/>
<br/>
!=0 so there is a collision
<br/>
<br/>
In this example, we have checked 27 pixels in one iteration.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58321 - tepples - Sat Oct 22, 2005 5:28 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Extreme Coder wrote:</b></span></td> </tr> <tr> <td class="quote">tepples &amp; alex:
<br/>
Well, I need pixel-perfect collisions for a game that really needs them, and wont work without it coughsoniccough</td> </tr></table><span class="postbody">
<br/>
What kind of "sonic" are you talking about? <span style="font-style: italic">Sonic the Hedgehog 2</span> for Genesis uses horizontal extents: each 16x16 pixel metatile has 16 rows, with a left side and a right side. But it could also have been easily done by treating each tile as a line segment and treating the Blue One as a circle.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58547 - darkfader - Mon Oct 24, 2005 3:09 pm</h4>
    <div class="postbody"><span class="postbody">What about sub-pixel-perfect collisions? The display is just an aliased view of your game. The accuracy depends on the amount of CPU time you want to spend. You might want trade-offs on the DS.
<br/>
I once made a simple ballgame proto on GBC and had to make the ball bounce off square edges. This was fairly simple of course since the shapes were fixed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58564 - Extreme Coder - Mon Oct 24, 2005 5:01 pm</h4>
    <div class="postbody"><span class="postbody">Mighty Max:
<br/>
Ok thanks, I will try that:D
<br/>
<br/>
Tepples:
<br/>
I am guessing the Blue one is Sonic,right?;)
<br/>
The sonic one I'm planning would be a bit retro (genesis) style games (but 360 degree rotation, they didn't have enough hardware to do that in the Genesis in those days:-)) because the sonic games on them, IMO, were the best ones.
<br/>
<br/>
DarkFader:
<br/>
I think we need to get this one done first, then we may think about sub-pixel perfect collisions. Anyway, I don't think that many games here actually use sub-pixels(but I could be wrong).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58606 - tepples - Mon Oct 24, 2005 9:32 pm</h4>
    <div class="postbody"><span class="postbody">Yes, when you press Down+C, the blue circle is Sonic.
<br/>
<br/>
In general, the experience from writing geometric collision code will be more useful than the experience from writing pixel-based collision code, especially when you move to a 3D environment.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58618 - Extreme Coder - Mon Oct 24, 2005 10:22 pm</h4>
    <div class="postbody"><span class="postbody">Geometric collisions? You mean circles and all that stuff? I don't even know how to do that. :-)
<br/>
But, for the purpose of my game, circle collision routines, if faster than pixel-perfect ones, would be useful.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58619 - Mighty Max - Mon Oct 24, 2005 10:30 pm</h4>
    <div class="postbody"><span class="postbody">They are. a lot.
<br/>
<br/>
If you want to check for circle collisions, just test if
<br/>
<br/>
((opject1.centerx-object2.centerx)^2) + ((object1.centery-object2.centery)^2) is less or equal to (radius1+radius2)^2<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58624 - tepples - Mon Oct 24, 2005 11:03 pm</h4>
    <div class="postbody"><span class="postbody">Mighty Max's explanation of circle to circle overlap testing is correct, but make sure to use integer or fixed-point math rather than the pow() function.
<br/>
<br/>
Circle to line segment overlap testing goes roughly like the following steps. None of this requires any division or square roots if implemented correctly (all endpoints and normal vectors stored as fixed-point numbers). <ol type="1"><li>Trivial rejection: First check if the circle is anywhere near the line segment. In a Sonic 2 style engine, you'll typically have a line segment for each 16x16 pixel ground tile; only those segments that correspond to tiles that the player's bounding box is overlapping need to be tested. </li><li>Normal line: Construct perpendicular lines to the segment through each endpoint. This divides the plane into three regions: points behind endpoint A's line, points behind endpoint B's line, and points between the lines. </li><li>If the center of the circle is "behind" an endpoint, check that circle against that endpoint and stop. </li><li>If the center of the circle is "between" the endpoints, calculate the distance from the line to the circle along the line segment's normal vector, which involves a dot product. </li></ol>
<br/>
A diagram would help you understand this, but I'm busy helping other people right now.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58746 - Extreme Coder - Tue Oct 25, 2005 7:13 pm</h4>
    <div class="postbody"><span class="postbody">But then the circle won't collide with anything but a straight line,right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58748 - tepples - Tue Oct 25, 2005 7:43 pm</h4>
    <div class="postbody"><span class="postbody">True, but if you build your map out of tiles and you associate a line segment with each tile...<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58751 - DekuTree64 - Tue Oct 25, 2005 7:58 pm</h4>
    <div class="postbody"><span class="postbody">Or use a circle-box check for the usually more common square tiles. Here's an easy one, which will also deal with a circle contained entirely by the box:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define CLAMP(val, min, max) \
<br/>
    ( ((val) &lt; (min) ? (min)) : \
<br/>
        ((val) &gt; (max) ? (max) : (val)) )
<br/>
<br/>
#define SQUARED(val) ((val) * (val))
<br/>
// mod note: calling it SQR will invite confusion between squared and square root
<br/>
<br/>
BOOL collideCircleBox(CIRCLE *circle, BOX *box)
<br/>
{
<br/>
    VECTOR2 closestPointOnBox;
<br/>
<br/>
    closestPointOnBox.x = CLAMP(circle-&gt;x, box-&gt;left, box-&gt;right);
<br/>
    closestPointOnBox.y = CLAMP(circle-&gt;y, box-&gt;top, box-&gt;bottom);
<br/>
<br/>
    if (SQUARED(closestPointOnBox.x) + SQUARED(closestPointOnBox.y) &lt; 
<br/>
        SQUARED(circle-&gt;radius))
<br/>
    {
<br/>
        return TRUE;
<br/>
    }
<br/>
    else
<br/>
    {
<br/>
        return FALSE;
<br/>
    }
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58806 - cybereality - Wed Oct 26, 2005 5:43 am</h4>
    <div class="postbody"><span class="postbody">Pixel-perfect collision isn't necessary for games at all. The only place I can think of that they would need this is for industrial prototyping (like crashing a car in a 3d computer simulation). For games, all you have to do is make the world believable, not physically accurate. Even games that pride themselves on the physics like HalfLife2 don't use pixel perfect collisions. They use simple hit boxes to register collisions (i.e. a box for the head, chest, arm, etc.). 
<br/>
<br/>
   Most 2D games will suffice with simply a hit box around the character. An easy way to do this is the treat the player as a point along the floor with a range the extends above and behind that point. You would need to define a playerX and playerY position value and also a playerHeight and playerWidth (uses as bounds for the hit box). Do a simple check to see if the player is anywhere close to the other object (enemy, wall, powerup, etc.) and if so check to see if their hit boxes overlap. Then do whatever it is happens (player loses life, stop movement, trigger event, etc.).  The same idea can be applied to circular collision instead you use the radius to check if the circles collide.<br/>_________________<br/><a class="postlink" href="http://www.cybereality.com" target="_blank">// cybereality</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58815 - Extreme Coder - Wed Oct 26, 2005 11:36 am</h4>
    <div class="postbody"><span class="postbody">cybereality:
<br/>
Well, you're almost correct. Most games do not need perfect-pixel collisions. But, there are a FEW cases in which they are needed. And sonic is one of those cases.
<br/>
<br/>
Tepples:
<br/>
Tepples, I will try looking into that , even though I would need lots of lines for one tile(slopes &amp; stuff).But won't that be CPU extensive?
<br/>
You seem to know everything about Sonic the Hedgehog 2:D
<br/>
<br/>
DekuTree64:
<br/>
I will try that today.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58822 - tepples - Wed Oct 26, 2005 2:57 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Extreme Coder wrote:</b></span></td> </tr> <tr> <td class="quote">Tepples, I will try looking into that , even though I would need lots of lines for one tile(slopes &amp; stuff).But won't that be CPU extensive?</td> </tr></table><span class="postbody">
<br/>
Do you need more than one slope for one 16x16 pixel tile? Or by "tile" do you mean the 128x128 pixel metatiles used in the compressed map?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">You seem to know everything about Sonic the Hedgehog 2:D</td> </tr></table><span class="postbody">
<br/>
I learned everything I know from a Sonic hacking site that may have since disappeared from the internets.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58842 - Extreme Coder - Wed Oct 26, 2005 6:04 pm</h4>
    <div class="postbody"><span class="postbody">By tile, I mean a 16x16 pixel tile.In some sonic games,slopes are not made of straight lines, like this: <a href="http://dual-soft.com/auds/slope.PNG">[Images not permitted - Click here to view it]</a>
<br/>
Seems you are a sonic fan.[/img]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58848 - M3d10n - Wed Oct 26, 2005 6:51 pm</h4>
    <div class="postbody"><span class="postbody">You don't need per-pixel collision checks for that. That is a slope, but it's just not a line.
<br/>
<br/>
You can represent different tiles like that as functions, where the tile height (Y) varies along the X coordinate. A straight 45? slope is just a plain line function. Of course, the function results can be stored in lookup tables for faster access. 
<br/>
<br/>
That way you can cast rays against the tiles, and by doing so, being able to make a moving object stop properly at a given tile no matter how fast it was traveling. It's also possible to figure out the normal at a given tile point, and bounce/slide the object along it.
<br/>
<br/>
Also, keep in mind that the Sonic games didn't quite have actual physics. Everything was mostly done by finite state machines, with state changes happenning when Sonic touches certain tiles.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#58894 - tepples - Thu Oct 27, 2005 12:27 am</h4>
    <div class="postbody"><span class="postbody">Specifically, I was referring to a piecewise linear approximation of the curved surface you use as an example:
<br/>
<br/>
<a class="postlink" href="http://pinocchio.jk0.org/gbaforum/slope.png" target="_blank">image: piecewise linear</a>
<br/>
Part 1 is the image you gave me, with a curved platform. Part 2 is the image with 16x16 tile boundaries marked. Part 3 is the image with tile boundaries, plus a linear approximation of the curve in each tile. Part 4 is just the tiles and line segments, as the collision engine would see them.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65881 - Ultima2876 - Fri Jan 06, 2006 2:39 pm</h4>
    <div class="postbody"><span class="postbody">Sonic 2 uses bounding boxes for object-object collisions. The floors don't use horizontal height-maps - they use vertical height maps (I wrote an editor for them a while back).
<br/>
<br/>
Sonic is treated as a geometric circle throughout the game, and to work out curves and resistance for his motion two points are stored for each tile which form a line - a vector. 
<br/>
<br/>
If you're interested, they use perfect circles (and sinewaves) for the paths in Sonic 3K's Death Egg. They yellow "tracker" paths =P
<br/>
<br/>
And no physics? No, Sonic has a physics engine - they use "state machines" for the movement routines sonic should be executing (jump after spindash, jump, roll, normal), but they don't use state machines to hardcode every tile. 
<br/>
<br/>
If you want an almost complete description of sonic's collision engine, see if you can find Dr Ivo's document on it. Last time I saw it was back at Area 51 last year sometime. Or of course you can dig around in a disassembly, but some stuff is pretty difficult to figure out (especially in Sonic 3/K).
<br/>
<br/>
And tepples; was that site Nemesis' one?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65930 - Dwedit - Fri Jan 06, 2006 9:16 pm</h4>
    <div class="postbody"><span class="postbody">Actually, pixel perfect collision is necessary if you are cloning an atari 2600 game which used that hardware feature.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65982 - tepples - Sat Jan 07, 2006 8:26 am</h4>
    <div class="postbody"><span class="postbody">But then the Atari 2600 just had two sprites, two rectangular missiles, a background, and a background missile. Games built around those limitations are generally simple enough that you can do exhaustive pixel-perfect collision on all 15 pairs without slowdown.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
