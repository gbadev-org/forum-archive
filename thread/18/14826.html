<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>swiCopy problem? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > swiCopy problem?</h2>
<div id="posts">
<div class="post">
    <h4>#148839 - JanoSicek - Fri Jan 11, 2008 1:40 am</h4>
    <div class="postbody"><span class="postbody">I just ran into a problem with swiCopy of big block of tiles from MAIN ram to VRAM
<br/>
<br/>
I wanted to copy 64kB, that is 16384 words to copy
<br/>
<br/>
However the copying always stopped at 48kB boundary, which is exactly between two VRAM banks. 
<br/>
<br/>
Memcpy was glitchy too.
<br/>
<br/>
I ended copying it in small 64B blocks....
<br/>
<br/>
Am I doing something wrong or is this behavior known?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148856 - simonjhall - Fri Jan 11, 2008 11:06 am</h4>
    <div class="postbody"><span class="postbody">When the banks are mapped into memory are they 'next' to each other in the address space? Is there a gap between the two blocks? Cos if there is then there's no way a single copy call is going to work :-D
<br/>
<br/>
Anyway the reason you're getting problems with memcpy is probably because it's copying the data one byte at a time yet you can only write data to that memory in 16- or 32-bit quantities. Just use a for loop that moves data in short quantities. Avoid DMA copies until you've gotten it working with the boring C copy and are aware of the implications of using DMA.
<br/>
<br/>
Peace.<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148859 - nipil - Fri Jan 11, 2008 1:59 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">Anyway the reason you're getting problems with memcpy is probably because it's copying the data one byte at a time yet you can only write data to that memory in 16- or 32-bit quantities. Just use a for loop that moves data in short quantities. Avoid DMA copies until you've gotten it working with the boring C copy and are aware of the implications of using DMA.</td> </tr></table><span class="postbody">
<br/>
<br/>
Just a remark : it's not because memcpy specifies the data length bytes that memcpy actually copies data one byte at a time. It's perfectly doable to copy most of it via 4-bytes access, and the remaining using either 2+1 or 3x1 as needed. AFAIK i <span style="font-style: italic">never </span>had any problem with memcpy, whatever the size, alignement and whether it be VRAM or not ;)
<br/>
<br/>
Second remark about memcpy/for-loop/dma/swiFastCopy : the update at the end of <a class="postlink" href="http://www.tobw.net/dswiki/index.php?title=How_to_clear_the_screen_really_fast" target="_blank">this wiki entry</a> just shows memcpy is the fastest. And for-loop the slowest... Besides, you can't implement a memcpy the wrong way ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148860 - JanoSicek - Fri Jan 11, 2008 2:50 pm</h4>
    <div class="postbody"><span class="postbody">How does swiCopy work? Is it the same as DMA copy?
<br/>
I know about some problems with DMA copy, so I try to avoid it until necessary. In my results the swiCopy produced fastest output, faster than memcpy...
<br/>
<br/>
VRAM banks are mapped next to each other
<br/>
VRAM A and VRAM D, where D has offset 6020000</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148874 - eKid - Fri Jan 11, 2008 5:03 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>JanoSicek wrote:</b></span></td> </tr> <tr> <td class="quote">How does swiCopy work? Is it the same as DMA copy? </td> </tr></table><span class="postbody">
<br/>
swiCopy is a function to call the 'CpuSet' function in the BIOS. It doesn't use DMA.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>JanoSicek wrote:</b></span></td> </tr> <tr> <td class="quote">However the copying always stopped at 48kB boundary, which is exactly between two VRAM banks.</td> </tr></table><span class="postbody">
<br/>
How are you using swiCopy? It should be able to copy way more than 48kB (gbatek says 20-bit word count).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148877 - JanoSicek - Fri Jan 11, 2008 5:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>eKid wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>JanoSicek wrote:</b></span></td> </tr> <tr> <td class="quote">How does swiCopy work? Is it the same as DMA copy? </td> </tr></table><span class="postbody">
<br/>
swiCopy is a function to call the 'CpuSet' function in the BIOS. It doesn't use DMA.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>JanoSicek wrote:</b></span></td> </tr> <tr> <td class="quote">However the copying always stopped at 48kB boundary, which is exactly between two VRAM banks.</td> </tr></table><span class="postbody">
<br/>
How are you using swiCopy? It should be able to copy way more than 48kB (gbatek says 20-bit word count).</span></td> </tr></table><span class="postbody">
<br/>
<br/>
bg-&gt;vramoffset=(u16*)(BG_TILE_RAM(tilebase));
<br/>
swiCopy((void*)ptiles,(void*)bg-&gt;vramoffset,16384);  //i tried 32768 or 65536, neither did work
<br/>
<br/>
like this
<br/>
when i copy to tilebase 5, which should cover bases 5,6,7 and 8
<br/>
the tiles in base 8 are blank
<br/>
<br/>
later when i copy tiles there one by one, they work, so bank 8 is mapped 
<br/>
<br/>
<br/>
vramSetBankA(VRAM_A_MAIN_BG); 
<br/>
	vramSetBankB(VRAM_B_MAIN_SPRITE_0x06420000);
<br/>
	vramSetBankC(VRAM_C_SUB_BG);
<br/>
	vramSetBankD(VRAM_D_MAIN_BG_0x06020000);</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148953 - simonjhall - Sat Jan 12, 2008 2:02 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>nipil wrote:</b></span></td> </tr> <tr> <td class="quote">Just a remark : it's not because memcpy specifies the data length bytes that memcpy actually copies data one byte at a time. It's perfectly doable to copy most of it via 4-bytes access, and the remaining using either 2+1 or 3x1 as needed.</td> </tr></table><span class="postbody">That only works if the alignments match. Assuming the 'bulk' of the copy is done with 32-bit writes (seems likely) then it will only be able to use this fast path if both addresses have the same 32-bit alignment. If not, a byte copy normally gets used instead.
<br/>
<br/>
eg,</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">memcpy((void* )0x200000, (void *)0x300000, 12345)</td> </tr></table><span class="postbody">will do the bulk with 32-bit writes but </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">memcpy((void* )0x200001, (void *)0x300000, 12345)</td> </tr></table><span class="postbody"> will normally be done completely with byte writes in the absense of any byte-rearranging instructions.
<br/>
finally </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">memcpy((void* )0x200001, (void *)0x300001, 12345)</td> </tr></table><span class="postbody"> will normally be done with the fast path, since both addresses have the same alignment.<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148964 - Cearn - Sat Jan 12, 2008 6:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
finally <table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">memcpy((void* )0x200001, (void *)0x300001, 12345)</td> </tr></table><span class="postbody"> will normally be done with the fast path, since both addresses have the same alignment.</span></td> </tr></table><span class="postbody">This last part unfortunately isn't true. At least not with the memcpy() found in devkitARM. DKA's memcpy() will use the faster way under two conditions:
<br/>
<ul><li>If the size is higher or equal to 16
<br/>
</li><li>If <span style="font-style: italic">both</span> the source and destination are word-aligned. The actual test used is (((u32)src | (u32)dest) &amp; 3)==0.</li></ul>Byte-copies are used in all other cases.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148977 - simonjhall - Sun Jan 13, 2008 12:12 am</h4>
    <div class="postbody"><span class="postbody">Wot I mean is - *normally* if the alignment is not word aligned, yet the source and destimation alignments match (like in that final example) first first three bytes would have been handled with a byte write, then the rest of it (apart from the end) would be done with word writes. The end bit would then be done with byte writes.
<br/>
However I've not looked at the DKA version of memcpy but this is what every version I have the source to does. If the DS memcpy doesn't support this extra path then maybe it should?
<br/>
<br/>
Either way, I wouldn't use memcpy on 16/32-bit only memory unless you're sure of what's going on.<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148996 - nipil - Sun Jan 13, 2008 11:20 am</h4>
    <div class="postbody"><span class="postbody">Another point with memcpy : even if you have good byte alignement, when you're accessing video memory, memcpy behaviour depends on the number of bytes written.
<br/>
<br/>
- under 16 bytes, "nothing" is written (ie byte access on video ram = "nothing")
<br/>
- 16  &lt;= len &lt; 20 : 16 pixels are written. remainder 1 to 3 pixels are not set.
<br/>
- goes on with 4-pixels steps...
<br/>
<br/>
While the "step" effect is normal (16 or 32 bit VRAM accesses) the "less than 16" effect is actually surprising. Furthermore, i had thought the step size would have been 2 pixels, as i thought memcpy used 32 bits accesses for main loop, then a 16bit and 8bit to fill the remainders. Here's a  capture to show what i mean (taken from no$gba, tested same behaviour on real DS) :
<br/>
<br/>
<a href="http://images3.hiboox.com/images/0208/so4vrfof.gif">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
Here's the test code used to show what i mean :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;nds.h&gt;
<br/>
#include &lt;cstring&gt;
<br/>
<br/>
int main(void) {
<br/>
   powerON(POWER_ALL_2D);
<br/>
   videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
   vramSetBankA(VRAM_A_MAIN_BG_0x06000000);
<br/>
<br/>
   BG_PALETTE[0] = RGB15(31,31,31);
<br/>
   BG_PALETTE[1] = RGB15(0,0,0);
<br/>
<br/>
   BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0) | BG_PRIORITY(2);
<br/>
   
<br/>
   BG3_XDX = 1 &lt;&lt; 8;
<br/>
   BG3_XDY = 0;
<br/>
   BG3_YDX = 0;
<br/>
   BG3_YDY = 1 &lt;&lt; 8;
<br/>
   BG3_CX = 0;
<br/>
   BG3_CY = 0;
<br/>
<br/>
   uint16* screen = (uint16*) BG_BMP_RAM(0);
<br/>
   memset(screen, 0, SCREEN_WIDTH*SCREEN_HEIGHT);
<br/>
<br/>
   uint8 data[256];
<br/>
   memset (data, 1, 256);
<br/>
<br/>
   for (int i=0; i &lt; 192; i++) {
<br/>
      memcpy(screen, data, i);
<br/>
      screen += 128; // 256px = 128 uint16
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Anyway, my advice would then be : <span style="font-style: italic">use memcpy when you are sure it's aligned</span> (ie <span style="font-weight: bold">both </span>src and dst base addresses are multiple of 4, <span style="font-weight: bold">and</span> the length is a multiple of 4)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149111 - JanoSicek - Tue Jan 15, 2008 2:53 pm</h4>
    <div class="postbody"><span class="postbody">I did some testing on loading individual tiles (64 bytes)
<br/>
When I was loading full screen of tiles, this took:
<br/>
856 microseconds for SwiCopy (COPY MODE WORD &amp; HWORD are similar results)
<br/>
3174 microseconds for memcpy
<br/>
1700 microseconds for DMAcopy (WORDS/HALFWORDS, asynch/synch)
<br/>
<br/>
I am quite curious about the wiki remark about memcpy being the fastest.
<br/>
For now, I'm using SwiCopy.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149114 - knight0fdragon - Tue Jan 15, 2008 4:19 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mushu wrote:</b></span></td> </tr> <tr> <td class="quote">Sorry to double post, but I'm a huge attention whore, and I wanted to get some attention :&gt;
<br/>
<br/>
Anyway, I've never really been satisfied with the benchmarks done on memcpy/swiCopy/dmaCopy, simply because they all seem to show that memcpy is faster than dmaCopy. dmaCopy is a memory transfer with a dedicated controller, so why the hell would it be faster than a software memcpy?
<br/>
<br/>
Additionally, all of the benchmarks I've ever seen only gave a single number for each of the functions, rather than testing over a variety of transfer sizes and locations (main memory vs. VRAM vs. shared memory, etc). So I decided to hunker down and do some testing of my own, and the results were... informative.
<br/>
<br/>
I wrote a small app (source+binary to follow) to test all power-of-two block sizes from 16-1048576 bytes, using either main memory or VRAM as src/dst, and main memory for dst/src (I didn't want to end up with the situation where the source and destination are the same address, so only 1 of them is allowed to be VRAM).
<br/>
<br/>
Additionally, I mapped all the VRAM to 0x6000000, assuming that it will perform the same regardless of the mapping (which makes sense to me, but may not be the case).
<br/>
<br/>
Oh god I have to make a table. These values were obtained with the binary (to follow) on my DS Lite; there's probably at least 5 bugs in the source, so I wouldn't call them very conclusive, but they definitely do suggest conclusions -
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Main Memory to Main Memory
<br/>
<br/>
          16B  32B 64B 128B  256B  512B 1024B 2048B 
<br/>
memcpy    41   52  73  115   312   731  1219  3906
<br/>
dmaCopy   94  158 286  542  1054  2118  4148  8244
<br/>
swiCopy  123  167 221  383   770  1440  2716  6691
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B
<br/>
memcpy   11063  23697  48677   98291  196727
<br/>
dmaCopy  16481  32887  65655  131263  262338
<br/>
swiCopy  17789  38230  77787  155769  311512
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
etc, you get the picture. This matches what I've read so far, memcpy &gt; dmaCopy &gt; swiCopy, which is expected. When you switch over to VRAM, however, a different picture emerges -
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Main Memory to VRAM
<br/>
<br/>
          16B  32B  64B 128B  256B  512B 1024B 2048B
<br/>
dmaCopy   48   56   72  104   168   324   592  1145
<br/>
memcpy    58   85  139  247   463   939  1891  4001
<br/>
swiCopy  168  204  360  598  1118  2124  4212  8456
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B
<br/>
dmaCopy   2226   4375   8627   17125   34121
<br/>
memcpy    8711  18657  38657   77907  155903
<br/>
swiCopy  17828  37827  76815  153746  307480
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Anyway, so it appears that dmaCopy is significantly faster for transferring any size of data to VRAM, while memcpy is faster when working only in main memory. I would suspect that the dma hardware doesn't actually kick in unless you're transferring to VRAM, but I have no foundation for that conclusion.
<br/>
<br/>
I'm sure a lot of people already knew about this (or I've made a mistake somewhere ._.) but I've always seem to have read that memcpy is faster than everything else etc, and just though that was odd.
<br/>
<br/>
Blarg.
<br/>
<br/>
<a class="postlink" href="http://mushu.dreamhosters.com/upload/Benchmark1.zip" target="_blank">Sauce + Binary</a>
<br/>
<a class="postlink" href="http://mushu.dreamhosters.com/upload/Benchmark1.nds" target="_blank">Just the Binary</a>
<br/>
<br/>
:&lt;
<br/>
<br/>
Oh, and controls for the thing -
<br/>
* A: Double the amount of memory allocated.
<br/>
* B: Halve the amount of memory allocated.
<br/>
* X: Toggle destination (VRAM/Main Memory)
<br/>
* Y: Toggle source (VRAM/Main Memory)</span></td> </tr></table><span class="postbody">
<br/>
<br/>
this is from <a href="http://forum.gbadev.org/viewtopic.php?t=13242" target="_blank">http://forum.gbadev.org/viewtopic.php?t=13242</a>
<br/>
<br/>
<br/>
source is there if you want to add more tests to it<br/>_________________<br/><a href="http://www.myspace.com/knight0fdragonds" target="_blank">http://www.myspace.com/knight0fdragonds</a>
<br/>
<br/>
MK DS FC: Dragon 330772 075464 
<br/>
AC WW FC: Anthony SamsClub 1933-3433-9458 
<br/>
MPFH: Dragon 0215 4231 1206</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149130 - nipil - Tue Jan 15, 2008 8:21 pm</h4>
    <div class="postbody"><span class="postbody">Very informative. I too had to rely on speed gossips. Thanks for the link.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149139 - JanoSicek - Tue Jan 15, 2008 10:39 pm</h4>
    <div class="postbody"><span class="postbody">Nice benchmarks, however in my case the swiCopy is the fastest solution!
<br/>
Why is this?
<br/>
The source of the data lies in the const u8 [100000] array with bitmap, in which part of the memory does this lie? Target is the VRAM.
<br/>
<br/>
EDIT: I just checked and the source is in 0x2........ which is main RAM, so the dmaCopy should be  fastest. However it is not :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149141 - JanoSicek - Tue Jan 15, 2008 11:24 pm</h4>
    <div class="postbody"><span class="postbody">DOH!
<br/>
<br/>
My problem was the emulator!
<br/>
<br/>
Copying RAM-&gt;VRAM
<br/>
Emulator NO$GBA 64 bytes
<br/>
Swi (22)
<br/>
dma (83)
<br/>
memcpy (156)
<br/>
Emulator NO$GBA 64kbytes
<br/>
Swi (22) !!
<br/>
dma (32819)
<br/>
memcpy (120870)
<br/>
<br/>
Don't trust the emulator :) Lesson learned for me :)
<br/>
On the hardware, indeed DMAcopy rules them all, with async option being the faster.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149154 - tepples - Wed Jan 16, 2008 1:29 am</h4>
    <div class="postbody"><span class="postbody">To make timing of SWI calls in NO$GBA somewhat more accurate, you can dump a BIOS from your DS and use that.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149158 - kusma - Wed Jan 16, 2008 2:07 am</h4>
    <div class="postbody"><span class="postbody">tepples: How would one go about to do that? I found a program that dumped to the save-ram for GBA, but I haven't seen any solutions for NDS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149161 - tepples - Wed Jan 16, 2008 2:33 am</h4>
    <div class="postbody"><span class="postbody">The only DS BIOS dumper I could find that's not on one of the Three Forbidden Sites is <a class="postlink" href="http://www.ndsretro.com/miscdown.html" target="_blank">this one</a>. SLOT-2 only, not GBAMP. If it came with source code, I would have ported it to libfat+DLDI like I did with the <a class="postlink" href="http://pinocchio.jk0.org/gbaforum/gbamp_bios_dumper.zip" target="_blank">GBA BIOS dumper</a>, but it doesn't.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149172 - OSW - Wed Jan 16, 2008 9:43 am</h4>
    <div class="postbody"><span class="postbody">maybe this is helpful?
<br/>
<a href="http://nds.cmamod.com/2007/01/24/dsbf_dump-79-bios-firmware-dumper/" target="_blank">http://nds.cmamod.com/2007/01/24/dsbf_dump-79-bios-firmware-dumper/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149174 - simonjhall - Wed Jan 16, 2008 10:24 am</h4>
    <div class="postbody"><span class="postbody">I was just reading the source in there to dump the ARM7 ROM - yikes! How did someone figure out that those two instructions were there?!
<br/>
Some people are just far too good!<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
