<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>3D engine design - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > 3D engine design</h2>
<div id="posts">
<div class="post">
    <h4>#161072 - Atreides - Sun Jul 27, 2008 10:04 pm</h4>
    <div class="postbody"><span class="postbody">Hi All,
<br/>
<br/>
  I have been writting 3D engines in asm since the 386 but havent had much time or opportunity to develop a from scratch 3d engine for several years.
<br/>
<br/>
  Ther opportunity to develop a 3d engine for the DS has come up and I have been looking through the tech specs and have a few questions that would help me in the design phase while I work out how I want to implement my engine.
<br/>
<br/>
  Firstly, I am curriouus about the 3D core. The quality of the renderer is poor and I dont want to use it, but is it a seperate chip or is it firmware that that utilises the ARM9 ? 
<br/>
<br/>
  Could I fill the data structs for the 3D core directly and force a render flush more than once per frame ?
<br/>
<br/>
  Is it possible to read back 3D transformation data for vectors and matrices from the 3d core ?
<br/>
<br/>
  I will probably use an incremental scan line renderer that implements gourad shading, phong lighting and texture mapping and I will be using 15bit colour modes. Any suggestions for what internal memory is best for scanline raster buffers that can be copied to vram, working data areas for span converted triangles and the like ... ?
<br/>
<br/>
  For a vram scaline copy can I set the scan line address that I want to block copy the video buffer to. This would mean that I could ignore the vertical refresh and not have to sync to it. Is this possible (and please let me know if the question doesn't make sense) ?
<br/>
<br/>
thansk for taking the time to read this and I look forwards to your replies
<br/>
<br/>
regards
<br/>
<br/>
Leo</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161074 - kusma - Sun Jul 27, 2008 10:14 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Atreides wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
  Firstly, I am curriouus about the 3D core. The quality of the renderer is poor and I dont want to use it, but is it a seperate chip or is it firmware that that utilises the ARM9 ? 
<br/>
</td> </tr></table><span class="postbody">
<br/>
Separate chip / gates. It does not affect the ARM9's performance. But I must say - not using the GPU ties up a LOT of CPU cycles that could be spared.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
  Could I fill the data structs for the 3D core directly and force a render flush more than once per frame ?
<br/>
</td> </tr></table><span class="postbody">
<br/>
No.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
  Is it possible to read back 3D transformation data for vectors and matrices from the 3d core ?
<br/>
</td> </tr></table><span class="postbody">
<br/>
Yes, to a certain degree. Check GBATek for details.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161075 - silent_code - Sun Jul 27, 2008 10:38 pm</h4>
    <div class="postbody"><span class="postbody">Saying that the quality of the images generated by the 3D hardware is poor, is a bit over the top. I actually find it has a very good quality for the hardware's specs. It's all up to the developers to use it propperly.
<br/>
<br/>
How come you think that way about the 3D hardware?
<br/>
<br/>
<br/>
In addition to kusma's post:
<br/>
<br/>
The hardware is "sealed off", controlable through a command FIFO and a few mode and status registers. It is not part of the CPU accessible bus.
<br/>
<br/>
You can write directly to VRAM (to offscreen lines), if you want. I read that memory is very fast.
<br/>
<br/>
But iIrc, VRAM can only be written to during VBlank.
<br/>
<br/>
Flushing 3D means waiting to the end of the frame (only for 3D rendering, everything else will still work, e.g. the ARM program).
<br/>
<br/>
I don't think "not synchronizing" is doable (s.a.) and is definitely not recommended, because the console (as nearly all consoles are) is BASED around the 60 hz display rate.
<br/>
<br/>
You also have to remember, that features like anti aliasing and fogging (any others as well) come at no cost when using the hardware. You merely switch things off than on. Performance impact is always 0. (There are other implications, but I am refering to the sole rendering side.)
<br/>
<br/>
Anyways, I share your enthusiasm for software rendering and I am definitely interested in seeing what you will achieve. :^)
<br/>
<br/>
And welcome the the forum! :^D
<br/>
<br/>
Good luck!<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161079 - DensitY - Sun Jul 27, 2008 11:17 pm</h4>
    <div class="postbody"><span class="postbody">In may I wrote up a software rendered based model renderer (affine texture mapper, Zbuffered, backface culled, 1 directional light), let me tell you that arm9 isn't overly fast for the task. I generally found the quickest I could get my test model (240 triangles) to render was about 4ms. Transformation and translation to 2d screen space was pretty quick, under 1ms, but actual texture mapping process, building you texture mapping gradients for the S,V coords was not so quick. 
<br/>
<br/>
I didn't go all out however, While I initially have all my code Software based, I did end up using the DS's 3d hardware for matrix by vertex multiplication and the DS's divider hardware todo division. however I didn't expliot the fact that the hardware is async from the arm9 (ie, I could of continued onto the next vertex for translation while I spend 15 cycles waiting for the current vertex to finish its matrix by vertex multiplication). 
<br/>
<br/>
considering the natural screen size of the DS, the ds's 3d hardware is pretty good. the lack of additive blending is annoying however its reasonably good and considerby faster then writing a software renderer for the arm9.
<br/>
<br/>
You could possibly do a Doom 1/2 rendering system and get some reasonable frame rates, ie fixed Z coord per column and have a floodfill like span rendering for floor/ceiling gaps, allowing you todo a quick fast DDA inner rendering loop. but yeah, software rendered based polygonal engine is best left done by the hardware.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">For a vram scaline copy can I set the scan line address that I want to block copy the video buffer to. This would mean that I could ignore the vertical refresh and not have to sync to it. Is this possible (and please let me know if the question doesn't make sense) ? </td> </tr></table><span class="postbody">
<br/>
<br/>
like DOS, you can render to say 0xA000 (PC mode 13 vram address). with the DS you set a screen to framebuffer mode then just write to VRAM_A memory location.. however unless you write to that memory bank after vsync interrupt, you'll get flickering.. you best bet there is to simply double buffer, render to a backbuffer in ram (or DTCM if you want most of your renderer to sit in ITCM memory), then copy that over to Vram on Vsync interrupt call to avoid flickering.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161082 - DekuTree64 - Sun Jul 27, 2008 11:58 pm</h4>
    <div class="postbody"><span class="postbody">I've considered such a project myself in the past. It might not be too practical, but it would be loads of fun to write. And you do have a whole 33MHz ARM7 as well, so you could just run the main game code over there and use ARM9 as the "sub processor" :)
<br/>
<br/>
Texture filtering would be cool to see, and maybe some voxel terrain just because you can't mix it with hardware 3D easily. Also additive blending. And if you plan to use it in any demo competitions, throw in some bump mapping too.
<br/>
<br/>
You could use the 3D chip to do matrix multiplies and vertex transformations. The <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#ds3dtests" target="_blank">position test</a> is a hardware matrix-vector multiply. You could probably do a nice 3-stage pipeline where the 3D chip transforms a vertex, the divider calculates the reciprocal of w, and the CPU multiplies by that reciprocal. Position test and division are independent of the CPU and eachother, so all 3 stages would be running at once (on 3 different vertices).
<br/>
<br/>
I'm not sure exactly what you mean by an "incremental scanline renderer" though? Maybe a span buffer renderer? That could probably reach higher speeds than a double buffered renderer with Z-buffer, but it also makes alpha blending harder, and you really have to keep your per-span info small for it to be effective, which makes it less flexible.
<br/>
<br/>
DTCM (16KB) is your best bet for small pieces of data that need a lot of reading and writing. The 2 16KB shared work RAM banks are good too. They're slower than DTCM, but still very fast. Or you can use them to transfer data back and forth between processors, or just give them to ARM7 so it has more memory that won't interfere with ARM9.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161084 - DensitY - Mon Jul 28, 2008 12:05 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
You could use the 3D chip to do matrix multiplies and vertex transformations. The <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#ds3dtests" target="_blank">position test</a> is a hardware matrix-vector multiply. You could probably do a nice 3-stage pipeline where the 3D chip transforms a vertex, the divider calculates the reciprocal of w, and the CPU multiplies by that reciprocal. Position test and division are independent of the CPU and eachother, so all 3 stages would be running at once (on 3 different vertices).</td> </tr></table><span class="postbody">
<br/>
<br/>
I actually wrote a matrix * vertex transformation code, and posted it here <a href="http://forum.gbadev.org/viewtopic.php?p=157517&amp;highlight=#157517" target="_blank">http://forum.gbadev.org/viewtopic.php?p=157517&amp;highlight=#157517</a> although it can be greatly improved, by implementing it in stages as you said.. possibly something he could look into.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
DTCM (16KB) is your best bet for small pieces of data that need a lot of reading and writing. The 2 16KB shared work RAM banks are good too. They're slower than DTCM, but still very fast. Or you can use them to transfer data back and forth between processors, or just give them to ARM7 so it has more memory that won't interfere with ARM9.</td> </tr></table><span class="postbody">
<br/>
<br/>
This. (Although with my implementation I had data/function statically stored in DTCM/ITCM, dynamic data storage is best).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161151 - TwentySeven - Tue Jul 29, 2008 12:36 pm</h4>
    <div class="postbody"><span class="postbody">ITCM is the same speed right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161175 - DensitY - Tue Jul 29, 2008 7:43 pm</h4>
    <div class="postbody"><span class="postbody">ITCM (instruction cache), and DTCM (data cache) runs at 66mhz, sits off next to the the arm9. The shared work ram banks, as far as I remember sits off the 33mhz bus, so shifting data to the ram is slow but the data is accessable by both processors. don't actually remember the speed of the work ram, I assume they are slower, esp when it comes to communication between it and the arm9's internal caches.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
