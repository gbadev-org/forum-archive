<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>draw a triangle - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > draw a triangle</h2>
<div id="posts">
<div class="post">
    <h4>#162772 - hacker013 - Fri Sep 12, 2008 5:59 pm</h4>
    <div class="postbody"><span class="postbody">hey everybody,
<br/>
<br/>
has anybody a formula for drawing a filled triangle??<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162773 - Justice - Fri Sep 12, 2008 6:33 pm</h4>
    <div class="postbody"><span class="postbody">2D or 3D? You can use openGl! Example:
<br/>
3D
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
glBegin(GL_TRIANGLES);                        
<br/>
glVertex3f( 0.0f, 1.0f, 0.0f);               
<br/>
glVertex3f(-1.0f,-1.0f, 0.0f);               
<br/>
glVertex3f( 1.0f,-1.0f, 0.0f);               
<br/>
glEnd();   
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162774 - DekuTree64 - Fri Sep 12, 2008 6:33 pm</h4>
    <div class="postbody"><span class="postbody">In software you mean? It's a lot like drawing lines. Just interpolate down the left and right edges of the triangle, and draw horizontal spans between them.
<br/>
<br/>
If you mean drawing with the 3D hardware, you at least need to set the projection matrix, set the backdrop color, set the vertex color, send some vertices (with some positive or negative Z, I can never remember which), and send a swap buffers command. There should be functions in libnds for all that, and probably some examples around somewhere.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162775 - hacker013 - Fri Sep 12, 2008 6:48 pm</h4>
    <div class="postbody"><span class="postbody">no, i mean in 2D.
<br/>
<br/>
@DekuTree64, it is not so easy as you say.<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162777 - DekuTree64 - Fri Sep 12, 2008 7:33 pm</h4>
    <div class="postbody"><span class="postbody">Yes, of course not :)
<br/>
Well, the theory is that simple, but implementing it can get confusing with so many interpolations going on at once. Plus there are tricky accuracy problems that cause cracks between polygons in a model.
<br/>
<br/>
<a class="postlink" href="http://freespace.virgin.net/hugo.elias/graphics/x_polysc.htm" target="_blank">Here is a good article</a> on scan converting, which also covers the accuracy problems.
<br/>
<br/>
Get it working flat shaded first. After that it's not too tough to add goraud shading and/or texture mapping.
<br/>
<br/>
Perspective correct texture mapping is hard though, just because it's unreasonably slow if you do it the straightforward way. Well, it's probably unreasonably slow nomatter what you do on a DS. But less than on GBA, since there's independent division hardware. <a class="postlink" href="http://chrishecker.com/Miscellaneous_Technical_Articles" target="_blank">Chris Hecker</a> wrote some good articles on texture mapping using floating point hardware for the perspective division, which should be applicable to DS.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162783 - Miked0801 - Fri Sep 12, 2008 9:27 pm</h4>
    <div class="postbody"><span class="postbody">Software triangle.  Use a fast line drawing algorithm to 'draw' the edges of the triangle in a 2D array of xPositions.  Fill the array with some flag so that you will know if something has already drawn in the first field.  When you draw all three edges, your array will hold the X start and X Stop positions.
<br/>
<br/>
Now run thru the list and quickly draw horizontal lines between the X start and x stop positions.  If the 2nd entry is blank, it's a 1 pixel line.
<br/>
<br/>
You've just drawn a scanline converted traingle to screen somewhat quickly.  To add shading, add another field for start and stop colors to each X position and interpolate across the line.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162791 - keldon - Fri Sep 12, 2008 11:24 pm</h4>
    <div class="postbody"><span class="postbody">The scanline method is about the easiest to code; you can even store uv and uz deltas for texture mapping without too much effort.
<br/>
<br/>
Just to show you in code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">fill_poly (point1, point2, point3)
<br/>
{
<br/>
   draw_line (point1, point2, min_max);
<br/>
   draw_line (point2, point3, min_max);
<br/>
   draw_line (point3, point1, min_max);
<br/>
<br/>
   interpolate(min_max);
<br/>
}
<br/>
<br/>
draw_line (a, b, min_max)
<br/>
{
<br/>
   foreach (pixel p in a-&gt;b)
<br/>
   {
<br/>
      put_pixel (p);
<br/>
      min_max[p.y].min = MIN (p.x, min_max.min[p.y]);
<br/>
      min_max[p.y].max = MAX (p.x, min_max.max[p.y]);
<br/>
   }
<br/>
}
<br/>
<br/>
interpolate (min_max)
<br/>
{
<br/>
   for (y = 0; y &lt; min_max.max_y(); ++y)
<br/>
   {
<br/>
      for (x = min_max[y].min; x &lt; min_max[y].max; ++x) put_pixel (x,y); 
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And just as mike said, you can store what you want at the beginning and end of the line. In the interpolate method you might read that RED is the colour on the left and BLUE is the colour on the right, and write a gradient using the interpolated values.
<br/>
<br/>
As a matter of fact, I've used it a few times myself.
<br/>
<br/>
p.s. I didn't implement it using those methods exactly, I'm just trying to show you the general logic.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162802 - hacker013 - Sat Sep 13, 2008 10:01 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">The scanline method is about the easiest to code; you can even store uv and uz deltas for texture mapping without too much effort.
<br/>
<br/>
Just to show you in code:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">fill_poly (point1, point2, point3)
<br/>
{
<br/>
   draw_line (point1, point2, min_max);
<br/>
   draw_line (point2, point3, min_max);
<br/>
   draw_line (point3, point1, min_max);
<br/>
<br/>
   interpolate(min_max);
<br/>
}
<br/>
<br/>
draw_line (a, b, min_max)
<br/>
{
<br/>
   foreach (pixel p in a-&gt;b)
<br/>
   {
<br/>
      put_pixel (p);
<br/>
      min_max[p.y].min = MIN (p.x, min_max.min[p.y]);
<br/>
      min_max[p.y].max = MAX (p.x, min_max.max[p.y]);
<br/>
   }
<br/>
}
<br/>
<br/>
interpolate (min_max)
<br/>
{
<br/>
   for (y = 0; y &lt; min_max.max_y(); ++y)
<br/>
   {
<br/>
      for (x = min_max[y].min; x &lt; min_max[y].max; ++x) put_pixel (x,y); 
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And just as mike said, you can store what you want at the beginning and end of the line. In the interpolate method you might read that RED is the colour on the left and BLUE is the colour on the right, and write a gradient using the interpolated values.
<br/>
<br/>
As a matter of fact, I've used it a few times myself.
<br/>
<br/>
p.s. I didn't implement it using those methods exactly, I'm just trying to show you the general logic.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Can you add some explanation because i don't get it?<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162809 - keldon - Sat Sep 13, 2008 11:30 am</h4>
    <div class="postbody"><span class="postbody">Sorry, that wasn't intended; I was just trying to add to what Mike said by showing you some psuedo code to demonstrate it.
<br/>
<br/>
In short; the polygon is drawn (mostly) by interpolate. All interpolate does is run along the y-plane and reading what the minimum and maximum x values are. For example, if you had a line from (0,0) to (10,0) then all min_max would store is:
<br/>
 - y[0] {min = 0, max = 10}
<br/>
<br/>
You can implement min_max by creating a 2d array, such as:
<br/>
 - int min_max [2][height]
<br/>
<br/>
... where min_max[0][y] gives the minimum, and min_max[1][y] gives the max (alternatively have two arrays, one for min and one for max). Initialize min_max so that min=WIDTH and max=0 for all y.
<br/>
<br/>
So to recap, the interpolate method just takes a min_max array. To prepare min_max simply draw lines between the three points, updating min_max as you go along. As you can see in the draw_line method, nothing more than storing the minimum and maximum pixels for the line is required - the put_pixel call in draw_line (now I think of it) is not even needed.
<br/>
<br/>
This simple algorithm can allow you to draw [simple] polygons of any length (so long as all polygons have inner angles &lt; 180 degrees).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162810 - hacker013 - Sat Sep 13, 2008 12:29 pm</h4>
    <div class="postbody"><span class="postbody">can you give an working example because it is for me to complicated.<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162811 - hacker013 - Sat Sep 13, 2008 12:37 pm</h4>
    <div class="postbody"><span class="postbody">Oeps, dubble post<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162812 - chuckstudios - Sat Sep 13, 2008 1:08 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>hacker013 wrote:</b></span></td> </tr> <tr> <td class="quote">can you give an working example because it is for me to complicated.</td> </tr></table><span class="postbody">
<br/>
<br/>
To be honest, part of the joy of programming is tackling challenges by yourself. Just experiment, and remember to have fun with it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162814 - keldon - Sat Sep 13, 2008 2:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>hacker013 wrote:</b></span></td> </tr> <tr> <td class="quote">can you give an working example because it is for me to complicated.</td> </tr></table><span class="postbody">
<br/>
<br/>
Note: I just spent the last 30 minutes trying to explain my code (in this post), but it was a texture mapping algorithm so I decided that I might as well just strip it of that code and turn it into a fill-poly routine.
<br/>
<br/>
It still has code geared for texture mapping, and it was written a long time ago for my image processing coursework so you will have to excuse the code a little. The section where KEdge is used to draw the line can easily be replaced with a different line drawing algorithm.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*!
<br/>
   Draws a texture mapped polygon to img.
<br/>
   
<br/>
   \param   img         Destination image
<br/>
   \param   points      KPoint*[npoints]
<br/>
   \param   npoints      Number of points in 'points' parameter.
<br/>
*/
<br/>
void drawPoly (wxImage *img, const KPoint **points, int npoints)
<br/>
{
<br/>
   int minx [img-&gt;getHeight()];
<br/>
   int maxx [img-&gt;getHeight()];
<br/>
   
<br/>
   int miny = img-&gt;getHeight();
<br/>
   int maxy = 0;
<br/>
   
<br/>
   //   &gt;
<br/>
   //      Initialize min/max in such a way that nothing will be drawn for each line
<br/>
   //   &gt;
<br/>
   for ( int i = 0; i &lt; img-&gt;getHeight(); i ++ )
<br/>
   {
<br/>
      minx[i] = img-&gt;getWidth();
<br/>
      maxx[i] = 0;
<br/>
   }
<br/>
   
<br/>
   //   &gt;
<br/>
   //      Calculate minx and maxx for each line, aswell as miny and maxy
<br/>
   //   &gt;
<br/>
   for ( int i = 0; i &lt; npoints -1; i ++ )
<br/>
   {
<br/>
      KPoint *p1 = points[i];
<br/>
      KPoint *p2 = points[i+1];
<br/>
      KEdge e( p1, p2);
<br/>
      
<br/>
      //   &gt;
<br/>
      //      KEdge stores some calculations on an edge designed to draw
<br/>
      //      an edge line by line. In short, each point in the line will be
<br/>
      //      reached.
<br/>
      //   &gt;
<br/>
      for ( int dx = e.a-&gt;x &lt;&lt;16, dy = e.a-&gt;y &lt;&lt;16, cy = 0; cy &lt; e.diffy ; cy++ )
<br/>
      {
<br/>
         int x = dx &gt;&gt; 16;
<br/>
         int y = dy &gt;&gt; 16;
<br/>
<br/>
         if ( x &lt; minx[y])
<br/>
         {
<br/>
            minx[y] = x;
<br/>
         }
<br/>
<br/>
         if ( x &gt; maxx[y]) maxx[y] = x; 
<br/>
         
<br/>
         if ( y &lt; miny ) miny = y;
<br/>
         if ( y &gt; maxy ) maxy = y;
<br/>
         
<br/>
         dx += e.dx;
<br/>
         dy += e.dy;
<br/>
      }
<br/>
   }
<br/>
<br/>
<br/>
   //   &gt;
<br/>
   //      Render shape using min/max values created when drawing the lines.
<br/>
   //   &gt;
<br/>
   for ( int y = miny; y &lt;= maxy; y ++ )
<br/>
   {
<br/>
      for ( int x = minx[y]; x &lt;= maxx[y]; x++ )
<br/>
      {
<br/>
         img-&gt;SetRGB(x,y, WHITE);
<br/>
          
<br/>
      }
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-size: 9px; line-height: normal"><span style="font-weight: bold">Edit</span>: oops, missed a bit of code</span></span><span class="gensmall"><br/><br/>Last edited by keldon on Sat Sep 13, 2008 9:28 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162815 - hacker013 - Sat Sep 13, 2008 2:29 pm</h4>
    <div class="postbody"><span class="postbody">thank you very much , but i'm needing for drawing a triangle in 2D on the screen with cordinates like x1, y1, x2, y2 , etc. For this i muss use a image, it is complicated, i don't get it anymore, it is confusing (for me).<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162837 - keldon - Sat Sep 13, 2008 11:09 pm</h4>
    <div class="postbody"><span class="postbody">My apologies, I overestimated your programming experience and thought you would know where to go from here. Simply replace the "calculate minx and maxx" section with a standard line drawing algorithm, and replace img-&gt;setPixel with your own set_pixel. My code is interfacing with wxWidgets, but that structure can easily be swapped with just about anything - for example width and height can be function parameters and you could just be passing an array to pixel data ^_^
<br/>
<br/>
Judging by your post, I guess you just want the code; if nobody has done it by 7pm GMT tomorrow then I'll put <a class="postlink" href="http://tech-algorithm.com/index.php?post=30" target="_blank">this line drawing algorithm in its place</a> for you. It's not that hard, but I guess you're at quite an early stage.
<br/>
<br/>
So what are you working on that requires polygon filling?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162850 - hacker013 - Sun Sep 14, 2008 9:07 am</h4>
    <div class="postbody"><span class="postbody">@keldon, i'm working on a gmwrapper (for the functions) for my libhax library. And i have already a line drawing function with the DDA algorithm.<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162861 - keldon - Sun Sep 14, 2008 8:09 pm</h4>
    <div class="postbody"><span class="postbody">100% untested - but compiles and in theory should do the job you require. And I've "written" (or should I say edited) the draw_line method as a template method to allow any class with the required methods to use the algorithm without run time speed penalties.
<br/>
<br/>
You might also want to throw in some asserts to make sure that the image is not greater than MAX_IMAGE_HEIGHT, and make sure that it is not possible to write to invalid addresses in your image.
<br/>
<br/>
You will have to fill in your POINT and IMAGE structures; if you are only writing to the screen then create an IMAGE class that relays the set_pixel message to your own set_pixel method.
<br/>
<br/>
p.s. I normally would dedicate more time to helping others, but I got back quite late from church service and I have some work to do.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define MIN( a, b )                        ( (a)&lt;(b)?(a):(b) )
<br/>
#define MAX( a, b )                        ( (a)&gt;(b)?(a):(b) )
<br/>
#define ABS( a )                        ( (a)&lt;0?-(a):(a) )
<br/>
#define FABS( a )                        ( (a)&lt;0.0?-(a):(a) )
<br/>
#define LIMIT( v, min, max )               ( (v)&gt;(max)?(max):((v)&lt;(min)?(min):v) )
<br/>
#define IN_RANGE( val, MIN, MAX )             ( ( MIN &lt;= val &amp;&amp; MAX &gt;= val ) ? 1 : 0 )
<br/>
#define OUT_OF_RANGE( val, MIN, MAX )          ( ( MIN &lt;= val &amp;&amp; MAX &gt;= val ) ? 0 : ( ( MIN &gt; val ) ? -1 : 1 ) )
<br/>
<br/>
class IMAGE;
<br/>
<br/>
typedef u16 COLOUR;
<br/>
<br/>
/*!   \class   IMAGE
<br/>
   \brief   This is the interface used in drawPoly.
<br/>
*/
<br/>
class IMAGE
<br/>
{
<br/>
   public:
<br/>
      void set_pixel (int x, int y, COLOUR colour);
<br/>
      u32 get_width (void) const;
<br/>
      u32 get_height (void) const;
<br/>
};
<br/>
<br/>
class SCANLINE_BOUNDARY
<br/>
{
<br/>
   public:
<br/>
   
<br/>
      SCANLINE_BOUNDARY (u32 *minx, u32 *maxx, u32 height)
<br/>
         : minx_ (minx), maxx_ (maxx), height_ (height) {}
<br/>
      
<br/>
      void set_pixel (int x, int y, COLOUR)
<br/>
      {
<br/>
         if (minx_ &amp;&amp; maxx_ &amp;&amp; (y &gt;= 0) &amp;&amp; (y &lt; height_))
<br/>
         {
<br/>
            minx_[y] = MIN (minx_[y], x);
<br/>
            maxx_[y] = MAX (maxx_[y], x);
<br/>
         }
<br/>
      }
<br/>
      
<br/>
   private:
<br/>
      u32 height_;
<br/>
      u32 *minx_;
<br/>
      u32 *maxx_;
<br/>
};
<br/>
<br/>
class POINT
<br/>
{
<br/>
   public:
<br/>
      int get_x()   {return 1;}
<br/>
      int get_y()   { return 1;}
<br/>
};
<br/>
<br/>
void drawPoly (IMAGE &amp;img, const POINT &amp;p1, const POINT &amp;p2, const POINT &amp;p3, COLOUR colour);
<br/>
<br/>
template &lt;class T&gt;
<br/>
void draw_line(T &amp;image, POINT p1, POINT p2, COLOUR color);
<br/>
<br/>
/*!
<br/>
   Draws a texture mapped polygon to img.
<br/>
   
<br/>
   \param   img         Destination image
<br/>
   \param   points      KPoint*[npoints]
<br/>
   \param   npoints      Number of points in 'points' parameter.
<br/>
*/
<br/>
void drawPoly (IMAGE &amp;img, const POINT &amp;p1, const POINT &amp;p2, const POINT &amp;p3, COLOUR colour)
<br/>
{
<br/>
   // minx and maxx could be changed to dynamically allocated arrays, but
<br/>
   // I opted for stack allocated arrays.
<br/>
   
<br/>
   const int MAX_IMAGE_HEIGHT = 512;
<br/>
   u32 minx [MAX_IMAGE_HEIGHT];
<br/>
   u32 maxx [MAX_IMAGE_HEIGHT];
<br/>
   
<br/>
   u32 miny = img.get_height();
<br/>
   u32 maxy = 0;
<br/>
   
<br/>
   //   &gt;
<br/>
   //      Initialize min/max in such a way that nothing will be drawn for each line
<br/>
   //   &gt;
<br/>
   for ( int i = 0; i &lt; img.get_height(); i ++ )
<br/>
   {
<br/>
      minx[i] = img.get_width();
<br/>
      maxx[i] = 0;
<br/>
   }
<br/>
   
<br/>
   SCANLINE_BOUNDARY boundary (minx, maxx, img.get_height());
<br/>
   draw_line(boundary, p1, p2, colour);
<br/>
   draw_line (boundary, p2, p3, colour);
<br/>
   draw_line (boundary, p3, p1, colour);
<br/>
<br/>
   //   &gt;
<br/>
   //      Render shape using min/max values created when drawing the lines.
<br/>
   //   &gt;
<br/>
   for ( u32 y = miny; y &lt;= maxy; y ++ )
<br/>
   {
<br/>
      for ( u32 x = minx[y]; x &lt;= maxx[y]; x++ )
<br/>
      {
<br/>
         img.set_pixel((int)x,(int)y, colour);
<br/>
          
<br/>
      }
<br/>
   }
<br/>
}
<br/>
<br/>
<br/>
template &lt;class T&gt;
<br/>
void draw_line(T &amp;image, POINT p1, POINT p2, COLOUR color) {
<br/>
   int x = p1.get_x();
<br/>
   int y = p1.get_y();
<br/>
   
<br/>
   int x2 = p2.get_x();
<br/>
   int y2 = p2.get_y();
<br/>
<br/>
    int w = x2 - x ;
<br/>
    int h = y2 - y ;
<br/>
    int dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0 ;
<br/>
    if (w&lt;0) dx1 = -1 ; else if (w&gt;0) dx1 = 1 ;
<br/>
    if (h&lt;0) dy1 = -1 ; else if (h&gt;0) dy1 = 1 ;
<br/>
    if (w&lt;0) dx2 = -1 ; else if (w&gt;0) dx2 = 1 ;
<br/>
    int longest = ABS(w) ;
<br/>
    int shortest = ABS(h) ;
<br/>
    if (!(longest&gt;shortest)) {
<br/>
        longest = ABS(h) ;
<br/>
        shortest = ABS(w) ;
<br/>
        if (h&lt;0) dy2 = -1 ; else if (h&gt;0) dy2 = 1 ;
<br/>
        dx2 = 0 ;            
<br/>
    }
<br/>
    int numerator = longest &gt;&gt; 1 ;
<br/>
    for (int i=0;i&lt;=longest;i++) {
<br/>
        image.set_pixel(x,y,color) ;
<br/>
        numerator += shortest ;
<br/>
        if (!(numerator&lt;longest)) {
<br/>
            numerator -= longest ;
<br/>
            x += dx1 ;
<br/>
            y += dy1 ;
<br/>
        } else {
<br/>
            x += dx2 ;
<br/>
            y += dy2 ;
<br/>
        }
<br/>
    }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-size: 9px; line-height: normal">Hope that helps!</span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
