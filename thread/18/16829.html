<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>inversing affine matrix inaccurate? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > inversing affine matrix inaccurate?</h2>
<div id="posts">
<div class="post">
    <h4>#169995 - vuurrobin - Fri Aug 21, 2009 1:58 am</h4>
    <div class="postbody"><span class="postbody">hello everybody,
<br/>
<br/>
because the ds hardware needs an inverse affine matrix instead of a normal affine matrix, I wanted to make an function that would inverse the matrix before storing it and some functions to get the normal matrix elements back. I used the inverse matrix formule on <a class="postlink" href="http://www.coranac.com/tonc/text/affine.htm" target="_blank">toncs affine matrix page</a>. 
<br/>
<br/>
it seems to work, but there seems to be some inaccuracy with the inverted matrix, and when inverting it back, the numbers are some points off. the axes also seems wrong. the y ax points down (which it should, according to tonc) but the x ax points to the left instead of the right. 
<br/>
<br/>
here is the code to invert the matrix:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/**
<br/>
    @brief Allows you to directly sets the affine transformation matrix.
<br/>
<br/>
    with this, you have more freedom to set the matrix, but it might be more difficult to use if
<br/>
    you're not used to affine transformation matrix.
<br/>
    this function will invert the matrix so it will work correctly with the hardware.
<br/>
<br/>
 * @param hdx   the 1st matrix value, in .8 fixed point format.
<br/>
 * @param vdx   the 2nd matrix value, in .8 fixed point format.
<br/>
 * @param hdy   the 3th matrix value, in .8 fixed point format.
<br/>
 * @param vdy   the 4th matrix value, in .8 fixed point format.
<br/>
<br/>
    @return a reference to the object, so you can chain multiple commands.
<br/>
 */
<br/>
inline AffineMatrix&amp; setAffineTransformation(const int hdx, const int vdx, const int hdy, const int vdy)
<br/>
{
<br/>
   register int temp = (((hdx*vdy) &gt;&gt; FIX_SHIFT) - ((vdx*hdy) &gt;&gt; FIX_SHIFT));
<br/>
                temp = ((FIX_VALUE_1 * FIX_SCALE) / temp);
<br/>
<br/>
   this-&gt;hdx = (temp * vdy)  &gt;&gt; FIX_SHIFT;
<br/>
   this-&gt;hdy = (temp * -vdx) &gt;&gt; FIX_SHIFT;
<br/>
   this-&gt;vdx = (temp * -hdy) &gt;&gt; FIX_SHIFT;
<br/>
   this-&gt;vdy = (temp * hdx)  &gt;&gt; FIX_SHIFT;
<br/>
<br/>
   return *this;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
where FIX_VALUE_1 and FIX_SCALE is (1&lt;&lt;8) and FIX_SHIFT is 8.
<br/>
and this is the code to invert one of the values back to its original:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/**
<br/>
    @brief returns the 1st value of the affine matrix.
<br/>
<br/>
    @return the 1st value of the affine matrix, in .8 fixed point format.
<br/>
*/
<br/>
inline const int gettesthdx() const
<br/>
{
<br/>
    register int temp = (((hdx*vdy) &gt;&gt; FIX_SHIFT) - ((vdx*hdy) &gt;&gt; FIX_SHIFT));
<br/>
                temp = ((FIX_VALUE_1 * FIX_SCALE) / temp);
<br/>
<br/>
    return (temp * vdy) &gt;&gt; FIX_SHIFT;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
does anybody sees a mistake that could explain the wrong ax, or a way to increase the accuracy so the points are more acurate? (maybe using more bits for the fixed point)
<br/>
<br/>
<br/>
I've also created a program to test this, if anybody is interesting:
<br/>
<br/>
<a href="http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix.zip" target="_blank">http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix.zip</a>
<br/>
(copy-paste to the adress balk if clicking it doesn't work)
<br/>
<br/>
the first 4 values are the normal affine matrix, which you can change with the ABXY and directional keys.
<br/>
<br/>
the second 4 is the inverse matrix, which the hardware uses. 
<br/>
<br/>
the last value is one of the matrix values inverted back. this should be equal to the first value, but sometimes it is off.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170003 - TwentySeven - Fri Aug 21, 2009 9:04 am</h4>
    <div class="postbody"><span class="postbody">If the matrixes you're feeding in are orthagonal the inverse is equal to the transpose.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170004 - Cearn - Fri Aug 21, 2009 10:52 am</h4>
    <div class="postbody"><span class="postbody">Don't  shift down so soon. Do the calculations in as high a precision as you can. This will increase the accuracy. There's also no real need for const here because ints are passed by value, and on ARM systems the register keyword is more or less useless because there's no other place for operands to be.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline AffineMatrix&amp; setAffineTransformation(int hdx, int vdx, int hdy, int vdy)
<br/>
{
<br/>
   int det= hdx*vdy - vdx*hdy;   // Q16
<br/>
   int invdet = 0x1000000 / det;  // Q8
<br/>
<br/>
   this-&gt;hdx = (invdet * vdy)  &gt;&gt; FIX_SHIFT;
<br/>
   this-&gt;hdy = (invdet * -vdx) &gt;&gt; FIX_SHIFT;
<br/>
   this-&gt;vdx = (invdet * -hdy) &gt;&gt; FIX_SHIFT;
<br/>
   this-&gt;vdy = (invdet * hdx)  &gt;&gt; FIX_SHIFT;
<br/>
<br/>
   return *this;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
This should be a little better, but you're always going to have a little offset. You're going to have to round off at some point, and that's where errors creep in. Where possible, use the direct matrices, rather than going through an inverse function.
<br/>
<br/>
As far as I can see, the axes are fine. With a 45· rotation to the left, <span style="font-weight: bold">h</span>=(1,-1)/√2 and <span style="font-weight: bold">v</span>=(1,1)√2. That is to say, <span style="font-weight: bold">h</span> points to top-right and <span style="font-weight: bold">v</span> to bottom-right. There is something odd about the numbers of the second matrix though. for a rotation, the minus sign should be in the other diagonal. The matrix in OAM is correct though.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170017 - vuurrobin - Fri Aug 21, 2009 10:56 pm</h4>
    <div class="postbody"><span class="postbody">I know that const and register isn't needed there, but I like to put there anyway. tells more about my code. 
<br/>
<br/>
your code does work, with more precision, but I've tried a different, more basic way of inversing the matrix. I'm not sure if its correct, or works with all 2*2 matrices, but it seems to work correctly:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">this-&gt;hdx = (-(hdx-FIX_VALUE_1)) + FIX_VALUE_1;
<br/>
this-&gt;hdy = -vdx;
<br/>
this-&gt;vdx = -hdy;
<br/>
this-&gt;vdy = (-(vdy-FIX_VALUE_1)) + FIX_VALUE_1;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
there are still some problems with it when trying to flip the image (it flips with 768, instead of -256), and I still think that one of the axes is wrong. when I increase vdx, the top part of the image go's to the left, instead of the right. which means that the ax points left...
<br/>
<br/>
the inverse of the identity matrix is exactly itself, right? does that also aply to this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
[[-1,  0]
<br/>
 [ 0, -1]]
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I've created another program with the second approach:
<br/>
<a href="http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix2.zip" target="_blank">http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix2.zip</a>
<br/>
(again, copy-paste to the adress balk if clicking it doesn't work)
<br/>
<br/>
it seems to work correctly, and the last value is exactly like the first value, which means converting and converting back is accurate.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">There is something odd about the numbers of the second matrix though. ... The matrix in OAM is correct though.</td> </tr></table><span class="postbody">
<br/>
<br/>
that doesn't make much sense, seeing as the second matrix is the one that is directly set into OAM.
<br/>
<br/>
EDIT: there is another problem with this method, causing the image to scale 2 times when the value is 384 instead of 512. will try to fix it later.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170018 - Cearn - Sat Aug 22, 2009 10:29 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">I know that const and register isn't needed there, but I like to put there anyway. tells more about my code. </td> </tr></table><span class="postbody">
<br/>
Fair enough. But remember that in general, less cruft makes code more readable.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">your code does work, with more precision, but I've tried a different, more basic way of inversing the matrix. I'm not sure if its correct, or works with all 2*2 matrices, but it seems to work correctly:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">this-&gt;hdx = (-(hdx-FIX_VALUE_1)) + FIX_VALUE_1;
<br/>
this-&gt;hdy = -vdx;
<br/>
this-&gt;vdx = -hdy;
<br/>
this-&gt;vdy = (-(vdy-FIX_VALUE_1)) + FIX_VALUE_1;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
there are still some problems with it when trying to flip the image (it flips with 768, instead of -256) 
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
This method doesn't work. Or, rather, it will work for some matrices, but not all. The definition of the inverse matrix <span style="font-weight: bold">A</span> is the matrix that, when multiplied with <span style="font-weight: bold">A</span> results in <span style="font-weight: bold">I</span> : <span style="font-weight: bold">A</span>[sup]-1[/sup]*<span style="font-weight: bold">A</span> = <span style="font-weight: bold">I</span>. For the general case, this will require division by the determinant.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
and I still think that one of the axes is wrong. when I increase vdx, the top part of the image go's to the left, instead of the right. which means that the ax points left...</td> </tr></table><span class="postbody">
<br/>
That depends on which vdx you're referring to. It might be better not to use the same terms for different matrices. Say that the forward transformation is given by axes <span style="font-weight: bold">A</span>=[<span style="font-weight: bold">a b</span>], with <span style="font-weight: bold">a</span>=(ax, ay) and <span style="font-weight: bold">b</span>=(bx, by) and the inverse by <span style="font-weight: bold">P</span>=[<span style="font-weight: bold">h v</span>]. If <span style="font-style: italic">bx</span> (which I assume you're referring to here) increases, the point for <span style="font-weight: bold">b</span> moves right. However, since <span style="font-weight: bold">b</span> points downward, you really need to look at the bottom-left point, not the top-left.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
    |                            \
<br/>
    |                             \
<br/>
    |                              \
<br/>
-------------&gt; a (1,0)          ----------&gt; a (1,0)  
<br/>
    |                                \
<br/>
    |                     ---\        \
<br/>
    |                     ---/         \
<br/>
    |                                   \
<br/>
    V  b (0,1)                          _\| b (1,1)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
the inverse of the identity matrix is exactly itself, right? does that also aply to this:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
[[-1,  0]
<br/>
 [ 0, -1]]
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody"> Yes in both cases. <span style="font-weight: bold">I</span>*<span style="font-weight: bold">I</span> = <span style="font-weight: bold">I</span> and (-<span style="font-weight: bold">I</span>)*(-<span style="font-weight: bold">I</span>) = (-1*-1)*(<span style="font-weight: bold">I</span>*<span style="font-weight: bold">I</span>) = <span style="font-weight: bold">I</span>.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I've created another program with the second approach:
<br/>
<a href="http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix2.zip" target="_blank">http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix2.zip</a>
<br/>
(again, copy-paste to the adress balk if clicking it doesn't work)
<br/>
<br/>
it seems to work correctly, and the last value is exactly like the first value, which means converting and converting back is accurate.
<br/>
EDIT: there is another problem with this method, causing the image to scale 2 times when the value is 384 instead of 512. will try to fix it later.</td> </tr></table><span class="postbody">
<br/>
The second demo does not seem to be following the equations you gave earlier. The demo handles shears fine (with vdx = - <span style="font-style: italic">bx</span>), but the equations have vdx = -ay, which isn't right.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">There is something odd about the numbers of the second matrix though. ... The matrix in OAM is correct though.</td> </tr></table><span class="postbody">
<br/>
<br/>
that doesn't make much sense, seeing as the second matrix is the one that is directly set into OAM.</span></td> </tr></table><span class="postbody">
<br/>
I think the error may be in printing the matrix. It seems hdy and vdx are switched.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170021 - vuurrobin - Sun Aug 23, 2009 1:54 am</h4>
    <div class="postbody"><span class="postbody">here is the fixed version of my method:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">this-&gt;hdx = (FIX_VALUE_1&lt;&lt;8) / hdx;
<br/>
this-&gt;vdy = (FIX_VALUE_1&lt;&lt;8) / vdy;
<br/>
this-&gt;hdy = -vdx;
<br/>
this-&gt;vdx = -hdy;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm still not sure if this is correct, but is seems correct to me. its at least better than my last attempt (which was just wrong), and the accuracy of inverting it back is also pretty good. 
<br/>
<br/>
I've created another program (again) with this method:
<br/>
<a href="http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix3.zip" target="_blank">http://vuurrobin.100webcustomers.com/stuff/changingAffineMatrix3.zip</a>
<br/>
this program prints the entire 3th matrix, which should be equal to the first (although there are some presicion errors). I've also implemented flipping the sprite horizontally and vertically using an affine matrix (cause hardware flipping can't be used when using an affine matrix). you can flip it with start and select. also, touching the screen will reset the matrix to the identity matrix. 
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">However, since b points downward, you really need to look at the bottom-left point, not the top-left. </td> </tr></table><span class="postbody">
<br/>
<br/>
ack, I mixed the axes up. that would explain it. sorry, my bad.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I think the error may be in printing the matrix. It seems hdy and vdx are switched.</td> </tr></table><span class="postbody">
<br/>
<br/>
I double-checked it, and printing the matrix seems correct. I also checked the rest of the code, in case I was switching function parameters or something, but that also seem fine. as far as I can tell, the second matrix on screen is the matrix in OAM.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170022 - Cearn - Sun Aug 23, 2009 11:16 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">here is the fixed version of my method:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">this-&gt;hdx = (FIX_VALUE_1&lt;&lt;8) / hdx;
<br/>
this-&gt;vdy = (FIX_VALUE_1&lt;&lt;8) / vdy;
<br/>
this-&gt;hdy = -vdx;
<br/>
this-&gt;vdx = -hdy;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm still not sure if this is correct, but is seems correct to me. its at least better than my last attempt (which was just wrong), and the accuracy of inverting it back is also pretty good. 
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
I'm sorry, but no. I think what you're trying to do is look at the elements individually -- to see if, when you plug-in the numbers, you get the old matrix back:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
| a  b | -&gt;  | (1/a)  -c   |  -&gt;  | 1/(1/a)   -(-b)    |  = | a  b |
<br/>
| c  d |     |   -b  (1/d) |      |  -(-c)    1/(1/d)  |    | c  d |
<br/>
</td> </tr></table><span class="postbody">
<br/>
This isn't how matrix inverses work. Matrix inverses look at matrix multiplications, specifically, if you have matrices <span style="font-weight: bold">A</span> and <span style="font-weight: bold">B</span> for which <span style="font-weight: bold">A</span>*<span style="font-weight: bold">B</span> = <span style="font-weight: bold">I</span> holds, then <span style="font-weight: bold">A</span> and <span style="font-weight: bold">B</span> are each other's inverses. If you multiply the matrices you have now, you get
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">| (1/a)  -c   |*| a  b |  = | ( a/a-cc) ( b/a-cd) |  = | (1-c²)  (b/a-cd) |
<br/>
|   -b  (1/d) | | c  d |    | (-ab+c/d) (-bb+d/d) |    | (c/d-ab)  (1-b²) |
<br/>
</td> </tr></table><span class="postbody">
<br/>
If b and c are 0 it'll work, but otherwise it won't. 
<br/>
You can also see it by trying out a scale + rotate, say R(45°)S(2,1). In Q8, that should be: 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">A = | 362  181 |    A^-1 = |  90   -90 |
<br/>
    | -362 181 |           | 181   181 |
<br/>
</td> </tr></table><span class="postbody">
<br/>
While the "test" matrix gives back the original matrix, the actual transformation is not what it should be.
<br/>
<br/>
The correct form of the inverse is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">A = | a  b |
<br/>
    | c  d |
<br/>
<br/>
D = ad-bc
<br/>
<br/>
P = | hx  vx |  = A^-1 =  |  d  -b | * 1/D
<br/>
    | hy  vy |            | -c   a | 
<br/>
</td> </tr></table><span class="postbody">
<br/>
This is pretty much what you had in the OP, except that there you had <span style="font-style: italic">vx</span> and <span style="font-style: italic">hy</span> swapped. I think the problem may be in the class definition itself.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vurrrobin wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I think the error may be in printing the matrix. It seems hdy and vdx are switched.</td> </tr></table><span class="postbody">
<br/>
I double-checked it, and printing the matrix seems correct. I also checked the rest of the code, in case I was switching function parameters or something, but that also seem fine. as far as I can tell, the second matrix on screen is the matrix in OAM.</span></td> </tr></table><span class="postbody">
<br/>
Run any of the programs in Desmume (0.9.4) and vary <span style="font-style: italic">hy</span> : 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
| 256   0 |
<br/>
|  hy  256 |
<br/>
</td> </tr></table><span class="postbody">
<br/>
Open the ARM9 memory viewer, goto 07000000 and set it to 16-bit. You should see the matrix in the 4th and 8th column. When you move <span style="font-style: italic">hy</span>, you'll see the 3th matrix element change. This is how it should be. However, in the 'raw' matrix on screen, it's the second element (rawvdx) that changes. This is what I meant when I said something's off in the debug prints.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170026 - vuurrobin - Mon Aug 24, 2009 12:13 am</h4>
    <div class="postbody"><span class="postbody">I think I've found the problem. from what I can see in gbatek and tonc, the parameters should come in this order in memory: hdx, vdx, hdy, vdy. but libnds has this in sprite.h:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/**
<br/>
 * @struct SpriteRotation
<br/>
 * @brief A sprite rotation entry
<br/>
 */
<br/>
typedef struct {
<br/>
  uint16 filler1[3]; /**&lt; Unused! Filler for the sprite entry attributes which overlap these */
<br/>
  int16 hdx;       /**&lt; The change in x per horizontal pixel */
<br/>
<br/>
  uint16 filler2[3];  /**&lt; Unused! Filler for the sprite entry attributes which overlap these */
<br/>
  int16 hdy;        /**&lt; The change in y per horizontal pixel */
<br/>
<br/>
  uint16 filler3[3];  /**&lt; Unused! Filler for the sprite entry attributes which overlap these */
<br/>
  int16 vdx;        /**&lt; The change in x per vertical pixel */
<br/>
<br/>
  uint16 filler4[3];  /**&lt; Unused! Filler for the sprite entry attributes which overlap these */
<br/>
  int16 vdy;         /**&lt; The change in y per vertical pixel */
<br/>
  
<br/>
} SpriteRotation, * pSpriteRotation;</td> </tr></table><span class="postbody">
<br/>
<br/>
I think int16 hdy and int16 vdx should be switched here. this also means that I overcompensated to get the values in oam right so that the values on screen were wrong. if someone can confirm this, then I'll post it in the bug report section of the devkitPro forums so it can be fixed with the next libnds version. 
<br/>
<br/>
<br/>
as for what I am doing, I'm trying to create a function that takes an affine matrix as how an human would see it, and put it in OAM in such a way that the image on screen will look like how the human will think it looks. this is useally done by inversing the matrix (which is what I first did), but then I tried to do it without inversing the matrix (which seemed more complicated than nessisary) to get a better accuracy and to make it easier for the human. if ? decide that axes pointing up-right instead of bottom-right is easier, than I will change the function like that (and document it of course). if the matrix in OAM isn't the inverse of the matrix entered by the human, or the formula won't work on all matricen, then thats fine by me. I'm sorry if this wasn't clear (although it wasn't really clear to me to at first)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
