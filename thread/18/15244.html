<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>sprite rotation problem. - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > sprite rotation problem.</h2>
<div id="posts">
<div class="post">
    <h4>#152898 - ben0bi - Sat Mar 22, 2008 11:14 am</h4>
    <div class="postbody"><span class="postbody">i copy/pasted some tutorial code and created a simple sprite engine for me.
<br/>
<br/>
now the problem is, rotating the first sprite affects ALL sprites while rotating the "second" sprite does not work.
<br/>
<br/>
i do not know what memory magic i (again) have to use, to make this work.
<br/>
<br/>
short: i can only rotate the first sprite, all other sprites are rotated in the same direction. it changes ALL sprites, not only the ones with the same picture....
<br/>
<br/>
here is my code, it is much again, but i really dont know where to search for this rotating stuff:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
a=new CSpriteImageInfo; a-&gt;Initialize(orangeShuttleTilesLen,orangeShuttleTiles,orangeShuttlePalLen,orangeShuttlePal,OBJSIZE_64);
<br/>
b=new CSpriteImageInfo; b-&gt;Initialize(moonTilesLen,moonTiles,moonPalLen,moonPal,OBJSIZE_32);
<br/>
<br/>
<br/>
int shuttleId=m_Sprites.CreateSprite(a,10,10,300);
<br/>
int shuttleId2=m_Sprites.CreateSprite(a,100,10,100);
<br/>
int moonId=m_Sprites.CreateSprite(b,50,10,100);
<br/>
<br/>
------------------------------------------------------------------
<br/>
<br/>
typedef struct{
<br/>
   bool used;
<br/>
    int oamId;
<br/>
    int width;
<br/>
    int height;
<br/>
    int angle;
<br/>
    SpriteEntry * entry;
<br/>
} SpriteInfo;
<br/>
<br/>
class CSpriteImageInfo
<br/>
{
<br/>
protected:
<br/>
   static int               m_iNEXTTILEMEMADRESS;
<br/>
   int                     m_iTilesLen;
<br/>
   int                     m_iPalLen;
<br/>
   int                     m_iTileMemAdress;
<br/>
<br/>
   const unsigned int         *m_pTiles;
<br/>
<br/>
   const short unsigned int   *m_pPalette;
<br/>
   tObjSize               m_objectSize;
<br/>
<br/>
public:
<br/>
   void CreateMemAdress()                  
<br/>
   {
<br/>
      m_iTileMemAdress=m_iNEXTTILEMEMADRESS;
<br/>
      m_iNEXTTILEMEMADRESS+=m_iTilesLen / OAM_BYTES_PER_16_COLOR_TILE;
<br/>
   }
<br/>
   static int GetNextAvailableMemAdress(void)   {return m_iNEXTTILEMEMADRESS;};
<br/>
   int GetMemAdress(void)                  {return m_iTileMemAdress;};
<br/>
   int GetTilesLen(void)                  {return m_iTilesLen;};
<br/>
   int GetPalLen(void)                     {return m_iPalLen;};
<br/>
   tObjSize GetObjSize(void)               {return m_objectSize;};
<br/>
   const unsigned int *GetTiles(void)         {return m_pTiles;};
<br/>
   const short unsigned int *GetPalette(void)   {return m_pPalette;};
<br/>
   
<br/>
   CSpriteImageInfo()
<br/>
   {
<br/>
      Initialize(0,NULL,0,NULL,OBJSIZE_8);
<br/>
      m_iTileMemAdress=-1;
<br/>
   }
<br/>
<br/>
   void Initialize(int imageLen,const unsigned int *imagePtr, int imagePalLen,const short unsigned int *imagePalette,tObjSize objSize)
<br/>
   {
<br/>
      m_iTilesLen=imageLen;
<br/>
      m_pTiles=imagePtr;
<br/>
      m_iPalLen=imagePalLen;
<br/>
      m_pPalette=imagePalette;
<br/>
      m_objectSize=objSize;
<br/>
   }
<br/>
};
<br/>
   int CreateSprite(CSpriteImageInfo *Image, int posX, int posY, int angle)
<br/>
   {
<br/>
      // eventually load the image/s to OAM if this has not happened before.
<br/>
      int iImageMemAdress=imageLoadToOAM(Image);
<br/>
      ////// first search an entry to use.
<br/>
      int emptyOAMID = -1;
<br/>
      for(int i=0;i&lt;SPRITE_COUNT;i++)
<br/>
      {
<br/>
         if(!m_SpriteInfo[i].used)
<br/>
         {
<br/>
            emptyOAMID=i;
<br/>
            break;
<br/>
         }
<br/>
      }
<br/>
      //// found an entry.
<br/>
      if(emptyOAMID!=-1)
<br/>
      {
<br/>
         printf("C\n");
<br/>
         int width=0;
<br/>
         int height=0;
<br/>
         switch(Image-&gt;GetObjSize())
<br/>
         {
<br/>
            case OBJSIZE_8:
<br/>
               width=height=8;
<br/>
               break;
<br/>
            case OBJSIZE_16:
<br/>
               width=height=16;
<br/>
               break;
<br/>
            case OBJSIZE_32:
<br/>
               width=height=32;
<br/>
               break;
<br/>
            case OBJSIZE_64:
<br/>
               width=height=64;
<br/>
               break;
<br/>
         }
<br/>
         SpriteInfo * sprInfo = &amp;m_SpriteInfo[emptyOAMID];
<br/>
         SpriteEntry * OAMEntry = &amp;oam-&gt;spriteBuffer[emptyOAMID];
<br/>
<br/>
         /* Initialize sprite info struct */
<br/>
         sprInfo-&gt;used=true;
<br/>
         sprInfo-&gt;oamId = emptyOAMID;
<br/>
         sprInfo-&gt;width = width;
<br/>
         sprInfo-&gt;height = height;
<br/>
         sprInfo-&gt;angle = angle;
<br/>
         sprInfo-&gt;entry = OAMEntry;
<br/>
<br/>
          /*
<br/>
         *  Configure attribute 0. 
<br/>
         *
<br/>
         *  OBJCOLOR_16 will make a 16-color sprite. We specify that we want an
<br/>
         *  affine sprite (via isRotoscale) here because we would like to rotate
<br/>
         *  the ship.
<br/>
         */
<br/>
         OAMEntry-&gt;posY = posY;
<br/>
         OAMEntry-&gt;posX = posX;
<br/>
         OAMEntry-&gt;isRotoscale = true;
<br/>
         /* This assert is a check to see a matrix is available to store the affine
<br/>
         * transformation matrix for this sprite. Of course, you don't have to have
<br/>
         * the matrix id match the affine id, but if you do make them match, this
<br/>
         * assert can be helpful. */
<br/>
         assert(!OAMEntry-&gt;isRotoscale || (sprInfo-&gt;oamId &lt; MATRIX_COUNT));
<br/>
         OAMEntry-&gt;rsDouble = false;
<br/>
         OAMEntry-&gt;objMode = OBJMODE_NORMAL;
<br/>
         OAMEntry-&gt;isMosaic = false;
<br/>
         OAMEntry-&gt;colMode = OBJCOLOR_16;
<br/>
         OAMEntry-&gt;objShape = OBJSHAPE_SQUARE;
<br/>
         /*
<br/>
         *  Configure attribute 1.
<br/>
         *
<br/>
         *  rsMatrixId refers to the location of affine transformation matrix. We
<br/>
         *  set it to a location computed with a macro. OBJSIZE_64, in our case
<br/>
         *  since we are making a square sprite, creates a 64x64 sprite.
<br/>
         */
<br/>
         OAMEntry-&gt;rsMatrixIdx = ATTR1_ROTDATA(sprInfo-&gt;oamId);
<br/>
         OAMEntry-&gt;objSize = Image-&gt;GetObjSize();//OBJSIZE_32;//OBJSIZE_64;
<br/>
<br/>
         /* 
<br/>
         *  Configure attribute 2.
<br/>
         * 
<br/>
         *  Configure which tiles the sprite will use, which priority layer it will
<br/>
         *  be placed onto, which palette the sprite should use, and whether or not
<br/>
         *  to show the sprite.
<br/>
         */
<br/>
         OAMEntry-&gt;tileIdx = iImageMemAdress;
<br/>
         OAMEntry-&gt;objPriority = OBJPRIORITY_0;
<br/>
         OAMEntry-&gt;objPal = sprInfo-&gt;oamId;
<br/>
<br/>
         /* Rotate the sprite */
<br/>
         spriteRotate(&amp;oam-&gt;matrixBuffer[sprInfo-&gt;oamId], sprInfo-&gt;angle);
<br/>
<br/>
         /*************************************************************************/
<br/>
<br/>
         /* Copy over the sprite palette */
<br/>
         dmaCopyHalfWords(OAM_SPRITE_DMA_CHANNEL,
<br/>
                     Image-&gt;GetPalette(),
<br/>
                     &amp;SPRITE_PALETTE[sprInfo-&gt;oamId *
<br/>
                                     OAM_COLORS_PER_PALETTE],
<br/>
               Image-&gt;GetPalLen());
<br/>
         
<br/>
         printf("-------------------------------\n");
<br/>
         printf("OAM ID: %i/%i (real)\n", emptyOAMID,sprInfo-&gt;oamId);
<br/>
         printf("TileMem    : %08x\nNextTileMem: %08x\n",Image-&gt;GetMemAdress(),Image-&gt;GetNextAvailableMemAdress());
<br/>
         return emptyOAMID;
<br/>
      }
<br/>
      return -1;
<br/>
   };
<br/>
<br/>
<br/>
   // returns the mem adress of the picture and sets it in the given struct.
<br/>
   // returns the same adress as bevore if it was loaded before.
<br/>
   int imageLoadToOAM(CSpriteImageInfo *Image)
<br/>
   {
<br/>
      if(Image-&gt;GetMemAdress()==-1)
<br/>
      {
<br/>
         printf("Not Existing\n");
<br/>
         // load the image to OAM.
<br/>
         /* Copy the sprite graphics to sprite graphics memory */
<br/>
         Image-&gt;CreateMemAdress();
<br/>
         dmaCopyHalfWords(OAM_SPRITE_DMA_CHANNEL,
<br/>
               Image-&gt;GetTiles(),
<br/>
                     &amp;SPRITE_GFX[Image-&gt;GetMemAdress() * OAM_MAINSPR_OFFSET_MULTIPLIER],
<br/>
                     Image-&gt;GetTilesLen());
<br/>
      }
<br/>
      return Image-&gt;GetMemAdress();
<br/>
   }
<br/>
<br/>
<br/>
void CSpriteEngine::spriteRotate(SpriteRotation *spriteRotation, u16 angle)
<br/>
{
<br/>
   s16 s = SIN[angle &amp; OAM_SPRITE_ANGLE_MASK]&gt;&gt;4;
<br/>
   s16 c = COS[angle &amp; OAM_SPRITE_ANGLE_MASK]&gt;&gt;4;
<br/>
<br/>
   spriteRotation-&gt;hdx=c;
<br/>
   spriteRotation-&gt;hdy=s;
<br/>
   spriteRotation-&gt;vdx=-s;
<br/>
   spriteRotation-&gt;vdy=c;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#152901 - Cearn - Sat Mar 22, 2008 12:02 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ben0bi wrote:</b></span></td> </tr> <tr> <td class="quote">i copy/pasted some tutorial code and created a simple sprite engine for me.
<br/>
<br/>
now the problem is, rotating the first sprite affects ALL sprites while rotating the "second" sprite does not work.
<br/>
<br/>
i do not know what memory magic i (again) have to use, to make this work.
<br/>
<br/>
short: i can only rotate the first sprite, all other sprites are rotated in the same direction. it changes ALL sprites, not only the ones with the same picture....
<br/>
<br/>
here is my code, it is much again, but i really dont know where to search for this rotating stuff:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
         OAMEntry-&gt;rsMatrixIdx = ATTR1_ROTDATA(sprInfo-&gt;oamId);
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
The ATTR<span style="font-style: italic">x</span>_ macros should only be used for full 16-bit attributes, not the named bitfields. Most of the macros shift the parameter so that it can be ORred into the attribute. With bitfields this shifting is done automatically ; you just write the number directly. If you use the shifted form for a bitfield, you'd probably get 0 as the result.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">objId= 1;                       // Object index 1
<br/>
mtxId= ATTR1_ROTDATA(objId);    // mtxId= 1&lt;&lt;9 = 0x0200
<br/>
obj-&gt;rsMatrixIdx= mtxId;        // Set object's matrix id to (0x0200&amp;31) = 0.
<br/>
                                //   Oops.</td> </tr></table><span class="postbody">
<br/>
<br/>
Also, be aware that there are only 32 matrices, but 128 object slots. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ben0bi wrote:</b></span></td> </tr> <tr> <td class="quote">here is my code, it is much again, but i really dont know where to search for this rotating stuff: </td> </tr></table><span class="postbody">Much of the NDS is similar or identical to the GBA. For overlapping parts, read <a class="postlink" href="http://www.coranac.com/tonc/text/" target="_blank">Tonc</a>. For everything else, go to <a class="postlink" href="http://nocash.emubase.de/gbatek.htm" target="_blank">GBATek</a>. If you're completely new, the GBA might be a better starting point, as the tools and tutorials are more mature.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ben0bi wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
         switch(Image-&gt;GetObjSize())
<br/>
         {
<br/>
            case OBJSIZE_8:
<br/>
               width=height=8;
<br/>
               break;
<br/>
            case OBJSIZE_16:
<br/>
               width=height=16;
<br/>
               break;
<br/>
            case OBJSIZE_32:
<br/>
               width=height=32;
<br/>
               break;
<br/>
            case OBJSIZE_64:
<br/>
               width=height=64;
<br/>
               break;
<br/>
         }
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
Note that this code will only work for square objects. For tall and wide objects, not only will the width and height be different, but the number in the OBJ_SIZE_ macro won't correspond to the actual dimensions. A better strategy to get the object's pixel sizes would be to create a look-up table and simply look them up, rather than use a switch-block.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// Usage: 
<br/>
// oam_sizes[shape][size][0] is width
<br/>
// oam_sizes[shape][size][1] is height
<br/>
const u8 oam_sizes[3][4][2]=
<br/>
{
<br/>
    { { 8, 8}, {16,16}, {32,32}, {64,64} }, 
<br/>
    { {16, 8}, {32, 8}, {32,16}, {64,32} },
<br/>
    { { 8,16}, { 8,32}, {16,32}, {32,64} },
<br/>
};</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#152916 - silent_code - Sat Mar 22, 2008 4:58 pm</h4>
    <div class="postbody"><span class="postbody">benobi, cearn's the man!
<br/>
but if you'd like, send me your code, i'll setup my nds dev env. today and check it out. i remember having odd sprite rotations myself (shearing and the like), but that was due to sh***y tutorials! tonc really gets it to the point.
<br/>
<br/>
again, if you'd like, i pm'ed you an offer to help. :^)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
