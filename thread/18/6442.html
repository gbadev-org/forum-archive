<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Thumb instructions on Nintendo DS? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Thumb instructions on Nintendo DS?</h2>
<div id="posts">
<div class="post">
    <h4>#49244 - sajiimori - Wed Jul 27, 2005 7:23 pm</h4>
    <div class="postbody"><span class="postbody"><span style="font-style: italic">split from a topic about <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=49243#49243" target="_blank">Lua</a></span>
<br/>
<br/>
Don't use thumb at all on DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49288 - ChronoDK - Thu Jul 28, 2005 7:27 am</h4>
    <div class="postbody"><span class="postbody">I got it working without errors now, but is still using thumb - why should I not compile for thumb-interworking sajimori?
<br/>
<br/>
I am only testing on iDeaS, so there is no guarentee it is really working...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49310 - wintermute - Thu Jul 28, 2005 12:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Don't use thumb at all on DS.</td> </tr></table><span class="postbody">
<br/>
<br/>
There's absolutely no reason why you shouldn't use thumb on DS. The main RAM is 16bit which gives ARM code a slight disadvantage as per GBA.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49326 - sajiimori - Thu Jul 28, 2005 6:15 pm</h4>
    <div class="postbody"><span class="postbody">Inner loops will be cached on the CPU after a single iteration so ARM will be faster.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49328 - Mighty Max - Thu Jul 28, 2005 6:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Inner loops will be cached on the CPU after a single iteration so ARM will be faster.</td> </tr></table><span class="postbody">
<br/>
<br/>
Thats not quite the point of using thumb instructions.
<br/>
<br/>
The abilities of thumb are a bit limited (parameter as well as opcode wise) and therefor requires less resources, that might result in less cycles per operation, and/or used logical gates.
<br/>
<br/>
Thumb has the advantage of: 
<br/>
- One cycle of opcode read in 16bit mem environment still matters when reading code without loops that fits into the cache.
<br/>
- The double amount of instructions can be cached and predicted.
<br/>
- power saving
<br/>
- memory saving through shorter opcodes
<br/>
It might as well increase the used pipes, but ... i don't know how N designed the cores.
<br/>
<br/>
The big disadvantage is mainly the reduced instruction set and parameter size, so that you probably need more instruction for the same computation.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49355 - ector - Fri Jul 29, 2005 1:24 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mighty Max wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Inner loops will be cached on the CPU after a single iteration so ARM will be faster.</td> </tr></table><span class="postbody">
<br/>
<br/>
Thats not quite the point of using thumb instructions.
<br/>
<br/>
The abilities of thumb are a bit limited (parameter as well as opcode wise) and therefor requires less resources, that might result in less cycles per operation, and/or used logical gates.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
This is definitely wrong. THUMB is implemented as a very simple instruction unpacker that expands the THUMB instructions out to the corresponding full ARM instruction before feeding into the CPU.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49358 - sajiimori - Fri Jul 29, 2005 1:43 am</h4>
    <div class="postbody"><span class="postbody">Yes.  I must warn readers that Max's post consisted of speculation, backwards thinking, and misinformation.
<br/>
<br/>
Wintermute was overstating by saying there's <span style="font-style: italic">no</span> reason not to use Thumb, but at least he had his facts straight.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49383 - Mighty Max - Fri Jul 29, 2005 7:11 am</h4>
    <div class="postbody"><span class="postbody">I have to correct myself is the "It might" part as that was real specualtion, the rest is as it is.
<br/>
<br/>
I might misread ARM's architecture documents, but afaik the translation of the 16 to 32 bit opcodes are not done precache, but in the pipe. That leaves the cache and read arguments valid.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Arm.com wrote:</b></span></td> </tr> <tr> <td class="quote">A "Thumb-aware" core is a standard ARM processor fitted with a Thumb decompressor in the instruction pipeline. </td> </tr></table><span class="postbody">
<br/>
<br/>
As the thumb still is only a subset of ARM the point of less resource usage and power saving stays valid, may i quote arm itself again
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Thumb offers the designer<ul>[...]<li>Industry-leading MIPS/Watt for maximum battery life and RISC performance</li></ul></td> </tr></table><span class="postbody">
<br/>
<br/>
And i don't think that the arm core designers did not optimize it that if an opcode can't have the full range of variations (a translated thumb instruction) uses all the components and steps a full range instruction would do. I.e. generally missing adds within multiply instruction
<br/>
<br/>
<br/>
<br/>
<br/>
PS: sajiimori: If you have doubts or problems with my posts, please address ME. I am not a third imaginary person here and can (unlike you?) make errors and have the ability to correct me in this case. Thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49423 - sajiimori - Fri Jul 29, 2005 6:05 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, you're right.  I tried to sum up the things that were wrong with your post, but I couldn't find anything that really captured it.  The whole thing seems to be based on this idea that since you can have twice the number of instructions, it must be faster.  If you'd actually check some benchmarks, you'd know better.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49432 - tepples - Fri Jul 29, 2005 6:50 pm</h4>
    <div class="postbody"><span class="postbody">Each ARM instruction would have to do the work of at least two Thumb instructions in order for ARM to be faster than Thumb from the same 16-bit memory. This is likely only if you're doing a lot of shifting and/or a lot of conditional execution.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49440 - sajiimori - Fri Jul 29, 2005 7:18 pm</h4>
    <div class="postbody"><span class="postbody">Right, but you only run from 16 bit memory on the first pass through a loop (unless your inner loop is over 8K in which case you might consider refactoring).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49479 - dXtr - Sat Jul 30, 2005 1:19 am</h4>
    <div class="postbody"><span class="postbody">I think I see a thumb war coming up ^^
<br/>
<a href="http://www.digitallyobsessed.com/cover_art/thumbwars.jpg">[Images not permitted - Click here to view it]</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49481 - sajiimori - Sat Jul 30, 2005 1:50 am</h4>
    <div class="postbody"><span class="postbody">Deku will save us all!  I have faith.  :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49484 - DekuTree64 - Sat Jul 30, 2005 2:58 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Deku will save us all!  I have faith.  :P</td> </tr></table><span class="postbody">
<br/>
*pops out from shadows*
<br/>
Fine, fine :P 
<br/>
There's NO difference in speed between a decoded THUMB instruction and the equivalent ARM instruction. 
<br/>
<br/>
I don't know about power consumption, but THUMB would probably win most of the time because of less memory reads on a 16-bit bus. 
<br/>
<br/>
On the DS though, ARM might win because you can get more work done with instruction, and once they're in the cache, you have 32-bit reads. I don't know how cache compares to main RAM in terms of power, but I'd guess it takes less since it's part of the CPU itself.
<br/>
<br/>
<br/>
THUMB is still good for non loop-heavy game code that won't get much benefit from the cache, and doesn't need to be fast anyway. No point in wasting main RAM on ARM code where it's not necessary.
<br/>
<br/>
Max's comment about fitting twice as many instructions into the cache is valid, but since it generally takes more THUMB instructions to do the same amount of work, and generally an inner loop will fit entirely in the cache even as ARM code, ARM will win.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#49607 - torne - Sun Jul 31, 2005 9:40 pm</h4>
    <div class="postbody"><span class="postbody">Just a few points to add:
<br/>
<br/>
1) Other than the reduced memory accesses, running in Thumb definately takes just as much power as running in ARM, if you are doing the same operations. The execution phase of the pipeline is not aware that the original was a Thumb instruction as the output from decode is the same whether the source is ARM or Thumb.
<br/>
<br/>
2) Thumb code generated by GCC is often slower than ARM code even taking 16-bit memory into account, even on platforms where the cache doesn't exist. This is because GCC is, well, crap at generating Thumb code. ARM's RVCT (RealView Compiler Toolkit) does substantially better, but is still not ideal - many segments of Thumb code produced by either GCC or RVCT can trivially be improved by anyone with a little assembly knowledge.
<br/>
<br/>
2a) Incidentally, yes, you can compile NDS or GBA stuff with RVCT if you have, well, paid the huge fees ARM demand for it. My work laptop has RVCT installed with a nodelock licence, so I tried it. You may need to write your own scatterload files as the GNU ld linkscript format is not compatible with armlink, but you can use the crt0.o from ndslib ok (though you can't *assemble* it with armasm because the syntax is different to GNU as). The resulting code is faster and smaller, in either ARM or Thumb mode. Oh, except where it's broken. My favourite RVCT bug is the way it ignores 'volatile' on long long quantities...
<br/>
<br/>
So, well, you might find it's faster to build everything as ARM anyway, and depend on the cache. Or, ideally, do explicit preloads into ITCM when you're not busy doing something else, say, during the vfill inbetween doing line params and mixing sounds.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#50614 - Ethos - Thu Aug 11, 2005 3:35 am</h4>
    <div class="postbody"><span class="postbody">Hmmm....not buying the ARM is better argument.
<br/>
<br/>
I wrote memcpy assembly routines that are extensively called over and over in both arm and thumb...and the thumb always wins speed wise.
<br/>
<br/>
Maybe I am missing the point...but I still see validity in programming in thumb.<br/>_________________<br/><a class="postlink" href="http://ethos.oddigytitanium.com" target="_blank">Ethos' Homepage (Demos/NDS 3D Tutorial)</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
