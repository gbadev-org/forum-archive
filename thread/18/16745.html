<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>getting angle and scale from any given affine matrix - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > getting angle and scale from any given affine matrix</h2>
<div id="posts">
<div class="post">
    <h4>#169312 - vuurrobin - Wed Jul 01, 2009 11:58 pm</h4>
    <div class="postbody"><span class="postbody">hello everybody,
<br/>
<br/>
is it possible to calculate the angle and scale from any given affine matrix? or is this only possible if you know for sure that the matrix is a rot/scale matrix and haven't sheared or anything.
<br/>
<br/>
I looked at tonc, but it only explains how to change an angle and scale to a matrix and not the other way around. I tried to do it myself, but I can't seem to wrap my mind around it, and google eather gives me links about 3d affine matrices, or a link to tonc.
<br/>
<br/>
<br/>
can somebody help me?
<br/>
<br/>
greets vuurrobin.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169313 - DensitY - Thu Jul 02, 2009 12:23 am</h4>
    <div class="postbody"><span class="postbody">I'm assuming you want from matrix to Euler coords (yaw, pitch, roll), in that case the following link should be useful.
<br/>
<br/>
<a href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToEuler/" target="_blank">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToEuler/</a>
<br/>
<br/>
Scale not so sure about when its been multiplied in, only got a 20 minute lunch break today :p</span><span class="gensmall"><br/><br/>Last edited by DensitY on Thu Jul 02, 2009 12:26 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#169314 - TwentySeven - Thu Jul 02, 2009 12:24 am</h4>
    <div class="postbody"><span class="postbody">You can pull euler angles back out of a orthagonal matrix, but it's complicated and slow.
<br/>
<br/>
Most 3d work treats matrixes as a derived, write-only product of some sort of "source" angle and position information, typically eulers or a quaternion.
<br/>
<br/>
The question is, I guess, why do you need to do this?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169315 - naleksiev - Thu Jul 02, 2009 12:51 am</h4>
    <div class="postbody"><span class="postbody">It is not possible from any affine matrix. If you use shearing the the coordinates aren't perpendicular anymore so you will loose the rotation. If you know that you sheared only one of the coordinates you can still get the rotation.
<br/>
<br/>
I didn't understand if you are interested in 2D or 3D matrices I'll try to  explain how to decompose 2D matrix hopefully you can do 3D yourself if you need.
<br/>
<br/>
First I haven't used 2D on DS so I don't know if the matrix is row or column based... I'll work with column based which looks like this
<br/>
Xx Xy
<br/>
Yx Yy
<br/>
If DS is using row based all the matrices need to be transposed.
<br/>
<br/>
The matrix I'm using is 2x2 which include only rotation and scale. In your case you might have translation as well so it will be 3x2
<br/>
Xx Xy
<br/>
Yx Yy
<br/>
Tx Ty
<br/>
<br/>
Why did I give such complex names to my cells? As you can see first and second columns have repeating capital letter which is X and Y. These are the vectors X and Y of your new coordinate system. Just make some transformation and try to draw vector X(Xx, Xy) and vector Y(Yx, Yy). 
<br/>
(I don't know how to explain this better without drawing it).
<br/>
<br/>
Now when you have the vectors X and Y you can just check their size to get the scale.
<br/>
<span style="font-weight: bold">scaleX = length(vec2(Xx, Xy));
<br/>
scaleY = length(vec2(Yx, Yy));</span>
<br/>
<br/>
For rotation you need to find out how much one of the vectors is rotated from it's original position which you can do by using arc tangent.
<br/>
<span style="font-weight: bold">rot = atn2(Xy, Xx)</span><br/>_________________<br/><a class="postlink" href="http://raynds.blogspot.com/" target="_blank">http://raynds.blogspot.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169316 - vuurrobin - Thu Jul 02, 2009 2:04 am</h4>
    <div class="postbody"><span class="postbody">I'm creating a library for the ds and you can set the affine matrix of a sprite by either setting the 4 matrix elements directly or by calling a function that will calculate it from a given angle and scale. I also wanted to return the angle, even if the user setted the elements on its own. 
<br/>
<br/>
its for 2d sprite transformation using a 2*2 matrix, so no 3d stuff.
<br/>
<br/>
<br/>
@DensitY
<br/>
I looked at the link for a bit, but I didn't understand most of it (I'm not that good at math, especially if its in a foreign language). I'll look at it in the morning and see is I can make something out of it. 
<br/>
<br/>
<br/>
@naleksiev
<br/>
I don't know if only 1 point has sheared if the user setted the matrix him/her self, so that wont work. however getting the scale is usefull, so thanks.
<br/>
<br/>
<br/>
thanks for the posts, everybody :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169321 - naleksiev - Fri Jul 03, 2009 12:34 am</h4>
    <div class="postbody"><span class="postbody">I finally got what you are trying to do. 
<br/>
<br/>
Either consider to detect that the matrix is sheared and show that to the user instead of angle and scale or show the sheared values.
<br/>
<br/>
I think you can assume that X isn't sheared and get it's rotation and scale. Then for Y compute shearing value, and scale.
<br/>
You will end up with <span style="font-weight: bold">scaleX, scaleY, rotation, shearY</span> parameters that you can show on the screen.
<br/>
<br/>
Or maybe another solution and my favorite is to show <span style="font-weight: bold">scaleX, scaleY, rotateX, rotateY</span>. Where you can have a separate rotation for X and Y. So for example if you crate rotation matrix on 30? the rotationX and rotationY will both show 30?. But if you shear Y so the angle between X and Y is 45? rotateX will be equal to 0 and rotateY will be -45? (because it's relative from it's original 90?)
<br/>
<br/>
You can accomplish this by using the explanation from my previews post. Just use
<br/>
<span style="font-weight: bold">rotX = atn2(Xy, Xx)
<br/>
rotY = atn2(Yy, Yx)</span><br/>_________________<br/><a class="postlink" href="http://raynds.blogspot.com/" target="_blank">http://raynds.blogspot.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169372 - Cearn - Mon Jul 06, 2009 7:37 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>naleksiev wrote:</b></span></td> </tr> <tr> <td class="quote">First I haven't used 2D on DS so I don't know if the matrix is row or column based... I'll work with column based which looks like this
<br/>
Xx Xy
<br/>
Yx Yy</td> </tr></table><span class="postbody">
<br/>
Since the vectors (capital X and Y) are in the rows, this matrix is actually row-based :P. 
<br/>
<br/>
The rest of your post(s) explains the concepts and steps well, but unfortunately, the GBA/NDS 2D transformation matrix works a little different.
<br/>
<br/>
The 2D matrix has 4 elements, referred to in gbatek as <span style="font-style: italic">pa</span>, <span style="font-style: italic">pb</span>, <span style="font-style: italic">pc</span>, <span style="font-style: italic">pd</span>. A 2x2 matrix contains 2 vectors that define the axes of transformation. Call these <span style="font-weight: bold">u</span>=(<span style="font-style: italic">ux</span>, <span style="font-style: italic">uy</span>) and <span style="font-weight: bold">v</span>= (<span style="font-style: italic">vx</span>, <span style="font-style: italic">vy</span>) <span style="color: blue">*</span>. The layout of the matrix is as follows:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">| pa  pb |  =  | ux  vx | 
<br/>
| pc  pd |     | uy  vy |
<br/>
</td> </tr></table><span class="postbody">
<br/>
This is a column-based matrix, although that's really just a matter of notation. What does matter is how <span style="font-weight: bold">u</span> and <span style="font-weight: bold">v</span> map onto <span style="font-style: italic">pa</span>-<span style="font-style: italic">pd</span>, and that the matrix is stored in memory by rows.
<br/>
<br/>
<span style="font-weight: bold">u</span> and <span style="font-weight: bold">v</span> are vectors like any other: they have a magnitude and a direction. So you have two lengths (scaling factors) and two angles (directional factors). So you have <span style="font-weight: bold">u</span>= ( <span style="font-style: italic">U</span>*cos(αu), <span style="font-style: italic">U</span>*sin(αu) ) and <span style="font-weight: bold">v</span>= ( <span style="font-style: italic">V</span>*cos(αv), <span style="font-style: italic">V</span>*sin(αv) ). In a rotation, <span style="font-weight: bold">u</span> and <span style="font-weight: bold">v</span> are perpendicular, so there's a 90 degree difference between angles αu and αv, which basically means that one of the sines and cosines swap and one of them gets a minus sign. Renaming the lengths to X and Y scales and relating the angles to some angle <span style="font-style: italic">a</span>, you get a matrix that looks something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">| ux  vx |  =  | Sx*cos(a)  -Sy*sin(a) |
<br/>
| uy  vy |     | Sx*sin(a)   Sy*cos(a) |
<br/>
</td> </tr></table><span class="postbody">
<br/>
And if you have this kind of matrix, you can calculate the <span style="font-style: italic">Sx</span>, <span style="font-style: italic">Sy</span> and <span style="font-style: italic">a</span> terms back from the lengths of the vectors and either an arccos, arcsin or arctan. This is basically what naleksiev said. The problem, however, is that <span style="font-weight: bold">it's the wrong matrix</span>.
<br/>
<br/>
If you just look at what you have on the screen, you can probably tell the principle axes of the transformation (and therefore the matrix). But the matrix you give to the hardware is the inverse of this (see the Tonc page and <a class="postlink" href="http://www.coranac.com/documents/geomatrix/#img-cotrans-inv" target="_blank">here</a> for details). There are still <span style="font-weight: bold">u</span> and <span style="font-weight: bold">v</span> vectors, but they're vectors in a different space. If the result on screen looks like a Scale-then-Rotate operation, what you need to issue is something like this
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">| ux  vx |  =  |  Sx*cos(a)   Sx*sin(a) |
<br/>
| uy  vy |     | -Sy*sin(a)   Sy*cos(a) |
<br/>
</td> </tr></table><span class="postbody">
<br/>
Note that these <span style="font-style: italic">Sx</span> and <span style="font-style: italic">Sy</span> are actually different than the ones used before: in this case they're shrink-factors rather than enlargements.
<br/>
<br/>
<br/>
You can still get the scales and angle back, but now it's 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">tan(a) = vx/ux                               -&gt;  a = atan2(ux, vx)
<br/>
ux² + vx² = Sx²*( cos²(a)+sin²(a) ) = Sx²    -&gt; Sx = sqrt(ux² + vx²)
<br/>
uy² + vy² = Sy²*(-sin²(a)+cos²(a) ) = Sy²    -&gt; Sy = sqrt(uy² + vy²)</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>vuurrobin wrote:</b></span></td> </tr> <tr> <td class="quote">I'm creating a library for the ds and you can set the affine matrix of a sprite by either setting the 4 matrix elements directly or by calling a function that will calculate it from a given angle and scale. I also wanted to return the angle, even if the user set the elements on its own. </td> </tr></table><span class="postbody">
<br/>
In trying something like this, be <span style="font-style: italic">very</span> careful how you define your terms and what you want to get out of it. Dealing with matrices can be troublesome on its own, but when you're really working with <span style="font-style: italic">inverse</span> transformation matrices, things can get really hairy. 
<br/>
<br/>
Think about this. If you use the following matrix:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">| 2&lt;&lt;8  0    |
<br/>
| 0     1&lt;&lt;8 |</td> </tr></table><span class="postbody">
<br/>
This causes a horizontal scaling of the sprite. However, it doesn't scale by 2; it shrinks by 1/2. If you want to be able to reproduce the matrix, returning scale==2&lt;&lt;8 would be appropriate. If you want to be able to 
<br/>
do some sort of math with it (for collisions, for example), you'd need to return 1/2&lt;&lt;8.
<br/>
<br/>
Another thing is that there are always four parameters in the matrix, whether that's just vectors+coordinates (<span style="font-style: italic">ux</span>, <span style="font-style: italic">uy</span>, <span style="font-style: italic">vx</span>, <span style="font-style: italic">vy</span>), or any combination of scales, shears or angles. You can just pick one that's most convenient for you. The scaleX, scaleY, angleX, angleY that naleksiev suggested is probably the most useful, though you have to be careful with what those terms will actually mean.
<br/>
<br/>
Also, if it helps, there is an easy way to see whether you're dealing with shears or scale+rotations: in the latter the vectors are perpendicular. Technically, you'd need to check the inner product of <span style="font-weight: bold">u</span> and <span style="font-weight: bold">v</span>, but with taking the inverse matrix into account what you actually need to check is <span style="font-style: italic">ux</span>*<span style="font-style: italic">uy</span>+<span style="font-style: italic">vx</span>*<span style="font-style: italic">vy</span>. If that's zero, then the axes will appear perpendicular on screen.
<br/>
<br/>
<br/>
<span style="font-size: 9px; line-height: normal"><span style="color: blue">*</span> If possible, do not use letters x and y for both the vectors and their coordinates. Confuzzlement generally follows quickly after.
<br/>
</span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
