<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Understanding the DCU - Question #2 (edit) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Understanding the DCU - Question #2 (edit)</h2>
<div id="posts">
<div class="post">
    <h4>#170460 - DiscoStew - Mon Sep 28, 2009 8:16 am</h4>
    <div class="postbody"><span class="postbody">My first question was answered, which is below, but now I have a 2nd question, which I will post again at what is currently the end of the thread, since people have already checked this thread, and skim to the end.
<br/>
<br/>
With the capture mode, does it completely write over what was previously in the VRAM slot used? What I am wanting to do is render a couple of different frame with the 3D engine, and have them layered over each other, so that the top-most layer doesn't block the ones behind them, kinda like how the 2D engine works, except the frame rate will be based on how many layers I want to render per go. I believe that if I were to use 2 vram banks, I'd swap between the two, having one in LCD mode for the capture, and the other in BG mode using it as a bitmap which gets added into the capture if it is layered underneath it, but I'm hoping there is a way to do it with just 1 bank.
<br/>
<br/>
From what I can tell, when using both source A and B, it will only do an additive mix, and not be able to just write over what's already there, even with an alpha value. Perhaps someone out there may know a way?
<br/>
<br/>
------------------------------------------------
<br/>
Original post:
<br/>
<br/>
{SOLVED}
<br/>
When using glFlush(), it doesn't swap the buffers until the next VBlank. The code below shows the correct way to do it.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   lcdMainOnTop();
<br/>
<br/>
   videoSetMode( MODE_FB3 );
<br/>
   vramSetBankD( VRAM_D_LCD );
<br/>
<br/>
   glInit();
<br/>
   glEnable( GL_ANTIALIAS );
<br/>
   glClearColor( 0, 0, 0, 31 );
<br/>
   glClearPolyID( 63 );
<br/>
   glClearDepth( 0x7FFF );
<br/>
   glViewport( 0, 0, 255, 191 );
<br/>
   glMatrixMode( GL_PROJECTION );
<br/>
   glLoadIdentity();
<br/>
   gluPerspective( 70, 256.0 / 192.0, 0.1, 100 );
<br/>
<br/>
   glPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE);
<br/>
   glMatrixMode(GL_MODELVIEW);
<br/>
<br/>
   render_Poly( 0 );
<br/>
   glFlush( 0 );
<br/>
   swiWaitForVBlank();      
<br/>
   REG_DISPCAPCNT = DCAP_ENABLE | DCAP_MODE( 0 ) | DCAP_BANK( 3 ) | DCAP_OFFSET( 0 ) | DCAP_SIZE( 3 ) | DCAP_SRC( 1 );
<br/>
   while(1)
<br/>
      swiWaitForVBlank();</td> </tr></table><span class="postbody"><br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"><br/><br/>Last edited by DiscoStew on Tue Sep 29, 2009 12:39 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#170462 - Min - Mon Sep 28, 2009 11:31 am</h4>
    <div class="postbody"><span class="postbody">Try doing the capture after glFlush().</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170463 - DiscoStew - Mon Sep 28, 2009 4:22 pm</h4>
    <div class="postbody"><span class="postbody">Ok, I understand it now. Moving it to after glFlush() didn't change it, but adding another swiWaitForVBlank() in between those two made it work. I forgot that when glFlush() is used, the buffers aren't swapped until the "next" VBlank.
<br/>
<br/>
thx<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170472 - DiscoStew - Tue Sep 29, 2009 12:39 am</h4>
    <div class="postbody"><span class="postbody">This is my 2nd question.
<br/>
<br/>
With the capture mode, does it completely write over what was previously in the VRAM slot used? What I am wanting to do is render a couple of different frame with the 3D engine, and have them layered over each other, so that the top-most layer doesn't block the ones behind them, kinda like how the 2D engine works, except the frame rate will be based on how many layers I want to render per go. I believe that if I were to use 2 vram banks, I'd swap between the two, having one in LCD mode for the capture, and the other in BG mode using it as a bitmap which gets added into the capture if it is layered underneath it, but I'm hoping there is a way to do it with just 1 bank.
<br/>
<br/>
From what I can tell, when using both source A and B, it will only do an additive mix, and not be able to just write over what's already there, even with an alpha value. Perhaps someone out there may know a way?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170482 - Min - Tue Sep 29, 2009 10:45 am</h4>
    <div class="postbody"><span class="postbody">I haven't tried this so please correct any mistakes.
<br/>
<br/>
Using two bg layers on the main screen, one for display capture and one for the 3D. Only one VRAM bank is used for the capture/bg layer.
<br/>
<br/>
1. Render 3D and flush
<br/>
2. Wait for Vblank
<br/>
3. Set the capture/bg bank to LCD
<br/>
4. Do display capture
<br/>
5. Set the capture/bg bank to BG
<br/>
<br/>
Both the previous captured frame and the new 3D on top will be captured, adding another layer to the captured image each time the list is repeated ( but that you already know. :P ) Step 3-5 should complete before the screen needs to redraw, and therefore having the capture/bg bank in LCD mode during the capture shouldn't affect the display.
<br/>
<br/>
Oh, and make sure the clear color is transparent.</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">glClearColor( 0,0,0,0 );</td> </tr></table><span class="postbody">
<br/>
<br/>
You can even transparent polygons blend with the bg if you add this little line to your code:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">REG_BLDCNT = BLEND_ALPHA | BLEND_SRC_BG0 | BLEND_DST_BG3 | BLEND_DST_BACKDROP;</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170495 - DiscoStew - Tue Sep 29, 2009 6:16 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Min wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Both the previous captured frame and the new 3D on top will be captured, adding another layer to the captured image each time the list is repeated ( but that you already know. :P ) Step 3-5 should complete before the screen needs to redraw, and therefore having the capture/bg bank in LCD mode during the capture shouldn't affect the display.</td> </tr></table><span class="postbody">
<br/>
<br/>
Not quite sure about that, because the capture is done <span style="font-weight: bold">while</span> the screen is refreshing.
<br/>
<br/>
<br/>
Anyways, this is what I have currently
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   glClearColor( 0, 0, 0, 0 );
<br/>
   videoSetMode( MODE_FB2 | DISPLAY_BG0_ACTIVE | DISPLAY_BG3_ACTIVE | ENABLE_3D );
<br/>
<br/>
   bgInit(3, BgType_Bmp16, BgSize_B16_256x256, 24, 0);
<br/>
   
<br/>
   swiWaitForVBlank();
<br/>
   render_Poly( 0 );
<br/>
   glFlush( 0 );
<br/>
   swiWaitForVBlank();
<br/>
<br/>
   vramSetBankD( VRAM_D_LCD );
<br/>
   REG_DISPCAPCNT = DCAP_ENABLE | DCAP_MODE( 0 ) | DCAP_BANK( 3 ) | DCAP_SIZE( 3 ) | DCAP_SRC( 0 );
<br/>
   render_Poly( 1 );
<br/>
   glFlush( 0 );
<br/>
   swiWaitForVBlank();
<br/>
   
<br/>
   vramSetBankC( VRAM_C_LCD );
<br/>
   vramSetBankD( VRAM_D_MAIN_BG );
<br/>
   REG_DISPCAPCNT = DCAP_ENABLE | DCAP_MODE( 0 ) | DCAP_BANK( 2 ) | DCAP_SIZE( 3 ) | DCAP_SRC( 0 );
<br/>
   swiWaitForVBlank();
<br/>
<br/>
   iprintf( "\n%02X\n", VRAM_C[ 50 + ( 256 * 96 )] );
<br/>
   
<br/>
   videoSetMode( MODE_FB2 );
<br/>
   
<br/>
   while(1)
<br/>
   {
<br/>
      swiWaitForVBlank();
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
<br/>
What this does is renders the first polygon (of a set size and distance away) and flushes it, then in the next VBlank, sets the capture hardware while sending in the next polygon (which is smaller, a different color, and closer than the last one, so both should be seen if done right), and then the 2nd capture is done in the next frame into VRAM_C, and then it is displayed.
<br/>
<br/>
As it is right now, it will only show the most recent polygon. If I comment out the 2nd polygon, the first one shows up instead. So, setting the 2nd polygon back in, I went and examined the data outside the polygon. The value was 0x8000, meaning that it was solid black, which might explain why the polygon in the back isn't showing, because it is being overwritten.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170499 - Min - Tue Sep 29, 2009 7:07 pm</h4>
    <div class="postbody"><span class="postbody">Ah, you are right. I had a feeling I was mistaken about something vital, please ignore my previous post.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170509 - Cydrak - Tue Sep 29, 2009 11:15 pm</h4>
    <div class="postbody"><span class="postbody">Hmm.. so you're trying to composite frames by capturing the 2D engine. Neat. I don't know a way to do it in one bank, sorry.
<br/>
<br/>
I think your bitmap needs modes 3-5 though, and that's why it's not capturing. I ran into a related issue myself. To get it working, you'll have to define your own constants (see below).
<br/>
<br/>
Basically there are two things to care about: the BG mode and the display source, which are bits 0-3 and 16-20 of REG_DISPCNT, respectively. (And as far as I could tell, despite living in the same register, the display source has no relation to the 2D engine, besides allowing you to actually see it! Completely bonkers, I know.)
<br/>
<br/>
The trouble with libnds "video modes" is that they implicitly assign both these settings. This means they'll conflict if you try to set MODE_FB2 | MODE_3_3D for example, even though it makes sense. So, have a look at <a class="postlink" href="http://www.daftcode.net/gbatek/ds#dsvideobgmodescontrol" target="_blank">GBATek:DISPCNT</a>. You're probably interested in display source = 2+8 and BG mode = 3+8... nicely defined, it'd look something like DISPLAY_SRC_FB2 + BG_MODE_3 + BG_ENABLE_3D.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170518 - DiscoStew - Wed Sep 30, 2009 4:16 am</h4>
    <div class="postbody"><span class="postbody">I think that did it. The background (when not setting it) was kept at 4 Text BGs, so when I added 0x0003 to the videoSetMode function (which sets the mode to BG0-BG2 as Text, and BG3 as Extended), it was then showing both, one in front of the other. Exactly what I wanted.
<br/>
<br/>
I was excited until I tested translucent polygons. It wasn't working, but then I referred back to Min's post about it, so I added in that line in teh appropriate spot, and added another poly to get rendered for the 2nd pass. One was at 50%, and the other at 100%, both next to each other,and both covering part of the poly in back. Result?
<br/>
<br/>
Exactly how you'd imagine it would look. I got quite giddy when seeing it work on both emulator and hardware. Thank you all for helping me with this.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
