<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How is "blh" implemented in ARM on ARM7 CPUs? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > How is "blh" implemented in ARM on ARM7 CPUs?</h2>
<div id="posts">
<div class="post">
    <h4>#154686 - Exophase - Sun Apr 20, 2008 8:19 am</h4>
    <div class="postbody"><span class="postbody">Wondering if anyone knows this... posting here so it'll be seen/responded to, and you guys have an ARM7 to play with. This has actually been in the back of my mind for a really long time (if it belongs somewhere else more please move it though...)
<br/>
<br/>
If what I've read is to be believed, the ARM7 pipeline will convert Thumb instructions to ARM instructions during the second half of the decode stage of its pipeline. This is also something they supposedly changed in ARM9+ (so that Thumb instructions are decoded directly to whatever native internal formats the pipeline uses). Anyway, this should mean that for ARM7 every instruction in Thumb corresponds 1 to 1 to an ARM instruction.
<br/>
<br/>
Actually, there appear to be two instructions that do not have an ARM equivalent, although they're subtle. I'm referring to the instructions that I've seen called "bll" and "blh." You might not find them in proper documentation - what they are are the two halves of the 32bit bl instructions. But they don't have to actually be used consecutively. Golden Sun 2 even uses blh, which is probably why it ends up at unaligned PC's. But they're useful instructions:
<br/>
<br/>
bll offset: lr = pc + 4 + sign_extend_21(offset &lt;&lt; 12)
<br/>
blh offset: _pc = lr + offset * 2; lr = ((pc + 2) | 1); pc = _pc
<br/>
<br/>
So there you have it, the second one is practically an implemenation of the indirect blx instruction in Thumb (minus the mode switching), so long as you're okay with using lr implicitly. It even allows you to add an integer offset to it - if you use Thumb on ARM9 you could use this for a one instruction jump table lookup + call (if the code is in IWRAM located at the beginning somewhere). And they're not slow either: according to No$ bll takes 1S and blh takes 2S + 1N. That means blh is the same speed as all the usual branching instructions.
<br/>
<br/>
But for the most part Thumb sucks. So is it at all possible that there are ARM instructions that correspond to these? Undefined/reserved ones. Or maybe ARM7 really converts <span style="font-style: italic">most</span> instructions but handles these in a special way.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154696 - masscat - Sun Apr 20, 2008 1:19 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Exophase wrote:</b></span></td> </tr> <tr> <td class="quote">Anyway, this should mean that for ARM7 every instruction in Thumb corresponds 1 to 1 to an ARM instruction.</td> </tr></table><span class="postbody">
<br/>
There is not a 1 to 1 mapping of Thumb instructions to ARM instructions. It is actually impossible to achieve as the value read from the PC is different when in Thumb (current instruction address + 4) and ARM mode (current instruction address + 8). So any instruction that reads the PC has no single equivalent in the other instruction set.
<br/>
<br/>
The branch instructions are described in section A7.1.17 of the ARM Architecture Reference Manual.
<br/>
The pair of branch instructions simply allow you to encode a branch of about +-4MiB using 16bit instructions. Normally, if you were writing assembler then you would write a single BL or BLX instruction with the desired PC relative offset and the assembler will form the correct branch instruction pair for you.
<br/>
<br/>
Why do you care how an ARM core handles instruction decoding internally? I am not sure that it is defined in the reference documentation.
<br/>
<br/>
Why Thumb:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ARM7TDMI Reference Manual wrote:</b></span></td> </tr> <tr> <td class="quote">Thumb code is typically 65% of the size of ARM code, and provides 160% of the performance of ARM code when running from a 16-bit memory system. Thumb, therefore, makes the ARM7TDMI core ideally suited to embedded applications with restricted memory bandwidth, where code density and footprint is important.
<br/>
The availability of both 16-bit Thumb and 32-bit ARM instruction sets gives designers the flexibility to emphasize performance or code size on a subroutine level, according to the requirements of their applications. For example, critical loops for applications such as fast interrupts and DSP algorithms can be coded using the full ARM instruction set then linked with Thumb code.</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154715 - Exophase - Sun Apr 20, 2008 9:17 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>masscat wrote:</b></span></td> </tr> <tr> <td class="quote">There is not a 1 to 1 mapping of Thumb instructions to ARM instructions. It is actually impossible to achieve as the value read from the PC is different when in Thumb (current instruction address + 4) and ARM mode (current instruction address + 8). So any instruction that reads the PC has no single equivalent in the other instruction set. </td> </tr></table><span class="postbody">
<br/>
<br/>
Although I forgot to mention that (I know there was something else that didn't map, couldn't remember what..) this is not really the same kind of difference as these constituent instructions. The PC being different does not mean that the instruction itself has to do something differently with that PC, it just means that the end result can't be achieved. As for the halfword aligned shifts on the offsets, I could see that being a byproduct of something mode dependent later in the pipeline. It still does not mean, at least not to me, that a different kind of instruction is being done. I can easily see Thumb to ARM translation still applying to what you said but I can't see it applying to the two "half instructions" I gave. There's no ARM instruction where you could fiddle with the operands a little and get this kind of functionality.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>masscat wrote:</b></span></td> </tr> <tr> <td class="quote">The branch instructions are described in section A7.1.17 of the ARM Architecture Reference Manual.
<br/>
The pair of branch instructions simply allow you to encode a branch of about +-4MiB using 16bit instructions. Normally, if you were writing assembler then you would write a single BL or BLX instruction with the desired PC relative offset and the assembler will form the correct branch instruction pair for you. </td> </tr></table><span class="postbody">
<br/>
<br/>
You're missing the point. Of course that's why they were written, but the two constituent instructions in isolation are actually highly useful in their own right, not just as a pair. There's a reason why Golden Sun 2 uses the "blh" instruction.
<br/>
<br/>
Even if there's no way to get an equivalent instruction in ARM (which I'm leaning towards) this is still useful information for Thumb programmers.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>masscat wrote:</b></span></td> </tr> <tr> <td class="quote">Why do you care how an ARM core handles instruction decoding internally? I am not sure that it is defined in the reference documentation.</td> </tr></table><span class="postbody">
<br/>
<br/>
(now I'm just repeating myself...) It's because the documents I have read have stated that in ARM7 Thumb instructions are converted to ARM ones during the decode stage. That should mean that, ignoring some modifications later done to the operands based on thumb bit, that there are hidden (reserved, or otherwise unavailable?) ARM instructions that do the equivalent of the bll/blh instructions. Instead, the truth is probably that  not EVERY instruction is handled in the pipeline this way (but notice - no pipeline delays for bll/blh to be special cased for this), or my sources were just completely wrong.
<br/>
<br/>
And please give me a little credit, I know why Thumb was invented/used and never asked why -_-</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154726 - Maxxie - Mon Apr 21, 2008 12:26 am</h4>
    <div class="postbody"><span class="postbody">For the bll the translation should be add lr,pc,#imm lsl #12
<br/>
<br/>
The blh, well i don't see a possible translation to an existing .arm opcode (alltho there are instructions that could be capable of it if the parameters would fit all into one opcode)
<br/>
<br/>
But the thing i am replying for:
<br/>
How does blh or its possible translation allows a "one instruction jump table lookup + call"?
<br/>
All i see there are arithmetric operation on the lr and pc registers, but no memory access beyond reading the instruction itself, which would be vital for a jump table lookup.
<br/>
<br/>
My choice in .s for that task would be the simple
<br/>
[possibly push lr]
<br/>
LDR lr,[(R)Base,ROffset]
<br/>
BLX lr
<br/>
[possibly pop lr]
<br/>
<br/>
In many cases (switch-case translation) the return address is known at compile time, thus LDR pc,[Base,Offset] leading to a chunk ending with the non linking branch with #imm pointing just behind the LDR instead of the usual BX lr
<br/>
<br/>
For a call to a dynamic function table in .c/.s intermix i'd create a naked helper function JumpTable(base,offset) only containing
<br/>
LDR pc,[r0,r1]
<br/>
<br/>
and let the compiler decide whether lr has to be backed up for the caller (could have been stored for another BL already)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154730 - kusma - Mon Apr 21, 2008 1:00 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Exophase wrote:</b></span></td> </tr> <tr> <td class="quote">If what I've read is to be believed, the ARM7 pipeline will convert Thumb instructions to ARM instructions during the second half of the decode stage of its pipeline.</td> </tr></table><span class="postbody">
<br/>
This sounds very unlikely to me, as this would most likely add another pipeline-step. Where did you read this?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154732 - Exophase - Mon Apr 21, 2008 1:20 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">For the bll the translation should be add lr,pc,#imm lsl #12</td> </tr></table><span class="postbody">
<br/>
<br/>
The imm here has 11 bits, so you can't do that.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">The blh, well i don't see a possible translation to an existing .arm opcode (alltho there are instructions that could be capable of it if the parameters would fit all into one opcode)</td> </tr></table><span class="postbody">
<br/>
<br/>
What instructions would be capable, what do you mean exactly?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">But the thing i am replying for:
<br/>
How does blh or its possible translation allows a "one instruction jump table lookup + call"?
<br/>
All i see there are arithmetric operation on the lr and pc registers, but no memory access beyond reading the instruction itself, which would be vital for a jump table lookup.
<br/>
<br/>
My choice in .s for that task would be the simple
<br/>
[possibly push lr]
<br/>
LDR lr,[(R)Base,ROffset]
<br/>
BLX lr
<br/>
[possibly pop lr]</td> </tr></table><span class="postbody">
<br/>
<br/>
Remember, ARM7 doesn't have BLX. This is basically a replacement for it. But it allows an offset too, which I guess was figuring could be uesd as a table offset. Naturally it wouldn't do what you're referring to in one instruction though (definitely not memory accesses).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">This sounds very unlikely to me, as this would most likely add another pipeline-step. Where did you read this?</td> </tr></table><span class="postbody">
<br/>
<br/>
Multiple things can happen in a pipeline stage (especially the third stage for the classic ARM pipeline). I don't have a lot of references for it right now, mostly something I've read before (that it's translated). A diagram in this PDF shows it though (page 9):
<br/>
<br/>
<a href="http://www.iti.uni-stuttgart.de/~rainer/Lehre/SoC99/PDF/19991207bw.pdf" target="_blank">http://www.iti.uni-stuttgart.de/~rainer/Lehre/SoC99/PDF/19991207bw.pdf</a>
<br/>
<br/>
Also:
<br/>
<br/>
<a href="http://www.cs.ucr.edu/~gupta/research/Publications/Comp/L14-krishnaswamy.pdf" target="_blank">http://www.cs.ucr.edu/~gupta/research/Publications/Comp/L14-krishnaswamy.pdf</a>
<br/>
<br/>
(section 2.2)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154764 - masscat - Mon Apr 21, 2008 1:27 pm</h4>
    <div class="postbody"><span class="postbody">Fire the ARM instruction encodings marked as UNPREDICTABLE at an ARM core and see what they do to the register set.
<br/>
<br/>
I still do not understand why you want to do this (anything more than just interest). Even if you find an instruction encoding that has the equivalent behaviour it is not of much use as ARM could happily change it between core versions and even implementations of a particular core, as the encoding should never be seen from an external source.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154765 - simonjhall - Mon Apr 21, 2008 1:51 pm</h4>
    <div class="postbody"><span class="postbody">I could understand if it's part of an emulator (exophase, isn't it you who did a gba emulator?) as you wouldn't need to code and test a second instruction set. You could just pipe a THUMB instruction through to the relevant ARM function to save yourself some time.
<br/>
I can't think of any other use - if this THUMB-&gt;ARM translation is not programmer visible then it doesn't really matter if a given implementation does it or not!
<br/>
<br/>
Out of curiosity, how do you know that ARM instructions aren't converted to THUMB? ;-)<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154791 - Exophase - Mon Apr 21, 2008 7:27 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>masscat wrote:</b></span></td> </tr> <tr> <td class="quote">Fire the ARM instruction encodings marked as UNPREDICTABLE at an ARM core and see what they do to the register set.
<br/>
<br/>
I still do not understand why you want to do this (anything more than just interest). Even if you find an instruction encoding that has the equivalent behaviour it is not of much use as ARM could happily change it between core versions and even implementations of a particular core, as the encoding should never be seen from an external source.</td> </tr></table><span class="postbody">
<br/>
<br/>
It is mostly just curiosity. However, even if it's just available on some cores that doesn't make it useless. For instance, if such a thing could be accessed on the ARM7TDMI in the DS then it could be slightly useful. If it could be accessed in the ARM920T on the GP2X it'd be slightly useful for me too. Homebrew code is already usually pretty platform specific and these particular instructions can be replaced with safe sequences that'll work on any ARM w/o destroying any additional registers.
<br/>
<br/>
Unfortunately I don't really have time to play around with something that's so unlikely :( I was kinda hoping someone would just know somehow ;)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">I could understand if it's part of an emulator (exophase, isn't it you who did a gba emulator?) as you wouldn't need to code and test a second instruction set. You could just pipe a THUMB instruction through to the relevant ARM function to save yourself some time.</td> </tr></table><span class="postbody">
<br/>
<br/>
Although I do emulate ARM/Thumb separately I've worked on some Thumb to ARM translation code, with the main goal being to optimize the code in the process. Here I've just used some reserved bit spaces (which is how I know it can fit, at least somewhere), so it's not really a big deal. But of course this is what got me thinking about all this.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">I can't think of any other use - if this THUMB-&gt;ARM translation is not programmer visible then it doesn't really matter if a given implementation does it or not!</td> </tr></table><span class="postbody">
<br/>
<br/>
If it's not possible to trigger it externally then it would be useless. But if the second part of the decode pipeline expects a real ARM instruction then that's what the Thumb expand stage would have to give it. Of course I doubt this is how it actually works, that's just how it has been described.
<br/>
<br/>
I could be totally off base with this, but I kinda hope that it might be useful to someone doing Thumb on ARM7 at least (which should actually still be a legitimate thing to do on DS)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">Out of curiosity, how do you know that ARM instructions aren't converted to THUMB? ;-)</td> </tr></table><span class="postbody">
<br/>
<br/>
ARM was there first, plus Thumb is a tiny subset of ARM. It'd be great if that were somehow possible though (it almost is with Thumb-2, but there'd be no point in compressing ARM code on the fly just to have to decompress it again)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154805 - Dwedit - Mon Apr 21, 2008 9:00 pm</h4>
    <div class="postbody"><span class="postbody">Does the GBA implement the forbidden "never" mode of all instructions as nops?  Haven't tested this, but I bet it does.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154882 - masscat - Tue Apr 22, 2008 10:05 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Does the GBA implement the forbidden "never" mode of all instructions as nops?  Haven't tested this, but I bet it does.</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ARM Tech Ref wrote:</b></span></td> </tr> <tr> <td class="quote">In ARMv4, any instruction with a condition field of 0b1111 is UNPREDICTABLE.</td> </tr></table><span class="postbody">
<br/>
So what they do is undefined. Some encodings may do nothing some might do stuff.
<br/>
<br/>
Another problem with using undefined instruction encodings is that you also need to hack the toolchain (compiler and assembler) to support them. A lot of work for very little gain.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154885 - eKid - Tue Apr 22, 2008 11:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Another problem with using undefined instruction encodings is that you also need to hack the toolchain (compiler and assembler) to support them. A lot of work for very little gain.</td> </tr></table><span class="postbody">
<br/>
Maybe you can use the assembler macros to define custom instructions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154997 - Maxxie - Wed Apr 23, 2008 9:08 pm</h4>
    <div class="postbody"><span class="postbody">Could be interesting to test out how the CPUs react to the opcodes marked green or red in <a class="postlink" href="http://oopsilon.com/ARM-Opcode-Map" target="_blank">this map</a>
<br/>
<br/>
I'm tempted to try them out and see which of them causes UND or anything else. They might be marked as unpredictable, but as long as N doesn't exchange the cores ...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154999 - simonjhall - Wed Apr 23, 2008 9:19 pm</h4>
    <div class="postbody"><span class="postbody">You could always write a program that automatically generated and ran instructions, and see which ones don't cause an undefined instruction exception?
<br/>
<br/>
50p says that there are some really juicy instructions in there...I'm hoping there are some fancy fp vector multiplying functions ;-)<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155005 - Maxxie - Wed Apr 23, 2008 10:04 pm</h4>
    <div class="postbody"><span class="postbody">That's what i'm trying to do right now.
<br/>
<br/>
To automate this requires to recover from trapping UND and undocumented register changes, as well as possible data aborts and so on. I don't feel like manually restart for every n-th possible opcode.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155010 - simonjhall - Wed Apr 23, 2008 10:21 pm</h4>
    <div class="postbody"><span class="postbody">Shouldn't be too hard!
<br/>
The simplest method I can think of off the top of my head would be: just install your own exception handler, and run your piece of code which runs your new generated instructions. If the exception handler is run the exact same number of times as 'new' instructions run, then that's a no-go! If it does differ (ie there are some instructions which don't generate an exception), binary chop your generated instructions until you find out what works.
<br/>
<br/>
Stick a pointer to your exception handler in at 0x27ffd9c and make it look something like this: (no idea if it compiles)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">exception_handler:
<br/>
//store your stuff
<br/>
ldr ip,=registers
<br/>
stmia ip,{r0-r11,sp}
<br/>
ldr ip,=registers
<br/>
<br/>
//increment your exception hit count
<br/>
ldr ip,=exception_hit_count
<br/>
ldr sp,[ip]
<br/>
add sp, sp, #1
<br/>
str sp,[ip]
<br/>
<br/>
/* if you want to call a real function, do this instead
<br/>
ldr ip,=my_new_stack
<br/>
ldr sp,[ip]
<br/>
mov lr,pc
<br/>
b my_exception_function
<br/>
*/
<br/>
<br/>
//restore your registers
<br/>
ldr ip,=registers
<br/>
ldmia ip,{r0-r11,sp}
<br/>
<br/>
//now do the bios code (not my code btw)
<br/>
ldmia sp!, {ip, lr}
<br/>
mcr 15, 0, ip, cr1, cr0, 0
<br/>
msr SPSR_fsxc, lr
<br/>
ldmia sp!, {ip, lr}
<br/>
subs pc, lr, #4</td> </tr></table><span class="postbody">
<br/>
<br/>
(this is effectively the core of my debugger btw, so should be legit...)
<br/>
<br/>
EDIT: missed out the store instruction
<br/>
EDIT2: assigned a stack<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"><br/><br/>Last edited by simonjhall on Thu Apr 24, 2008 7:44 am; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#155021 - Maxxie - Wed Apr 23, 2008 11:31 pm</h4>
    <div class="postbody"><span class="postbody">On the first batch on the arm9:
<br/>
<br/>
The opcodes 0b1110 0000 01?? ???? ???? ???? 1001 ???? do all trap undef (256 KiInstructions)
<br/>
Same with 0b1110 00001 1??? ???? ???? ???? 1001 ????
<br/>
And 0b1110 0011 0000 ???? ???? ???? ???? ???? ???? (TEQ with s = 0)
<br/>
<br/>
Eureka!
<br/>
There is one, a "ldrd" ( a v5e instruction) is working on the arm9: 0xE00F00D0 did load two instructions in the register pair r0:r1
<br/>
[edit]Just noticed that oppsilon's site is dedicated to the nds cores, wonder if he did check them all or just took them out of the docu[/edit]
<br/>
<br/>
Possibly one of the opcodes before did too, but was not detected because i just noticed that it didn't check if the exception was really a undef or possibly an data abort.</span><span class="gensmall"><br/><br/>Last edited by Maxxie on Thu Apr 24, 2008 1:36 am; edited 3 times in total</span></div>    
</div>
<div class="post">
    <h4>#155042 - masscat - Thu Apr 24, 2008 9:44 am</h4>
    <div class="postbody"><span class="postbody">The ARM9 in the DS is a ARM946E-S which implements the ARMv5TE architecture. So it will have all the enhanced DSP instructions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155047 - simonjhall - Thu Apr 24, 2008 12:52 pm</h4>
    <div class="postbody"><span class="postbody">So what's involved with "DSP instructions"? Anything cool?<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155048 - Maxxie - Thu Apr 24, 2008 1:29 pm</h4>
    <div class="postbody"><span class="postbody">ldrd/strd - loading &amp; storing doublewords (64 bit)
<br/>
qadd/qdadd - saturated add
<br/>
qsub/qdsub - saturated add
<br/>
smul?? - 16&amp;32 bit intermixed signed multiplications (with accumulation)
<br/>
pld - preloading data
<br/>
<br/>
Did thought the arm9 was only subset of the arm946e-s (which seemed the nearest known core to me) well, now i know better :) thanks masscat
<br/>
<br/>
Think ill just try v6 etc instructions maybe there is a glimmer somewhere, but doubt that now.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155049 - simonjhall - Thu Apr 24, 2008 1:46 pm</h4>
    <div class="postbody"><span class="postbody">Do they function or just not cause exceptions? I never got any love from pld and I have doubts that it works...<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155050 - masscat - Thu Apr 24, 2008 1:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">Did thought the arm9 was only subset of the arm946e-s (which seemed the nearest known core to me) well, now i know better :) thanks masscat</td> </tr></table><span class="postbody">
<br/>
I do not know that as fact (was quoting gbatek and others). But I cannot see Nintendo/ARM having a core that does some of the ARMv5TE but not all as it would require custom tools and the like.
<br/>
The Makefile used to build libnds and the one from the NDS examples from DKP sets the following gcc options:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">-march=armv5te -mtune=arm946e-s</td> </tr></table><span class="postbody">
<br/>
<br/>
The STRD and LRDD instructions are definitely supported (as you found) as I had to added support for them to desmume as the palib startup code uses them.
<br/>
<br/>
simonjhall:
<br/>
It is perfectly valid for PLD to do bugger all:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">It has no architecturally defined effect, and memory systems that do not support this optimization can ignore it. On such memory systems, PLD acts as a NOP.</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155051 - eKid - Thu Apr 24, 2008 1:57 pm</h4>
    <div class="postbody"><span class="postbody">I used pld once and it shaved off a couple % cpu :P. It's a bit hard to control though... I added it in another spot (which was a very similar operation) and it raised the cpu usage.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155055 - simonjhall - Thu Apr 24, 2008 3:21 pm</h4>
    <div class="postbody"><span class="postbody">Yeah that could be anything then I guess - better or worse usage of instruction cache?
<br/>
<br/>
@masscat, I think you're right about the tools and aww shucks about that quote from the ARM manual!<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
