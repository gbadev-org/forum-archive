<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Issues with VRAM memory allocations - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Issues with VRAM memory allocations</h2>
<div id="posts">
<div class="post">
    <h4>#52122 - cybereality - Sat Aug 27, 2005 12:05 am</h4>
    <div class="postbody"><span class="postbody">I have just started wih NDS development, but I have read a good amount of what is on the web and the examples given with devkitPro. I started by going through Chris Double's tutorials and while I understand all the logic, I am having trouble with the VRAM allocations. I took Chris' demo to display a JPEG and edited it with my own images. Then I added an extra BG layer on the sub screen so I could display a large image over both screens. I did this by duplicating the image data in both main and sub BG buffers and offseting the Y value in hardware. That works fine, no problem. Now I want to add the console output on one screen (over the image) and it doesn't work. The main screen displays the image fine, the sub screen has a bunch of random ASCII characters on i but colored like the image should be. If I move the image around, I can tell it is writing the the correct VRAM, but the console text garbles it up. I need some help with this from someone who knows what they are talking about.
<br/>
<br/>
The lines I have a feeling are wrong are:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
consoleInitDefault((u16*)SCREEN_BASE_BLOCK_SUB(31), (u16*)CHAR_BASE_BLOCK_SUB(0), 16);
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
BltImage(images[current_image], BG_GFX_SUB, 256, 256);
<br/>
</td> </tr></table><span class="postbody">
<br/>
Basically, it seems that I am writing the sub image and the console output to the same VRAM bank. I tried a bunch of different things, but I am not all that experienced with low-level memory coding and I can't find any simple demos that do this. I have posted the code below, hopefully someone can make some sense out of it for me. I dont understand what (u16*)SCREEN_BASE_BLOCK_SUB(31) refers to (it sets the map buffer base for the consoleInit I know, but where is this coming from?). Also I couldn't find any info on BG_GFX or BG_GFX_SUB and what other constants could be used for these. If you can, please help me out. Thanks.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> /*
<br/>
   mode5_scrolling ARM9 Code 
<br/>
   Chris Double (chris.double@double.co.nz)
<br/>
   http://www.double.co.nz/nintendo_ds
<br/>
   
<br/>
   edits by: cybereality
<br/>
*/
<br/>
<br/>
#include &lt;nds.h&gt;
<br/>
#include "nds/arm9/console.h"
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
#include "gba-jpeg.h"
<br/>
#include "gba-jpeg-decode.h"
<br/>
#include "gbfs.h"
<br/>
<br/>
// Given the name of a file, look it up in the GBFS archive and use
<br/>
// the JPEG routines to return the width and height of the image.
<br/>
void GetImageSize(char* name, int* width, int* height) {
<br/>
  WAIT_CR &amp;= ~0x80;
<br/>
  GBFS_FILE const* gbfs_file = 
<br/>
    find_first_gbfs_file((void*)0x08000000);
<br/>
  const unsigned char* image = (const unsigned char*)gbfs_get_obj(gbfs_file, 
<br/>
                  name, 
<br/>
                  0);
<br/>
  JPEG_Decoder decoder;
<br/>
  JPEG_Decoder_ReadHeaders(&amp;decoder, &amp;image);
<br/>
  *width = decoder.frame.width;
<br/>
  *height = decoder.frame.height;
<br/>
  WAIT_CR |= 0x80;
<br/>
}
<br/>
<br/>
// Decode the jpeg file with the given name to the VRAM location
<br/>
// specified.  The height and width are the height and width of the
<br/>
// output bitmap.
<br/>
void BltImage(char* name, u16* vram, int output_width, int output_height)
<br/>
{
<br/>
  WAIT_CR &amp;= ~0x80;
<br/>
  GBFS_FILE const* gbfs_file = 
<br/>
    find_first_gbfs_file((void*)0x08000000);
<br/>
  uint8* image = (uint8*)gbfs_get_obj(gbfs_file, 
<br/>
                  name, 
<br/>
                  0);
<br/>
  JPEG_DecompressImage(image, vram, output_width, output_height);
<br/>
<br/>
  WAIT_CR |= 0x80;
<br/>
}
<br/>
<br/>
static int scrolly = 0;
<br/>
static int scrollx = 0;
<br/>
<br/>
static int scale_settings[] = {
<br/>
  1 &lt;&lt; 4,
<br/>
  1 &lt;&lt; 5,
<br/>
  1 &lt;&lt; 6,
<br/>
  1 &lt;&lt; 7,
<br/>
  1 &lt;&lt; 8,
<br/>
  2 &lt;&lt; 8,
<br/>
  3 &lt;&lt; 8,
<br/>
  4 &lt;&lt; 8,
<br/>
  5 &lt;&lt; 8,
<br/>
  6 &lt;&lt; 8,
<br/>
  7 &lt;&lt; 8,
<br/>
  8 &lt;&lt; 8,
<br/>
  9 &lt;&lt; 8,
<br/>
  10 &lt;&lt; 8
<br/>
};
<br/>
static int scale_count = sizeof(scale_settings) / sizeof(int);
<br/>
static int scale = 4;
<br/>
<br/>
static char* images[] = { 
<br/>
  "shadowrun1.jpg", 
<br/>
  "shadowrun2.jpg", 
<br/>
  "shadowrun3.jpg", 
<br/>
  "shadowrun4.jpg" 
<br/>
};
<br/>
static int image_count = sizeof(images) / sizeof(char*);
<br/>
int current_image = 0;
<br/>
<br/>
static int height = 0;
<br/>
static int width = 0;
<br/>
<br/>
void on_irq() 
<br/>
{   
<br/>
  if(IF &amp; IRQ_VBLANK) {
<br/>
    // Handle vertical blank interrupt
<br/>
   
<br/>
   // debug traces
<br/>
   consoleClear();
<br/>
   consolePrintf("// cybereality\n\n");
<br/>
   consolePrintf("Width: %d\n", width);
<br/>
   consolePrintf("Height: %d\n", height);
<br/>
   consolePrintf("scrolly: %d\n", scrolly);
<br/>
   consolePrintf("scrollx: %d\n", scrollx);
<br/>
   
<br/>
    // Tell the DS we handled the VBLANK interrupt
<br/>
    VBLANK_INTR_WAIT_FLAGS |= IRQ_VBLANK;
<br/>
    IF |= IRQ_VBLANK;
<br/>
  }
<br/>
  else {
<br/>
    // Ignore all other interrupts
<br/>
    IF = IF;
<br/>
  }
<br/>
}
<br/>
<br/>
void InitInterruptHandler()
<br/>
{
<br/>
  IME = 0;
<br/>
  IRQ_HANDLER = on_irq;
<br/>
  IE = IRQ_VBLANK;
<br/>
  IF = ~0;
<br/>
  DISP_SR = DISP_VBLANK_IRQ;
<br/>
  IME = 1;
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
  powerON(POWER_ALL);
<br/>
  
<br/>
  //   WAIT_CR=0xe800;
<br/>
  //   POWER_CR=0x30F;
<br/>
   
<br/>
  // Mode5: Backgrounds 0 and 1 are text. Background 2 and 3 are
<br/>
  // extended rotation backgrounds. Background 0 can be used for 3D.
<br/>
  videoSetMode(MODE_5_2D | DISPLAY_BG2_ACTIVE);
<br/>
  vramSetBankA(VRAM_A_MAIN_BG_0x6000000);
<br/>
  
<br/>
  BG2_CR = BG_BMP16_256x256;
<br/>
<br/>
  // Set translations
<br/>
  BG2_XDX = scale_settings[scale];
<br/>
  BG2_XDY = 0;
<br/>
  BG2_YDX = 0;
<br/>
  BG2_YDY = scale_settings[scale];
<br/>
  BG2_CY = 0;
<br/>
  BG2_CX = 0;
<br/>
<br/>
  // top screen
<br/>
  videoSetModeSub(MODE_5_2D | DISPLAY_BG0_ACTIVE | DISPLAY_BG3_ACTIVE);
<br/>
  vramSetBankC(VRAM_C_SUB_BG_0x6200000);
<br/>
  SUB_BG3_CR = BG_BMP16_256x256;
<br/>
  
<br/>
  // console text output on bg0
<br/>
  SUB_BG0_CR = BG_MAP_BASE(31);
<br/>
  BG_PALETTE_SUB[255] = RGB15(31,31,31);
<br/>
  consoleInitDefault((u16*)SCREEN_BASE_BLOCK_SUB(31), (u16*)CHAR_BASE_BLOCK_SUB(0), 16);
<br/>
  
<br/>
  // allocate memory for main banks
<br/>
  //vramSetMainBanks(VRAM_A_MAIN_BG_0x6000000,VRAM_B_MAIN_BG_0x6020000,VRAM_C_SUB_BG_0x6200000,VRAM_D_LCD);
<br/>
  
<br/>
    // Set translations
<br/>
  SUB_BG3_XDX = scale_settings[scale];
<br/>
  SUB_BG3_XDY = 0;
<br/>
  SUB_BG3_YDX = 0;
<br/>
  SUB_BG3_YDY = scale_settings[scale];
<br/>
  SUB_BG3_CY = (-260&lt;&lt;8);
<br/>
  SUB_BG3_CX = 0;
<br/>
<br/>
  // Initialize and enable VBlank interrupt
<br/>
  InitInterruptHandler();
<br/>
<br/>
  // Initialiaze key handler
<br/>
  keysInit();
<br/>
<br/>
  // Wait for the vertical blank interrupt before decoding the image to
<br/>
  // VRAM. This prevents seeing the image being drawn as its written to
<br/>
  // memory.
<br/>
  swiWaitForVBlank();
<br/>
  
<br/>
  // draw image to main screen (bottom)
<br/>
  BltImage(images[current_image], BG_GFX, 256, 256);
<br/>
  // draw image to sub screen (top)
<br/>
  // BltImage(images[current_image], BG_GFX_SUB, 256, 256);
<br/>
  
<br/>
  GetImageSize(images[current_image], &amp;width, &amp;height);
<br/>
<br/>
<br/>
  while(1) {
<br/>
    scanKeys();
<br/>
    swiWaitForVBlank();
<br/>
    if(keysHeld() &amp; KEY_DOWN) {
<br/>
      scrolly++;
<br/>
      BG2_CY = (scrolly&lt;&lt;8);
<br/>
     SUB_BG3_CY = (scrolly-260&lt;&lt;8);
<br/>
    }
<br/>
    if(keysHeld() &amp; KEY_UP) {
<br/>
      scrolly--;
<br/>
      BG2_CY = (scrolly&lt;&lt;8);
<br/>
     SUB_BG3_CY = (scrolly-260&lt;&lt;8);
<br/>
    }
<br/>
    if(keysHeld() &amp; KEY_RIGHT) {
<br/>
      scrollx++;
<br/>
      BG2_CX = (scrollx&lt;&lt;8);
<br/>
     SUB_BG3_CX = (scrollx&lt;&lt;8);
<br/>
    }
<br/>
    if(keysHeld() &amp; KEY_LEFT) {
<br/>
      scrollx--;
<br/>
      BG2_CX = (scrollx&lt;&lt;8);
<br/>
     SUB_BG3_CX = (scrollx&lt;&lt;8);
<br/>
    }
<br/>
    if(keysDown() &amp; KEY_A) { 
<br/>
      scale++;
<br/>
      if(scale &gt;= scale_count)
<br/>
   scale = scale_count - 1;
<br/>
      BG2_XDX = scale_settings[scale];
<br/>
      BG2_YDY = scale_settings[scale];
<br/>
     SUB_BG3_XDX = scale_settings[scale];
<br/>
      SUB_BG3_YDY = scale_settings[scale];
<br/>
    }
<br/>
    if(keysDown() &amp; KEY_B) { 
<br/>
      scale--;
<br/>
      if(scale &lt;1)
<br/>
   scale = 1;
<br/>
      BG2_XDX = scale_settings[scale];
<br/>
      BG2_YDY = scale_settings[scale];
<br/>
     SUB_BG3_XDX = scale_settings[scale];
<br/>
      SUB_BG3_YDY = scale_settings[scale];
<br/>
    }
<br/>
      
<br/>
    if(keysDown() &amp; KEY_SELECT) {
<br/>
      current_image++;
<br/>
      if(current_image &gt;= image_count)
<br/>
   current_image = 0;
<br/>
      memset(BG_GFX, 0, 256*256*2);
<br/>
     memset(BG_GFX_SUB, 0, 256*256*2);
<br/>
      BltImage(images[current_image], BG_GFX, 256, 256);
<br/>
     BltImage(images[current_image], BG_GFX_SUB, 256, 256);
<br/>
      GetImageSize(images[current_image], &amp;width, &amp;height);
<br/>
    }
<br/>
  }
<br/>
<br/>
  return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">[/code]</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
