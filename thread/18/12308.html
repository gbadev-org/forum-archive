<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>libnds 20070127 fifo irq issues - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > libnds 20070127 fifo irq issues</h2>
<div id="posts">
<div class="post">
    <h4>#116897 - GPFerror - Tue Jan 30, 2007 7:35 pm</h4>
    <div class="postbody"><span class="postbody">"The interrupt dispatcher has now returned to the older method of acknowledging before entering the user handler. The convoluted method was based on a misunderstanding of a situation where it appeared user data was lost if the interrupt flag was cleared first" This is in the latest libnds release notes, maybe its related?
<br/>
<br/>
My fifo/irq has stopped working in latest release and not sure how to fix it yet.
<br/>
<br/>
here is my arm7 code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void VblankHandler(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
<br/>
   u32 i;
<br/>
   if(REG_IF &amp; IRQ_VBLANK)
<br/>
   {
<br/>
      SoundVBlankIrq();
<br/>
<br/>
<br/>
   //sound code  :)
<br/>
   TransferSound *snd = IPC-&gt;soundData;
<br/>
   IPC-&gt;soundData = 0;
<br/>
<br/>
   if (0 != snd) {
<br/>
<br/>
      for (i=0; i&lt;snd-&gt;count; i++) {
<br/>
         s32 chan = getFreeSoundChannel();
<br/>
<br/>
         if (chan &gt;= 0) {
<br/>
            startSound(snd-&gt;data[i].rate, snd-&gt;data[i].data, snd-&gt;data[i].len, chan, snd-&gt;data[i].vol, snd-&gt;data[i].pan, snd-&gt;data[i].format);
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
   }
<br/>
   if(REG_IF &amp; IRQ_FIFO_NOT_EMPTY)
<br/>
   {
<br/>
      SoundFifoHandler();
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
and the init code
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   irqInit();
<br/>
   irqSet(IRQ_VBLANK, VblankHandler);
<br/>
   SetYtrigger(80);
<br/>
   vcount = 80;
<br/>
   irqSet(IRQ_VCOUNT, VcountHandler);
<br/>
   REG_IPC_FIFO_CR = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR | IPC_FIFO_RECV_IRQ;
<br/>
   irqSet(IRQ_FIFO_NOT_EMPTY, VblankHandler);
<br/>
   irqEnable(IRQ_VBLANK | IRQ_VCOUNT|IRQ_FIFO_NOT_EMPTY);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
and my arm9 code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void InterruptHandler(void)
<br/>
{
<br/>
   u32 command,remain;
<br/>
   //printdbg("InterruptHandler\n");
<br/>
   if(REG_IF &amp; IRQ_VBLANK)
<br/>
   {
<br/>
      framecounter++;
<br/>
   }
<br/>
   if(REG_IF &amp; IRQ_FIFO_NOT_EMPTY)
<br/>
   {
<br/>
      if(!(REG_IPC_FIFO_CR &amp; IPC_FIFO_RECV_EMPTY))
<br/>
      {
<br/>
         command = REG_IPC_FIFO_RX;
<br/>
         
<br/>
         switch(command)
<br/>
         {
<br/>
         case FIFO_NONE:
<br/>
            break;
<br/>
         case UPDATEON_ARM9:
<br/>
            MixSound();
<br/>
            SendCommandToArm7(MIXCOMPLETE_ONARM9);
<br/>
            break;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
and its init code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   irqInit();
<br/>
   irqSet(IRQ_VBLANK | IRQ_FIFO_NOT_EMPTY,&amp;InterruptHandler);
<br/>
   irqEnable(IRQ_FIFO_NOT_EMPTY);
<br/>
   
<br/>
   REG_IPC_FIFO_CR = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR | IPC_FIFO_RECV_IRQ;</td> </tr></table><span class="postbody">
<br/>
<br/>
Any ideas on what I need to change it to for r20?
<br/>
<br/>
Thanks,
<br/>
Troy(GPF)
<br/>
<a href="http://gpf.dcemu.co.uk" target="_blank">http://gpf.dcemu.co.uk</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116898 - DekuTree64 - Tue Jan 30, 2007 8:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>GPFerror wrote:</b></span></td> </tr> <tr> <td class="quote">"The interrupt dispatcher has now returned to the older method of acknowledging before entering the user handler. The convoluted method was based on a misunderstanding of a situation where it appeared user data was lost if the interrupt flag was cleared first" This is in the latest libnds release notes, maybe its related?</td> </tr></table><span class="postbody">
<br/>
Awesome! That means FIFO interrupts can actually be 100% reliable now (see <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=11398&amp;postdays=0&amp;postorder=asc&amp;start=11" target="_blank">this post</a> for details).
<br/>
<br/>
As for your code, you'll need to check the not empty bit in FIFO control rather than the interrupt flags. Or just give the FIFO its own interrupt handler so you don't have to check it in the first place, which is less confusing anyway.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116905 - GPFerror - Tue Jan 30, 2007 10:39 pm</h4>
    <div class="postbody"><span class="postbody">arm7 code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void VblankHandler(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
<br/>
   u32 i;
<br/>
<br/>
   SoundVBlankIrq();
<br/>
<br/>
   //sound code  :)
<br/>
   TransferSound *snd = IPC-&gt;soundData;
<br/>
   IPC-&gt;soundData = 0;
<br/>
<br/>
   if (0 != snd) {
<br/>
<br/>
      for (i=0; i&lt;snd-&gt;count; i++) {
<br/>
         s32 chan = getFreeSoundChannel();
<br/>
<br/>
         if (chan &gt;= 0) {
<br/>
            startSound(snd-&gt;data[i].rate, snd-&gt;data[i].data, snd-&gt;data[i].len, chan, snd-&gt;data[i].vol, snd-&gt;data[i].pan, snd-&gt;data[i].format);
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
<br/>
}
<br/>
void FiFoHandler(void) 
<br/>
//---------------------------------------------------------------------------------
<br/>
{
<br/>
   while ( !(REG_IPC_FIFO_CR &amp; (IPC_FIFO_RECV_EMPTY)) )
<br/>
   {
<br/>
      SoundFifoHandler();
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   irqInit();
<br/>
   irqSet(IRQ_VBLANK, VblankHandler);
<br/>
   SetYtrigger(80);
<br/>
   vcount = 80;
<br/>
   irqSet(IRQ_VCOUNT, VcountHandler);
<br/>
   REG_IPC_FIFO_CR = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR | IPC_FIFO_RECV_IRQ;
<br/>
   irqSet(IRQ_FIFO_NOT_EMPTY, FiFoHandler);
<br/>
   irqEnable(IRQ_VBLANK | IRQ_VCOUNT|IRQ_FIFO_NOT_EMPTY);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
arm7 SoundFifoHandler and SendCommandToArm9
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void SoundFifoHandler(void)
<br/>
{
<br/>
   u32 command;
<br/>
<br/>
   if (!(REG_IPC_FIFO_CR &amp; IPC_FIFO_RECV_EMPTY))
<br/>
   {
<br/>
      command = REG_IPC_FIFO_RX;
<br/>
      
<br/>
      switch(command)
<br/>
      {
<br/>
      case FIFO_NONE:
<br/>
         break;
<br/>
      case MIXCOMPLETE_ONARM9:
<br/>
         soundsystem-&gt;soundcursor += soundsystem-&gt;numsamples;
<br/>
         if(soundsystem-&gt;format == 8)
<br/>
            while (soundsystem-&gt;soundcursor &gt; soundsystem-&gt;buffersize) soundsystem-&gt;soundcursor -= soundsystem-&gt;buffersize;
<br/>
         else
<br/>
            while (soundsystem-&gt;soundcursor &gt; (soundsystem-&gt;buffersize &gt;&gt; 1)) soundsystem-&gt;soundcursor -= (soundsystem-&gt;buffersize &gt;&gt; 1);
<br/>
         break;
<br/>
      }
<br/>
   }
<br/>
}
<br/>
<br/>
void SendCommandToArm9(u32 command)
<br/>
{
<br/>
    while (REG_IPC_FIFO_CR &amp; IPC_FIFO_SEND_FULL);
<br/>
    if (REG_IPC_FIFO_CR &amp; IPC_FIFO_ERROR)
<br/>
    {
<br/>
        REG_IPC_FIFO_CR |= IPC_FIFO_SEND_CLEAR;
<br/>
    } 
<br/>
    
<br/>
    REG_IPC_FIFO_TX = command;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
arm9 code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int framecounter;
<br/>
void InterruptHandler(void)
<br/>
{
<br/>
   framecounter++;
<br/>
}
<br/>
void FiFoHandler(void)
<br/>
{
<br/>
   u32 command,remain;
<br/>
   while ( !(REG_IPC_FIFO_CR &amp; (IPC_FIFO_RECV_EMPTY)) ) 
<br/>
   {
<br/>
      command = REG_IPC_FIFO_RX;
<br/>
<br/>
      switch(command)
<br/>
      {
<br/>
      case FIFO_NONE:
<br/>
         break;
<br/>
      case UPDATEON_ARM9:
<br/>
         MixSound();
<br/>
         SendCommandToArm7(MIXCOMPLETE_ONARM9);
<br/>
         break;
<br/>
      }
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   irqInit();
<br/>
   irqSet(IRQ_VBLANK,&amp;InterruptHandler);
<br/>
   irqSet(IRQ_FIFO_NOT_EMPTY,&amp;FiFoHandler);
<br/>
   irqEnable(IRQ_FIFO_NOT_EMPTY);
<br/>
   
<br/>
   REG_IPC_FIFO_CR = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR | IPC_FIFO_RECV_IRQ;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
arm7 SoundFifoHandler and SendCommandToArm9
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void SoundFifoHandler(void)
<br/>
{
<br/>
   u32 command;
<br/>
<br/>
   if (!(REG_IPC_FIFO_CR &amp; IPC_FIFO_RECV_EMPTY))
<br/>
   {
<br/>
      command = REG_IPC_FIFO_RX;
<br/>
      
<br/>
      switch(command)
<br/>
      {
<br/>
      case FIFO_NONE:
<br/>
         break;
<br/>
      case MIXCOMPLETE_ONARM9:
<br/>
         soundsystem-&gt;soundcursor += soundsystem-&gt;numsamples;
<br/>
         if(soundsystem-&gt;format == 8)
<br/>
            while (soundsystem-&gt;soundcursor &gt; soundsystem-&gt;buffersize) soundsystem-&gt;soundcursor -= soundsystem-&gt;buffersize;
<br/>
         else
<br/>
            while (soundsystem-&gt;soundcursor &gt; (soundsystem-&gt;buffersize &gt;&gt; 1)) soundsystem-&gt;soundcursor -= (soundsystem-&gt;buffersize &gt;&gt; 1);
<br/>
         break;
<br/>
      }
<br/>
   }
<br/>
}
<br/>
<br/>
void SendCommandToArm9(u32 command)
<br/>
{
<br/>
    while (REG_IPC_FIFO_CR &amp; IPC_FIFO_SEND_FULL);
<br/>
    if (REG_IPC_FIFO_CR &amp; IPC_FIFO_ERROR)
<br/>
    {
<br/>
        REG_IPC_FIFO_CR |= IPC_FIFO_SEND_CLEAR;
<br/>
    } 
<br/>
    
<br/>
    REG_IPC_FIFO_TX = command;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
arm9 SendCommandToArm7
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void SendCommandToArm7(u32 command)
<br/>
{
<br/>
    while (REG_IPC_FIFO_CR &amp; IPC_FIFO_SEND_FULL);
<br/>
    if (REG_IPC_FIFO_CR &amp; IPC_FIFO_ERROR)
<br/>
    {
<br/>
        REG_IPC_FIFO_CR |= IPC_FIFO_SEND_CLEAR;
<br/>
    } 
<br/>
    
<br/>
    REG_IPC_FIFO_TX = command;
<br/>
}
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah this seems to work correctly now, not sure if its the correct way or not, seems to be broken in Dualis and no$gba, and partially works in Desmume 5, but works fine on hardware :)
<br/>
<br/>
Troy(GPF)
<br/>
<a href="http://gpf.dcemu.co.uk" target="_blank">http://gpf.dcemu.co.uk</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116935 - wintermute - Wed Jan 31, 2007 4:21 am</h4>
    <div class="postbody"><span class="postbody">This looks fine for basic FIFO goodness but might be a little hard to extend for extra commands.
<br/>
<br/>
Something to be aware of here is that the libnds dispatcher defaults to a single interrupt mode where other interrupts cannot be processed until the last one completes. If you have a sound mixer on the ARM9 which might take some time at arbitrary intervals then you should probably enable nesting before jumping into the mixer. This is achieved by simply enabling the master interrupt - REG_IME = 1. The dispatcher already takes care of switching to system stack before user handlers are called so blowing the irq stack isnt an issue.
<br/>
<br/>
When you enable nesting in this way you need to take care that your FIFO functions are reentrant or can't be called again until they complete. Another poster suggested disabling the FIFO interrupt temporarily in a scenario like this which is one potential solution. This would mean that you could only process one FIFO command at a time though.
<br/>
<br/>
I'm intending to put together some FIFO related functions and build a command system to put in the default arm7 if I ever get the time to finish it.
<br/>
<br/>
What I'd like to do is create a command packet system which includes the size of the packet in the first word which the base FIFO handler would use to receive an entire packet before handing off the packet to a subsystem function determined from part of the command ID. This way I could have some commands in a single word which might be used for power management related functions and other complex multi word commands for playing sounds.
<br/>
<br/>
Right now I'm not sure about how to handle return values from FIFO related functions. It would be nice to know which channel a sound was played on if we retain the play on free channel system in the current, crude system. This could be done by placing a value in the shared memory somewhere but still leaves the issue of knowing when that value is valid. Perhaps a callback to pick up the return value via FIFO might be useful in this case - as I've said many times I believe the IPC structure should be deprecated in favour of something more reliable.
<br/>
<br/>
Any thoughts and suggestions regarding such a system would be appreciated.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#117008 - DekuTree64 - Wed Jan 31, 2007 7:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>wintermute wrote:</b></span></td> </tr> <tr> <td class="quote">Any thoughts and suggestions regarding such a system would be appreciated.</td> </tr></table><span class="postbody">
<br/>
I've been thinking about doing a packet system like that too. Probably could just have the receive handler loop until it gets the whole thing. Not much point in buffering them since the sender will be doing it all in one go anyway.
<br/>
<br/>
My current FIFO system only handles single word messages, and uses the upper 4 bits as the message type, and lower 28 as the data. That way you get a reasonable number of types, and enough data to send pointers.
<br/>
<br/>
You can either send and wait for processing to complete (uses some counters in shared memory to coordinate), or send and return immediately. The send function returns a handle to the command sent (actually the value of the shared memory counter), which you can pass to another function to check if processing has completed on it.
<br/>
<br/>
The packet system could mostly be built on top of that system, using one of the 16 types as "packet", and the 28 data bits to specify the type of packet, and number of words.
<br/>
<br/>
A "finished processing" callback for commands (single-word and packets) would probably the best way to send return values. Could do it using the FIFO, but may be easier to use the IPC sync register and shared memory to avoid conflicts.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#117032 - HyperHacker - Wed Jan 31, 2007 9:58 pm</h4>
    <div class="postbody"><span class="postbody">I've been using a simple system that seems to work well. Each command is in the format ccpp0000; cc=command ID, pp=# of parameters. After that comes the parameters, one word each. Currently the system allows for only 4 parameters but it wouldn't be hard to allow more; it waits until space is free before sending each, and the other CPU waits to receive them all before processing them. I haven't yet figured how to implement return values though.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
