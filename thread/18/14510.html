<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>gluLookAtf32 vs. glRotate/glTranslate - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > gluLookAtf32 vs. glRotate/glTranslate</h2>
<div id="posts">
<div class="post">
    <h4>#145206 - a128 - Mon Nov 12, 2007 5:30 pm</h4>
    <div class="postbody"><span class="postbody">I use gluLookAtf32() for my camera system..which works fine and smooth
<br/>
<br/>
When I use a inverse transformation system for my camera (which yields to the same output)
<br/>
<br/>
via 
<br/>
glRotate(360-angle) //inverse angle
<br/>
glTransform(-eye)
<br/>
<br/>
it suffers from  NON-smooth rotations even when I interpolate between the "inverse angle"
<br/>
<br/>
any suggestions?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145209 - sajiimori - Mon Nov 12, 2007 7:46 pm</h4>
    <div class="postbody"><span class="postbody">If you're doing 3 separate rotations (along the X, Y, and Z axes), note that earlier rotations affect later ones.  It's order-dependent, and difficult to achieve smooth interpolations in the most general case.
<br/>
<br/>
Here's another thread about it.  Though I don't like the solution that Noda ended up using, it has some good replies from a few people.
<br/>
<br/>
<a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=14394" target="_blank">http://forum.gbadev.org/viewtopic.php?t=14394</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145279 - a128 - Tue Nov 13, 2007 4:19 pm</h4>
    <div class="postbody"><span class="postbody">Now I use quaternion for my camera transformations
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
   m3x3 rot;
<br/>
<br/>
        q1.FromEuler(rot_x,360-Heading,0); //x,y,z rot
<br/>
   q1.CreateMatrix(rot);
<br/>
<br/>
   glMultMatrix3x3(&amp;rot);
<br/>
<br/>
   MATRIX_TRANSLATE=-eye_.X();//get the 20:12 values
<br/>
      MATRIX_TRANSLATE=-eye_.Y();//get the 20:12 values
<br/>
      MATRIX_TRANSLATE=-eye_.Z();//get the 20:12 values
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
which works quite smooth
<br/>
<br/>
if I use in FromEuler() fixed point sin/cos from libnds it's NON-smooth again!!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void Quaternion::FromEuler(dfloat ex,dfloat ey,dfloat ez)
<br/>
// Create a quaternion from Euler angles. Angles are applied in the order XYZ,
<br/>
// while another order may be more appropriate.
<br/>
// Code after an example from GDMag, march '98, pp 18. (modified somewhat)
<br/>
{
<br/>
    dfloat rx,ry,rz;
<br/>
    Quaternion qx,qy,qz;
<br/>
<br/>
   #if 1
<br/>
    // Get half angles
<br/>
    Fixed ti=(ex*0.5f);
<br/>
    Fixed tj=(ey*0.5f);
<br/>
    Fixed tk=(ez*0.5f);
<br/>
    // Quaternion
<br/>
    qx.x=Fixed::sin(ti);
<br/>
    qx.y=0;
<br/>
    qx.z=0;
<br/>
    qx.w=Fixed::cos(ti);
<br/>
    qy.x=0;
<br/>
    qy.y=Fixed::sin(tj);
<br/>
    qy.z=0;
<br/>
    qy.w=Fixed::cos(tj);
<br/>
    qz.x=0;
<br/>
    qz.y=0;
<br/>
    qz.z=Fixed::sin(tk);
<br/>
    qz.w=Fixed::cos(tk);
<br/>
#else
<br/>
  // Convert angles to radians
<br/>
    rx=(ex*(float)M_PI)/(360/2);
<br/>
    ry=(ey*(float)M_PI)/(360/2);
<br/>
   rz=(ez*(float)M_PI)/(360/2);
<br/>
   // Get half angles
<br/>
    float ti=(rx*0.5f).Float();
<br/>
    float tj=(ry*0.5f).Float();
<br/>
    float tk=(rz*0.5f).Float();
<br/>
    // Quaternion
<br/>
    qx.x=sinf(ti);
<br/>
    qx.y=0;
<br/>
    qx.z=0;
<br/>
    qx.w=cosf(ti);
<br/>
    qy.x=0;
<br/>
    qy.y=sinf(tj);
<br/>
    qy.z=0;
<br/>
    qy.w=cosf(tj);
<br/>
    qz.x=0;
<br/>
    qz.y=0;
<br/>
    qz.z=sinf(tk);
<br/>
    qz.w=cosf(tk);
<br/>
#endif
<br/>
    Multiply(&amp;qx,&amp;qy);
<br/>
    Multiply(&amp;qz);
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145280 - a128 - Tue Nov 13, 2007 4:35 pm</h4>
    <div class="postbody"><span class="postbody">the only smooth "third person" camera I know is
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> 
<br/>
   
<br/>
    camera = pos;
<br/>
<br/>
    // Translate the forward vector to the origin
<br/>
    // in relation to look.
<br/>
    Vec3 tempMeasure = pos -forward;
<br/>
<br/>
    tempMeasure.Normalize();
<br/>
    
<br/>
    camera = camera + ( tempMeasure * camera_distance);
<br/>
       
<br/>
      gluLookAtf32(camera.x,camera.y+2,camera.z,
<br/>
                                  pos.x, pos.y ,pos.z.,
<br/>
                                     0, inttof32(1), 0);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I guess it's smooth because of gluLookAt()  normalizes all vectors and using those three othronormal vectors it constructs the correct transformation.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145382 - sajiimori - Wed Nov 14, 2007 6:12 pm</h4>
    <div class="postbody"><span class="postbody">As soon as you introduce Euler angles, you've got order dependency.  This is fine in some situations, and not in others.  If they're causing you trouble, skip the Euler angles entirely, and use e.g. axis-angle pairs.  Quaternions convert naturally to and from axis-angle format.
<br/>
<br/>
If I understand what you're doing correctly, gluLookAtf32 is working well because you can linearly interpolate the camera position and lookat position, and that usually looks pretty good, whereas interpolating pitch/yaw/roll often looks bad.
<br/>
<br/>
But hey, gluLookAtf32 might make a lot of sense for a 3rd-person view!  It's there to be used.  :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#158915 - a128 - Fri Jun 20, 2008 8:23 pm</h4>
    <div class="postbody"><span class="postbody">Mario Kart DS has a simple but effective third person view.
<br/>
The camera is fixed behind the player kart.
<br/>
<br/>
If you steer or jump, you notice some lag of the camera position.
<br/>
This lag let you see that the kart steers or jumps.
<br/>
<br/>
Here is a code which does this
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
//Y is UP
<br/>
<br/>
<br/>
#define RELAXATION(target, prev, rate) \
<br/>
do { \
<br/>
target = (prev) + (rate) * ((target) - (prev)) ; \
<br/>
prev = (target); \
<br/>
} while (0)
<br/>
<br/>
<br/>
const Vec3 pos=KART_POSITION;
<br/>
Fixed a=KART_HEADING_DEGREE;
<br/>
dt=1.0f/FPS; //timestep per frame
<br/>
<br/>
if (first_start) {
<br/>
olda_=a;
<br/>
}
<br/>
<br/>
//interpolate the heading of the kart
<br/>
<br/>
RELAXATION(a,olda_,dt*8);
<br/>
<br/>
//Note: I use float sinf/cosf which has a greater resolution then the fixpoint SIN/COS
<br/>
//without the float code you will see the camera jumping..
<br/>
<br/>
//position eye behind the kart
<br/>
eye_.x = camera_distance*sinf(a*DEGTORAD)+pos.x;
<br/>
eye_.y = pos.y;
<br/>
eye_.z = camera_distance*cosf(a*DEGTORAD)+pos.z;
<br/>
<br/>
eye_.y+= camera_height;
<br/>
<br/>
look=pos;
<br/>
look.y+=camera_height_view;
<br/>
<br/>
if (first_start) {
<br/>
lasteye_=eye_;
<br/>
lastlook_=look;
<br/>
}
<br/>
<br/>
//only interpolate the y position (up/down)
<br/>
<br/>
RELAXATION(eye_.y,lasteye_.y,dt*8);
<br/>
RELAXATION(look.y,lastlook_.y,dt*8);
<br/>
<br/>
gluLookAtf32(eye_.x.value,eye_.y.value,eye_.z.value,
<br/>
look.x.value,look.y.value,look.z.value,
<br/>
0,inttof32(1),0); //Y is UP</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
