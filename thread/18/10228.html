<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Accurate timing using built-in timers - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > Accurate timing using built-in timers</h2>
<div id="posts">
<div class="post">
    <h4>#91176 - xyierz - Wed Jul 05, 2006 1:36 am</h4>
    <div class="postbody"><span class="postbody">I'm working on a program which requires very accurate timing. The problem is that I have a base-unit of time in seconds stored as a rational number (eg. 1/24 which means 24 ticks per second) and I want to use the DS's built in timers to tick at that rate, as accurately as possible.
<br/>
<br/>
One way I've tried to tackle this problem is using cascade timing: I calculate the equivalent time interval in system clock ticks, then find a value for the first timer that evenly divides this value (as much as possible), and use count-up timing in the next system timer to generate an interrupt whenever the preceding timer has overflowed the appropriate number of times.  Unfortunately this doesn't work -- apparently you can't have the second timer generate an interrupt when using cascade timing, or else I'm doing something wrong.
<br/>
<br/>
Does anyone have any ideas on the best way to solve this problem that preferably doesn't take a lot of extra CPU time?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#91177 - tepples - Wed Jul 05, 2006 1:38 am</h4>
    <div class="postbody"><span class="postbody">What do you need the 24 Hz timebase for? Is it for video playback?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#91180 - xyierz - Wed Jul 05, 2006 2:00 am</h4>
    <div class="postbody"><span class="postbody">That's right.  The reason it needs to be so accurate is that most of the time in video files the video and audio are running at different framerates, so I would need two separate timers to keep track of both streams.  If either timer is inaccurate they will eventually become desynched.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#91182 - tepples - Wed Jul 05, 2006 2:05 am</h4>
    <div class="postbody"><span class="postbody">No, what you need is one timer that counts audio samples, and then you need to count how many samples have passed. Once enough samples have passed, draw one video frame.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#91184 - xyierz - Wed Jul 05, 2006 2:11 am</h4>
    <div class="postbody"><span class="postbody">Thanks.  I'm surprised I hadn't thought of doing it that way.  I'm a little worried it might interfere with my buffering scheme, but I'll give it a shot.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
