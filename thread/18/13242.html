<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>which is faster,swiCopy or dmaCopy?? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > which is faster,swiCopy or dmaCopy??</h2>
<div id="posts">
<div class="post">
    <h4>#129188 - odelot - Sun May 20, 2007 7:09 am</h4>
    <div class="postbody"><span class="postbody">?? what are the differences between them??</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#129189 - LiraNuna - Sun May 20, 2007 7:44 am</h4>
    <div class="postbody"><span class="postbody">swiCopy is a BIOS call. it stops CPU execution and IRQs. There is believed to be a bug in one of it's modes though (called swiFastCopy) - the first 3/4N bytes will be copied fast, while the last 1/4N will be copied very slowly.
<br/>
<br/>
DMA copy is done by an external controller, and is also copying while CPU halted in addition to IRQs.
<br/>
<br/>
I remember dsboi doing a speed test to check up which of the 4 copy methods are the fastest. ASM copy, which was a 32bit ldmia writes, memcpy, DMA copy in 32bit mode and swiCopy (and swiFastCopy)
<br/>
<br/>
Those were the results (I don't have the actual numbers)
<br/>
<br/>
1) ldmia copy
<br/>
2) memcpy
<br/>
3) DMA copy
<br/>
4) swiCopy
<br/>
5) swiFastCopy
<br/>
<br/>
I'll have to find that benchmark .nds...<br/>_________________<br/>Private property.
<br/>
Violators will be shot, survivors will be shot again.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#129748 - Mushu - Sat May 26, 2007 1:03 am</h4>
    <div class="postbody"><span class="postbody">Hrm, I remember reading about that benchmark test, but the page I read it on seemed to be somewhat dated. Happen to know what version (or around what version) of libnds they were compiled with?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130005 - wintermute - Wed May 30, 2007 1:42 am</h4>
    <div class="postbody"><span class="postbody">The libnds version isn't at all relevant.
<br/>
<br/>
The gcc version *may* have some bearing on the speed but not much. The only function used for testing written in C was memcpy IIRC.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130014 - Mushu - Wed May 30, 2007 4:50 am</h4>
    <div class="postbody"><span class="postbody">Oh, for some reason I thought the "bug" in swiFastCopy was a bug in libnds, rather than a malfunction in the hardware implementation. Thanks for the clarification.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130319 - Mushu - Sat Jun 02, 2007 5:44 am</h4>
    <div class="postbody"><span class="postbody">Sorry to double post, but I'm a huge attention whore, and I wanted to get some attention :&gt;
<br/>
<br/>
Anyway, I've never really been satisfied with the benchmarks done on memcpy/swiCopy/dmaCopy, simply because they all seem to show that memcpy is faster than dmaCopy. dmaCopy is a memory transfer with a dedicated controller, so why the hell would it be faster than a software memcpy?
<br/>
<br/>
Additionally, all of the benchmarks I've ever seen only gave a single number for each of the functions, rather than testing over a variety of transfer sizes and locations (main memory vs. VRAM vs. shared memory, etc). So I decided to hunker down and do some testing of my own, and the results were... informative.
<br/>
<br/>
I wrote a small app (source+binary to follow) to test all power-of-two block sizes from 16-1048576 bytes, using either main memory or VRAM as src/dst, and main memory for dst/src (I didn't want to end up with the situation where the source and destination are the same address, so only 1 of them is allowed to be VRAM).
<br/>
<br/>
Additionally, I mapped all the VRAM to 0x6000000, assuming that it will perform the same regardless of the mapping (which makes sense to me, but may not be the case).
<br/>
<br/>
Oh god I have to make a table. These values were obtained with the binary (to follow) on my DS Lite; there's probably at least 5 bugs in the source, so I wouldn't call them very conclusive, but they definitely do suggest conclusions -
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Main Memory to Main Memory
<br/>
<br/>
          16B  32B 64B 128B  256B  512B 1024B 2048B 
<br/>
memcpy    41   52  73  115   312   731  1219  3906
<br/>
dmaCopy   94  158 286  542  1054  2118  4148  8244
<br/>
swiCopy  123  167 221  383   770  1440  2716  6691
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B
<br/>
memcpy   11063  23697  48677   98291  196727
<br/>
dmaCopy  16481  32887  65655  131263  262338
<br/>
swiCopy  17789  38230  77787  155769  311512
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
etc, you get the picture. This matches what I've read so far, memcpy &gt; dmaCopy &gt; swiCopy, which is expected. When you switch over to VRAM, however, a different picture emerges -
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Main Memory to VRAM
<br/>
<br/>
          16B  32B  64B 128B  256B  512B 1024B 2048B
<br/>
dmaCopy   48   56   72  104   168   324   592  1145
<br/>
memcpy    58   85  139  247   463   939  1891  4001
<br/>
swiCopy  168  204  360  598  1118  2124  4212  8456
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B
<br/>
dmaCopy   2226   4375   8627   17125   34121
<br/>
memcpy    8711  18657  38657   77907  155903
<br/>
swiCopy  17828  37827  76815  153746  307480
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Anyway, so it appears that dmaCopy is significantly faster for transferring any size of data to VRAM, while memcpy is faster when working only in main memory. I would suspect that the dma hardware doesn't actually kick in unless you're transferring to VRAM, but I have no foundation for that conclusion.
<br/>
<br/>
I'm sure a lot of people already knew about this (or I've made a mistake somewhere ._.) but I've always seem to have read that memcpy is faster than everything else etc, and just though that was odd.
<br/>
<br/>
Blarg.
<br/>
<br/>
<a class="postlink" href="http://mushu.dreamhosters.com/upload/Benchmark1.zip" target="_blank">Sauce + Binary</a>
<br/>
<a class="postlink" href="http://mushu.dreamhosters.com/upload/Benchmark1.nds" target="_blank">Just the Binary</a>
<br/>
<br/>
:&lt;
<br/>
<br/>
Oh, and controls for the thing -
<br/>
* A: Double the amount of memory allocated.
<br/>
* B: Halve the amount of memory allocated.
<br/>
* X: Toggle destination (VRAM/Main Memory)
<br/>
* Y: Toggle source (VRAM/Main Memory)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130323 - mml - Sat Jun 02, 2007 8:20 am</h4>
    <div class="postbody"><span class="postbody">I think the larger part of the DMA controller's benefit is being able to copy asynchronously (for some value thereof, anyway).  But this benefit is lost when using dmaCopy(), since it spins on the control register and only returns once the copy is actually complete.  Of course if you're courageous and use dmaCopyAsynch() or its variants, you then have to manage the synchronisation yourself, which in most cases is probably more pain in the arse than it's worth...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130334 - simonjhall - Sat Jun 02, 2007 10:12 am</h4>
    <div class="postbody"><span class="postbody">Yo, what are the units in that table? Good work anyway :-)
<br/>
<br/>
One thing I'm interested in is how exactly does the copy loop in memcpy work? Does it copy in word quantites until it has less than a word of memory to go, or does it do the whole transfer by just copying bytes?
<br/>
I bet you could write a really fast asm copy assuming that the source + dest are 16/32-bit aligned and the size is some multiple of something...
<br/>
<br/>
Reckon you could also do the test on main memory to the uncached memory map? memcpy is probably faster to main memory because it uses the cache, but dmacopy and swicopy don't. To make it uncached OR your addresses with 0x400000.<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130340 - wintermute - Sat Jun 02, 2007 10:47 am</h4>
    <div class="postbody"><span class="postbody">memcpy source from newlib
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
/*
<br/>
FUNCTION
<br/>
        &lt;&lt;memcpy&gt;&gt;---copy memory regions
<br/>
<br/>
ANSI_SYNOPSIS
<br/>
        #include &lt;string.h&gt;
<br/>
        void* memcpy(void *&lt;[out]&gt;, const void *&lt;[in]&gt;, size_t &lt;[n]&gt;);
<br/>
<br/>
TRAD_SYNOPSIS
<br/>
        void *memcpy(&lt;[out]&gt;, &lt;[in]&gt;, &lt;[n]&gt;
<br/>
        void *&lt;[out]&gt;;
<br/>
        void *&lt;[in]&gt;;
<br/>
        size_t &lt;[n]&gt;;
<br/>
<br/>
DESCRIPTION
<br/>
        This function copies &lt;[n]&gt; bytes from the memory region
<br/>
        pointed to by &lt;[in]&gt; to the memory region pointed to by
<br/>
        &lt;[out]&gt;.
<br/>
<br/>
        If the regions overlap, the behavior is undefined.
<br/>
<br/>
RETURNS
<br/>
        &lt;&lt;memcpy&gt;&gt; returns a pointer to the first byte of the &lt;[out]&gt;
<br/>
        region.
<br/>
<br/>
PORTABILITY
<br/>
&lt;&lt;memcpy&gt;&gt; is ANSI C.
<br/>
<br/>
&lt;&lt;memcpy&gt;&gt; requires no supporting OS subroutines.
<br/>
<br/>
QUICKREF
<br/>
        memcpy ansi pure
<br/>
   */
<br/>
<br/>
#include &lt;_ansi.h&gt;
<br/>
#include &lt;stddef.h&gt;
<br/>
#include &lt;limits.h&gt;
<br/>
<br/>
/* Nonzero if either X or Y is not aligned on a "long" boundary.  */
<br/>
#define UNALIGNED(X, Y) \
<br/>
  (((long)X &amp; (sizeof (long) - 1)) | ((long)Y &amp; (sizeof (long) - 1)))
<br/>
<br/>
/* How many bytes are copied each iteration of the 4X unrolled loop.  */
<br/>
#define BIGBLOCKSIZE    (sizeof (long) &lt;&lt; 2)
<br/>
<br/>
/* How many bytes are copied each iteration of the word copy loop.  */
<br/>
#define LITTLEBLOCKSIZE (sizeof (long))
<br/>
<br/>
/* Threshhold for punting to the byte copier.  */
<br/>
#define TOO_SMALL(LEN)  ((LEN) &lt; BIGBLOCKSIZE)
<br/>
<br/>
_PTR
<br/>
_DEFUN (memcpy, (dst0, src0, len0),
<br/>
   _PTR dst0 _AND
<br/>
   _CONST _PTR src0 _AND
<br/>
   size_t len0)
<br/>
{
<br/>
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
<br/>
  char *dst = (char *) dst0;
<br/>
  char *src = (char *) src0;
<br/>
<br/>
  _PTR save = dst0;
<br/>
<br/>
  while (len0--)
<br/>
    {
<br/>
      *dst++ = *src++;
<br/>
    }
<br/>
<br/>
  return save;
<br/>
#else
<br/>
  char *dst = dst0;
<br/>
  _CONST char *src = src0;
<br/>
  long *aligned_dst;
<br/>
  _CONST long *aligned_src;
<br/>
  int   len =  len0;
<br/>
<br/>
  /* If the size is small, or either SRC or DST is unaligned,
<br/>
     then punt into the byte copy loop.  This should be rare.  */
<br/>
  if (!TOO_SMALL(len) &amp;&amp; !UNALIGNED (src, dst))
<br/>
    {
<br/>
      aligned_dst = (long*)dst;
<br/>
      aligned_src = (long*)src;
<br/>
<br/>
      /* Copy 4X long words at a time if possible.  */
<br/>
      while (len &gt;= BIGBLOCKSIZE)
<br/>
        {
<br/>
          *aligned_dst++ = *aligned_src++;
<br/>
          *aligned_dst++ = *aligned_src++;
<br/>
          *aligned_dst++ = *aligned_src++;
<br/>
          *aligned_dst++ = *aligned_src++;
<br/>
          len -= BIGBLOCKSIZE;
<br/>
        }
<br/>
<br/>
      /* Copy one long word at a time if possible.  */
<br/>
      while (len &gt;= LITTLEBLOCKSIZE)
<br/>
        {
<br/>
          *aligned_dst++ = *aligned_src++;
<br/>
          len -= LITTLEBLOCKSIZE;
<br/>
        }
<br/>
<br/>
       /* Pick up any residual with a byte copier.  */
<br/>
      dst = (char*)aligned_dst;
<br/>
      src = (char*)aligned_src;
<br/>
    }
<br/>
<br/>
  while (len--)
<br/>
    *dst++ = *src++;
<br/>
<br/>
  return dst0;
<br/>
#endif /* not PREFER_SIZE_OVER_SPEED */
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
You can certainly write a fast asm copy like that but it won't be a drop in replacement for memcpy. 
<br/>
<br/>
Why wouldn't swiCopy use the cache?
<br/>
<br/>
The most interesting thing about these tests that I noticed was this.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
                        1K    2K
<br/>
dmaCopy main to main  4148  8244 
<br/>
dmaCopy main to VRAM   592  1145
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Notice anything there?<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130342 - Dark Knight ez - Sat Jun 02, 2007 11:16 am</h4>
    <div class="postbody"><span class="postbody">You mean besides being 8 times more quick?<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><a class="postlink" href="http://amplituds.drunkencoders.com" target="_blank">AmplituDS website</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130343 - NeX - Sat Jun 02, 2007 11:20 am</h4>
    <div class="postbody"><span class="postbody">Does it really matter how quick it is when most people are using MicroSD cards, some of the slowest on the planet?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130344 - wintermute - Sat Jun 02, 2007 11:35 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dark Knight ez wrote:</b></span></td> </tr> <tr> <td class="quote">You mean besides being 8 times more quick?</td> </tr></table><span class="postbody">
<br/>
<br/>
Which suggests what?<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130345 - wintermute - Sat Jun 02, 2007 11:38 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>NeX wrote:</b></span></td> </tr> <tr> <td class="quote">Does it really matter how quick it is when most people are using MicroSD cards, some of the slowest on the planet?</td> </tr></table><span class="postbody">
<br/>
<br/>
Most slot 2 cards load everything into gba cart space before executing the app.
<br/>
<br/>
Data doesn't necessarily have to be loaded from the filesystem *every* time you want to use it. That all depends on how well you've thought things out.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130348 - Dark Knight ez - Sat Jun 02, 2007 1:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>wintermute wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dark Knight ez wrote:</b></span></td> </tr> <tr> <td class="quote">You mean besides being 8 times more quick?</td> </tr></table><span class="postbody">
<br/>
<br/>
Which suggests what?</span></td> </tr></table><span class="postbody">
<br/>
Erm... that dmaCopy can copy entire blocks of 8*2bytes at one time to VRAM as opposed to just 2bytes at a time like memcpy does? Or am I missing something?<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><a class="postlink" href="http://amplituds.drunkencoders.com" target="_blank">AmplituDS website</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130355 - Lick - Sat Jun 02, 2007 3:26 pm</h4>
    <div class="postbody"><span class="postbody">What happens when you cache the VRAM? x_x<br/>_________________<br/><a class="postlink" href="http://licklick.wordpress.com" target="_blank">http://licklick.wordpress.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130359 - wintermute - Sat Jun 02, 2007 4:07 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lick wrote:</b></span></td> </tr> <tr> <td class="quote">What happens when you cache the VRAM? x_x</td> </tr></table><span class="postbody">
<br/>
<br/>
Your graphics break.
<br/>
<br/>
Not entirely sure what you're getting at either.
<br/>
<br/>
Cache would only affect the CPU copies, DMA doesn't go through the cache - this is why cache needs to be flushed before a DMA transfer when the source memory is cached and invalidated after if the destination is cached.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"><br/><br/>Last edited by wintermute on Sat Jun 02, 2007 4:13 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#130360 - wintermute - Sat Jun 02, 2007 4:09 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dark Knight ez wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Erm... that dmaCopy can copy entire blocks of 8*2bytes at one time to VRAM as opposed to just 2bytes at a time like memcpy does? Or am I missing something?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not really sure I follow your logic here.
<br/>
<br/>
The dma from main RAM to VRAM is approximately 8 times faster than from main RAM to main RAM. This implies that copying from main RAM to VRAM can copy 8 times as much data in the same time period. Nothing can be inferred about the amount of data  transferred in a single chunk.
<br/>
<br/>
Assuming that VRAM to main RAM is the same speed then DMA from main to VRAM &amp; back to main should theoretically be 4 times faster than main to main.
<br/>
<br/>
Right now I'm not sure why this should be the case. I'm open to suggestions.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130378 - Cearn - Sat Jun 02, 2007 6:57 pm</h4>
    <div class="postbody"><span class="postbody">This little bit from gbatek may be of interest:
<br/>
<br/>
From <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#dsdmatransfers" target="_blank">http://nocash.emubase.de/gbatek.htm#dsdmatransfers</a>:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><span style="font-weight: bold">NDS Sequential Main Memory DMA</span>
<br/>
Main RAM has different access time for sequential and non-sequential access. Normally DMA uses sequential access (except for the first word), however, if the source and destination addresses are both in Main RAM, then all accesses become non-sequential. In that case it would be faster to use two DMA transfers, one from Main RAM to a scratch buffer in WRAM, and one from WRAM to Main RAM.</td> </tr></table><span class="postbody">
<br/>
<br/>
Unfortunately, I can't find what the waitstates for DS sections are in gbatek :\
<br/>
<br/>
Also fun is adding FlushAll() right before the copies. This has quite a large effect on the results (except, of course, for DMA).
<br/>
<br/>
The comparisons aren't quite correct though. dmaCopy() uses the byte-size, not the halfword size, so the figures for DMA are inflated (or, rather, deflated). Also, why use halfword copies instead of word copies?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130384 - Mushu - Sat Jun 02, 2007 7:27 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>mml wrote:</b></span></td> </tr> <tr> <td class="quote">I think the larger part of the DMA controller's benefit is being able to copy asynchronously (for some value thereof, anyway).  But this benefit is lost when using dmaCopy(), since it spins on the control register and only returns once the copy is actually complete.  Of course if you're courageous and use dmaCopyAsynch() or its variants, you then have to manage the synchronisation yourself, which in most cases is probably more pain in the arse than it's worth...</td> </tr></table><span class="postbody">
<br/>
Yeah, I thought the same thing at first too, since I figured there'd be four separate DMA controllers, each controlled by one of the registers. In my tests though, this query -
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void query_quadDmaCopy() {
<br/>
   PROF_START();
<br/>
   int part_size = 1 &lt;&lt; ( mem_size - 2 );
<br/>
   dmaCopyWordsAsynch( 0, psrc + 0*part_size, pdst + 0*part_size, part_size );
<br/>
   dmaCopyWordsAsynch( 1, psrc + 1*part_size, pdst + 1*part_size, part_size );
<br/>
   dmaCopyWordsAsynch( 2, psrc + 2*part_size, pdst + 2*part_size, part_size );
<br/>
   dmaCopyWordsAsynch( 3, psrc + 3*part_size, pdst + 3*part_size, part_size );
<br/>
   while ( dmaBusy(0) || dmaBusy(1) || dmaBusy(2) || dmaBusy(3) );
<br/>
   PROF_END( t_quadDmaCopy );
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Always had a higher delay than the single DMA transfer. I'm not sure if this is a flaw in my understanding/implementation of the copy, but it raises doubts on the idea that there is a unique DMA controller for each channel. Might just be the same controller juggling all four channels, which kills any benefit you'd normally get from parallel copies. If that's the case though, dunno why they'd have four separate channels in the first place :&lt;
<br/>
<br/>
Well. I guess it would be useful if you were loading things in the background (like changing tilesets without a loading screen!) D:
<br/>
<br/>
If you want the binary/source with the 4-channel DMA transfer (or just numbers) I can post those too.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">Yo, what are the units in that table? </td> </tr></table><span class="postbody">
<br/>
lol I actually have no idea, I just stole the timer code straight from TONC since I didn't want to have to figure out how to properly set up the timers with the right frequency so they don't overflow, cascaded right, etc. It doesn't really matter what the units are for comparison purposes, since all of the tests use the same timer setup :3
<br/>
<br/>
&lt;3 TONC.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">The comparisons aren't quite correct though. dmaCopy() uses the byte-size, not the halfword size, so the figures for DMA are inflated (or, rather, deflated). Also, why use halfword copies instead of word copies?</td> </tr></table><span class="postbody">
<br/>
Whoooops. Changed the dma query function from -
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void query_dmaCopy() {   
<br/>
   PROF_START();
<br/>
   dmaCopy( psrc, pdst, 1 &lt;&lt; (mem_size-1) );
<br/>
   PROF_END( t_dmaCopy );
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
to
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void query_dmaCopy() {   
<br/>
   PROF_START();
<br/>
   dmaCopyWords( 3, psrc, pdst, 1 &lt;&lt; (mem_size) );
<br/>
   PROF_END( t_dmaCopy );
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Which ended up adding on some time to the DMA transfer (hopefully I got it right this time). Actually, this makes a lot more sense, since it's basically spot-on with the 4-channel DMA transfer posted above. Lemmie upload updated binaries/source :&lt;
<br/>
<br/>
<a class="postlink" href="http://mushu.dreamhosters.com/upload/Benchmark1-1.zip" target="_blank">Updated Binary/Source</a>
<br/>
<br/>
And, might as well-redo the tables~
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Main Memory to Main Memory
<br/>
<br/>
          16B  32B 64B 128B  256B  512B 1024B 2048B 
<br/>
memcpy    41   52  73  115   312   731  1219  3906
<br/>
dmaCopy  102  174 318  365  1182  2334  4638  9246
<br/>
swiCopy  123  167 221  383   770  1440  2716  6691
<br/>
4dmaCopy 143  215 359  647  1223  2397  4701  9309
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B
<br/>
memcpy   11063  23697  48677   98291  196727
<br/>
dmaCopy  18525  36960  73824  147624  295083
<br/>
swiCopy  17789  38230  77787  155769  311512
<br/>
4dmaCopy 18525  36957  73893  147625  295152
<br/>
<br/>
Main Memory to VRAM
<br/>
<br/>
          16B  32B  64B 128B  256B  512B 1024B 2048B
<br/>
dmaCopy   53   65   89  137   233   432   830  1641
<br/>
4dmaCopy 123  139  163  211   307   499   883  1679
<br/>
memcpy    58   85  139  247   463   939  1891  4001
<br/>
swiCopy  168  204  360  598  1118  2124  4212  8456
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B
<br/>
dmaCopy   3256   6519  13022   25973   51950
<br/>
4dmaCopy  3293   6449  12905   25941   51797
<br/>
memcpy    8711  18657  38657   77907  155903
<br/>
swiCopy  17828  37827  76815  153746  307480</td> </tr></table><span class="postbody">
<br/>
<br/>
:&gt;
<br/>
<br/>
Ughhh, okay, wtf.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>http://nocash.emubase.de/gbatek.htm#dmatransfers wrote:</b></span></td> </tr> <tr> <td class="quote">The CPU is paused when DMA transfers are active, however, the CPU is operating during the periods when Sound/Blanking DMA transfers are paused.</td> </tr></table><span class="postbody">
<br/>
<br/>
So to test this, I editted out the while( dmaBusy etc ) loop in the 4-channel DMA query -
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void query_quadDmaCopy() {
<br/>
   PROF_START();
<br/>
   int part_size = 1 &lt;&lt; ( mem_size - 2 );
<br/>
   dmaCopyWordsAsynch( 0, psrc + 0*part_size, pdst + 0*part_size, part_size );
<br/>
   dmaCopyWordsAsynch( 1, psrc + 1*part_size, pdst + 1*part_size, part_size );
<br/>
   dmaCopyWordsAsynch( 2, psrc + 2*part_size, pdst + 2*part_size, part_size );
<br/>
   dmaCopyWordsAsynch( 3, psrc + 3*part_size, pdst + 3*part_size, part_size );
<br/>
   // while ( dmaBusy(0) || dmaBusy(1) || dmaBusy(2) || dmaBusy(3) );
<br/>
   PROF_END( t_quadDmaCopy );
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
It appears to work exactly the same on the hardware, whether or not that line is there, which suggests the DMA transfer might be blocking (and would also explain why this is approximately the same speed as dmaCopy).
<br/>
<br/>
If this is the case, then wtf are there 4 channels for? D:
<br/>
<br/>
(moar) auuuughhh wtf. There's actually an anomaly in here - when transferring 16384B from main memory to main memory (4KB on each DMA channel) the copy executes in 8350 units (compared to 49308 units taken by memcpy). I dunno lol :&lt;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130392 - tepples - Sat Jun 02, 2007 11:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mushu wrote:</b></span></td> </tr> <tr> <td class="quote">I'm not sure if this is a flaw in my understanding/implementation of the copy, but it raises doubts on the idea that there is a unique DMA controller for each channel. Might just be the same controller juggling all four channels, which kills any benefit you'd normally get from parallel copies. If that's the case though, dunno why they'd have four separate channels in the first place :&lt;</td> </tr></table><span class="postbody">
<br/>
On the GBA it was
<br/>
0. Raster effect
<br/>
1. Secondary raster effect or stereo PCM
<br/>
2. PCM
<br/>
3. Immediate copies
<br/>
<br/>
On the DS ARM9 it might be
<br/>
0. Raster effect to main screen
<br/>
1. Raster effect to sub screen
<br/>
2. ???
<br/>
3. Immediate copies
<br/>
<br/>
That's what the four channels are for: transfers in modes other than immediate.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130394 - HyperHacker - Sat Jun 02, 2007 11:37 pm</h4>
    <div class="postbody"><span class="postbody">Having 4 channels when only one can run at a time is still good because if one transfer is in progress/pending, you can simply schedule one on the next channel and it'll be done automatically when the previous ones finish. Even if only one runs at a time, you can still do 2 in parallel, one by DMA and one by CPU (or CPU can do other things during transfer).
<br/>
<br/>
It's interesting that the CPU is paused during DMA though, which kinda kills that advantage. The Game Boy is similar: during DMA only the upper 128 bytes of RAM are accessible. The CPU keeps going but is basically forced to spin in a timed loop in that small space. Here, the advantage is that DMA is faster than a CPU copy (slow CPU), but it sounds like on NDS, that only applies for main &lt;--&gt; VRAM.
<br/>
<br/>
So if I understand correctly (probably not) and this info is all correct, on the DS, DMA is only useful for VRAM access, sound, and HDMA.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130415 - wintermute - Sun Jun 03, 2007 3:32 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">This little bit from gbatek may be of interest:
<br/>
<br/>
From <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#dsdmatransfers" target="_blank">http://nocash.emubase.de/gbatek.htm#dsdmatransfers</a>:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><span style="font-weight: bold">NDS Sequential Main Memory DMA</span>
<br/>
Main RAM has different access time for sequential and non-sequential access. Normally DMA uses sequential access (except for the first word), however, if the source and destination addresses are both in Main RAM, then all accesses become non-sequential. In that case it would be faster to use two DMA transfers, one from Main RAM to a scratch buffer in WRAM, and one from WRAM to Main RAM.</td> </tr></table><span class="postbody">
<br/>
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Awesome, that makes perfect sense now.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Also fun is adding FlushAll() right before the copies. This has quite a large effect on the results (except, of course, for DMA).
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Uh, I really don't recommend doing that - DC_FlushRange() &amp; DC_InvalidateRange() exist for a reason.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The comparisons aren't quite correct though. dmaCopy() uses the byte-size, not the halfword size, so the figures for DMA are inflated (or, rather, deflated). Also, why use halfword copies instead of word copies?</td> </tr></table><span class="postbody">
<br/>
<br/>
You've lost me here. You mean memcpy uses byte size (blatently it doesn't  unless source &amp; destination are misaligned)?<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130420 - DekuTree64 - Sun Jun 03, 2007 6:49 am</h4>
    <div class="postbody"><span class="postbody">Wow, this is really interesting. I just tried it with an 8-register ldmia/stmia copy and it beats memcpy in pretty much all cases. Here is the function:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">fastCopy:
<br/>
@bail out for misaligned/0 size
<br/>
tst r2, #31
<br/>
bxne lr
<br/>
cmp r2, #32
<br/>
bxlt lr
<br/>
<br/>
stmfd sp!, {r4-r11, lr}
<br/>
<br/>
fastCopyLoop:
<br/>
ldmia r1!, {r4-r11}
<br/>
stmia r0!, {r4-r11}
<br/>
subs r2, r2, #32
<br/>
bgt fastCopyLoop
<br/>
<br/>
ldmfd sp!, {r4-r11, pc}</td> </tr></table><span class="postbody">
<br/>
I also added in the DC_FlushAll before each profile, so the small sizes aren't all just cache-to-cache. But what was really surprised me is that if you align the source and dest to land on 32 byte boundaries (i.e. cache lines), it speeds it up by quite a lot. 
<br/>
<br/>
Here are the results. fastCopy is my function, and fcAlign has source/dest aligned to 32-bytes.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Main Memory to Main Memory 
<br/>
<br/>
          16B  32B 64B 128B  256B  512B 1024B 2048B 
<br/>
memcpy    157  217 313  505   889  1657  3193  6265 
<br/>
fastCopy  n/a  132 196  304   520   972  1816  3564 
<br/>
fcAlign   n/a  151 198  292   480   856  1608  3112 
<br/>
dmaCopy4  169  241 385  673  1249  2401  4705  9313
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B 
<br/>
memcpy    12409  24697  49273   98425  196729 
<br/>
fastCopy   7020  13912  27756   55384  110779
<br/>
fcAlign    6120  12136  24168   48232  96439
<br/>
dmaCopy4  18592  36961  73825  147625  295094
<br/>
<br/>
Main Memory to VRAM 
<br/>
<br/>
          16B  32B  64B 128B  256B  512B 1024B 2048B 
<br/>
memcpy    163  212  288  440   744  1352  2568  5000 
<br/>
fastCopy  n/a  142  208  300   484   852  1588  3060 
<br/>
fcAlign   n/a  158  202  290   466   818  1522  2930 
<br/>
dmaCopy4  120  132  156  204   300   499   897  1698
<br/>
<br/>
          4096B  8192B 16384B  32768B  65536B 
<br/>
memcpy    9864   19592  39048   77960  155784 
<br/>
fastCopy  6004   11892  23648   47220   94322
<br/>
fcAlign   5746   11378  22642   45170   90226
<br/>
dmaCopy4  3312    6553  13035   25986   51974</td> </tr></table><span class="postbody"><br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#130459 - Noda - Sun Jun 03, 2007 8:05 pm</h4>
    <div class="postbody"><span class="postbody">Why not adding an ASM copy function like yours in libnds? could be useful...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#134024 - HyperHacker - Tue Jul 10, 2007 3:53 am</h4>
    <div class="postbody"><span class="postbody">Pardon the bump, but I don't think it's true that only one DMA channel can run at a time. I just timed loading 256x192 of a 512x512 bitmap from VRAM to main RAM. If I only use one DMA channel it takes 145ms, while if I use all 4 and spin on the last one, it finishes in a mere 32ms - about 22% as long, which is actually <span style="font-style: italic">more</span> than 4 times as fast.
<br/>
<br/>
Specifically, what I'm doing is calling dmaCopyWordsAsynch() for channels 0, 1 and 2 and dmaCopyWords() for channel 3. Each is copying 512 bytes at a time; 98304 bytes are copied in total.
<br/>
<br/>
What is worth noting, though, is that having all four DMA transfers be asynchronous and doing a CPU copy while they run didn't improve performance at all.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#134031 - olimar - Tue Jul 10, 2007 5:59 am</h4>
    <div class="postbody"><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by olimar on Wed Aug 20, 2008 10:47 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#134038 - Ant6n - Tue Jul 10, 2007 7:13 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>olimar wrote:</b></span></td> </tr> <tr> <td class="quote">...
<br/>
If the CPU doesn't touch main ram (i.e. TCMs or cache), it's not stopped by DMA.</td> </tr></table><span class="postbody">
<br/>
I thought as long as the cpu doesn't touch the bus everything is fine. since tcm/cache live on the cpu, they dont stall. But then there'd be many more ways to stall the cpu, i.e. accessing video ram, or shared ram, or memory mapped I/O, no?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#134057 - olimar - Tue Jul 10, 2007 11:46 am</h4>
    <div class="postbody"><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by olimar on Wed Aug 20, 2008 10:47 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#134060 - tepples - Tue Jul 10, 2007 11:51 am</h4>
    <div class="postbody"><span class="postbody">To be specific, there are 3 kinds of "ROM" that need testing: <ul><li>GBA ROM (which is not present if you use a SLOT-1 card) </li><li>DS Game Card I/O </li><li>DS BIOS </li></ul><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
