<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Fastest way to calculate normals on the fly ? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Fastest way to calculate normals on the fly ?</h2>
<div id="posts">
<div class="post">
    <h4>#118753 - qw3rty - Fri Feb 16, 2007 12:57 pm</h4>
    <div class="postbody"><span class="postbody">I have to calculate the normal from triangles.
<br/>
The x and z- positions of the vertices is fixed, only the y-position changes.
<br/>
<br/>
I do currently claculate the cross-product of two sides of the triangle.
<br/>
Is there a faster way to do, because I use smooth-shading, and have to calculate 6 normals per vertex (one per surrounding triangle) - that takes away almost 2/3rd of the cpu-time :O
<br/>
(not optimized in any way other than FP-maths - didn't use IWRAM or anything)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118755 - kusma - Fri Feb 16, 2007 2:05 pm</h4>
    <div class="postbody"><span class="postbody">Is this a grid in the x/y plane with varying height?
<br/>
If so, you can use the old fashioned heightmap method. It's something like this:
<br/>
<br/>
nx = node(x - 1, z) - node(x + 1, z)
<br/>
ny = height_of_y_axis
<br/>
nz = node(x, z - 1) - node(x, z + 1)
<br/>
<br/>
and then normalize the vector.
<br/>
<br/>
edit: note that this won't work too well with high frequency height-maps (but neither does smooth-shading in the first place ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118758 - memoni - Fri Feb 16, 2007 2:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for (each vertex)
<br/>
  normal[i].Set(0,0,0)
<br/>
<br/>
for (each face)
<br/>
{
<br/>
  n = face[i].calcNormal()
<br/>
  normal[face[i].a] += n;
<br/>
  normal[face[i].b] += n;
<br/>
  normal[face[i].c] += n;
<br/>
}
<br/>
<br/>
for (each vertex)
<br/>
  normal[i].normalize()</td> </tr></table><span class="postbody">
<br/>
<br/>
Depending on the size of your mesh and the format of the normals you may not need to normalize the face normals. For example you could have a "scratch" normals in 22:10 format, and pack them after normalization. If you dont normalize the face normals larger faces will affect more the direction of the normals, but that often looks better anyway :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118796 - qw3rty - Fri Feb 16, 2007 9:07 pm</h4>
    <div class="postbody"><span class="postbody">after going back to a regular mesh (quadratic) from an irregular (odd lines were moved 1/2 gridstep) my normal-calculation got much easier.
<br/>
After using triangle_strip instead of triangles I got a pretty good performance.
<br/>
The heightmap method looks interesting though ! smooth shading with the ammount of calculation of flat-shading :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#118962 - silent_code - Sun Feb 18, 2007 5:40 pm</h4>
    <div class="postbody"><span class="postbody">but you don't recalculate normals each frame, do you? that would be a horrible waste of cpu time. instead, just transform them together with the vertices. there are some good tutorials on this out there.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119054 - qw3rty - Mon Feb 19, 2007 11:28 am</h4>
    <div class="postbody"><span class="postbody">I'm doing a dynamic water-surface.
<br/>
I think I have no other choice than calculate the normals everytime the water-surface changes.
<br/>
But I got it fast enough for my project.
<br/>
The water with 512 triangles (16x16 grid) takes half of my CPU-time, but the water is my main gfx-feature - so I think it will be ok.
<br/>
And I still have room for optimization - e.g. put the wave-points into a faster MEM-region.
<br/>
<br/>
P.S. : tranforming the normals with the vertices would need matrix-multiplication, right ? I think I wouldn't save that much CPU-time, because the normal-calculation is pretty simple in my case (since I've gone back to a regular grid)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119072 - Rajveer - Mon Feb 19, 2007 1:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>qw3rty wrote:</b></span></td> </tr> <tr> <td class="quote">P.S. : tranforming the normals with the vertices would need matrix-multiplication, right ? I think I wouldn't save that much CPU-time, because the normal-calculation is pretty simple in my case (since I've gone back to a regular grid)</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah it would require matrix multiplication for transformations, but wouldn't it be pretty quick as you can make use of the DS's matrix-multiplication hardware? Or doesn't it make that much of a performance difference?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119094 - qw3rty - Mon Feb 19, 2007 4:31 pm</h4>
    <div class="postbody"><span class="postbody">No idea - calculating 256 smooth normals needs aprox. 50 scanlines (high wave-activity) - and I think most of the time is wasted waiting for RAM-access, which I could minimize by using a faster RAM area.
<br/>
<br/>
If I wanted to transform the normals, I would need to read almost as much data, because before I can transform the normal, I need the difference in angle/squew etc.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119172 - silent_code - Tue Feb 20, 2007 1:00 pm</h4>
    <div class="postbody"><span class="postbody">yes, i meant transforming normals by the hw.
<br/>
<br/>
on thing to optimize online recalculation is having precomputed dependencies between triangles that contribute to a smooth normal. normally you would scan through the whole mesh to find these dependencies.
<br/>
another thing could be a recalculation threshold. you tag each vertex that has moved, then in the recalculating step you just check for the recently transformed vertices and recalculate the triangles normals. if the triangle normals don't differ too much, just don't recalculate the smooth normal. that way you could save a lot of computation, though the worst case would be a little bit worse than brute force (caused by the checking) and it requires a bit more memory for the additional data structures.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119175 - Mighty Max - Tue Feb 20, 2007 1:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>qw3rty wrote:</b></span></td> </tr> <tr> <td class="quote">I'm doing a dynamic water-surface.
<br/>
I think I have no other choice than calculate the normals everytime the water-surface changes.
<br/>
But I got it fast enough for my project.
<br/>
The water with 512 triangles (16x16 grid) takes half of my CPU-time, but the water is my main gfx-feature - so I think it will be ok.
<br/>
And I still have room for optimization - e.g. put the wave-points into a faster MEM-region.
<br/>
<br/>
P.S. : tranforming the normals with the vertices would need matrix-multiplication, right ? I think I wouldn't save that much CPU-time, because the normal-calculation is pretty simple in my case (since I've gone back to a regular grid)</td> </tr></table><span class="postbody">
<br/>
<br/>
This setup does not need to do the complete maths to calculate the normals. It should be much quicker to derive them from the additional Info then generating them just from the triangles.
<br/>
<br/>
In such a grid:
<br/>
- all normals go into the same half-room
<br/>
- two components of the vectors to the neighbour are constant
<br/>
- the triangles contain a 90? angle
<br/>
<br/>
Lets say you have a grid in the x-y-plane. A is a vector parallel to the x axis between two points, Y parallel to the y axis. All normals shall go up (adding to z axis)
<br/>
<br/>
The x and the y component of the xx and yy vectors are constant. You can now create a a parallel to normal vector with -z component of A in the new x component, the -z component of B as a new y. Put the gridgranularity_x + gridgranularity_y in the new z. If needed (and not done by hardware) cut the vectors length.
<br/>
<br/>
This should be much faster then solving trigonometric functions based on the finished mesh.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119177 - qw3rty - Tue Feb 20, 2007 2:11 pm</h4>
    <div class="postbody"><span class="postbody">I've done the cross-product on paper, and made it as easy as possible - I think I have more or less the thing you are suggesting, mighty max.
<br/>
<br/>
the two vectors I do cross are (Y-Axis up):
<br/>
<br/>
<br/>
A = (0,dy_a,step)
<br/>
B = (step,dy_b,0)
<br/>
<br/>
the resulting vector is N = step * (-dy_a,step,-dy_b)
<br/>
of course I divided N by step, resulting in
<br/>
<br/>
N = (-dy_a,step,-dy_b)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119208 - tepples - Tue Feb 20, 2007 8:17 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>silent_code wrote:</b></span></td> </tr> <tr> <td class="quote">on thing to optimize online recalculation is having precomputed dependencies between triangles that contribute to a smooth normal. normally you would scan through the whole mesh to find these dependencies.</td> </tr></table><span class="postbody">
<br/>
That takes linear time in the number of vertices and faces:
<br/>
<ol type="1"><li>Allocate a list of lists foundEdges[nVertices][maxEdgesPerVertex]. (If you are using an array for the inner list, maxEdgesPerVertex might be up to 8.) </li><li>Build a list of edges around each vertex by scanning through the triangles. For each triangle, for each vertex in the triangle, add the vertex in the triangle . For instance, add vertexNo[1] to foundEdges[vertexNo[0]], vertexNo[2] to foundEdges[vertexNo[1]], and vertexNo[0] to foundEdges[vertexNo[2]]. By now, you have a list of edges from each vertex in the mesh. </li><li>For each vertex, fit a distance-regression plane to the set of edge points around the vertex. This plane contains the points' centroid, and its normal approximates the smooth normal of the vertex. </li></ol>
<br/>
Doing steps 1 and 2 once or multiple times is a time-space tradeoff that depends on how many meshes you have vs. how often you deform them.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
