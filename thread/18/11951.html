<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Help about icon. - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Help about icon.</h2>
<div id="posts">
<div class="post">
    <h4>#112313 - tecljg - Fri Dec 15, 2006 4:48 am</h4>
    <div class="postbody"><span class="postbody">hi, 
<br/>
<br/>
the documents say the NDS icon 32x32 pixels, 4x4 tile, i write a program under windows, but can not display the icon properly,anybody can give more detailed explaination. what's the 4x4 tile? 
<br/>
<br/>
Below is my program:
<br/>
<br/>
void displat_icon()
<br/>
{ 
<br/>
// read icon from nds file 
<br/>
readicon(ico); 
<br/>
<br/>
unsigned short color[16]; 
<br/>
unsigned short *ptr = (unsigned short *)(ico+544); 
<br/>
<br/>
// Get palette 
<br/>
for(i=0;i&lt;16;i++) 
<br/>
{ 
<br/>
color[i]=*ptr++; 
<br/>
} 
<br/>
<br/>
BYTE *ptr2 = ico+32; // point to icon data 
<br/>
<br/>
// x, y is draw start position 
<br/>
int x=100, y=100, count=0; 
<br/>
<br/>
for(i=0;i&lt;32;i++) // 32 pixels width 
<br/>
{ 
<br/>
for(int j=0;j&lt;32;j++) // 32 pixels height 
<br/>
{ 
<br/>
BYTE b = ptr2[count/2]; // one byte consist of two pixels 
<br/>
BYTE b2,b3; 
<br/>
<br/>
// one pixel is 4 bits, 
<br/>
b2 = (b&gt;&gt;4)&amp;0xf; // first pixel color palette index 
<br/>
b3 = b&amp;0xf; // second pixel color palette index 
<br/>
<br/>
unsigned short c1=color[b2], c2=color[b3]; 
<br/>
BYTE rr1,gg1,bb1; 
<br/>
BYTE rr2,gg2,bb2; 
<br/>
<br/>
// first pixel\'s RGB 
<br/>
rr1=(c1&amp;0x1f)&lt;&lt;3; 
<br/>
gg1=((c1&gt;&gt;5)&amp;0x1f)&lt;&lt;3; 
<br/>
bb1=((c1&gt;&gt;10)&amp;0x1f)&lt;&lt;3; 
<br/>
<br/>
// second pixel\'s RGB 
<br/>
rr2=(c2&amp;0x1f)&lt;&lt;3; 
<br/>
gg2=((c2&gt;&gt;5)&amp;0x1f)&lt;&lt;3; 
<br/>
bb2=((c2&gt;&gt;10)&amp;0x1f)&lt;&lt;3; 
<br/>
<br/>
CDC *dc = GetDC(); 
<br/>
if(b2) // 0 is transparent 
<br/>
dc-&gt;SetPixel(x,y,RGB(r1,g1,bb1)); 
<br/>
<br/>
x++; // drawing move to next 
<br/>
if(b3) // 0 is transparent 
<br/>
dc-&gt;SetPixel(x,y,RGB(r2,g2,bb2)); 
<br/>
<br/>
count+=1; 
<br/>
} 
<br/>
x=100; 
<br/>
y++; // next line 
<br/>
}
<br/>
<br/>
Thanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112315 - tepples - Fri Dec 15, 2006 5:17 am</h4>
    <div class="postbody"><span class="postbody">Have you ever programmed for the Game Boy Advance system? Most 2D graphics on the GBA and Nintendo DS are divided into 8x8 pixel tiles. You'll need one pair of loops to scan the tiles and one pair to scan the pixels inside the tiles. It might be clearer to put these loops into separate functions, as I did in the following (untested) code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline unsigned int translateRGB5(unsigned int dsColor) {
<br/>
  unsigned int r = dsColor &amp; 0x1F;
<br/>
  unsigned int g = (dsColor &gt;&gt; 5) &amp; 0x1F;
<br/>
  unsigned int b = (dsColor &gt;&gt; 10) &amp; 0x1F;
<br/>
  return makecol(r &lt;&lt; 3 | r &gt;&gt; 2, g &lt;&lt; 3 | g &gt;&gt; 2, b &lt;&lt; 3 | b &gt;&gt; 2);
<br/>
}
<br/>
<br/>
void displayTile(BITMAP *dc,
<br/>
        const unsigned char *src, const unsigned short *palette,
<br/>
        int dstX, int dstY) {
<br/>
  for (int y = tileY; y &lt; tileY + 8; ++y) {
<br/>
    for (int x = tileX; x &lt; tileX + 8; x += 2) {
<br/>
      unsigned int data = *src++;
<br/>
<br/>
      unsigned int leftColorIndex = data &amp; 0x0F;
<br/>
      if (leftColorIndex) {
<br/>
        unsigned int leftColor = translateRGB5(palette[leftColorIndex]);
<br/>
        putpixel(dc, x, y, leftColor);
<br/>
      }
<br/>
<br/>
      unsigned int rightColorIndex = (data &amp; 0xF0) &gt;&gt; 4;
<br/>
      if (rightColorIndex) {
<br/>
        unsigned int rightColor = translateRGB5(palette[rightColorIndex]);
<br/>
        putpixel(dc, x + 1, y, rightColor);
<br/>
      }
<br/>
    }
<br/>
  }
<br/>
}
<br/>
<br/>
void displayGBACel32x32(BITMAP *dc,
<br/>
        const unsigned char *src, const unsigned short *palette,
<br/>
        int dstX, int dstY) {
<br/>
  for (int tileY = 0; tileY &lt; 32; tileY += 8) {
<br/>
    for (int tileX = 0; tileX &lt; 32; tileX += 8) {
<br/>
      displayTile(dc, src, palette, dstX + tileX, dstY + tileY);
<br/>
      src += 32;
<br/>
    }
<br/>
  }
<br/>
}
<br/>
<br/>
void displat_icon() {
<br/>
  // read icon from nds file
<br/>
  readicon(ico);
<br/>
<br/>
  displayGBACel32x32(dc,
<br/>
        ico+32,
<br/>
        (unsigned short *)(ico+544),
<br/>
        100, 100);
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112317 - tecljg - Fri Dec 15, 2006 5:56 am</h4>
    <div class="postbody"><span class="postbody">Great!
<br/>
<br/>
I tried and done!
<br/>
<br/>
thank you!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112524 - headspin - Sun Dec 17, 2006 2:19 pm</h4>
    <div class="postbody"><span class="postbody">Here some code from WMBFront that will convert an NDS icon to a windows icon.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">HICON CWMBFrontDlg::MakeIcon(COLORREF *lpData, COLORREF clrTransparent) 
<br/>
{ 
<br/>
   HICON hIcon; 
<br/>
   DWORD dwSize; 
<br/>
<br/>
   HBITMAP hMask, hColor; 
<br/>
   LPCOLORREF lpColorData, lpMaskData; 
<br/>
<br/>
   BITMAPINFOHEADER bmi; 
<br/>
   bmi.biBitCount = 32; 
<br/>
   bmi.biClrImportant = 0; 
<br/>
   bmi.biClrUsed = 0; 
<br/>
   bmi.biCompression = BI_RGB; 
<br/>
   bmi.biHeight = 32; 
<br/>
   bmi.biPlanes = 1; 
<br/>
   bmi.biSize = sizeof(BITMAPINFOHEADER); 
<br/>
   bmi.biSizeImage = 0; 
<br/>
   bmi.biWidth = 32; 
<br/>
   bmi.biXPelsPerMeter = 0; 
<br/>
   bmi.biYPelsPerMeter = 0; 
<br/>
<br/>
   hColor = CreateDIBSection(NULL, (LPBITMAPINFO) &amp;bmi, 0, (void**)&amp;lpColorData, NULL, DIB_RGB_COLORS); 
<br/>
<br/>
   if(hColor == NULL) 
<br/>
      return NULL; 
<br/>
<br/>
   hMask = CreateDIBSection(NULL, (LPBITMAPINFO) &amp;bmi, 0, (void**)&amp;lpMaskData, NULL, DIB_RGB_COLORS); 
<br/>
<br/>
   if(hMask == NULL) 
<br/>
   { 
<br/>
      ::DeleteObject(hColor); 
<br/>
      return NULL; 
<br/>
   } 
<br/>
<br/>
   dwSize = 32*32; 
<br/>
<br/>
   for(DWORD d=0; d&lt;dwSize; d++) 
<br/>
   { 
<br/>
      if(*lpData == clrTransparent) 
<br/>
      { 
<br/>
         lpMaskData[d] = 0xFFFFFF; 
<br/>
         lpColorData[d] = 0; 
<br/>
      } 
<br/>
      else 
<br/>
      { 
<br/>
         lpMaskData[d] = 0; 
<br/>
         lpColorData[d] = *lpData; 
<br/>
      } 
<br/>
      lpData++; 
<br/>
   } 
<br/>
<br/>
   ICONINFO ii; 
<br/>
   ii.fIcon = 1; 
<br/>
   ii.hbmColor = hColor; 
<br/>
   ii.hbmMask = hMask; 
<br/>
   ii.xHotspot = 0; 
<br/>
   ii.yHotspot = 0; 
<br/>
   hIcon = CreateIconIndirect(&amp;ii); 
<br/>
<br/>
   ::DeleteObject(hMask); 
<br/>
   ::DeleteObject(hColor); 
<br/>
<br/>
   return hIcon; 
<br/>
} 
<br/>
<br/>
HICON CWMBFrontDlg::DSIconToWinIcon(char *buf) 
<br/>
{ 
<br/>
   HICON hIcon = NULL; 
<br/>
   BANNER* pBanner = (BANNER *) buf; 
<br/>
<br/>
   HDC hdc = CreateCompatibleDC(NULL); 
<br/>
   BITMAPINFO bi; 
<br/>
   ZeroMemory(&amp;bi.bmiHeader, sizeof(BITMAPINFOHEADER)); 
<br/>
   bi.bmiHeader.biWidth = 32; 
<br/>
   bi.bmiHeader.biHeight = 32; 
<br/>
   bi.bmiHeader.biPlanes = 1; 
<br/>
   bi.bmiHeader.biBitCount = 24; 
<br/>
   bi.bmiHeader.biSizeImage = 0; 
<br/>
   bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
<br/>
   bi.bmiHeader.biClrUsed = 0; 
<br/>
   bi.bmiHeader.biClrImportant = 0; 
<br/>
<br/>
   VOID* pvBits; 
<br/>
<br/>
   HBITMAP hbmp = CreateDIBSection(hdc, &amp;bi, DIB_RGB_COLORS, &amp;pvBits, NULL, 0); 
<br/>
<br/>
   RGBQUAD palette[16]; 
<br/>
<br/>
   for (int i=0; i &lt; 16; i++) { 
<br/>
      palette[i].rgbRed = (pBanner-&gt;palette[i] &amp; 0x1F) &lt;&lt; 3; 
<br/>
      palette[i].rgbGreen = ((pBanner-&gt;palette[i]&gt;&gt;5) &amp; 0x1F) &lt;&lt; 3; 
<br/>
      palette[i].rgbBlue = ((pBanner-&gt;palette[i]&gt;&gt;10) &amp; 0x1F) &lt;&lt; 3; 
<br/>
      palette[i].rgbReserved = 0; 
<br/>
   } 
<br/>
<br/>
   palette[0].rgbRed = 255; 
<br/>
   palette[0].rgbGreen = 0; 
<br/>
   palette[0].rgbBlue = 255; 
<br/>
<br/>
   // tile data (4 bit / tile, 4x4 total tiles) 
<br/>
   // 32 bytes per tile (in 4 bit mode) 
<br/>
   for (int row=0; row&lt;4; row++) 
<br/>
   { 
<br/>
      for (int col=0; col&lt;4; col++) 
<br/>
      { 
<br/>
         for (int y=0; y&lt;8; y++) 
<br/>
         { 
<br/>
            for (int x=0; x&lt;8; x+=2) 
<br/>
            { 
<br/>
               ((RGBQUAD *)pvBits)[(((3-row)*8 + (7-y))*32)+(col*8 + x + 0)] = palette[(pBanner-&gt;tile_data[row][col][y][x/2] &amp; 0xF)]; 
<br/>
               ((RGBQUAD *)pvBits)[(((3-row)*8 + (7-y))*32)+(col*8 + x + 1)] = palette[(pBanner-&gt;tile_data[row][col][y][x/2] &gt;&gt; 4) &amp; 0xF]; 
<br/>
            } 
<br/>
         } 
<br/>
      } 
<br/>
   } 
<br/>
<br/>
   hIcon = MakeIcon((COLORREF *) pvBits, RGB(255,0,255)); 
<br/>
<br/>
   DeleteObject(hbmp); 
<br/>
   DeleteDC(hdc); 
<br/>
    
<br/>
   return hIcon; 
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
