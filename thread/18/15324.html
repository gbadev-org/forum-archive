<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Send FIFO is breaking things (Solved) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > Send FIFO is breaking things (Solved)</h2>
<div id="posts">
<div class="post">
    <h4>#153684 - HyperHacker - Thu Apr 03, 2008 10:20 pm</h4>
    <div class="postbody"><span class="postbody">[edit] Fixed it. It looks like you only get a FIFO Not Empty interrupt when the FIFO <span style="font-style: italic">becomes</span> non-empty. If your interrupt handler doesn't completely drain it the interrupt won't fire again because it's still not empty. The solution is to simply loop in the interrupt handler, reading everything:
<br/>
while(!(REG_IPC_FIFO_CR &amp; IPC_FIFO_RECV_EMPTY))
<br/>
<br/>
What would happen was I'd send two messages to ARM9 within a very short time, and it would only read one every time the Not Empty interrupt fired. The second message would arrive before it had read all of the first one, and thus never get read. ARM7 continues sending, the FIFO fills up with unread messages, and SendMessage() goes into an endless loop waiting for it to be not full. Since I'd call SendMessage() from the VBlank interrupt, other interrupts never got a chance to fire, hence never returning to the main loop and/or not receiving messages <span style="font-style: italic">from</span> ARM9. Nasty!
<br/>
<br/>
Also I didn't need to do any of that gross nested interrupt stuff. :-D I <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=13884" target="_blank">discovered</a> that the FIFO interrupt will simply fire when the VBlank handler is done.
<br/>
<br/>
(I swear, the best way to fix a bug is to ask for help on a forum. Probably 90% of the time I fix it myself within hours of posting. :-p)
<br/>
<br/>
<br/>
Original post follows.
<br/>
<br/>
<br/>
This is my ARM7 code so far (obviously far from complete):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//ARM7 Code
<br/>
#include "main.h"
<br/>
<br/>
volatile bool ARM9Init = false;
<br/>
<br/>
/*
<br/>
Entry Point
<br/>
CPU: ARM7
<br/>
Inputs:
<br/>
   -argc: Number of arguments
<br/>
   -argv: Pointer to arguments
<br/>
Returns: Program return code
<br/>
*/
<br/>
int main(int argc, char** argv)
<br/>
{
<br/>
   irqInit();
<br/>
   REG_IME = IME_DISABLE;
<br/>
   memset((u8*)IPC, 0, sizeof(TransferRegion)); //Blank out IPC
<br/>
<br/>
<br/>
   //Init interrupts
<br/>
   REG_IPC_FIFO_CR = IPC_FIFO_ENABLE | IPC_FIFO_SEND_IRQ | IPC_FIFO_RECV_IRQ; //Enable FIFO IRQs
<br/>
   irqSet(IRQ_VBLANK, VBlankInterrupt);
<br/>
   //irqSet(IRQ_TIMER3, Timer3Interrupt);
<br/>
   irqSet(IRQ_FIFO_NOT_EMPTY, FifoRecvInterrupt);
<br/>
   irqEnable(IRQ_VBLANK | IRQ_FIFO_NOT_EMPTY);
<br/>
<br/>
<br/>
   SendMessage(IPC_SYS_INIT, 0);
<br/>
   REG_IME = IME_ENABLE; //Enable interrupts
<br/>
   swiWaitForVBlank();
<br/>
   swiWaitForVBlank();
<br/>
   swiWaitForVBlank();
<br/>
<br/>
   while(true)
<br/>
   {
<br/>
      if(ARM9Init)
<br/>
      {
<br/>
         writePowerManagement(0, PM_SOUND_AMP | PM_BACKLIGHT_TOP | PM_BACKLIGHT_BOTTOM | BIT(4));
<br/>
         while(true) swiWaitForVBlank();
<br/>
      }
<br/>
<br/>
      swiWaitForVBlank();
<br/>
   }
<br/>
   return 0;
<br/>
}
<br/>
<br/>
<br/>
/*
<br/>
Sends a message to ARM9.
<br/>
Inputs:
<br/>
   -Msg: Message ID (one of IPC_*).
<br/>
   -Params: # of parameters.
<br/>
   -...: Parameters (32 bits).
<br/>
Returns: True on success, false otherwise.
<br/>
Notes:
<br/>
   -Blocks until the message can be sent (i.e. FIFO is not too full).
<br/>
*/
<br/>
bool SendMessage(IPCMessage Msg, u16 Params, ...)
<br/>
{
<br/>
   u32 Word;
<br/>
   va_list list;
<br/>
<br/>
   va_start(list, Params);
<br/>
   Word = (Msg &lt;&lt; 16) | Params;
<br/>
   for(u32 i=0; i&lt;(Params + 1); i++) //+1 for the message itself
<br/>
   {
<br/>
      while(REG_IPC_FIFO_CR &amp; IPC_FIFO_SEND_FULL);
<br/>
      REG_IPC_FIFO_TX = Word;
<br/>
      Word = va_arg(list, u32);
<br/>
   }
<br/>
<br/>
   va_end(list);
<br/>
   return true;
<br/>
}
<br/>
<br/>
<br/>
/*
<br/>
VBlank handler
<br/>
CPU: ARM7
<br/>
*/
<br/>
void VBlankInterrupt()
<br/>
{
<br/>
   touchPosition tempPos;
<br/>
   s32 T1, T2; //todo: what exactly are these for?
<br/>
   u32 Btns;
<br/>
   u16 TouchX = 0, TouchY = 0, TouchZ1 = 0, TouchZ2 = 0;
<br/>
<br/>
   REG_IME = IME_ENABLE; //Receive FIFO interrupts while processing VBlank
<br/>
<br/>
   //Read buttons
<br/>
   Btns = ((~REG_KEYXY) &lt;&lt; 10) &amp; (KEY_X | KEY_Y);
<br/>
   if(!(REG_KEYXY &amp; BIT(3))) Btns |= KEY_DEBUG;
<br/>
   Btns |= (~REG_KEYINPUT) &amp; 0x3FF;
<br/>
   if(REG_KEYXY &amp; 0x80) Btns |= KEY_LID;
<br/>
<br/>
   //Read touchscreen
<br/>
   if(!(REG_KEYXY &amp; 0x40)) //touched
<br/>
   {
<br/>
      Btns |= KEY_TOUCH;
<br/>
      tempPos = touchReadXY();
<br/>
      TouchX = tempPos.px;
<br/>
      TouchY = tempPos.py;
<br/>
   }
<br/>
<br/>
   TouchZ1 = touchRead(TSC_MEASURE_Z1);
<br/>
   TouchZ2 = touchRead(TSC_MEASURE_Z2);
<br/>
<br/>
   //todo: read temperature once per second not once per frame
<br/>
   SendMessage(IPC_SYS_INPUT, 4, Btns, (TouchX &lt;&lt; 16) | TouchY, (TouchZ1 &lt;&lt; 16) | TouchZ2, touchReadTemperature(&amp;T1, &amp;T2));
<br/>
}
<br/>
<br/>
<br/>
/*
<br/>
Timer3 interrupt handler
<br/>
CPU: ARM7
<br/>
*/
<br/>
void Timer3Interrupt()
<br/>
{
<br/>
}
<br/>
<br/>
<br/>
/*
<br/>
FIFO Not Empty interrupt handler
<br/>
CPU: ARM7
<br/>
*/
<br/>
void FifoRecvInterrupt()
<br/>
{
<br/>
   u32 Word;
<br/>
   IPCMessage Msg;
<br/>
   u16 Params; //# params - only used for messages with variable parameters
<br/>
<br/>
   Word = REG_IPC_FIFO_RX;
<br/>
   Msg = Word &gt;&gt; 16;
<br/>
   Params = Word &amp; 0xFFFF;
<br/>
<br/>
   switch(Msg)
<br/>
   {
<br/>
      case IPC_SYS_INIT:
<br/>
         ARM9Init = true;
<br/>
         writePowerManagement(0, 0);
<br/>
      break;
<br/>
<br/>
      case IPC_SYS_COMPLETE:
<br/>
      case IPC_SYS_ERROR:
<br/>
      case IPC_SYS_FATAL:
<br/>
         //todo
<br/>
      break;
<br/>
<br/>
      case IPC_SND_PLAY:
<br/>
      break;
<br/>
<br/>
      //Messages that ARM7 shouldn't be receiving, defined here to shut the compiler up.
<br/>
      case IPC_SYS_INPUT: break;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">I added some writePowerManagement() calls for debugging. When it receives the IPC_SYS_INIT message it turns off the backlights. When the main loop sees this message has been received (ARM9Init == true) it turns them back on and blinks the power LED. Right now they turn off and never come back on so somehow it's getting the message but ARM9Init is being set back to false?
<br/>
<br/>
It works if I remove this line at the end of VBlankInterrupt:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">SendMessage(IPC_SYS_INPUT, 4, Btns, (TouchX &lt;&lt; 16) | TouchY, (TouchZ1 &lt;&lt; 16) | TouchZ2, touchReadTemperature(&amp;T1, &amp;T2));</td> </tr></table><span class="postbody">Replacing the touchReadTemperature() call with a constant zero didn't help either. Somehow sending a message is breaking something? It receives the message from ARM9 but the flag isn't set or the main loop doesn't get run or something.
<br/>
<br/>
I had to enable nesting in the VBlank interrupt or else the FIFO interrupt would be missed and it wouldn't get the message at all. Anything wrong with that?<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
