<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Full screen redraw (effect-based) game - slow DMA copying! - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Full screen redraw (effect-based) game - slow DMA copying!</h2>
<div id="posts">
<div class="post">
    <h4>#100850 - HotChilli - Thu Aug 31, 2006 3:00 am</h4>
    <div class="postbody"><span class="postbody">Hi! 
<br/>
<br/>
I try make some effect-based game or demo. I.e. smoke, optical effects or visual effects like in MediaPlayer or WinAmp. But... Here is a problem....
<br/>
<br/>
I use static arrays (as backbuffers) for both screens but they copy to v-memory too slow! Copying (through "dmaCopy") from static array performs 5,1 ms. For 60fps i must perform all operations in 16 ms. 16 - 2*5,1 = 5ms! Too small for effect logic, game logic or something else. :(
<br/>
<br/>
My question is - can i redraw background (256*192 pixels) in less than 5 ms?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100884 - bjoerngiesler - Thu Aug 31, 2006 11:08 am</h4>
    <div class="postbody"><span class="postbody">Doesn't dmaCopy() return immediately, effectively parallelizing the copying and the rest of the code? If so, you have no problem.<br/>_________________<br/><a class="postlink" href="http://giesler.biz/~bjoern/en/sw_dsftp.html" target="_blank">DSFTP homepage</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100888 - melw - Thu Aug 31, 2006 12:44 pm</h4>
    <div class="postbody"><span class="postbody">If you use framebuffer with two banks, it's easy to achieve 60fps output no matter what you do... Something like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//screen init stuff:
<br/>
<br/>
u16* backBuffer;
<br/>
u16* frontBuffer;
<br/>
int screenBufferActive=0;
<br/>
<br/>
videoSetMode(MODE_FB1);
<br/>
...
<br/>
vramSetMainBanks(VRAM_A_LCD, VRAM_B_LCD, VRAM_C_SUB_BG, VRAM_D_SUB_SPRITE);
<br/>
<br/>
backBuffer = VRAM_A;
<br/>
frontBuffer = VRAM_B;
<br/>
<br/>
// while blitting the screen:
<br/>
<br/>
swiWaitForVBlank();
<br/>
<br/>
if(screenBufferActive==1) {
<br/>
   videoSetMode(MODE_FB1);
<br/>
   frontBuffer = VRAM_B;
<br/>
   backBuffer = VRAM_A;
<br/>
   screenBufferActive = 0;
<br/>
} else {
<br/>
   videoSetMode(MODE_FB0);
<br/>
   frontBuffer = VRAM_A;
<br/>
   backBuffer = VRAM_B;
<br/>
   screenBufferActive = 1;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
This assuming you're drawing always to backBuffer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100905 - josath - Thu Aug 31, 2006 5:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>bjoerngiesler wrote:</b></span></td> </tr> <tr> <td class="quote">Doesn't dmaCopy() return immediately, effectively parallelizing the copying and the rest of the code? If so, you have no problem.</td> </tr></table><span class="postbody">
<br/>
No, the libnds dmaCopy* functions wait until the copy is done until they return.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101037 - HyperHacker - Fri Sep 01, 2006 9:17 pm</h4>
    <div class="postbody"><span class="postbody">This is what I use. I don't know how fast it is, but unlike with dmaCopy() I've yet to run out of VBlank time using it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.arm
<br/>
.align
<br/>
<br/>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
<br/>
@ FastCopy
<br/>
@ Copies memory really fast.
<br/>
@ Inputs:
<br/>
@  -r0: Source
<br/>
@  -r1: Destination
<br/>
@  -r2: # of bytes
<br/>
@  -r3: Copy size (0=byte, 1=short (2 bytes), 2=int (4 bytes))
<br/>
@ Notes:
<br/>
@  -When there are less than 44 bytes remaining, they're copied one at a time.
<br/>
@   You can copy less than 44 bytes, but it's not going to be very fast.
<br/>
@  -The size parameter is provided to get around memory access limitations of
<br/>
@   the Nintendo DS. Limitations that I know of are:
<br/>
@   -Cannot write 8 bits to VRAM
<br/>
@   -Cannot write 8 or 32 bits to GBA ROM
<br/>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
<br/>
<br/>
.global FastCopy
<br/>
.type FastCopy,function
<br/>
FastCopy:
<br/>
stmfd sp!, {r3-r12, lr}
<br/>
sub sp, sp, #4
<br/>
str r3, [sp] @We need this later, but for now, r3 can assist in copying.
<br/>
<br/>
.loop:
<br/>
cmp r2, #44
<br/>
blt .part2 @by checking here, we can copy less than 44 bytes in one call (but it's slow)
<br/>
ldmia r0!, {r3-r12, lr}
<br/>
stmia r1!, {r3-r12, lr}
<br/>
sub r2, r2, #44 @copy 44 bytes at a time (!), and we need those flags updated
<br/>
b .loop
<br/>
<br/>
<br/>
@copy remaining bytes one byte/short/int at a time, so we get them all.
<br/>
.part2:
<br/>
@add r2, r2, #4
<br/>
ldr r3, [sp] @Find unit size
<br/>
add sp, sp, #4
<br/>
cmp r3, #0
<br/>
beq .loop2_byte @0=byte
<br/>
subs r3, r3, #1
<br/>
beq .loop2_short @1=short
<br/>
@otherwise it must be 2=int (we'll just pretend anything else is 2)
<br/>
<br/>
<br/>
.loop2_int:
<br/>
subs r2, r2, #1
<br/>
bmi .end
<br/>
ldr r3, [r0, #1]!
<br/>
str r3, [r1, #1]!
<br/>
b .loop2_int
<br/>
<br/>
<br/>
.loop2_short:
<br/>
subs r2, r2, #1
<br/>
bmi .end
<br/>
ldrh r3, [r0, #1]!
<br/>
strh r3, [r1, #1]!
<br/>
b .loop2_short
<br/>
<br/>
<br/>
.loop2_byte:
<br/>
subs r2, r2, #1
<br/>
bmi .end
<br/>
ldrb r3, [r0, #1]!
<br/>
strb r3, [r1, #1]!
<br/>
b .loop2_byte
<br/>
<br/>
<br/>
.end:
<br/>
@add r2, r2, #1
<br/>
ldmfd sp!,{r3-r12,lr}
<br/>
bx lr
<br/>
<br/>
.pool
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Prototyped like so:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#ifdef __cplusplus //Non-mangled names plz
<br/>
extern "C" {
<br/>
#endif
<br/>
<br/>
extern void FastCopy(void* Src, void* Dest, u32 NumBytes, u32 Size);
<br/>
<br/>
#ifdef __cplusplus
<br/>
}
<br/>
#endif //__cplusplus</td> </tr></table><span class="postbody">
<br/>
<br/>
I've been trying to figure out how to put it in ITCM for even more speed, no luck though.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101043 - Cearn - Fri Sep 01, 2006 9:55 pm</h4>
    <div class="postbody"><span class="postbody">Unless ARM instructions have changed considerably between ARM7 and ARM9, that code is very unsafe, and in some cases non-optimal.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.global FastCopy
<br/>
.type FastCopy,function
<br/>
FastCopy:
<br/>
    stmfd sp!, {r3-r12, lr}
<br/>
    sub sp, sp, #4
<br/>
    str r3, [sp] @We need this later, but for now, r3 can assist in copying.
<br/>
</td> </tr></table><span class="postbody">
<br/>
You're storing r3 twice here, for no apparent reason. Once is enough.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.loop:
<br/>
  cmp r2, #44
<br/>
  blt .part2 @by checking here, we can copy less than 44 bytes in one call (but it's slow)
<br/>
  ldmia r0!, {r3-r12, lr}
<br/>
  stmia r1!, {r3-r12, lr}
<br/>
  sub r2, r2, #44 @copy 44 bytes at a time (!), and we need those flags updated
<br/>
  b .loop
<br/>
</td> </tr></table><span class="postbody">
<br/>
You're assuming r0 and r1 are word aligned, which would result in incorrect copying if they're not. They usually will be, but a general routine should check for misalignments.
<br/>
Also, there is no need for two branches in the loop, one is enough. This goes for all the loops in the routine. The compare is also redundant, or at least could be taken out of the loop.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  ldr r3, [sp]
<br/>
  add sp, sp, #4
<br/>
</td> </tr></table><span class="postbody">
<br/>
This is simply a 'pop {r3}'
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.loop2_int:
<br/>
  subs r2, r2, #1
<br/>
  bmi .end
<br/>
  ldr r3, [r0, #1]!
<br/>
  str r3, [r1, #1]!
<br/>
  b .loop2_int
<br/>
</td> </tr></table><span class="postbody">
<br/>
This loop fails completely because words need a #4 offset, not #1. Same goes for the halfword loop. And since r2 is the byte count, not the wordcount, it executes 3x too many.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#ifdef __cplusplus //Non-mangled names plz
<br/>
extern "C" {
<br/>
#endif
<br/>
<br/>
extern void FastCopy(void* Src, void* Dest, u32 NumBytes, u32 Size);
<br/>
<br/>
#ifdef __cplusplus
<br/>
}
<br/>
#endif //__cplusplus</td> </tr></table><span class="postbody">
<br/>
Use `const void*' for the source; this saves the users the trouble of having to cast away the constness of the data.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101087 - HyperHacker - Sat Sep 02, 2006 7:25 am</h4>
    <div class="postbody"><span class="postbody">There are good reasons for some of that, actually.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.global FastCopy
<br/>
.type FastCopy,function
<br/>
FastCopy:
<br/>
    stmfd sp!, {r3-r12, lr}
<br/>
    sub sp, sp, #4
<br/>
    str r3, [sp] @We need this later, but for now, r3 can assist in copying.
<br/>
</td> </tr></table><span class="postbody">
<br/>
You're storing r3 twice here, for no apparent reason. Once is enough.</span></td> </tr></table><span class="postbody">
<br/>
This is because I need to copy, then restore r3 and not all those other registers. I don't know of any way to push multiple registers and then only pop one, so I did push all, push r3, copy, pop r3, do some more, pop all.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.loop:
<br/>
  cmp r2, #44
<br/>
  blt .part2 @by checking here, we can copy less than 44 bytes in one call (but it's slow)
<br/>
  ldmia r0!, {r3-r12, lr}
<br/>
  stmia r1!, {r3-r12, lr}
<br/>
  sub r2, r2, #44 @copy 44 bytes at a time (!), and we need those flags updated
<br/>
  b .loop
<br/>
</td> </tr></table><span class="postbody">
<br/>
You're assuming r0 and r1 are word aligned, which would result in incorrect copying if they're not. They usually will be, but a general routine should check for misalignments.
<br/>
Also, there is no need for two branches in the loop, one is enough. This goes for all the loops in the routine. The compare is also redundant, or at least could be taken out of the loop.</span></td> </tr></table><span class="postbody">
<br/>
True, but I don't know what exactly I would do if they're not aligned. I don't see how I can remove the second branch, and the compare is how it knows when to stop (notice r2 is subtracted).
<br/>
<br/>
For the rest, it's mainly because I've never written ARM ASM before. &gt;_&gt;<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101092 - Cearn - Sat Sep 02, 2006 9:58 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>HyperHacker wrote:</b></span></td> </tr> <tr> <td class="quote">There are good reasons for some of that, actually.
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.global FastCopy
<br/>
.type FastCopy,function
<br/>
FastCopy:
<br/>
    stmfd sp!, {r3-r12, lr}
<br/>
    sub sp, sp, #4
<br/>
    str r3, [sp] @We need this later, but for now, r3 can assist in copying.
<br/>
</td> </tr></table><span class="postbody">
<br/>
You're storing r3 twice here, for no apparent reason. Once is enough.</span></td> </tr></table><span class="postbody">
<br/>
This is because I need to copy, then restore r3 and not all those other registers. I don't know of any way to push multiple registers and then only pop one, so I did push all, push r3, copy, pop r3, do some more, pop all.
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
stmfd will place the registers in the list in memory in the order of the register-indices, in your case r3 would have the lowest address (i.e., the one that sp will point to in the end), then r4 above that, then r5 etc. This should suffice:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">FastCopy:
<br/>
    push    {r3-r11,lr} @identical to stmfd sp!, {r3-r11,lr}
<br/>
    
<br/>
    @ copy main blocks
<br/>
    
<br/>
    pop     {r3}        @ pop r3    ( same as ldmfd sp!, {r3} )
<br/>
<br/>
    @ copy smaller stuff
<br/>
<br/>
    pop     {r4-r11,lr} @ pop rest  ( same as ldmfd sp!, {r4-r11,lr}
<br/>
    bx  lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.loop:
<br/>
  cmp r2, #44
<br/>
  blt .part2 @by checking here, we can copy less than 44 bytes in one call (but it's slow)
<br/>
  ldmia r0!, {r3-r12, lr}
<br/>
  stmia r1!, {r3-r12, lr}
<br/>
  sub r2, r2, #44 @copy 44 bytes at a time (!), and we need those flags updated
<br/>
  b .loop
<br/>
</td> </tr></table><span class="postbody">
<br/>
You're assuming r0 and r1 are word aligned, which would result in incorrect copying if they're not. They usually will be, but a general routine should check for misalignments.
<br/>
Also, there is no need for two branches in the loop, one is enough. This goes for all the loops in the routine. The compare is also redundant, or at least could be taken out of the loop.</span></td> </tr></table><span class="postbody">
<br/>
True, but I don't know what exactly I would do if they're not aligned. I don't see how I can remove the second branch, and the compare is how it knows when to stop (notice r2 is subtracted).
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
If the both source and destination cannot be resolved to word alignment then you're pretty much screwed; you'd have to do it the slow way then. Although you could always unroll part of the loop I guess. As for the basic copy loop, they usually look something like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    cmp     r2, #4
<br/>
    bcc     .Lcpy_end       @ Don't copy if there's nothing to do
<br/>
.Lcpy_loop:
<br/>
    ldr     r3, [r0], #4    @ tmp= *r0++;
<br/>
    str     r3, [r1], #4    @ *r0++ = tmp
<br/>
    subs    r2, r2, #4      @ count -= 4
<br/>
    bhi     .Lcpy_loop      @ if(count&gt;0) goto .Lcpy_loop
<br/>
.Lcpy_end:
<br/>
    @stuff
<br/>
</td> </tr></table><span class="postbody">
<br/>
The body of the loop needs only a load, a store, a subtract and a jump. That you have to make a compare outside the loop to test if it's worth going into the loop is of little concern, as it'll only be executed once anyway. In some cases you might even get away with
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.Lcpy_loop:
<br/>
    subs    r2, r2, #4      @ count -= 4
<br/>
    ldrcs   r3, [r0], #4    @ if(count&gt;=0) tmp= *r0++;
<br/>
    strcs   r3, [r1], #4    @ if(count&gt;=0) *r0++ = tmp
<br/>
    bhi     .Lcpy_loop      @ if(count&gt;0)  goto .Lcpy_loop
<br/>
</td> </tr></table><span class="postbody">
<br/>
if you already know r2 won't be used later. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">For the rest, it's mainly because I've never written ARM ASM before. &gt;_&gt;</td> </tr></table><span class="postbody">In that case, be even more careful :P 
<br/>
It's very easy to make mistakes in asm, especially when it concerns either alignment of data or off-by-one errors in loops. In fact, I think I may have just discovered one of those in my own FastCopy routine :P. Always check for potential breaks in code; this is true in C, and is doubly true in asm.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101162 - HotChilli - Sun Sep 03, 2006 2:37 pm</h4>
    <div class="postbody"><span class="postbody">Thanx, guys. :) But here is a stupid question. How can i compile asm-arm code in devkitPro? :))
<br/>
<br/>
PS: _asm { } don't work too... Maybe some special compiler parameters?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101167 - gmiller - Sun Sep 03, 2006 3:02 pm</h4>
    <div class="postbody"><span class="postbody">If you want to do it in with your C++ code make sure the name of the file is one that tells gcc that you are doing C++ (Like .cpp ).  If you want a stand alone file just name it (.s or .S).  C as a language does not support inline assembly so putting the code in a C source file is problematic at best.  There is a command line switch that you can use to force the type so the language parser does not need to guess as well.   Sorry for not giving direct examples but my msys is broken right now because I switched to another laptop and tried to just copy it (what a fool).  Hope this helps.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101189 - HotChilli - Sun Sep 03, 2006 7:16 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">If you want to do it in with your C++ code make sure the name of the file is one that tells gcc that you are doing C++ (Like .cpp ).  If you want a stand alone file just name it (.s or .S).  C as a language does not support inline assembly so putting the code in a C source file is problematic at best.  There is a command line switch that you can use to force the type so the language parser does not need to guess as well.   Sorry for not giving direct examples but my msys is broken right now because I switched to another laptop and tried to just copy it (what a fool).  Hope this helps.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah. Thanx. :) With .s files asm-code from message above compile properly. Makefile parameters (and compiler parameters) is:
<br/>
<br/>
asm.o: asm.s
<br/>
	arm-eabi-gcc -x assembler-with-cpp -c $&lt; -o $@
<br/>
<br/>
Ok. But FastCopy works slower than Dma analog (!) with videomemory and don't working at all (!!!) with RAM memory (global arrays, i.e.).
<br/>
<br/>
Here is handmade profiler values =) (tested on DS hardware; functions make fullredraw (update 256*192 pixels))
<br/>
<br/>
<span style="font-weight: bold">FastCopy (RAM)</span> - crash
<br/>
<span style="font-weight: bold">FastCopy (VRAM)</span> - 4.1 ms :(
<br/>
<span style="font-weight: bold">dmaCopy (RAM)</span> - 23.5 ms
<br/>
<span style="font-weight: bold">dmaCopy (VRAM)</span> - 3.1 ms
<br/>
<span style="font-weight: bold">Copying through cycle</span> - 13.9 ms
<br/>
<span style="font-weight: bold">memcopy (RAM)</span> - 8.8 ms
<br/>
<span style="font-weight: bold">memcopy (VRAM)</span> - 6.6 ms
<br/>
<br/>
And now i have investigated memset functions
<br/>
<br/>
<span style="font-weight: bold">memset (RAM)</span> - 6.3 ms
<br/>
<span style="font-weight: bold">memset (VRAM)</span> - 4.4 ms
<br/>
<span style="font-weight: bold">"dmaSet" (RAM)</span> - 13.2 ms
<br/>
<span style="font-weight: bold">"dmaSet" (VRAM)</span> - 8.3 ms
<br/>
<br/>
And now one trouble. Dma analog of memset works slower than software memset! Ehh...
<br/>
<br/>
Here is my code for dmaset.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// global variable for dma
<br/>
const uint32 dword_for_dmacopy[1] = { 0x00000000 };
<br/>
...
<br/>
...
<br/>
DMA_SRC(3) = (uint32)dword_for_dmacopy;
<br/>
DMA_DEST(3) = BG_BMP_RAM_SUB(0);
<br/>
DMA_CR(3) = DMA_ENABLE | DMA_32_BIT | DMA_SRC_FIX | DMA_START_NOW | (256 * 192 / 2);
<br/>
while(DMA_CR(3) &amp; DMA_BUSY); 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And now updated question. =) <span style="text-decoration: underline">How we can write memset and memcopy for VRAM faster than 4.1 ms and 3.1 ms respectively?</span></span><span class="gensmall"><br/><br/>Last edited by HotChilli on Sun Sep 03, 2006 7:25 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#101190 - Sausage Boy - Sun Sep 03, 2006 7:23 pm</h4>
    <div class="postbody"><span class="postbody">You could just skip the wait and do other stuff there instead.<br/>_________________<br/>"no offense, but this is the gayest game ever"</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101191 - HotChilli - Sun Sep 03, 2006 7:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Sausage Boy wrote:</b></span></td> </tr> <tr> <td class="quote">You could just skip the wait and do other stuff there instead.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah. That's work in particular case. But i.e. i write in bottom part of VRAM and next time dma erase my changes... That bugs me! :))</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101272 - HyperHacker - Mon Sep 04, 2006 3:08 am</h4>
    <div class="postbody"><span class="postbody">FYI, when you do this:
<br/>
<span style="font-style: italic">while(something);</span>
<br/>
You're wasting CPU power doing essentially nothing, which is hard on the batteries if you do it a lot. I think swiDelay() (or was it swiSleep()? haven't done any DS stuff recently) actually stops the CPU for a while, which would be much easier on the batteries:
<br/>
while(something) swiDelay(5);
<br/>
Of course this means it could take up to 5 units (not sure what measurement that is) before it realizes DMA is done, so you'd want to adjust that number depending how fast you need the entire routine to be.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101455 - HotChilli - Tue Sep 05, 2006 6:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>HyperHacker wrote:</b></span></td> </tr> <tr> <td class="quote">FYI, when you do this:
<br/>
<span style="font-style: italic">while(something);</span>
<br/>
You're wasting CPU power doing essentially nothing, which is hard on the batteries if you do it a lot. I think swiDelay() (or was it swiSleep()? haven't done any DS stuff recently) actually stops the CPU for a while, which would be much easier on the batteries:
<br/>
while(something) swiDelay(5);
<br/>
Of course this means it could take up to 5 units (not sure what measurement that is) before it realizes DMA is done, so you'd want to adjust that number depending how fast you need the entire routine to be.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah. That's looks better. ;)
<br/>
<br/>
PS: Have you test your FastCopy function for different types of memory? VRAM? RAM? Is it only for VRAM?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#101517 - HyperHacker - Wed Sep 06, 2006 6:34 am</h4>
    <div class="postbody"><span class="postbody">I designed it for VRAM but I tested it with ordinary RAM too.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
