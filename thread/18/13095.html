<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Memory management - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > Memory management</h2>
<div id="posts">
<div class="post">
    <h4>#127026 - Phantaseur - Sun Apr 29, 2007 11:06 am</h4>
    <div class="postbody"><span class="postbody">What happens in NDS when I call 'malloc' function?
<br/>
As I know my program have monopolistic access to all resources of NDS, so who provides memory management? Or memory manager is built in program by compiler when I use 'malloc' function? So can I manage memory manually adresating certain areas of RAM, can I have access to whole RAM not using memory allocation functions or write my own ones?
<br/>
<br/>
If I can overwrite 'malloc', 'realloc' &amp; 'free' functions and create my own memory manager what can I do with 'new' &amp; 'delete' operators of c++?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#127042 - tepples - Sun Apr 29, 2007 3:14 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Phantaseur wrote:</b></span></td> </tr> <tr> <td class="quote">What happens in NDS when I call 'malloc' function?
<br/>
As I know my program have monopolistic access to all resources of NDS, so who provides memory management? Or memory manager is built in program by compiler when I use 'malloc' function?</td> </tr></table><span class="postbody">
<br/>
Yes. The C library 'newlib' implements 'malloc' and 'free' in terms of any part of main RAM that isn't allocated to code or global/static data.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">So can I manage memory manually adresating certain areas of RAM, can I have access to whole RAM not using memory allocation functions or write my own ones?</td> </tr></table><span class="postbody">
<br/>
Correct.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">If I can overwrite 'malloc', 'realloc' &amp; 'free' functions and create my own memory manager what can I do with 'new' &amp; 'delete' operators of c++?</td> </tr></table><span class="postbody">
<br/>
I believe the standard C++ library just calls 'malloc' and 'free'.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#127063 - Sausage Boy - Sun Apr 29, 2007 6:57 pm</h4>
    <div class="postbody"><span class="postbody">You can define your own version of operator new. Here's a snippet of psuedo code found in the book Effective C++ (3rd edition) by Scott Meyers.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void* operator new(std::size_t size) throw(std::bad_alloc)
<br/>
{
<br/>
   using namespace std;
<br/>
   if (size==0) {
<br/>
      size = 1;
<br/>
   }
<br/>
<br/>
   while (true) {
<br/>
      attempt to allocate size bytes
<br/>
<br/>
      if (the allocation was successful)
<br/>
         return (a pointer to the memory);
<br/>
<br/>
      new_handler globalHandler = set_new_handler(0);
<br/>
      set_new_handler(globalHandler);
<br/>
<br/>
      if (globalHandler) (*globalHandler)();
<br/>
      else throw std::bad_alloc();
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
The book contains some comments for the code and some explanations, but at least this will give you some terms to google with. I suggest you buy the book. Basically what we're doing is trying to allocate memory in an infinite loop, and if we fail, we call the new handler to see if it can free some memory. If it can't, it'll remove itself and we throw an exception. Also, we need to provide a valid pointer for requests for 0 bytes, so we treat it as a request for 1 byte.
<br/>
<br/>
It is not <span style="font-style: italic">operator new</span>'s responsibility to call constructors and stuff, that's handled by the <span style="font-style: italic">new</span> operator (riiiiight, not confusing :P). You can't change the new operator. But really, get the book, or perhaps some other book. My explanations can't even be compared to those from our friend Meyers.<br/>_________________<br/>"no offense, but this is the gayest game ever"</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
