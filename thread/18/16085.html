<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How can I test if sound can be decoded fast enough? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > How can I test if sound can be decoded fast enough?</h2>
<div id="posts">
<div class="post">
    <h4>#163251 - Lazy1 - Sat Sep 27, 2008 9:05 am</h4>
    <div class="postbody"><span class="postbody">With quite a bit of hacking I managed to get the much more optimized YM3812 sound chip emulator from ScummVM working on the arm7.
<br/>
Unfortunately I have not been able to get any good results, the sound is generated fine but I'm not sure if the buffer isn't being filled fast enough or what.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163254 - silent_code - Sat Sep 27, 2008 11:34 am</h4>
    <div class="postbody"><span class="postbody">Get a profiler. :^)<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163256 - Lazy1 - Sat Sep 27, 2008 1:00 pm</h4>
    <div class="postbody"><span class="postbody">I don't know of any arm7 profilers or I would, though I think it may have been a buffering error on my part.
<br/>
<br/>
The number of samples produced by the emulator can be more or less than what is needed to fill the buffer at the required time.
<br/>
I'm still trying to wrap my head around this but I think I know what I need to do.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163258 - tepples - Sat Sep 27, 2008 1:16 pm</h4>
    <div class="postbody"><span class="postbody">Set a timer, and look at the value when your subroutine finishes. Write that value somewhere in the IPC struct where the ARM9 can pick it up and use it. (You should probably be able to finish this profiling before WinterMute and friends change libnds to no longer use an IPC struct.)<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163263 - Lazy1 - Sat Sep 27, 2008 6:27 pm</h4>
    <div class="postbody"><span class="postbody">I think I may have the buffering thing figured out but I'll post the relevant code here anyway to get more opinions.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int EmulateIMFTick( void ) {
<br/>
   int Samples = 0;
<br/>
<br/>
   while ( SongSize ) {
<br/>
      OPLWrite( Adlib, Song-&gt;r, Song-&gt;v );
<br/>
<br/>
      if ( Song-&gt;pause &gt; 0 ) {
<br/>
         Samples = ( Song-&gt;pause * OPLFreq ) / 700;
<br/>
         YM3812UpdateOne( Adlib, SampleBuffer, Samples );
<br/>
<br/>
         Song++;
<br/>
         SongSize-= sizeof( IMFCommand );
<br/>
<br/>
         return Samples;
<br/>
      }
<br/>
<br/>
      Song++;
<br/>
      SongSize-= sizeof( IMFCommand );
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}
<br/>
<br/>
void PlayTheTune( void ) {
<br/>
   int SamplesNeeded = 0;
<br/>
   int SamplesMade = 0;
<br/>
   int SamplesReady = 0;
<br/>
<br/>
   SoundCursor = RingBuffer;
<br/>
   BufferPos = RingBuffer;
<br/>
<br/>
   // Initial buffer fill
<br/>
   SamplesNeeded = ( 11025 * 10 );//512;
<br/>
   do {
<br/>
      if ( SamplesReady ) {
<br/>
         // We had some left over samples from the last
<br/>
         // emulation tick.
<br/>
         // Just pretend we ran through the emulator :D
<br/>
         SamplesMade = SamplesReady;
<br/>
      } else {
<br/>
         SamplesMade = EmulateIMFTick( );
<br/>
      }
<br/>
<br/>
      if ( SamplesMade == SamplesNeeded ) {
<br/>
         // Exactly enough samples were generated.
<br/>
         // Copy them directly into the ring buffer.
<br/>
         memcpy( BufferPos, SampleBuffer, SamplesMade * 2 );
<br/>
         break;
<br/>
      } else if ( SamplesMade &gt; SamplesNeeded ) {
<br/>
         // More samples were generated than needed.
<br/>
         // Copy the needed amount of samples into the buffer and move
<br/>
         // the unused samples to the start of the sample buffer.
<br/>
         SamplesReady = ( SamplesMade - SamplesNeeded );
<br/>
<br/>
         memcpy( BufferPos, SampleBuffer, SamplesNeeded * 2 );
<br/>
         memmove( SampleBuffer, &amp;SampleBuffer[ SamplesReady ], SamplesReady * 2 );
<br/>
<br/>
         break;
<br/>
      } else {
<br/>
         // Not enough samples were generated.
<br/>
         // Do another run through the loop.
<br/>
         memcpy( BufferPos, SampleBuffer, SamplesMade * 2 );
<br/>
<br/>
         BufferPos+= SamplesMade;
<br/>
         SamplesNeeded-= SamplesMade;
<br/>
      }
<br/>
   }
<br/>
   while ( SamplesNeeded );
<br/>
<br/>
   SCHANNEL_SOURCE( 0 ) = RingBuffer;
<br/>
   SCHANNEL_LENGTH( 0 ) = RingBufferSize &gt;&gt; 2;
<br/>
   SCHANNEL_TIMER( 0 ) = SOUND_FREQ( OPLFreq );
<br/>
   SCHANNEL_CR( 0 ) = SCHANNEL_ENABLE | SOUND_ONE_SHOT | SOUND_16BIT | SOUND_VOL( 0x7F ) | SOUND_PAN( 0 );
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Of course PlayTheTune() is not where the code is supposed to be but I wanted to make sure if the buffering is correct before moving ahead.
<br/>
It does sound good though at 11025Hz, hopefully the arm7 is fast enough to do this in realtime.
<br/>
<br/>
Another bonus is if someone wants to add YM3812 emulation into the DS port of DOOM so we get music :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163264 - Maxxie - Sat Sep 27, 2008 6:50 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
It does sound good though at 11025Hz, hopefully the arm7 is fast enough to do this in realtime.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Just a sidenote:
<br/>
Actually the DS does not support 11025Hz samples. If you keep the casts in mind when setting the sample rate register you'll set a slightly different speed. You can't hear that in the pitch (at least i don't) but if you use timer to fill the buffer you need to keep that in mind otherwise you will get out of sync sooner or later.
<br/>
<br/>
Iirc it was around 11031Hz,to get the exact speed, just look at the actual value written to the sample rate register and do the reverse calculation.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163267 - Lazy1 - Sat Sep 27, 2008 8:23 pm</h4>
    <div class="postbody"><span class="postbody">I'll keep that in mind when I get the buffering working properly, so far it "plays" but has short gaps and repeats which probably means my buffering code is broken.
<br/>
<br/>
I did make a few modifications and most of the streaming code is from memory when I did it with MP3.
<br/>
<br/>
MWHAHAHAHA!
<br/>
It really works, god only knows why but it actually works.
<br/>
<br/>
A few more modifications are needed but this pretty much proves that you can emulate the YM3812 chip on the arm7.
<br/>
Currently only full speed at 8000Hz though but for most purposes that should be fine.
<br/>
<br/>
Anybody want to start adding music to doom? :D
<br/>
<br/>
EDIT:
<br/>
Too soon, tested another song and it's crackly.
<br/>
Now I'll have to test the CPU usage.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163274 - Lazy1 - Sun Sep 28, 2008 9:51 am</h4>
    <div class="postbody"><span class="postbody">Ok, so increasing the buffer size to 16KB has solved the crackling issue however there are still a few problems that make no sense at all.
<br/>
<br/>
Lots of magic numbers involved in this too, is it a necessary evil of DS audio programming or is it just luck why things aren't (horribly) going wrong?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int EmulateIMFTick( void ) {
<br/>
   int Samples = 0;
<br/>
<br/>
   while ( SongSize ) {
<br/>
      OPLWrite( Adlib, Song-&gt;r, Song-&gt;v );
<br/>
<br/>
      if ( Song-&gt;pause &gt; 0 ) {
<br/>
         Samples = ( Song-&gt;pause * OPLFreq ) / 700;
<br/>
         YM3812UpdateOne( Adlib, SampleBuffer, Samples );
<br/>
<br/>
         Song++;
<br/>
         SongSize-= sizeof( IMFCommand );
<br/>
<br/>
         return Samples;
<br/>
      }
<br/>
<br/>
      Song++;
<br/>
      SongSize-= sizeof( IMFCommand );
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}
<br/>
<br/>
short* SoundCursor = NULL;
<br/>
short* BufferPos = NULL;
<br/>
<br/>
void SwapCursor( void ) {
<br/>
   if ( SoundCursor == RingBuffer ) SoundCursor+= ( ( RingBufferSize / 2 ) / 2 );
<br/>
   else SoundCursor = RingBuffer;
<br/>
}
<br/>
<br/>
int SamplesReady = 0;
<br/>
<br/>
void BufferFill( int SamplesNeeded ) {
<br/>
   int SamplesMade = 0;
<br/>
<br/>
   BufferPos = SoundCursor;
<br/>
<br/>
   do {
<br/>
      if ( SamplesReady ) {
<br/>
         // We had some left over samples from the last
<br/>
         // emulation tick.
<br/>
         // Just pretend we ran through the emulator :D
<br/>
         SamplesMade = SamplesReady;
<br/>
         SamplesReady = 0;
<br/>
      } else {
<br/>
         SamplesMade = EmulateIMFTick( );
<br/>
      }
<br/>
<br/>
      if ( SamplesMade == SamplesNeeded ) {
<br/>
         // Exactly enough samples were generated.
<br/>
         // Copy them directly into the ring buffer.
<br/>
         memcpy( BufferPos, SampleBuffer, SamplesMade * 2 );
<br/>
         BufferPos+= SamplesMade;
<br/>
         break;
<br/>
      } else if ( SamplesMade &gt; SamplesNeeded ) {
<br/>
         // More samples were generated than needed.
<br/>
         // Copy the needed amount of samples into the buffer and move
<br/>
         // the unused samples to the start of the sample buffer.
<br/>
         SamplesReady = ( SamplesMade - SamplesNeeded );
<br/>
<br/>
         memcpy( BufferPos, SampleBuffer, SamplesNeeded * 2 );
<br/>
         memmove( SampleBuffer, &amp;SampleBuffer[ SamplesNeeded ], SamplesReady * 2 );
<br/>
         //memmove( SampleBuffer, &amp;SampleBuffer[ SamplesReady ], SamplesReady * 2 );
<br/>
<br/>
         BufferPos+= SamplesNeeded;
<br/>
<br/>
         break;
<br/>
      } else {
<br/>
         // Not enough samples were generated.
<br/>
         // Do another run through the loop.
<br/>
         memcpy( BufferPos, SampleBuffer, SamplesMade * 2 );
<br/>
<br/>
         BufferPos+= SamplesMade;
<br/>
         SamplesNeeded-= SamplesMade;
<br/>
      }
<br/>
   }
<br/>
   while ( SamplesNeeded &amp;&amp; SongSize );
<br/>
<br/>
   SwapCursor( );
<br/>
}
<br/>
<br/>
void WaitBufferFinished( void ) {
<br/>
   // TODO:
<br/>
   // Something should go here, but nothing has worked so far.
<br/>
}
<br/>
<br/>
void PlayTheTune( void ) {
<br/>
   int LastTimer2Data = 0;
<br/>
   int Timer2Data = 0;
<br/>
   int i;
<br/>
<br/>
   SoundCursor = RingBuffer;
<br/>
<br/>
   // Fill the ring buffer completely before starting
<br/>
   BufferFill( RingBufferSize );
<br/>
<br/>
   TIMER0_DATA = SOUND_FREQ( OPLFreq ) * 2;
<br/>
   TIMER1_DATA = 65536 - ( ( RingBufferSize / 2 ) / 2 );
<br/>
   TIMER2_DATA = 0;
<br/>
<br/>
   TIMER0_CR = TIMER_ENABLE | TIMER_DIV_1;
<br/>
   TIMER1_CR = TIMER_ENABLE | TIMER_DIV_1 | TIMER_CASCADE;
<br/>
   TIMER2_CR = TIMER_ENABLE | TIMER_DIV_1 | TIMER_CASCADE;
<br/>
<br/>
   SCHANNEL_SOURCE( 0 ) = ( u32 ) RingBuffer;
<br/>
   SCHANNEL_LENGTH( 0 ) = RingBufferSize &gt;&gt; 2;
<br/>
   SCHANNEL_TIMER( 0 ) = SOUND_FREQ( OPLFreq );
<br/>
   SCHANNEL_CR( 0 ) = SCHANNEL_ENABLE | SOUND_REPEAT | SOUND_16BIT | SOUND_VOL( 0x7F ) | SOUND_PAN( 0 );
<br/>
<br/>
   SCHANNEL_SOURCE( 1 ) = ( u32 ) RingBuffer;
<br/>
   SCHANNEL_LENGTH( 1 ) = RingBufferSize &gt;&gt; 2;
<br/>
   SCHANNEL_TIMER( 1 ) = SOUND_FREQ( OPLFreq );
<br/>
   SCHANNEL_CR( 1 ) = SCHANNEL_ENABLE | SOUND_REPEAT | SOUND_16BIT | SOUND_VOL( 0x7F ) | SOUND_PAN( 127 );
<br/>
<br/>
   WaitBufferFinished( );
<br/>
<br/>
   while ( SongSize ) {
<br/>
      // WTF?
<br/>
      // All this searching and it took adding 1 to TIMER2_DATA
<br/>
      // to fix the crackling?
<br/>
      Timer2Data = TIMER2_DATA + 1;
<br/>
<br/>
      if ( Timer2Data &gt; LastTimer2Data ) {
<br/>
         BufferFill( ( RingBufferSize / 2 ) / 2 );
<br/>
      }
<br/>
<br/>
      LastTimer2Data = Timer2Data;
<br/>
   }
<br/>
<br/>
   // TODO:
<br/>
   // Wait until last part of buffer finishes playing.
<br/>
   WaitBufferFinished( );
<br/>
<br/>
   SCHANNEL_CR( 0 ) = 0;
<br/>
   SCHANNEL_CR( 1 ) = 0;
<br/>
   TIMER0_CR = 0;
<br/>
   TIMER1_CR = 0;
<br/>
   TIMER2_CR = 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Once the music starts the first part of the buffer gets overwritten, that makes sense since it hasn't finished playing yet.
<br/>
The problem being no matter how I try to wait for it nothing aligns and screws up the rest of the stream.
<br/>
<br/>
Other than the start screwing up and the end being cut off (WaitBufferFinished issue) the whole thing seems to work fine.
<br/>
Even 11025Hz works now with the larger buffer, a huge improvement over 8000Hz at least for wolf3d music.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163282 - Dwedit - Sun Sep 28, 2008 6:36 pm</h4>
    <div class="postbody"><span class="postbody">So when do ASM optimizations come into play?<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163284 - Lazy1 - Sun Sep 28, 2008 6:47 pm</h4>
    <div class="postbody"><span class="postbody">Maybe when I get around to learning arm assembly, I found a nice ebook on it but unfortunately the text to speech option has been disabled on it.
<br/>
<br/>
It's fast enough to run at 11025Hz but the timing issue is still there and makes  no sense.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163285 - tepples - Sun Sep 28, 2008 6:50 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">but unfortunately the text to speech option has been disabled on it.</td> </tr></table><span class="postbody">
<br/>
Have you tried contacting its publisher?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163286 - Lazy1 - Sun Sep 28, 2008 6:55 pm</h4>
    <div class="postbody"><span class="postbody">I was going to but got distracted and did something else instead.
<br/>
Maybe in the next week or so I will.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163288 - Cydrak - Sun Sep 28, 2008 8:34 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">Lots of magic numbers involved in this too, is it a necessary evil of DS audio programming or is it just luck why things aren't (horribly) going wrong? </td> </tr></table><span class="postbody">
<br/>
Nah, no magic or evil so far as I know. The main annoyance is needing separate stream timers in the first place... (You can actually get away with one timer, which is what I do, but two or three should work fine.)
<br/>
<br/>
I'm not sure about the beginning and the end... it depends on how you're doing it. If you only track TIMER2, it looks like there's no guarantee EmulateIMFTick() will really fill the whole thing. In that case, wouldn't you have to zero the rest of that half before waiting for it to finish?
<br/>
<br/>
Hm, I see BufferFill() swaps the cursor once at the end, apparently expecting to fill half in one go. But then you do this at the start:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   SoundCursor = RingBuffer;
<br/>
   BufferFill( RingBufferSize );   // size in bytes? samples?
<br/>
</td> </tr></table><span class="postbody">
<br/>
If that's in bytes (BufferFill clearly expects a sample count), you could be overrunning the buffer here. But more importantly, where does it put the cursor afterward?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">Even 11025Hz works now with the larger buffer, a huge improvement over 8000Hz at least for wolf3d music.</td> </tr></table><span class="postbody">
<br/>
Yikes, 11Khz is ear-grating compared to the real thing! :|
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">So when do ASM optimizations come into play?</td> </tr></table><span class="postbody">
<br/>
There's definitely room for that; but IMHO, a lot sorta boils down to loop invariants, and simplifying the hotspots as far as possible. The emulators I looked at grind through <span style="font-style: italic">every</span> oscillator for <span style="font-style: italic">every</span> sample, and I don't even <span style="font-style: italic">want</span> to know how much cache and register thrashing is involved! o_o
<br/>
<br/>
Anyhow, I've got some C++/assembler kicking around that can handle 32Khz stereo (admittedly incomplete, with some minor bugs and cheating involved). At that rate, 18 YM voices take around 66% of the ARM9, fast enough to run some decent MIDI through it. I'm sick of optimizing, so it's fallen aside, but if there's enough interest, I'll try to clean it up. &gt;_&gt;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163291 - Lazy1 - Sun Sep 28, 2008 10:05 pm</h4>
    <div class="postbody"><span class="postbody">You're right, there were a few bugs in there I missed.
<br/>
Now the start plays properly but drifts out of alignment fairly quickly.
<br/>
<br/>
I'll have to upload the source+binary so it can be heard, 11KHz is not _that_ bad.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void WaitBufferFinished( void ) {
<br/>
   int Future = TIMER2_DATA + 1;
<br/>
<br/>
   while ( TIMER2_DATA &lt; Future )
<br/>
   ;
<br/>
}
<br/>
<br/>
void PlayTheTune( void ) {
<br/>
   int LastTimer2Data = 0;
<br/>
   int Timer2Data = 0;
<br/>
   int i;
<br/>
<br/>
   SoundCursor = RingBuffer;
<br/>
<br/>
   // Fill the ring buffer completely before starting
<br/>
   BufferFill( ( RingBufferSize / 2 ) / 2 );
<br/>
<br/>
   TIMER0_DATA = SOUND_FREQ( OPLFreq ) * 2;
<br/>
   TIMER1_DATA = 65536 - ( ( RingBufferSize / 2 ) / 2 );
<br/>
   TIMER2_DATA = 0;
<br/>
<br/>
   TIMER0_CR = TIMER_ENABLE | TIMER_DIV_1;
<br/>
   TIMER1_CR = TIMER_ENABLE | TIMER_DIV_1 | TIMER_CASCADE;
<br/>
   TIMER2_CR = TIMER_ENABLE | TIMER_DIV_1 | TIMER_CASCADE;
<br/>
<br/>
   SCHANNEL_SOURCE( 0 ) = ( u32 ) RingBuffer;
<br/>
   SCHANNEL_LENGTH( 0 ) = RingBufferSize &gt;&gt; 2;
<br/>
   SCHANNEL_TIMER( 0 ) = SOUND_FREQ( OPLFreq );
<br/>
   SCHANNEL_CR( 0 ) = SCHANNEL_ENABLE | SOUND_REPEAT | SOUND_16BIT | SOUND_VOL( 0x7F ) | SOUND_PAN( 0 );
<br/>
<br/>
   SCHANNEL_SOURCE( 1 ) = ( u32 ) RingBuffer;
<br/>
   SCHANNEL_LENGTH( 1 ) = RingBufferSize &gt;&gt; 2;
<br/>
   SCHANNEL_TIMER( 1 ) = SOUND_FREQ( OPLFreq );
<br/>
   SCHANNEL_CR( 1 ) = SCHANNEL_ENABLE | SOUND_REPEAT | SOUND_16BIT | SOUND_VOL( 0x7F ) | SOUND_PAN( 127 );
<br/>
<br/>
   //WaitBufferFinished( );
<br/>
<br/>
   while ( SongSize ) {
<br/>
      WaitBufferFinished( );
<br/>
      BufferFill( ( RingBufferSize / 2 ) / 2 );
<br/>
   }
<br/>
<br/>
   // TODO:
<br/>
   // Wait until last part of buffer finishes playing.
<br/>
   WaitBufferFinished( );
<br/>
<br/>
   SCHANNEL_CR( 0 ) = 0;
<br/>
   SCHANNEL_CR( 1 ) = 0;
<br/>
   TIMER0_CR = 0;
<br/>
   TIMER1_CR = 0;
<br/>
   TIMER2_CR = 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
EDIT:
<br/>
One downside is that currently it requires a vram bank mapped to the arm7.
<br/>
<br/>
EDIT 2:
<br/>
I would be interested to hear what hacks I can do to speed it up though, now I see that some songs just won't run at 11KHz :/</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163363 - Lazy1 - Tue Sep 30, 2008 7:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote">The main annoyance is needing separate stream timers in the first place... (You can actually get away with one timer, which is what I do, but two or three should work fine.)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
How would you stream using only one timer?
<br/>
I think it's time to re-write the streaming code and try to get some idea as to how long it's taking.
<br/>
<br/>
I could count hblanks before and after buffer fills but that would not be very accurate since a different amount of samples can be generated each time.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163369 - Maxxie - Tue Sep 30, 2008 9:08 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
How would you stream using only one timer?</td> </tr></table><span class="postbody">
<br/>
<br/>
Manage them with a list.
<br/>
If you add an event (the previous timer IRQ) to the list check if the timer is allready running:
<br/>
<ul>
<br/>
<li>running: is current time left in timer &gt; new timer delay
<br/>
<ul>
<br/>
<li>yes: reduce the saved delay in the first element to current time left in timer - new timer delay, push_front the new event with the new timer delay
<br/>
</li><li>no: iterate through the list until the accumulated delay times are &gt; new timer delay. Insert just before it the new event with new timer delay - accumulated delay just before, and reduce the following delay by the new timer delay
<br/>
</li></ul>
<br/>
</li><li>not running: obvious
<br/>
</li></ul>
<br/>
<br/>
If then the timer irq fires, do the first event in the list and remove it, set the new timer with the delay with the next event. (Beware of the 0 delay)
<br/>
<br/>
All timer events are queued up by their chronological order, seperated by the time passed between them with only one timer.
<br/>
<br/>
PS: You'll need to take care about timer progress while adding a new event. Usually you can just stop the timer for short and start it again after you are done. If you do this, set the timer data again by the value you have just read, otherwise it's data will reset to the last written value on enable (see GBATEK)<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163377 - Cydrak - Wed Oct 01, 2008 1:23 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">How would you stream using only one timer? </td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">Manage them with a list.</td> </tr></table><span class="postbody">
<br/>
Hmm, I'm not sure I understand your suggestion, since the timers above are not separate timers; they're linked (cascaded) as a large one. (Although I'm curious how you avoid drift while adjusting the timer delay...)
<br/>
<br/>
To be sure, the way Lazy1's got it set up:
<br/>
- TIMER0 counts right along with the sound channel's..
<br/>
- TIMER1 counts a sample every time TIMER0 overflows..
<br/>
- TIMER2 counts halves of the ring buffer every time TIMER1 overflows. (The same could have been done in TIMER1's IRQ instead.)
<br/>
<br/>
Let's say I try:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">playCursor         = 0;
<br/>
TIMER0_DATA        = 2*SOUND_FREQ( sampleRate );
<br/>
...
<br/>
SCHANNEL_LENGTH(0) = streamSize * sampleBits/32;
<br/>
SCHANNEL_CR(0)     = SCHANNEL_ENABLE | ...;
<br/>
TIMER0_CR          = TIMER_ENABLE | TIMER_IRQ_REQ | TIMER_DIV_1;
<br/>
...
<br/>
<br/>
void streamTimerHr() {
<br/>
    playCursor++;
<br/>
    if(playCursor &gt;= streamSize)
<br/>
        playCursor -= streamSize;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
This fires an IRQ every sample, sort of a waste, really.
<br/>
<br/>
But the thing is, you don't need a super-accurate playback position. You just need to know that it will be between X and X+B, where B is some forward bound in the ring buffer. Then, so long as you keep up, you can refill it up to X-1 whenever you like.
<br/>
<br/>
So instead, I do this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">playCursor         = 0;
<br/>
samplePeriod       = 2*SOUND_FREQ( sampleRate );
<br/>
timerMultiple      = -0x10000 / samplePeriod;
<br/>
timerPeriod        = timerMultiple * samplePeriod;
<br/>
TIMER0_DATA        = timerPeriod;
<br/>
...
<br/>
SCHANNEL_LENGTH(0) = streamSize * sampleBits/32;
<br/>
SCHANNEL_CR(0)     = SCHANNEL_ENABLE | ...;
<br/>
TIMER0_CR          = TIMER_ENABLE | TIMER_IRQ_REQ | TIMER_DIV_1;
<br/>
...
<br/>
<br/>
void streamTimerHr() {
<br/>
    playCursor += timerMultiple;
<br/>
    if(playCursor &gt;= streamSize)
<br/>
        playCursor -= streamSize;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Now if I want to stream at 11025hz or whatever, I'll have:
<br/>
- samplePeriod = 2 * (-2^24 / 11025) = -3042
<br/>
- timerMultiple = -0x10000 / -3042 = 21
<br/>
- timerPeriod = 21 * -3042 = -63882
<br/>
<br/>
What I did was pick the largest multiple of samples that fits in the 16-bit timer period, to get a lowish frequency (&gt;= 512hz). Since the timers and audio derive from the same clock, I still know--within the bounds of the multiple--what samples are being played (which is to say: where in the buffer I should stop writing).
<br/>
<br/>
In this case the timer runs around 525hz and the audio will be ~11030hz, or something close to that.* To give some perspective, that's a little over 8 IRQs/frame, which seems reasonable. (Hblank IRQs happen around 30 times that rate and I haven't had problems.)
<br/>
<br/>
<span style="font-size: 9px; line-height: normal">* GBAtek and libnds slightly disagree, nevermind physical variations.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163384 - Maxxie - Wed Oct 01, 2008 6:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">How would you stream using only one timer? </td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">Manage them with a list.</td> </tr></table><span class="postbody">
<br/>
Hmm, I'm not sure I understand your suggestion, since the timers above are not separate timers; they're linked (cascaded) as a large one. (Although I'm curious how you avoid drift while adjusting the timer delay...)</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Not the physical timers, just the timer events.
<br/>
<br/>
Just lie them down in a list like pearls on a chain.
<br/>
Set the timer only for the first timer event in the chain and handle it. If done, set it for the next timer event, while keeping in mind the time that did allready pass since the init of that event ....
<br/>
<br/>
One timer active at any time and all events handled.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163396 - Miked0801 - Wed Oct 01, 2008 5:27 pm</h4>
    <div class="postbody"><span class="postbody">Consider finding the free version of No$.  It has decent timers built in for per cycle profiling.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163443 - Lazy1 - Thu Oct 02, 2008 2:28 pm</h4>
    <div class="postbody"><span class="postbody">I did a cheap hack profile sort of thing by seeing how many hblanks pass during a call to EmulateIMFTick().
<br/>
Apparently the longest it took was 3299 hblanks to generate 3039 samples, maybe someone has the math to figure that one out?
<br/>
<br/>
EDIT: At 11025Hz</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163445 - Maxxie - Thu Oct 02, 2008 3:07 pm</h4>
    <div class="postbody"><span class="postbody">At 15.7343kHz H-timing, You just spent ~0.21 seconds for 3039 samples = ~0.27 seconds of audio (at 11025Hz)
<br/>
<br/>
-&gt; should be enought, BUT
<br/>
<br/>
You are spending around 2312 system cycles (33Mhz) per sample which is a LOT for 8? 16? 32? bist.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163456 - Miked0801 - Thu Oct 02, 2008 6:31 pm</h4>
    <div class="postbody"><span class="postbody">Did you disable interrupts while counting your lines?  You may very well be getting VBlank time in with your measurements.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163458 - Lazy1 - Thu Oct 02, 2008 7:20 pm</h4>
    <div class="postbody"><span class="postbody">Hmm, disabling all but the hblank interrupt really changes the numbers...
<br/>
<br/>
2535 Samples took 2748 hblanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163496 - Lazy1 - Fri Oct 03, 2008 5:29 pm</h4>
    <div class="postbody"><span class="postbody">OK, So it appears the ring buffer size must be a multiple of the sample rate?
<br/>
Everything works perfectly now, thanks for all the help :D</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
