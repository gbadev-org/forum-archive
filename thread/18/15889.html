<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Need help with converting float to fixed - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Need help with converting float to fixed</h2>
<div id="posts">
<div class="post">
    <h4>#161316 - 3dfx - Fri Aug 01, 2008 2:05 am</h4>
    <div class="postbody"><span class="postbody">I'm trying to port my 3d game-ish/engine to the DS. At first I used floats because it made more sense to me but my frame rate started taking a nose dive so I converted everything to fixed point. Everything seems to work all right except my models. The interpolation between keyframes with them are screwed up big time using fixed point but are fine with floats. Here's how I have the interpolation:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//model-&gt;timeStep is how far from 0.0f to 1.0f the model has been animated
<br/>
//model-&gt;end and model-&gt;begin are int values of what frame our current animation begins and ends at
<br/>
<br/>
//old way
<br/>
float fraction =  (model-&gt;timeStep - (float)(start - model-&gt;begin) / (float)(model-&gt;end - model-&gt;begin + 1)) * (model-&gt;end - model-&gt;begin + 1);
<br/>
VERTEX3 one, two, pt;
<br/>
one.x = model-&gt;frames[start].vertices[vertex].position.x;
<br/>
one.y = model-&gt;frames[start].vertices[vertex].position.y;
<br/>
one.z = model-&gt;frames[start].vertices[vertex].position.z;
<br/>
 
<br/>
two.x = model-&gt;frames[end].vertices[vertex].position.x;
<br/>
two.y = model-&gt;frames[end].vertices[vertex].position.y;
<br/>
two.z = model-&gt;frames[end].vertices[vertex].position.z;
<br/>
<br/>
//my new vertex
<br/>
pt.x = one.x * (1 - fraction) + two.x * fraction;
<br/>
pt.y = one.y * (1 - fraction) + two.y * fraction;
<br/>
pt.z = one.z * (1 - fraction)    + two.z * fraction;
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
^^ Works fine. Using fixed points,
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
float fraction =  (model-&gt;timeStep - (float)(start - model-&gt;begin) / (float)(model-&gt;end - model-&gt;begin + 1)) *  (model-&gt;end - model-&gt;begin + 1);
<br/>
v16 cFrac = floattov16(fraction);
<br/>
<br/>
VERTEX3F one, two, pt;
<br/>
one.x = model-&gt;frames[start].vertices[vertex].position.x;
<br/>
one.y = model-&gt;frames[start].vertices[vertex].position.y;
<br/>
one.z = model-&gt;frames[start].vertices[vertex].position.z;
<br/>
 
<br/>
two.x = model-&gt;frames[end].vertices[vertex].position.x;
<br/>
two.y = model-&gt;frames[end].vertices[vertex].position.y;
<br/>
two.z = model-&gt;frames[end].vertices[vertex].position.z;
<br/>
<br/>
//my new vertex
<br/>
pt.x = one.x * (floattov16(1.0f) - cFrac) + two.x * cFrac;
<br/>
pt.y = one.y * (floattov16(1.0f) - cFrac) + two.y * cFrac;
<br/>
pt.z = one.z * (floattov16(1.0f) - cFrac) + two.z * cFrac;
<br/>
</td> </tr></table><span class="postbody">
<br/>
The model animates fine when I don't interpolate  (albeit jerkily as it should).
<br/>
Can anyone see what I'm doing wrong?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161317 - Sausage Boy - Fri Aug 01, 2008 2:38 am</h4>
    <div class="postbody"><span class="postbody">I'm a bit tired, but I think your problem lies with the fixed point multiplication.  Basically, you need to right-shift your answer by 12 (I think). Think about what would happen if you tried to calculate 1*1 in fixed point. You might need to cast to bigger containers to keep from overflowing as well.
<br/>
<br/>
You probably won't be able to use my advice right away, but I hope it can be a starting point for information-searching and experimenting.<br/>_________________<br/>"no offense, but this is the gayest game ever"</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161318 - 3dfx - Fri Aug 01, 2008 2:52 am</h4>
    <div class="postbody"><span class="postbody">Well your advice worked perfectly! :D
<br/>
The bitshift worked, and now I'll remember to it. :)
<br/>
I shoulda known 1*1 = (1&lt;&lt;12)*(1&lt;&lt;12) in 4.12 fixed point, just not used to dealing with fixed points I guess.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161319 - DensitY - Fri Aug 01, 2008 2:56 am</h4>
    <div class="postbody"><span class="postbody">easiest way to think of it is this
<br/>
<br/>
say you have 
<br/>
16.16 fixed point number and an interger
<br/>
<br/>
multiplying a fixed number by a standard number results in a fixed point result, multipling a fixed number by another fixed number gives you a fixed point result but with double the precision range.
<br/>
<br/>
for example
<br/>
<br/>
16.16 = 16.16 * int
<br/>
16.32 = 16.16 * 16.16 
<br/>
<br/>
if you want the fixed * int to be back to int you do
<br/>
int = (16. 16 * int) &gt;&gt; 16
<br/>
<br/>
if you want the fixed * fixed to be 16.16 you do
<br/>
16.16 = (16.16 * 16.16) &gt;&gt; 16
<br/>
<br/>
follow?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161323 - silent_code - Fri Aug 01, 2008 9:57 am</h4>
    <div class="postbody"><span class="postbody">You might also want to use the hardware divider.
<br/>
IIrc, the function was "divf32()" or atleast something along the lines.<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161334 - naleksiev - Fri Aug 01, 2008 6:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>silent_code wrote:</b></span></td> </tr> <tr> <td class="quote">You might also want to use the hardware divider.
<br/>
IIrc, the function was "divf32()" or atleast something along the lines.</td> </tr></table><span class="postbody">
<br/>
<br/>
From what I remember when I profiled it, hardware division was about 5-10 times faster than normal division</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161335 - Maxxie - Fri Aug 01, 2008 6:47 pm</h4>
    <div class="postbody"><span class="postbody">There is no need for a division here, if you divide by (semi) constant data:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
float fraction =  (model-&gt;timeStep - (float)(start - model-&gt;begin) / (float)(model-&gt;end - model-&gt;begin + 1)) * (model-&gt;end - model-&gt;begin + 1); 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Just precalculate the inverse of the divisor (Either in your code when model-&gt;end/begin changes or even when creating the model itself), and store it with the model data. Every time you need to do the division, you can just multiply with that value, which is much faster on the arm.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161360 - 3dfx - Fri Aug 01, 2008 11:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>naleksiev wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>silent_code wrote:</b></span></td> </tr> <tr> <td class="quote">You might also want to use the hardware divider.
<br/>
IIrc, the function was "divf32()" or atleast something along the lines.</td> </tr></table><span class="postbody">
<br/>
<br/>
From what I remember when I profiled it, hardware division was about 5-10 times faster than normal division</span></td> </tr></table><span class="postbody">
<br/>
The f32 is fixed 32 right? Just wanna make sure.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
ust precalculate the inverse of the divisor (Either in your code when model-&gt;end/begin changes or even when creating the model itself), and store it with the model data. Every time you need to do the division, you can just multiply with that value, which is much faster on the arm.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I'm actually doing that right now but posted it so for clarity's sake.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
