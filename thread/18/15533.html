<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Plotting pixels in Mode 0, How to? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Plotting pixels in Mode 0, How to?</h2>
<div id="posts">
<div class="post">
    <h4>#156772 - Polaris - Tue May 13, 2008 9:54 pm</h4>
    <div class="postbody"><span class="postbody">Here is my current code to accomplish this task, it doesn't work. I'm omitting stuff as Vram bank set up, to make it as short as possible.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define TOTALCOLS 32
<br/>
#define PIXELSPERTILE 64
<br/>
u16 *bg0MapMemory;
<br/>
u16 *bg0TileData;
<br/>
<br/>
void initBackgrounds() {
<br/>
   bg0MapMemory =(u16*)BG_MAP_RAM(31);
<br/>
   bg0TileData =(u16*)BG_TILE_RAM(0);
<br/>
<br/>
   BACKGROUND.control[0] = BG_32x32 | BG_COLOR_16 | BG_MAP_BASE(31) | BG_TILE_BASE(0) | BG_PRIORITY(0);
<br/>
      
<br/>
   BG_PALETTE[1] = RGB15(0,31,0);
<br/>
   
<br/>
//This gives each tile an idividual value.
<br/>
   int row,col; 
<br/>
   int tileIndex = 0; 
<br/>
   for (row=0; row&lt;32; row++) { 
<br/>
      for (col=0; col&lt;32; col++) { 
<br/>
         bg0MapMemory[row*32 + col] = tileIndex;
<br/>
         tileIndex++; 
<br/>
      } 
<br/>
   }
<br/>
}
<br/>
void plotPixels(int screenPosX, int screenPosY, unsigned short int color)
<br/>
{
<br/>
   int tileX,tileY,interiorX,interiorY,pixelNumber,myIndex,myPixel; 
<br/>
<br/>
   tileX = screenPosX/8; // figure out the "column" we're writing to 
<br/>
   tileY = screenPosY/8; // figure out the "row" 
<br/>
   interiorX = screenPosX - tileX*8; // figure our X offset within the tile 
<br/>
   interiorY = screenPosY - tileY*8; // figure our Y offset withing the tile 
<br/>
<br/>
   // this next bit calculates the pixel "index" as if the tileData 
<br/>
   // were a u4 array 
<br/>
   pixelNumber = (tileY*(TOTALCOLS*PIXELSPERTILE) + tileX*PIXELSPERTILE) + ((interiorY*8) + interiorX); 
<br/>
<br/>
   // divide by 4 to get the u16 index 
<br/>
   // (remember that this u16 contains 4 pixels worth of data) 
<br/>
   myIndex = pixelNumber/4; 
<br/>
<br/>
   // remember which of the 4 pixels we're trying to write to 
<br/>
   myPixel = pixelNumber - myIndex*4; 
<br/>
<br/>
   // pull a copy of the "original" color, since we need to change 
<br/>
   // only one 4-bit section of the thing 
<br/>
   u16 originalColor = bg0TileData[myIndex];
<br/>
<br/>
   // do some bit math to mask out our pixel and then add it to 
<br/>
   // our new color to set just that one pixel 
<br/>
   if (myPixel==0) { 
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0xFFF0) + color; 
<br/>
   } else if (myPixel==1) { 
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0xFF0F) + color&lt;&lt;4; 
<br/>
   } else if (myPixel==2) { 
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0xF0FF) + color&lt;&lt;8;
<br/>
   } else if (myPixel==3) { 
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0x0FFF) + color&lt;&lt;12; 
<br/>
            }
<br/>
}
<br/>
int main() {
<br/>
    initBackgrounds(); 
<br/>
<br/>
//Everthing bellow is a really really crud way of plotting many pixels :P
<br/>
   int bla = 0;
<br/>
   int delay = 100000;
<br/>
<br/>
   while(1){
<br/>
      if(bla &lt; 1024){
<br/>
         if(delay &gt; 0){
<br/>
            delay--;
<br/>
         }
<br/>
         else{
<br/>
            delay = 100000;
<br/>
            plotPixels(bla, 0, RGB15(0,31,0));
<br/>
            bla++;
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
<br/>
    return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I found this digging on the forums in the following thread
<br/>
<a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=7160&amp;highlight=plotting+pixels+mode" target="_blank">http://forum.gbadev.org/viewtopic.php?t=7160&amp;highlight=plotting+pixels+mode</a>.
<br/>
There the original poster said it was incomplete code, but I took it any way to see if I could complete it. Turns out it's a bit tougher than expected.
<br/>
<br/>
Anyone familiar with this, probably already knows that the main problem with this approach is saving the actual pixel you want, because writes into VRAM are only 16 bit and pixels are 4 bit, so you end up taking 4 pixels at a time. 
<br/>
It took me a little while, but I realised this particular part is not right, because myPixel always ends up as 0.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   // divide by 4 to get the u16 index 
<br/>
   // (remember that this u16 contains 4 pixels worth of data) 
<br/>
 myIndex = pixelNumber/4; 
<br/>
<br/>
   // remember which of the 4 pixels we're trying to write to 
<br/>
   myPixel = pixelNumber - myIndex*4</td> </tr></table><span class="postbody">
<br/>
Any ideas as to what I should do in order to tell into which one of the four pixels I should be writting in?
<br/>
<br/>
The other thing I don't yet understand fully is the bit masking part.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">bg0TileData[myIndex] = (originalColor &amp; 0xFFF0) + color;
<br/>
</td> </tr></table><span class="postbody">
<br/>
I do understand that &amp; 0xFFF0 clears the lowers bits, which is exactly what I want.
<br/>
What I don't get that much is the part where the color is added. Shouln't I be doing something like
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">bg0TileData[myIndex] = (originalColor &amp; 0xFFF0);
<br/>
bg0TileData[myIndex] |= color;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
To my understanding that should set the apropiate bits. But my understanding is not very reliable, so some help would be apreciated.
<br/>
<br/>
I'll leave it at that for now.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156774 - TwentySeven - Tue May 13, 2008 10:15 pm</h4>
    <div class="postbody"><span class="postbody">re: the color thing, if color &gt; 0xF  the + and | are going to have the same result.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156780 - Maxxie - Tue May 13, 2008 10:44 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Polaris wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   // divide by 4 to get the u16 index 
<br/>
   // (remember that this u16 contains 4 pixels worth of data) 
<br/>
 myIndex = pixelNumber/4; 
<br/>
<br/>
   // remember which of the 4 pixels we're trying to write to 
<br/>
   myPixel = pixelNumber - myIndex*4</td> </tr></table><span class="postbody">
<br/>
Any ideas as to what I should do in order to tell into which one of the four pixels I should be writting in?</span></td> </tr></table><span class="postbody">
<br/>
<br/>
This should work if it is executed this way, however i am not sure if the /4 and the later use of *4 gets optimized away so that for the later instruction the original pixelNumber value is used rather then (pixelNumber / 4) * 4.
<br/>
<br/>
To avoid this, you can set 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
myIndex = (pixelNumber &gt;&gt; 2) ; // using all but the lower two bits for addressing the pixel's u16
<br/>
myPixel = pixelNumber &amp; 3 ; // using the lower two bits to index the pixel within it's u16
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156833 - Polaris - Wed May 14, 2008 3:44 pm</h4>
    <div class="postbody"><span class="postbody">Thanks guys, it now works. Next time I read something does exactly the same as something else, programatically, I might stab myself. The description should always be "Very Similar".
<br/>
<br/>
I'm talking about stuff like a pointer being the same as a constant array or even more on topic, shifting bits being the same as multiplying or dividing. I'm sure in 99% of the cases it really is up to the user, but not always.
<br/>
<br/>
Anyway back on topic, cause there is still something that's puzzling me. 
<br/>
<br/>
If you see my code again, this part particularly
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">BG_PALETTE[1] = RGB15(0,31,0);</td> </tr></table><span class="postbody">
<br/>
There I set up the second Index as color green and that is fine. What I don't understand is what is going on when I tell a certain pixel to be of a certain color.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">plotPixels(0, 0, RGB15(1,0,0));
<br/>
</td> </tr></table><span class="postbody">
<br/>
If I call my plotPixels fuction with those parameters, the pixel is plotted just fine. Which is a bit strange since not only it is not the maximum value, it's the wrong channel!
<br/>
<br/>
The question would be, how do I properly use any given palette when plotting pixels individually?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156834 - Maxxie - Wed May 14, 2008 3:51 pm</h4>
    <div class="postbody"><span class="postbody">Your plotPixels is taking a palette index (in the range of 0-15), not the RGB value as color 
<br/>
<br/>
BG_PALETTE[num] = RGB15(r,g,b) ;
<br/>
plotPixels(x,y,num)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156835 - Polaris - Wed May 14, 2008 4:06 pm</h4>
    <div class="postbody"><span class="postbody">I guess that's what I get for copying and pasting :P
<br/>
<br/>
Thanks!
<br/>
<br/>
Edit:
<br/>
<br/>
Still at this. Recently I got working some code to plot a circle, it was pretty easy seeing as how there is tons of source code waiting to be used.
<br/>
<br/>
Now I'm working on implementing a flood fill algo, and it seems all I have left to do is figure out a way to get the color of a pixel, in order to be able to check if it is already painted or not.
<br/>
<br/>
So back on topic, I figured that to do this I would need to make a function that does pretty much the same as the one on my first post, but instead of setting values I would need to return them. That last part I'm not quite getting. 
<br/>
<br/>
What should I be doing to return those 4-bits representing the color of the pixel? I'm guessing I need to do some bit shifting with the u16 that contains the pixel I want to get, but since I'm very new to bitwise operations I still can't tell for sure what is that I have to do.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#156925 - Polaris - Fri May 16, 2008 6:26 am</h4>
    <div class="postbody"><span class="postbody">Figured this out on my own. If anyone finds it usefull, the following code works to find out the palette index of a pixel, in a tiled background using a 16 color palette.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 getPixelColor(int screenPosX, int screenPosY)
<br/>
{
<br/>
   int tileX,tileY,interiorX,interiorY,pixelNumber,myIndex,myPixel; 
<br/>
<br/>
   tileX = screenPosX/8;
<br/>
   tileY = screenPosY/8; 
<br/>
   interiorX = screenPosX - tileX*8;
<br/>
   interiorY = screenPosY - tileY*8;
<br/>
<br/>
   pixelNumber = (tileY*(TOTALCOLS*PIXELSPERTILE) + tileX*PIXELSPERTILE) + ((interiorY*8) + interiorX); 
<br/>
<br/>
   myIndex = pixelNumber&gt;&gt;2;  
<br/>
   myPixel = pixelNumber &amp; 3;
<br/>
<br/>
   u16 pixelColor = bg0TileData[myIndex];
<br/>
<br/>
   if (myPixel==0) { 
<br/>
      pixelColor &amp;= 0x000F;
<br/>
      return pixelColor;
<br/>
   } else if (myPixel==1) { 
<br/>
      pixelColor &amp;= 0x00F0;
<br/>
      return pixelColor&gt;&gt;4;
<br/>
   } else if (myPixel==2) { 
<br/>
      pixelColor &amp;= 0x0F00;
<br/>
      return pixelColor&gt;&gt;8;
<br/>
   } else if (myPixel==3) { 
<br/>
      pixelColor &amp;= 0xF000;
<br/>
      return pixelColor&gt;&gt;12;
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
<br/>
It's largely the same as setting a pixel color, only the AND's clear different parts of the u16 and the shifts go the other way.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157195 - Polaris - Tue May 20, 2008 7:16 am</h4>
    <div class="postbody"><span class="postbody">Can anyone with better math skills than I, tell me how many Tile and Map bases is this technique to plot pixels using.
<br/>
<br/>
I was looking into setting up a back buffer in order to eliminate any flickering when doing lots of pixel drawing. 
<br/>
<br/>
Only when I went to change the background settings to make enough room for the back buffer, did I realize how many different tiles I was using. 
<br/>
<br/>
32*32 looks like a lot of tiles. I still don't have a firm grasp when it comes setting up Tile and Map bases, but it seems like this is using up more than the regular 1 or 2 that can be found in many examples.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157230 - Cydrak - Tue May 20, 2008 8:07 pm</h4>
    <div class="postbody"><span class="postbody">1 tile * 4 bits/px
<br/>
= 8px * 8px * 4 bits/px
<br/>
= 64px * 4 bits/px
<br/>
= 256 bits = 32 bytes
<br/>
<br/>
giving 1 4-bit tile = 32 bytes.
<br/>
<br/>
Multiply by 32*32 and you get 1024 4-bit tiles = 32 KB. This is the max for one layer. Remember the screens are only 32*24 tiles, though, so you can use the remainder for maps, etc.
<br/>
<br/>
Meanwhile, 1 "tile base" = 16 KB (512 4-bit tiles). Therefore you'll need to separate your buffers by 2 units. You can easily fit four of them in one of A..D, two buffers in bank E, or one in bank H.
<br/>
<br/>
You might find all the bitshifting to be a little slow. If it becomes a problem, think how you can work with the VRAM limitation, rather than against it. (Drawing big solid regions? 32 bits hold 8 pixels, a whole tile row...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157241 - Polaris - Tue May 20, 2008 11:53 pm</h4>
    <div class="postbody"><span class="postbody">At last, success! Everything is ready to make a nice particle system with out the need of wasting precious sprites!
<br/>
<br/>
Oh and thanks for the clarification Cydrak, things look slightly less shady now :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157312 - Cearn - Wed May 21, 2008 10:48 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Polaris wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void plotPixels(int screenPosX, int screenPosY, unsigned short int color)
<br/>
{
<br/>
   int tileX,tileY,interiorX,interiorY,pixelNumber,myIndex,myPixel;
<br/>
<br/>
   tileX = screenPosX/8; // figure out the "column" we're writing to
<br/>
   tileY = screenPosY/8; // figure out the "row"
<br/>
   interiorX = screenPosX - tileX*8; // figure our X offset within the tile
<br/>
   interiorY = screenPosY - tileY*8; // figure our Y offset withing the tile
<br/>
<br/>
   // this next bit calculates the pixel "index" as if the tileData
<br/>
   // were a u4 array
<br/>
   pixelNumber = (tileY*(TOTALCOLS*PIXELSPERTILE) + tileX*PIXELSPERTILE) + ((interiorY*8) + interiorX);
<br/>
<br/>
   // divide by 4 to get the u16 index
<br/>
   // (remember that this u16 contains 4 pixels worth of data)
<br/>
   myIndex = pixelNumber/4;
<br/>
<br/>
   // remember which of the 4 pixels we're trying to write to
<br/>
   myPixel = pixelNumber - myIndex*4;
<br/>
<br/>
   // pull a copy of the "original" color, since we need to change
<br/>
   // only one 4-bit section of the thing
<br/>
   u16 originalColor = bg0TileData[myIndex];
<br/>
<br/>
   // do some bit math to mask out our pixel and then add it to
<br/>
   // our new color to set just that one pixel
<br/>
   if (myPixel==0) {
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0xFFF0) + color;
<br/>
   } else if (myPixel==1) {
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0xFF0F) + color&lt;&lt;4;
<br/>
   } else if (myPixel==2) {
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0xF0FF) + color&lt;&lt;8;
<br/>
   } else if (myPixel==3) {
<br/>
      bg0TileData[myIndex] = (originalColor &amp; 0x0FFF) + color&lt;&lt;12;
<br/>
            }
<br/>
} </td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
There are a number of ways to both shorter and speed up this function. First, you have a if/else block where the clauses are identical except for some number, there's usually an arithmetical solution. In this case, what you really need is the shift of the nybble you need to update, which is simply x%8*4 (by the way x-x/a*a is essentially the definition of x%a). Then you follow the normal procedure of inserting a bitfield:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// Inserting a 4-bit value into data.
<br/>
u32 shift= x%8*4, mask= 15&lt;&lt;shift;
<br/>
data = (data &amp;~ mask ) | ((value&amp;mask)&lt;&lt;shift);
<br/>
</td> </tr></table><span class="postbody">
<br/>
As Cydrak mentioned, 8 pixels of 4-bit data fits nicely into a 32-bit word. This means you don't have to figure out which halfword the pixel belongs in. This also makes finding the address you need to access a little easier. In the y-direction, you can simply use y%8 for the internal word; y/8 you'll need to multiply with the number of words in a row of tiles, which is works out to be the width of the surface (#bytes per tilerow = <span style="font-style: italic">width</span>*<span style="font-style: italic">bpp</span>/8*8 =<span style="font-style: italic">width</span>*4 bytes = <span style="font-style: italic">width</span> words).
<br/>
The routine then becomes:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u32 *bg0TileData;
<br/>
<br/>
//! Plot a pixel on a 4bpp tiled surface.
<br/>
void chr4r_plot(unsigned int x, unsigned int y, u16 color)
<br/>
{
<br/>
   u32 *dst= &amp;bg0TileData[y/8*SCREEN_WIDTH + y%8 + x/8];
<br/>
   u32 shift= x%8*4;
<br/>
<br/>
   *dst = (*dst &amp;~ 15&lt;&lt;shift) | (color&amp;15)&lt;&lt;shift;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
And yes, the multiplies, divisions and modulos will be optimized to shifts and ANDs. Mostly anyway. Since for negative numbers division and shifts give different answers, using signed numbers would use extra code. Hence the unsigned types for <span style="font-style: italic">x</span> and <span style="font-style: italic">y</span>.
<br/>
<br/>
There's also an alternative tile-rendering mode that's actually better. Right now the tiles are ordered in row-major order, i.e., tile 1 is to the right of tile 0. In column-major order tile 1 is under tile 0, meaning that the words of a column of tiles are all adjacent. This eliminates the need for splitting the <span style="font-style: italic">y</span> coordinate.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Row major:
<br/>
   __________________
<br/>
  |00 01 02 ..    31 |
<br/>
  |32 33 ..          |
<br/>
  |64                |
<br/>
  | :                |
<br/>
  | _________________|
<br/>
<br/>
Colum major:
<br/>
   __________________
<br/>
  |00 32 64 ..       |
<br/>
  |01 33 ..          |
<br/>
  |02                |
<br/>
  | :                |
<br/>
  |__________________|
<br/>
</td> </tr></table><span class="postbody">
<br/>
This will require some changes in the rendering functions and 
<br/>
map initialization:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u32 *bg0TileData;
<br/>
<br/>
//! Plot a pixel on a 4bpp tiled surface, column-major.
<br/>
void chr4c_plot(unsigned int x, unsigned int y, u16 color)
<br/>
{
<br/>
   u32 *dst= &amp;bg0TileData[y+ x/8*SCREEN_HEIGHT];
<br/>
   u32 shift= x%8*4;
<br/>
<br/>
   *dst = (*dst &amp;~ 15&lt;&lt;shift) | (color&amp;15)&lt;&lt;shift;
<br/>
}
<br/>
<br/>
//! Prepare map for column-major tile rendering, 
<br/>
//!     with a base offset for palswapping/offset tile.
<br/>
void chr4c_prep_map(u16 *map, u32 base)
<br/>
{
<br/>
   u32 ix, iy, entry= base;
<br/>
<br/>
   // Note the order of the loops!
<br/>
   for(ix=0; ix&lt;32; ix++)
<br/>
      for(iy=0; iy&lt;32; iy++)
<br/>
         map[iy*32+ix]= entry++;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
I've recently added a few rendering functions to tonclib for this kind of graphics, including drawing pixels, lines, rectangles and a blitter. If you want to take a look, start <a class="postlink" href="http://www.coranac.com/2008/05/14/surface-drawing-routines/" target="_blank">here</a>.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157322 - Polaris - Thu May 22, 2008 12:05 am</h4>
    <div class="postbody"><span class="postbody">The method looked kinda clunky but it looked like an ok solution, to atleast see some stuff on screen, while I learned more on bitwise operations.
<br/>
<br/>
Thanks to you, I can concentrate in more joyful things. Thanks!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
