<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>DSWifi *Raw* functions? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > DSWifi *Raw* functions?</h2>
<div id="posts">
<div class="post">
    <h4>#166220 - Pete_Lockwood - Mon Feb 02, 2009 11:57 am</h4>
    <div class="postbody"><span class="postbody">Has anyone successfully used the *Raw* functions in the DSWifi library to run comms directly between two DS units?
<br/>
<br/>
I've been amazed to find that almost all discussion of DSWifi seems to be centered on getting the DS attached to a full-on network using an access point.  There seems to be very little discussion on using it to have multiple DSes connect directly to each other without going through an access point.
<br/>
<br/>
I need to connect multiple DSes together specifically without using an access point but it appears about the closest someone has come is libLobby (?) and from what I gather this isn't considered stable and isn't up to date with the latest libNds anyway.
<br/>
<br/>
Are the *Raw* functions the way to go with this?<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166223 - elhobbs - Mon Feb 02, 2009 2:22 pm</h4>
    <div class="postbody"><span class="postbody">when I tried raw mode all I ever was able to receive was beacons and other management packets. I think there are some pieces missing from dswifi to fully enable this for direct ds to ds communication. on the plus side I think that sgstair may have resumed work on dswifi with one of the goals being ds to ds direct connections.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166248 - sgstair - Tue Feb 03, 2009 9:40 am</h4>
    <div class="postbody"><span class="postbody">Hi Pete,
<br/>
<br/>
The situation is still pretty complicated :)
<br/>
When I originally figured out the wifi hardware, I didn't try too hard to figure it all out after I got the "important" stuff working (connecting to access points, etc) - so while the ds wifi lib has somewhat support ad-hoc, I haven't actually ever got it to work.
<br/>
I do expect this to change though; I'm currently working on reverse engineering the hardware again, more completely this time - and I expect to have everything fully working after this.
<br/>
That's not to say it will be any time soon; I've got quite a bit of work ahead of me, so it could be several months. But I do intend to get it done as soon as I can.
<br/>
<br/>
-Stephen<br/>_________________<br/><a class="postlink" href="http://blog.akkit.org/" target="_blank">http://blog.akkit.org/</a> - <a class="postlink" href="http://www.akkit.org/dswifi/" target="_blank">http://www.akkit.org/dswifi/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166254 - Pete_Lockwood - Tue Feb 03, 2009 12:16 pm</h4>
    <div class="postbody"><span class="postbody">Thanks, I appreciate your taking the time to post.
<br/>
<br/>
Just a thought but..  Could it be easier for someone to disassemble the code from a piece of software that already supports ad-hoc and get the answers that way rather than attacking the hardware?<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166274 - sgstair - Tue Feb 03, 2009 6:39 pm</h4>
    <div class="postbody"><span class="postbody">As strange as it may seem, -nothing- on the DS has ever supported ad-hoc. I'm sure it can be done, but it requires figuring out hardware that isn't ever used for that purpose.
<br/>
And the official local multiplayer actually sets up one of the DSes as an access point; which is also pretty complicated.
<br/>
<br/>
-Stephen<br/>_________________<br/><a class="postlink" href="http://blog.akkit.org/" target="_blank">http://blog.akkit.org/</a> - <a class="postlink" href="http://www.akkit.org/dswifi/" target="_blank">http://www.akkit.org/dswifi/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166283 - Pete_Lockwood - Tue Feb 03, 2009 7:59 pm</h4>
    <div class="postbody"><span class="postbody">Yowza.  Really?
<br/>
<br/>
Would you be able to guess whether your existing lib exposes enough to act as a soft access point?<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166297 - sgstair - Wed Feb 04, 2009 4:47 am</h4>
    <div class="postbody"><span class="postbody">Yes really, everything done on DS so far is infrastructure mode.
<br/>
I'm sure it's capable of adhoc, just haven't worked out the filtering mechanism yet.
<br/>
<br/>
No, the API does not expose nearly enough to run as a soft-ap. The documentation contains barely enough to do so, but I wouldn't expect anyone to work it out from that :)
<br/>
<br/>
Next lib will definitely make it easy though.
<br/>
<br/>
-Stephen<br/>_________________<br/><a class="postlink" href="http://blog.akkit.org/" target="_blank">http://blog.akkit.org/</a> - <a class="postlink" href="http://www.akkit.org/dswifi/" target="_blank">http://www.akkit.org/dswifi/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167012 - Pete_Lockwood - Thu Feb 26, 2009 4:13 pm</h4>
    <div class="postbody"><span class="postbody">Is there any technical reason preventing me hacking up the existing ARM7 and ARM9 code to bypass the AP and just send/read packets directly?  
<br/>
<br/>
Presumably the wireless chip can't/won't stop me doing that and there's enough info in the existing DSWifi library to drive the chip?<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167014 - elhobbs - Thu Feb 26, 2009 4:27 pm</h4>
    <div class="postbody"><span class="postbody">nope, nothing to stop you. you just need to figure out the correct sequence/values to write to the wifi registers to allow the packets to be sent and recieved. easy as pie ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167017 - Pete_Lockwood - Thu Feb 26, 2009 5:17 pm</h4>
    <div class="postbody"><span class="postbody">Shouldn't be *that* hard given SG's code already does it :)
<br/>
<br/>
If I'm only talking my own protocol to other DSes presumably I don't need to care about the proper 802.11 or networking rules.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167020 - elhobbs - Thu Feb 26, 2009 5:34 pm</h4>
    <div class="postbody"><span class="postbody">I wish you the best of luck. I was not able to get the receiving ds to see any of my packets. my wireless card on my computer can not do promiscuous mode, so I could not even tell if my ds was sending any packets! you need to set the send and receive filters (plus more I would guess) to allow the hardware to send and recieve.
<br/>
<br/>
just turning on promiscuous mode on the receiving ds does not allow it to see anything but management packets. I could not figure out how to get it to see anything else. I even tried setting the receive filters to the same as in liblobby with no luck.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167021 - Maxxie - Thu Feb 26, 2009 5:37 pm</h4>
    <div class="postbody"><span class="postbody">If you got a ralink, it works great for communicating ds&lt;-&gt;pc or minitoring two DS communicating.
<br/>
<br/>
Even if liblobby has massive flaws on the flowcontrol, take a look at it's sending/receiving part of the source. It can actually do this without an STA (AP)<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167024 - Pete_Lockwood - Thu Feb 26, 2009 7:24 pm</h4>
    <div class="postbody"><span class="postbody">The receive filters are in the hardware?<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167026 - Maxxie - Thu Feb 26, 2009 9:27 pm</h4>
    <div class="postbody"><span class="postbody">Yes.
<br/>
There are flags to skip receiving on various filters.
<br/>
<br/>
Shortly before Martin (no$cash) went MIA he used a busy checking system to capture the skipped and even invalid packets on the DS. They are written into the mem even if ignored later on.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167296 - Pete_Lockwood - Sun Mar 08, 2009 2:16 pm</h4>
    <div class="postbody"><span class="postbody">Finally found some time to play with this.  Looks like receiving works using the stock DSWifi library, which is kinda interesting as I'd assumed receiving would be troublesome and sending would be easy.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167309 - Pete_Lockwood - Sun Mar 08, 2009 6:58 pm</h4>
    <div class="postbody"><span class="postbody">Got send working too :)
<br/>
<br/>
Still need to work out *why* it works where the default DSWifi code doesn't and tidy things up but looks good.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167461 - yellowstar - Thu Mar 12, 2009 7:56 pm</h4>
    <div class="postbody"><span class="postbody">How are you sending raw packets with Dswifi, Pete? I attempted raw packet sending /w Dswifi when you posted about success with this, but my incomplete WMB Host/Client adapted for Dswifi didn't send any packets.(I tried capturing the beacons on channel 11, but no WMB beacons were being sent; I'm calling Wifi_SetChannel(11).) I'm using Wifi_InitDefault(0), and Wifi_ScanMode(). Removing the latter doesn't help. For sending, I'm using Wifi_RawTxFrame. I tried both data rates of 2 and 11, but neither sends anything.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167465 - Pete_Lockwood - Thu Mar 12, 2009 11:15 pm</h4>
    <div class="postbody"><span class="postbody">I rewrote Wifi_RawTxFrame using Wifi_TransmitFunction as a template.  I'm also, currently, as a hack, calling LWIFI_Init after Wifi_Init.  This weekend I plan to work out what it is about LWIFI_Init that's different to Wifi_Init with the intention of merging the appropriate differences back into Wifi_Init.
<br/>
<br/>
Yes, I said LWIFI_Init :D  I just figured since Lobby is able to transmit there'd be no reason DSWifi wouldn't be able to too.
<br/>
<br/>
If you wanna PM me your email address I can send you what I have now (incl. a small test app) or you can wait and I'll post back when I've sorted out proper integration of the Init functions.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167467 - yellowstar - Thu Mar 12, 2009 11:35 pm</h4>
    <div class="postbody"><span class="postbody">I can wait; this wmb client/host isn't really a priority currently. Previously, this WMB host/client used to use liblobby, but the host had issues. Sending the pings in a infinite while loop like Juglak's WMB Host caused my host to freeze, and sending the pings in the vblank handler caused the client to time out.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167471 - Pete_Lockwood - Fri Mar 13, 2009 3:16 am</h4>
    <div class="postbody"><span class="postbody">OK..  I'm somewhat confused.  I went back through the Init code and couldn't see a difference that appeared relevant so I started pulling out the Lobby Wifi Init code I'd inserted into DSWifi.  Long story short it seems that the only thing needed to get the Raw send working is the rewrite of Wifi_RawTxFrame.
<br/>
<br/>
Any chance someone can confirm I'm not going insane?  If so, the rewritten function is as follows:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int Wifi_RawTxFrame(u16 datalen, u16 rate, u16 * data) {
<br/>
    int base,framelen, hdrlen, writelen;
<br/>
    int copytotal, copyexpect;
<br/>
   u16 framehdr[6 + 12 + 2];
<br/>
    framelen=datalen + 8 + (WifiData-&gt;wepmode7 ? 4 : 0);
<br/>
<br/>
   if(framelen + 40&gt;Wifi_TxBufferWordsAvailable()*2) { // error, can't send this much!
<br/>
      SGIP_DEBUG_MESSAGE(("Transmit:err_space"));
<br/>
      return -1; //?
<br/>
   }
<br/>
   
<br/>
   framehdr[0]=0;
<br/>
   framehdr[1]=0;
<br/>
   framehdr[2]=0;
<br/>
   framehdr[3]=0;
<br/>
   framehdr[4]=0; // rate, will be filled in by the arm7.
<br/>
   hdrlen=18;
<br/>
   framehdr[6]=0x0208;
<br/>
   framehdr[7]=0;
<br/>
<br/>
   // MACs.
<br/>
   memset(framehdr + 8, 0xFF, 18);
<br/>
<br/>
   if(WifiData-&gt;wepmode7)
<br/>
   {
<br/>
      framehdr[6] |=0x4000;
<br/>
      hdrlen=20;
<br/>
   }
<br/>
   framehdr[17] = 0;
<br/>
   framehdr[18] = 0; // wep IV, will be filled in if needed on the arm7 side.
<br/>
   framehdr[19] = 0;
<br/>
<br/>
    framehdr[5]=framelen+hdrlen * 2 - 12 + 4;
<br/>
    copyexpect= ((framelen+hdrlen * 2 - 12 + 4) + 12 - 4 + 1)/2;
<br/>
    copytotal=0;
<br/>
<br/>
   WifiData-&gt;stats[WSTAT_TXQUEUEDPACKETS]++;
<br/>
   WifiData-&gt;stats[WSTAT_TXQUEUEDBYTES] += framelen + hdrlen * 2;
<br/>
<br/>
   base = WifiData-&gt;txbufOut;
<br/>
   Wifi_TxBufferWrite(base,hdrlen,framehdr);
<br/>
   base += hdrlen;
<br/>
    copytotal += hdrlen;
<br/>
   if(base &gt;= (WIFI_TXBUFFER_SIZE / 2)) base -= WIFI_TXBUFFER_SIZE / 2;
<br/>
<br/>
   // add LLC header
<br/>
   framehdr[0]=0xAAAA;
<br/>
   framehdr[1]=0x0003;
<br/>
   framehdr[2]=0x0000;
<br/>
   unsigned short protocol = 0x08FE;
<br/>
   framehdr[3] = ((protocol &gt;&gt; 8) &amp; 0xFF) | ((protocol &lt;&lt; 8) &amp; 0xFF00);
<br/>
<br/>
   Wifi_TxBufferWrite(base, 4, framehdr);
<br/>
   base += 4;
<br/>
    copytotal += 4;
<br/>
   if(base&gt;=(WIFI_TXBUFFER_SIZE/2)) base -= WIFI_TXBUFFER_SIZE/2;
<br/>
<br/>
   writelen = datalen;
<br/>
   if(writelen) {
<br/>
      Wifi_TxBufferWrite(base,(writelen+1)/2,data);
<br/>
      base += (writelen + 1) / 2;
<br/>
        copytotal += (writelen + 1) / 2;
<br/>
      if(base&gt;=(WIFI_TXBUFFER_SIZE/2)) base -= WIFI_TXBUFFER_SIZE/2;
<br/>
   }
<br/>
    if(WifiData-&gt;wepmode7)
<br/>
   { // add required extra bytes
<br/>
        base += 2;
<br/>
        copytotal += 2;
<br/>
        if(base &gt;= (WIFI_TXBUFFER_SIZE / 2)) base -= WIFI_TXBUFFER_SIZE / 2;
<br/>
    }
<br/>
   WifiData-&gt;txbufOut = base; // update fifo out pos, done sending packet.
<br/>
<br/>
    if(copytotal!=copyexpect)
<br/>
   {
<br/>
        SGIP_DEBUG_MESSAGE(("Tx exp:%i que:%i",copyexpect,copytotal));
<br/>
    }
<br/>
    if(synchandler) synchandler();
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
My simple test app, which just sends 10 packets a second between a pair of DSes:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
#include &lt;dswifi9.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
<br/>
void Handler(int packetID, int readlength)
<br/>
{
<br/>
   static char data[4096];
<br/>
   static int bytesRead;
<br/>
<br/>
   bytesRead = Wifi_RxRawReadPacket(packetID, readlength, (unsigned short *)data);
<br/>
<br/>
   // Lazy test to see if this is our packet.
<br/>
   if(data[32] == '*' &amp;&amp; data[33] == '*')
<br/>
   {
<br/>
      iprintf("\x1b[1;0HRcv:%d ", atoi(data+59));
<br/>
   }
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   consoleDemoInit(); 
<br/>
<br/>
   Wifi_InitDefault(false);
<br/>
   Wifi_SetPromiscuousMode(1);
<br/>
   Wifi_EnableWifi();
<br/>
   Wifi_RawSetPacketHandler(Handler);
<br/>
   Wifi_SetChannel(10);
<br/>
<br/>
   iprintf("Touch screen to start");
<br/>
   touchPosition touch;
<br/>
   while(1)
<br/>
   {
<br/>
      scanKeys();
<br/>
      touchRead(&amp;touch);
<br/>
      int pressed = keysDown();
<br/>
      if(pressed &amp; KEY_TOUCH)
<br/>
         break;
<br/>
   }
<br/>
<br/>
   iprintf("\x1b[0;0H                      ");
<br/>
<br/>
   int send = 0;
<br/>
   int f;
<br/>
   unsigned short buffer[100];
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
      iprintf("\x1b[0;0HSending %d", send);
<br/>
      sprintf((char *)buffer,"***********-T-E-S-T-******:%d", send++);
<br/>
<br/>
      if(Wifi_RawTxFrame(strlen((char *)buffer) + 1, 0x0014, buffer) != 0)
<br/>
      {
<br/>
         iprintf("\n\nError calling RawTxFrame\n\n");
<br/>
      }
<br/>
<br/>
      for(f = 0 ; f &lt; 6 ; f++)
<br/>
         swiWaitForVBlank();
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167481 - sgstair - Fri Mar 13, 2009 4:46 pm</h4>
    <div class="postbody"><span class="postbody">This defeats the intent of that function.
<br/>
RawTxFrame always has been able to send raw frames, but it sends raw 802.11 frames, not raw ethernet-ish frames.
<br/>
<br/>
The difficulty has always been in actually receiving those frames at the other end.
<br/>
<br/>
I see what that's doing; it's clever but not correct for this type of communication. it sets the "from DS" bit in the 802.11 header, but the 802.11 standard states that should only happen when an AP is sending data to a client.
<br/>
<br/>
Apparently that would be the bit that the DS receive filter is set to filter on by default; so that's useful information. But this is not good for trying to make adhoc work (which should have a control word of 0x0008 rather than 0x0208)
<br/>
<br/>
-Stephen<br/>_________________<br/><a class="postlink" href="http://blog.akkit.org/" target="_blank">http://blog.akkit.org/</a> - <a class="postlink" href="http://www.akkit.org/dswifi/" target="_blank">http://www.akkit.org/dswifi/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167482 - elhobbs - Fri Mar 13, 2009 5:31 pm</h4>
    <div class="postbody"><span class="postbody">is this a good idea either?</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   // MACs. 
<br/>
   memset(framehdr + 8, 0xFF, 18); 
<br/>
</td> </tr></table><span class="postbody">wouldn't this make it impossible for multiple sessions to exists at the same time?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167487 - Pete_Lockwood - Fri Mar 13, 2009 7:14 pm</h4>
    <div class="postbody"><span class="postbody">If I can get a bunch of DSes communicating this way, which appears to be the case, I personally don't much mind what the 802.11 standard says I'm <span style="font-style: italic">supposed</span> to be doing.  Yes, it would be nice to do things properly but in the absence of properly I'll settle for workable.
<br/>
<br/>
'Sessions' can be handled by passing information in the data if the MAC can't be sent in the proper header format.
<br/>
<br/>
Using this approach I always expected I'd haveta handle stuff in my application that you'd usually get for free - but I don't have an AP available and I'm not willing to suffer the pain of LibLobby.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167491 - sgstair - Sat Mar 14, 2009 2:21 am</h4>
    <div class="postbody"><span class="postbody">Yet another reason why I really need to get this right for the next wifilib ;)
<br/>
can't have everyone going around sending non-standards-compliant traffic. You actually could interfere with legitimate wifi devices by doing this.<br/>_________________<br/><a class="postlink" href="http://blog.akkit.org/" target="_blank">http://blog.akkit.org/</a> - <a class="postlink" href="http://www.akkit.org/dswifi/" target="_blank">http://www.akkit.org/dswifi/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167492 - Pete_Lockwood - Sat Mar 14, 2009 2:37 am</h4>
    <div class="postbody"><span class="postbody">:D
<br/>
<br/>
When you do it right I'll be more than happy to make the switch.  For now, I'll trust that the very few packets my application will send aren't going to cause an international incident :D<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168304 - chebastian - Mon Apr 20, 2009 12:17 pm</h4>
    <div class="postbody"><span class="postbody">Bump.
<br/>
<br/>
Im realy interested in making an app where 2ds's are communicating with each other.
<br/>
<br/>
Any progress?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168305 - Pete_Lockwood - Mon Apr 20, 2009 1:19 pm</h4>
    <div class="postbody"><span class="postbody">I assume you're asking SGStair?<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168988 - dragontje124 - Mon Jun 08, 2009 5:44 pm</h4>
    <div class="postbody"><span class="postbody">any progress on this?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169079 - Emmanuel - Sat Jun 13, 2009 3:36 am</h4>
    <div class="postbody"><span class="postbody">Umm, talking about this. I have a slight problem. Having the DS on wifi mode is ok, nothing bad happens, but as soon as there is some sort of signal coming it starts draining the free memory in timed intervals. This timed intervals might be around the 10 secs, and the data is send once per loop. *having a wait for VBL at the end of the loop*
<br/>
This makes me believe it's the handler function.
<br/>
<br/>
Mine is
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void handler(int packetID, int readlength){
<br/>
   unsigned short * data = new unsigned short[DATA_LENGTH]; 
<br/>
   if(readlength &gt;= DATA_LENGTH){
<br/>
      readlength = DATA_LENGTH-1;
<br/>
   }
<br/>
   Wifi_RxRawReadPacket(packetID, readlength, data); 
<br/>
    
<br/>
   multiManage-&gt;cleanData();
<br/>
   strncpy(multiManage-&gt;receivedData, (char*)data+32, DATA_LENGTH-1);
<br/>
   multiManage-&gt;receivedData[DATA_LENGTH-1] = '\0';
<br/>
   multiManage-&gt;checkSSBCData();
<br/>
   memset(data, 0, DATA_LENGTH*2);
<br/>
   delete [] data;
<br/>
   data = NULL;
<br/>
   
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Clean data is simply
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void MultiManager::cleanData(){
<br/>
   memset(receivedData, 0, DATA_LENGTH);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
And checkSSBCData. It's used to convert the obtained data into the 
<br/>
format I'm using.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void MultiManager::checkSSBCData(){
<br/>
   if(   receivedData[0] == 'S' &amp;&amp;
<br/>
         receivedData[1] == 'S' &amp;&amp;
<br/>
         receivedData[2] == 'B' &amp;&amp;
<br/>
         receivedData[3] == 'C'){
<br/>
         
<br/>
      if(otherPlayer != NULL){
<br/>
         delete otherPlayer;
<br/>
         otherPlayer = NULL;
<br/>
      }
<br/>
      bool slash = false;
<br/>
      int counter = 0;
<br/>
      string data = "";
<br/>
      do{
<br/>
         if(receivedData[counter+4] != '/'){
<br/>
            data += receivedData[counter+4];
<br/>
            counter++;
<br/>
         }else{
<br/>
            slash = true;
<br/>
         }
<br/>
      }while(!slash);
<br/>
      int length = 0;
<br/>
      stringstream lengthStream;
<br/>
      lengthStream &lt;&lt; data;
<br/>
      lengthStream &gt;&gt; length;
<br/>
      otherPlayer = new SSBCData(&amp;receivedData[4+counter+1] , length);
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
SSBCData objects don't have a single pointer *they are just 1 int and 1 string* so, there shouldn't be memory leaks with them.
<br/>
<br/>
Dunno if it's my handler function or the function for communications here.
<br/>
<br/>
I'm using the latest Devkit *I think, at least it was the latest before the start of this month* and the function that was developed here. DSwifi was the only lib that had some modifications: I copy pasted this function and added AdHoc at the end and added it to the .h file. And, I had to use a previous version because the latest had some critical section errors or something S:
<br/>
<br/>
So far it has worked perfectly, except sometimes there's a freeze, which I think may end up being because of this leak.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169082 - Pete_Lockwood - Sat Jun 13, 2009 1:41 pm</h4>
    <div class="postbody"><span class="postbody">I'd cut down the code performed in the handler to an absolute minimum, then turn off interrupts when you actually read the network buffers.  This is roughly how I use the handler:
<br/>
<br/>
First create a simple array of message references:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const int maxQSize = 4096;
<br/>
<br/>
struct MsgQElement {
<br/>
    int packetID;
<br/>
    int length;
<br/>
};
<br/>
<br/>
MsgQElement InMsgQ[maxQSize];
<br/>
int InMsgQSize;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
This is <span style="text-decoration: underline">all</span> the handler does:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void PacketHandler(int packetID, int length)
<br/>
{
<br/>
    InMsgQ[InMsgQSize].packetID = packetID;
<br/>
    InMsgQ[InMsgQSize].length = length;
<br/>
    InMsgQSize++;
<br/>
<br/>
    if(InMsgQSize &gt;= maxQSize)
<br/>
    {
<br/>
        // This would be bad.
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Then I have a VBlank function that looks a bit like this, which I call in the one or two places in my code that wait for a VBlank (and more importantly can handle a state change caused by an update coming across the network):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void WaitForVBlank(void)
<br/>
{
<br/>
    // Disable interrupts while we catch up with the network buffers.
<br/>
    // Otherwise, things will go bad because we'll be doing stuff and
<br/>
    // the Wifi will still be reading more buffers at the same time.
<br/>
<br/>
    REG_IME = 0;
<br/>
    if(InMsgQSize)
<br/>
    {
<br/>
        updated = ReadNetworkBuffers();
<br/>
    }
<br/>
    REG_IME = 1;
<br/>
<br/>
    if(updated)
<br/>
    {
<br/>
        UpdateEverything();
<br/>
    }
<br/>
<br/>
    // Actually wait for the VBlank now
<br/>
    swiWaitForVBlank();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And finally the piece that actually deals with the network buffers:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
bool ReadNetworkBuffers()
<br/>
{
<br/>
    int f;
<br/>
    bool updated = false;
<br/>
<br/>
    for(f = 0 ; f &lt; InMsgQSize ; f++)
<br/>
    {
<br/>
        Wifi_RxRawReadPacket(InMsgQ[f].packetID, InMsgQ[f].length, (unsigned short *)InBuffer);
<br/>
        updated |= ProcessBuffer(InBuffer);
<br/>
    }
<br/>
    InMsgQSize = 0;
<br/>
<br/>
    return updated;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Will that resolve your leak?  Don't know, but I do know that when I used to process the buffer immediately in the handler things would get messy after a while.  It's best to exit the callback as soon as possible then come back when program flow is under your control.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"><br/><br/>Last edited by Pete_Lockwood on Sun Jun 14, 2009 3:35 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#169086 - Emmanuel - Sun Jun 14, 2009 9:54 am</h4>
    <div class="postbody"><span class="postbody">It fixed a leak I had in the receiving side, and the freezing in the sending side.
<br/>
<br/>
Now, I just need to do some fixes in the sending of data, but performance has increased so much, and your idea of keeping an array of referrences to messages gave me an idea and all in all the performance in the COMM side has increased a lot, just in the aspects it was failing before.
<br/>
<br/>
Thanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169318 - melw - Thu Jul 02, 2009 10:11 pm</h4>
    <div class="postbody"><span class="postbody">One could do yet another comparison between DS Wifi library and Lib Lobby and see where the registers differ. If also the former can send 802.11 beacon frames, it shouldn't be too far from receiving data frames either. Could it be as simple as missing the <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=142119#142119" target="_blank">correct RX filter setting</a> (0x0D in WiFi registers)?
<br/>
<br/>
Probably not. :)
<br/>
<br/>
Anyhow, just dropping random thoughts. I actually took few hours and converted the Pong example from LibLobby to use modified DsWifi library as my personal playground. But like Sgstair said, this isn't too useful as long as the traffic isn't transmitted in data frames.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
