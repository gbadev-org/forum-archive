<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Which ARM does Interrupt Handling ? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > Which ARM does Interrupt Handling ?</h2>
<div id="posts">
<div class="post">
    <h4>#161657 - SDy - Sat Aug 09, 2008 1:38 pm</h4>
    <div class="postbody"><span class="postbody">Greetings everyone,
<br/>
<br/>
After attempting to improve the interrupt handling in libnds (version 20071023), I end up asking myself several questions :
<br/>
<br/>
Which one of the CPU is "supposed" to be handling the interrupts ? (i.e. on which one of them does the interrupt handler runs)
<br/>
I'm not sure where the irqTable is located since it is declared with a "section(.itcm)" attribute but only the ARM9 has such section.
<br/>
<br/>
How many cycles does it require for the ARM7 to fetch a 32-bit word from its IWRAM ?
<br/>
The best source of info I could find is 
<br/>
<br/>
<a class="postlink" href="http://nocash.emubase.de/gbatek.htm#dsmemorytimings" target="_blank">http://nocash.emubase.de/gbatek.htm#dsmemorytimings</a>
<br/>
<br/>
but the column marked as "BUS" in those tables is not described, is it simply the bus width for transferring stuff to/from those memories ? Also the IWRAM timings are not given :s
<br/>
<br/>
Any help would be appreciated :)
<br/>
<br/>
<br/>
S.</span><span class="gensmall"><br/><br/>Last edited by SDy on Sat Aug 09, 2008 1:53 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#161658 - Dwedit - Sat Aug 09, 2008 1:50 pm</h4>
    <div class="postbody"><span class="postbody">Both CPUs have their own interrupt handler.  What are you trying to get at?<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161660 - SDy - Sat Aug 09, 2008 2:08 pm</h4>
    <div class="postbody"><span class="postbody">By looking at the code for the interrupt handler as it is, the fact of going through the irqTable, comparing the mask then fetching the handler address when it's the right one seems not extremely efficient to me (as the size of the table increases). I'd imagine that an interrupt handler should grab the handler's address in a constant time, not based on its position within the table.
<br/>
Also, the number of memory accesses should be kept as low as possible (because they're usually *very* slow).
<br/>
<br/>
I was thrilled to see the clz instruction which would allow me to compute the offset within the table in 2 instructions, but it's only available on v5 and above ARM.
<br/>
<br/>
The main problem I'm bumping into is how to compute the index of a set bit in an interrupt mask. The best solution I found requires around 10 arithmetic instructions. So what I'm trying to figure out is, which one is the fastest ?
<br/>
<br/>
<br/>
S.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161661 - tepples - Sat Aug 09, 2008 4:30 pm</h4>
    <div class="postbody"><span class="postbody">When I used to write my own ISRs, I would unroll the dispatching loop by hand, checking for each interrupt that I was interested in. Usually this was only vblank, and the ISR was short.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161666 - Maxxie - Sat Aug 09, 2008 7:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>SDy wrote:</b></span></td> </tr> <tr> <td class="quote">By looking at the code for the interrupt handler as it is, the fact of going through the irqTable, comparing the mask then fetching the handler address when it's the right one seems not extremely efficient to me (as the size of the table increases). I'd imagine that an interrupt handler should grab the handler's address in a constant time, not based on its position within the table.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
- It's limited by a constant time. 32 iterations through a shift (to get the next bit) and tst (to check the flag's state) instruction shouldn't be troubling you) the other effort for things like getting the function address keeps the same.
<br/>
<br/>
- Interrupt handling of the flags in REG_IF in constant times for all IRQs is impossible. There can be more then one flag be valid at the same time, in which you allways have to do one first, thus having a delay for the other.
<br/>
<br/>
- doing the lookup itself in constant time is possible through lookup tables, but not for the DS with it's 4MiB and 32bit IF. On 8bit machines it's could save a little time on the cost of memory.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Also, the number of memory accesses should be kept as low as possible (because they're usually *very* slow).
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The iterating and testing method below needs 4 accesses (IE addr, IE&amp;IF content, table) + 4 stack operations allways, and n (table index) accesses and n*8 stack operations(the call &amp; recovering), with n as the number of enabled and set bits.
<br/>
<br/>
(edit: actually reduced stack operations on set bit below by 2)
<br/>
<br/>
(not checked but this should point the way)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
STMDB sp!,{r4,lr}
<br/>
LDR r0,=REG_IE_ADDR
<br/>
LDR r1,[r0]
<br/>
LDR r0,[r0,#4]
<br/>
AND r0,r0,r1
<br/>
MOV  r1,#0
<br/>
MOV r2,#1
<br/>
LDR r4,=Table
<br/>
loop:
<br/>
TST r0,r2 lsl r1
<br/>
ADD r1,r1,#1
<br/>
BNE check
<br/>
CMP r0,#32
<br/>
BEQ end
<br/>
B loop
<br/>
check:
<br/>
LDR r3,[r4,r1 lsl #2]
<br/>
TST r3,r3
<br/>
BEQ loop
<br/>
STMDB sp!,{r0-r1,r3}
<br/>
BL r3
<br/>
LDMIA sp!,{r0-r1,r3}
<br/>
MOV r2,#1
<br/>
B loop
<br/>
end:
<br/>
LDMIA sp!,{r4,lr}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I was thrilled to see the clz instruction which would allow me to compute the offset within the table in 2 instructions, but it's only available on v5 and above ARM.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And it would only give you the highest enabled bit, leaving you with the problem that you need to repeat the test after clearing this bit and thus not doing it in constant time.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161676 - eKid - Sun Aug 10, 2008 1:38 am</h4>
    <div class="postbody"><span class="postbody">The libnds irq handler just stores a bitmask with each entry. If you only have 3 irqs enabled, the 'find irq' loop will only iterate up to three times. (also gives a simple priority system)
<br/>
<br/>
ARM7 can access iwram in 3 cycles.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161680 - Cydrak - Sun Aug 10, 2008 6:49 am</h4>
    <div class="postbody"><span class="postbody">Both processors handle their own interrupts (and by necessity IME, IE and IF are local to each CPU). Some devices and their IRQs stick to one side. Others (notably DMA, FIFO and timers), come in pairs.
<br/>
<br/>
He's listed IWRAM as "WRAM," and EWRAM as "Main RAM." I think bus width is right. Keep in mind, the table doesn't include the cycles related to LDR itself.
<br/>
<br/>
I'm no ARM guru, but I think the table is reasonable. It's already in fast memory and usually pretty tiny. Come to think, I bet you could even get that loop down to 4 ops, less if it's unrolled:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">; Untested, should be pretty obvious though..
<br/>
<br/>
    orr  r1, #(1&lt;&lt;31)      ; r1 = pending IRQ mask
<br/>
    ldr  r2, =irqTable     ;      (+sign bit to test end marker)
<br/>
findIRQ:
<br/>
    ldr  r0, [r2], #8
<br/>
    ands r0, r1
<br/>
    bgt  callHandler       ; &gt; 0 if matched something
<br/>
    beq  findIRQ           ; = 0 if no match, but more entries
<br/>
</td> </tr></table><span class="postbody">
<br/>
My gut feeling is 10 ALU ops should break even with 1-2 iterations here. But the mask table gives you something over shifting.. you can order them by priority and (in some cases?) service related IRQs in the same handler. In other words, although there might be "worse" latency, you have more control where it goes.
<br/>
<br/>
So, what are you trying to do with this? If it's important, I can only suggest to time it and see. Sometimes there is no "fastest" general purpose solution, in which case whatever you do will be either 1) a tradeoff (for better or worse), or 2) "good enough."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161701 - Miked0801 - Mon Aug 11, 2008 5:01 pm</h4>
    <div class="postbody"><span class="postbody">Optimizing the interrupt handler table isn't a bad idea to get some generic perforamance back.  One problem though is you have to push every register you play with.  That in and of itself adds overhead that is hard to overcome to a reasonable degree.
<br/>
<br/>
Anyways, if you wanted to trade a bunch of space for speed, you could skip the masking altogehter and just feed the if flag directly into a table of vectors and eitehr null terminate it for end check or store the number of vectors in the first position to check instead.  No masking fun, just stepping through an ordered table of functions.  Of course, a table 8-bits long is 256 entries of up to 8 functions.  Straight state machine code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161703 - Dwedit - Mon Aug 11, 2008 6:56 pm</h4>
    <div class="postbody"><span class="postbody">When I made my really tiny ISR for my GBA sleep hack patching program, I took advantage of the fact that r0 initially contains 0x04000000.  I managed to squeeze in a check for the vblank or keyboard interrupt and a jump to the previous ISR if neither interrupt is set into 5 instructions (plus two words to hold a couple addresses).
<br/>
<br/>
Does the NDS also set r0 to 0x04000000 before calling the user ISR?  If so, that's one less instruction you need.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161722 - SDy - Tue Aug 12, 2008 12:24 pm</h4>
    <div class="postbody"><span class="postbody">perhaps some code can help. My first idea was the following :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldr r0,=irqTable
<br/>
ldr r1,[REG_IE]
<br/>
ldr r2,[REG_IF]
<br/>
ands r1,r1,r2       @ r1 = interrupts to handle
<br/>
beq end
<br/>
str r1,[REG_IF]  @ acknowledge interrupts that will be handled
<br/>
loop:
<br/>
<br/>
    @ the two following instructions are the x &amp;= ~(x-1) trick which allows to extract the lowest bit set
<br/>
    sub r3,r1,#1
<br/>
    bic r3,r1,r3
<br/>
<br/>
    @ r3 contains the lowest interrupt bit which is set, so clz will give us the offset within irqTable where the handler to handle it is located
<br/>
    @ (assuming irqTable is ordered following : irqTable[0] = IRQ_HANDLER_BIT_24 .. irqTable[24] = IRQ_HANDLER_BIT_0)
<br/>
    clz r3,r3
<br/>
    sub r3,r3,#7 @ because there are only 25 interrupts we consider. If clz returns some number 'n', it should be between 7 and 31. So n-7 gives us [0:24]
<br/>
    ldr r2,[r0, r3]
<br/>
    stmfd sp!,{r0-r1,lr}
<br/>
    bx r2
<br/>
    ldmfd sp!,{r0-r1,lr}
<br/>
<br/>
    @ the following two instructions are the x &amp;= (x-1) trick which clears the lowest set bit in r1.
<br/>
    sub r3,r1,#1
<br/>
    ands r1,r1,r3
<br/>
    bne loop
<br/>
end:</td> </tr></table><span class="postbody">
<br/>
<br/>
Now, in this case, at each iteration, one interrupt will be handled, requiring one fetching from memory. Also, I cut the irqTable size in half since I don't need to store the irqMask for the lookup.
<br/>
My problem here is that clz is not available on ARM7TDMI, so I have to compute myself the offset within irqTable where the handler is located.
<br/>
<br/>
The code I have obtained so far is based on the idea found <a class="postlink" href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog" target="_blank">here</a> {check the // OR (IF YOU KNOW v IS A POWER OF 2) section of the code}
<br/>
<br/>
and is as follows :
<br/>
<br/>
(Assuming that r1 equals the mask of the interrupt for which we are computing the offset. Comments follow. I haven't tested this yet so a C code follows in case this one contains errors)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r2,#0
<br/>
lsrs r3,r1,#0x10     
<br/>
orrne r2,r2,#0x10
<br/>
moveq r3,r1
<br/>
lsrs r3,r3,#0x8
<br/>
orrne r2,r2,#0x8
<br/>
moveq r3,r1,lsr r2
<br/>
lsrs r3,r3,#0x4
<br/>
orrne r2,r2,#0x4
<br/>
moveq r3,r1,lsr r2
<br/>
lsrs r3,r3,#0x2
<br/>
orrne r2,r2,#0x2
<br/>
moveq r3,r1,lsr r2
<br/>
orrne r2,r2,r3,lsr #0x1
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Pseudo-code :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
r1 = REG_IE | REG_IF;
<br/>
r2 = 0;
<br/>
r3 = r1;
<br/>
if (r3 &gt;&gt;= 0x10) {r2 |= 0x10;} else {r3 = r1;}
<br/>
if (r3 &gt;&gt;= 0x8) {r2 |= 0x8;} else {r3 = r1 &gt;&gt; r2;}
<br/>
if (r3 &gt;&gt;= 0x4) {r2 |= 0x4;} else {r3 = r1 &gt;&gt; r2;}
<br/>
if (r3 &gt;&gt;= 0x2) {r2 |= 0x2;} else {r3 = r1 &gt;&gt; r2;}
<br/>
if (r3 &gt;&gt;= 0x1) {r2 |= 0x1;}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The idea is to shift-right r1 by 16 positions and update the Z flag. If the set bit is in [31:16], the shift-right will not zero r1 (and Z=1). This can be used as the condition to whether the set bit is within [31:16] or [15:0].
<br/>
This is basically a search in a binary tree where the bit position corresponds to the sequence of five boolean values obtained from asking at each point the question "Is it in the left-half of the word we're considering or the right-half ?" We then do it successively for the shift-right by 8, 4, 2 and 1.
<br/>
r2 now contains the offset we can add to the irqTable address to find the address to which bx will branch.
<br/>
<br/>
<br/>
Some replies :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">- Interrupt handling of the flags in REG_IF in constant times for all IRQs is impossible. There can be more then one flag be valid at the same time, in which you allways have to do one first, thus having a delay for the other.</td> </tr></table><span class="postbody">
<br/>
<br/>
What I meant was to get the address of a handler in constant time. If we have 10 bit set in REG_IE, and the one for which the handler is at the end of the irqTable occurs, the loop will go through all of them (9 useless ldr's) before actually finding the right one. I know that servicing is linear in the number of bits set in REG_IE.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote">So, what are you trying to do with this? If it's important, I can only suggest to time it and see. Sometimes there is no "fastest" general purpose solution, in which case whatever you do will be either 1) a tradeoff (for better or worse), or 2) "good enough."</td> </tr></table><span class="postbody">
<br/>
<br/>
What I want is to optimize the way interrupts are serviced here. I realize that in some cases it might be more interesting to write your own interrupt handler (the main one), for instance when there is 1 or 2 bits set in REG_IE. Perhaps only some local improvements can be made (merging some instructions, restructuring the code, etc.).
<br/>
How exactly would you time it ? Does no$gba or desmume offer timing facilities ?
<br/>
<br/>
EDIT: ok, no$gba does provide profiling capabilities but I'm not willing to pay 750$ (yet ^^)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Optimizing the interrupt handler table isn't a bad idea to get some generic perforamance back. One problem though is you have to push every register you play with.</td> </tr></table><span class="postbody">
<br/>
<br/>
Actually, I read that the BIOS-level interrupt handler (which branches to the interrupt handler I'm modifying) stores r0-r3 before branching (<a class="postlink" href="http://nocash.emubase.de/gbatek.htm#gbainterruptcontrol" target="_blank">scrolldown to BIOS Interrupt Handler</a>) so I'm trying to exclusively use r0-r3 if possible.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Anyways, if you wanted to trade a bunch of space for speed, you could skip the masking altogehter and just feed the if flag directly into a table of vectors</td> </tr></table><span class="postbody">
<br/>
<br/>
Precisely what I'm trying to do :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Does the NDS also set r0 to 0x04000000 before calling the user ISR? If so, that's one less instruction you need.</td> </tr></table><span class="postbody">
<br/>
<br/>
Again, according to <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#gbainterruptcontrol" target="_blank">this</a>, it doesn't seem to do it. Besides the location of irqTable is not hardware-hardcoded, only REG_{IE,IF,IME} are.
<br/>
<br/>
EDIT : my mistake; it does seem to place 0x4000000 in r0 before jumping to the main interrupt handler
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">0000012C  mov    r0,4000000h         ;ptr+4 to 03FFFFFC (mirror of 03007FFC)
<br/>
00000130  add    r14,r15,0h          ;retadr for USER handler $+8=138h
<br/>
00000134  ldr    r15,[r0,-4h]        ;jump to [03FFFFFC] USER handler</td> </tr></table><span class="postbody">
<br/>
<br/>
S.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161726 - Cydrak - Tue Aug 12, 2008 2:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>SDy wrote:</b></span></td> </tr> <tr> <td class="quote">What I want is to optimize the way interrupts are serviced here. I realize that in some cases it might be more interesting to write your own interrupt handler (the main one), for instance when there is 1 or 2 bits set in REG_IE. Perhaps only some local improvements can be made (merging some instructions, restructuring the code, etc.).</td> </tr></table><span class="postbody">
<br/>
I was moreso curious what you need the fast ISR for, or if it's just academic. For me libnds' is good enough, and I guess I appreciate the straightforward code. If you do optimize, you probably want to test if it really *is* faster, in which case the conditions are relevant...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>SDy wrote:</b></span></td> </tr> <tr> <td class="quote">How exactly would you time it ? Does no$gba or desmume offer timing facilities ?</td> </tr></table><span class="postbody">
<br/>
Buying NO$GBA aside (since it seems unavailable at the moment), a couple things come to mind. Obviously, if it's impacting the app's performance, that can be measured. Otherwise the hardware timers can give reasonable cycle counts.
<br/>
<br/>
You can read TIMER_DATA, subtracting the reload value to get the time since last rollover. In a timer handler this would give some indication of ISR latency. Another option would be to set the timer, arrange for an IRQ in the next few cycles, and measure (adding NOPs, if needed, until it shows up) the roundtrip time through the ISR.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>SDy wrote:</b></span></td> </tr> <tr> <td class="quote">Actually, I read that the BIOS-level interrupt handler (which branches to the interrupt handler I'm modifying) stores r0-r3 before branching</td> </tr></table><span class="postbody">
<br/>
Yep. It saves r0-r3,r12,lr_irq. Notice though that the two BIOS are different. The ISR will see r0 = 0x04000000 (ARM7) or DTCM + 0x4000 (ARM9; normally 0x0b004000, IIRC).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161729 - SDy - Tue Aug 12, 2008 4:52 pm</h4>
    <div class="postbody"><span class="postbody">You could say it's more academic. I never got my hands on such low-level coding. I studied some assembly and know how hardware works, so I figured why not try toying with the libnds to put that knowledge to practice.
<br/>
My objective is to get a full understanding of what happens deep down inside the library. Improving it in the process is a plus.
<br/>
<br/>
<br/>
Thanks for the advices Cydrak. And thanks to the others of course ^^
<br/>
<br/>
<br/>
S.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
