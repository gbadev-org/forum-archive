<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>InvSqrt - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > InvSqrt</h2>
<div id="posts">
<div class="post">
    <h4>#160092 - ChronoDK - Thu Jul 10, 2008 2:35 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I'm slowly porting a demo I made on pc, but I ran into a problem. I was using the Quake 3 InvSqrt function:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
float CVector2D::InvSqrt(float x) {
<br/>
   float xhalf = 0.5f * x;
<br/>
   int i = *(int*)&amp;x;
<br/>
   i = 0x5f3759df - (i &gt;&gt; 1);
<br/>
   x = *(float*)&amp;i;
<br/>
   x = x*(1.5f - xhalf*x*x);
<br/>
   return x;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
But it does not seem to work on DS. I'm guessing the float format is different. Is there some way to make this magic work?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160095 - Maxxie - Thu Jul 10, 2008 2:50 pm</h4>
    <div class="postbody"><span class="postbody">The float format is the same. The standrad is IEEE 754
<br/>
<br/>
The code however is some really dirty speedhack. Not really readable.
<br/>
<br/>
What is InvSqrt intended to do?
<br/>
If it is the Squareroot of the inverse, then replace it with sqrt(1/x). (Surely slower, but float is slow on the DS anyways)
<br/>
<br/>
You should however get away from floats anyways, as they are caclulated via software emulation (not hardware as on PC) and thus hell of slow.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160098 - elhobbs - Thu Jul 10, 2008 2:56 pm</h4>
    <div class="postbody"><span class="postbody">you could always use ;)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
float CVector2D::InvSqrt(float x) { 
<br/>
    return 1.0/sqrt(x); 
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
are you sure that it is not working? this is only one iteration of the newton method so it may not be as accurate as you require.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160099 - elhobbs - Thu Jul 10, 2008 2:59 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">What is InvSqrt intended to do?
<br/>
If it is the Squareroot of the inverse, then replace it with sqrt(1/x).</td> </tr></table><span class="postbody"> in q3 it isued in calulations to normalize vectors so it the inverse of the square root not the square root of the inverse. so 1.0/sqrt(x).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160100 - Maxxie - Thu Jul 10, 2008 3:05 pm</h4>
    <div class="postbody"><span class="postbody">which is the same:
<br/>
<br/>
(1/x)^y = (1^y)/ (x^y) = 1 / (x^y)
<br/>
with y = 0.5 for square root
<br/>
<br/>
:D ... and that newton iteration, yes that could be what i was missing on the reading, however it also simplifies a bit the different float parts. It shouldn't be valid for a lot of possible x values (i.e. negative x should result into intermixing the exponent with the sign (bitshifting one right), but then negatives arn't "rootable" anyways, but same happen on exponent/mantisse limit)<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160105 - elhobbs - Thu Jul 10, 2008 3:22 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">which is the same:
<br/>
<br/>
(1/x)^y = (1^y)/ (x^y) = 1 / (x^y)
<br/>
with y = 0.5 for square root</td> </tr></table><span class="postbody">hides head in shame...
<br/>
<br/>
if you were using the hardware sqrt though I am not sure that would give the same result, or would it?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160107 - Maxxie - Thu Jul 10, 2008 3:29 pm</h4>
    <div class="postbody"><span class="postbody">There might be slight differences at the end of the mantisse due to the different direction the roundings are influencing the result.
<br/>
<br/>
The acuracy should be the same however, as the inverse allways operates as far away from the neutral exponent (^1 -&gt; exp=128) as the original<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160108 - elhobbs - Thu Jul 10, 2008 3:41 pm</h4>
    <div class="postbody"><span class="postbody">I meant the ds hardware sqrt</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160109 - ChronoDK - Thu Jul 10, 2008 3:48 pm</h4>
    <div class="postbody"><span class="postbody">I'm using the InvSqrt in another function where I normalize a vector. 
<br/>
<br/>
That hardware sqrt sounds nice, but that works with fixed point only right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160110 - elwing - Thu Jul 10, 2008 3:54 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ChronoDK wrote:</b></span></td> </tr> <tr> <td class="quote">I'm using the InvSqrt in another function where I normalize a vector. 
<br/>
<br/>
That hardware sqrt sounds nice, but that works with fixed point only right?</td> </tr></table><span class="postbody">
<br/>
<br/>
yes, but you should never use something that is not fixed point, the DS don't manage floating points, it's wholly emulated and DAMN slow...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160112 - Maxxie - Thu Jul 10, 2008 3:58 pm</h4>
    <div class="postbody"><span class="postbody">ah,
<br/>
<br/>
well since it is an 64bit integer sqrt i'd would allways take the expression that is &gt;=1 out of 1/x or x. Multiply it as long with 4 until the i64 representation has none or only one leading zero left. After the hw sqrt convert back to float and divide as many times with 2 as you multiplied with 4 before. 
<br/>
<br/>
Then apply the inverse if it is still missing (if you took x)
<br/>
<br/>
That should give the best accuracy on the ds hw sqrt.
<br/>
<br/>
if you keep within an exponent between (64-23) above ^1 (so from ^40 to ^1) you should have as good or better accuracy as with float emulation. Outside this range, your accuraly should be less or equal.
<br/>
<br/>
:edit: removed sign reserve in register width - mantisse width bit
<br/>
:edit2: it's not needed to care about -exp, so only need ^+ range, and take the full 40 possible shifts for positives<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#160117 - Maxxie - Thu Jul 10, 2008 4:41 pm</h4>
    <div class="postbody"><span class="postbody">Half-Pseudocode for the suggested method.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
float SqrtAbove1(float x)
<br/>
{
<br/>
   /* the exp bits */
<br/>
   signed char exp = (signed char) (*(int *)&amp;x &amp; 0x7F800000) ;   
<br/>
   /* actual exponent is stored negative */
<br/>
   exp = -exp ;
<br/>
      
<br/>
   /* if we have an exp &lt;23 we have a fraction &lt; 1, we move shift it until we have no such fraction anymore */
<br/>
   /* since we have to reverse this operation later and can't do halfbit shifts, we align this correction at 2 */
<br/>
   if (exp &lt; 23)
<br/>
   {
<br/>
      expCorrection = (exp + 1) &amp; ~1 ;
<br/>
   } else
<br/>
      expCorrection = 0 ;
<br/>
      
<br/>
   /* get all bits into the ordinal */
<br/>
   u64 i = x * pow(2,expCorrection) ;
<br/>
<br/>
   /* occupy as much bits as possible, but only do 2-shifts, for later reverse */   
<br/>
   int count = 0 ;
<br/>
   while (!(i &amp; 0xC000000000000000))
<br/>
   {
<br/>
      i &lt;&lt;= 2 ;
<br/>
      count++ ;
<br/>
   }
<br/>
      
<br/>
      
<br/>
   /* do actual sqrt */
<br/>
   SQRT_PARAM = i ;
<br/>
   SQRTCNT  = 8001 ;
<br/>
   while (SQRTCNT &amp; 0x8000) ;
<br/>
   i = SQRT_RESULT ;
<br/>
      
<br/>
   /* reverse shifts */
<br/>
   i &gt;&gt;= count ;
<br/>
      
<br/>
   /* reverse expCorrection */
<br/>
   x = (float)i / pow(2,(expCorrection &gt;&gt; 1) ;
<br/>
   
<br/>
   return x ;
<br/>
}
<br/>
<br/>
float InvSqrt(float x)
<br/>
{
<br/>
   if (x&lt;=0) return NaN ;
<br/>
   if (x&gt;=1)
<br/>
   {
<br/>
      x = SqrtAbove1(x)
<br/>
      /* and apply Inverse */
<br/>
      x = 1 / x ;
<br/>
   } else
<br/>
   {
<br/>
      /* apply inverse first */
<br/>
      x = SqrtAbove1(1/x) ;
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The shift/reverse shifting is based on
<br/>
<br/>
sqrt(x) = (sqrt(4) / 2) * sqrt(x) = sqrt(4*x) / 2
<br/>
-&gt;
<br/>
sqrt(x) = (sqrt(4^n) / 2^n) * sqrt(x) = sqrt(4^n*x) / 2^n
<br/>
<br/>
<br/>
The * or / pow(2,...) in the float can be fastened by direct bit manipulating the exp part of the float.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
