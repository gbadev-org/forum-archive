<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>DS screen of death? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > DS screen of death?</h2>
<div id="posts">
<div class="post">
    <h4>#110288 - PypeBros - Mon Nov 27, 2006 5:01 pm</h4>
    <div class="postbody"><span class="postbody">Is there anyone around working on something like a "blue screen of death" library for the DS? i had a couple of debbuging sessions "darker than the nights" lately, and i'm missing the time where i was catching segmentation faults on the PC and dumping the register and stack content on the screen.
<br/>
<br/>
Is there something like a "software fault" trap on the DS, which i could reprogram to give debugging information? or at least is there a way to inspect ARM9 registers from a "guru meditation" tool that would be running on the ARM7 (assuming that the ARM7 has the ability of modifying the VRAM, which i'm unsure of).
<br/>
<br/>
Let me hear your random thoughts on the subject.<br/>_________________<br/><a class="postlink" href="http://sylvainhb.blogspot.com/p/sprite-editor.html" target="_blank"> SEDS: Sprite Edition on DS</a> :: <a class="postlink" href="http://sylvainhb.blogspot.com/search/label/modplayer" target="_blank">modplayer</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#110289 - simonjhall - Mon Nov 27, 2006 5:24 pm</h4>
    <div class="postbody"><span class="postbody">Yes you can catch the execution of illegal instructions, read/write to invalid addresses, breakpoints and...I think there's something else.
<br/>
It's relatively easy to do, and it's the basis of the debugger that I wrote.
<br/>
I'll whip out some code for you when I get home later, assuming someone doesn't get there first!
<br/>
<br/>
And I'm thinking of releasing the debugger again... (but that's off topic, so let's not discuss that here!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#110310 - Mighty Max - Mon Nov 27, 2006 8:24 pm</h4>
    <div class="postbody"><span class="postbody">defaultExceptionHandler() installs a some kind of bluescreen already. Trapping into an exception will cause a "Guru Meditation Error" Screen showing the registers content at the time of the exception.
<br/>
<br/>
If it fails to display information (flickering of the upper lines) the cause of the exception was a jump into an invalid addressspace for reading, causing yet another exception.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#110314 - simonjhall - Mon Nov 27, 2006 9:13 pm</h4>
    <div class="postbody"><span class="postbody">I left my card reader at work, so I can't make a bit of code for you, but check out Mighty Max's exception stuff (search the forums) as that's the stuff I used to trap exceptions!
<br/>
<br/>
Basically you set the interrupt vector to point to an exception-handling function which stores all your registers and gives you a bit of stack. Once this gets called (ie your program has done something wrong), you can then from there jump to your real handling function which'll look at the CPSR to decide what kind of exception it was. You can then draw your blue screen of death.
<br/>
<br/>
This bit is optional:
<br/>
If it was a data abort, read back the instruction which failed, decode it and compute the address which was accessed which caused the failure. You'll need an accurate copy of all the registers in order to do this.
<br/>
<br/>
Really off topic:
<br/>
If you'd like to do some kind of virtual memory stuff you can use that failed address as an index into some fake memory space (like a file). Then insert the data at that address into the target register of the failed instruction (assuming it was a read) and continue execution from the instruction after the failed instruction. Easy? Yeah :-)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
