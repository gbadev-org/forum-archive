<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Zooming out of an image - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Zooming out of an image</h2>
<div id="posts">
<div class="post">
    <h4>#161492 - Jeremysr - Tue Aug 05, 2008 1:41 am</h4>
    <div class="postbody"><span class="postbody">I'm making an Image class and need a way to draw an image zoomed out. Zooming in is easy, you just take each pixel and make a 2x2 (or whatever) square filled with the colour of that pixel. But to zoom out I guess you have to take a 2x2 (or larger) square of pixels from the image, and convert those 4 pixels into 1 pixel. So I guess my question is how would I take the four colours of the 2x2 square of pixels and change it into 1 pixel?
<br/>
<br/>
If the way I explained it was confusing, here's an example. This is an image of an "X" with 0 representing black and 1 representing white
<br/>
<br/>
<span style="font-weight: bold"><span style="color: red">11</span><span style="color: blue">00</span></span>000011
<br/>
<span style="font-weight: bold"><span style="color: red">11</span><span style="color: blue">00</span></span>000011
<br/>
0011001100
<br/>
0011001100
<br/>
0000110000
<br/>
0000110000
<br/>
0011001100
<br/>
0011001100
<br/>
1100000011
<br/>
1100000011
<br/>
<br/>
I want to change it to:
<br/>
<br/>
<span style="font-weight: bold"><span style="color: red">1</span><span style="color: blue">0</span></span>001
<br/>
01010
<br/>
00100
<br/>
01010
<br/>
10001
<br/>
<br/>
See how the 4 highlighted 1's are changed into a single 1 in the lower image, and the highlighted 0's are changed into a single 0? What if the 4 pixels were all different colours? Then what would the single pixel in the bottom image be?<br/>_________________<br/><a class="postlink" href="http://viewsourcecode.org/" target="_blank">viewsourcecode</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161493 - Dwedit - Tue Aug 05, 2008 1:48 am</h4>
    <div class="postbody"><span class="postbody">The two most common ways to shrink an image by 2x are:
<br/>
<br/>
* Take one pixel from the four and use that ("Nearest Neighbor")
<br/>
* Take the average of all four pixels (linear interpolaton)
<br/>
<br/>
Remember to average the R G and B components separately of course.
<br/>
<br/>
There are other methods of interpolation as well.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161494 - Jeremysr - Tue Aug 05, 2008 2:01 am</h4>
    <div class="postbody"><span class="postbody">Ok, I kind of thought of both those methods actually, I just thought the first method wouldn't look good and the second one I couldn't think of how to "put 4 colours together". I guess I'll try both methods and see which one works best for the image I want to be scaled.
<br/>
<br/>
Thanks!<br/>_________________<br/><a class="postlink" href="http://viewsourcecode.org/" target="_blank">viewsourcecode</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161498 - gauauu - Tue Aug 05, 2008 3:26 am</h4>
    <div class="postbody"><span class="postbody">And to state the obvious:  it also depends on how much time/processor power you have available and how much image data you are working with.  The linear interpolation would be significantly slower than the nearest neighbor.  Of course, depending on what you're doing, that "significantly slower" could be pretty insignificant ;-)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161500 - Jeremysr - Tue Aug 05, 2008 3:55 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gauauu wrote:</b></span></td> </tr> <tr> <td class="quote">And to state the obvious:  it also depends on how much time/processor power you have available and how much image data you are working with.  The linear interpolation would be significantly slower than the nearest neighbor.  Of course, depending on what you're doing, that "significantly slower" could be pretty insignificant ;-)</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, I think I'll have to go with the Nearest Neighbour method. My image is 4 times as big as the DS screen, and my RGB values are packed into 2 bytes so a lot of time would be spent unpacking them.<br/>_________________<br/><a class="postlink" href="http://viewsourcecode.org/" target="_blank">viewsourcecode</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161517 - Dwedit - Tue Aug 05, 2008 7:34 pm</h4>
    <div class="postbody"><span class="postbody">Not that hard to unpack and average 15 bit color...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static __inline u16 average_color(u16 a, u16 b, u16 c, u16 d)
<br/>
{
<br/>
   int redsum,greensum,bluesum;
<br/>
   redsum=(a&amp;0x31) + (b&amp;0x31) + (c&amp;0x31) + (d&amp;0x31);
<br/>
   greensum=(a&amp;0x3E0) + (b&amp;0x3E0) + (c&amp;0x3E0) + (d&amp;0x3E0);
<br/>
   bluesum=(a&amp;0x7C00) + (b&amp;0x7C00) + (c&amp;0x7C00) + (d&amp;0x7C00);
<br/>
   return ((redsum/4)&amp;0x31) + ((greensum/4)&amp;0x3E0) + ((bluesum/4)&amp;0x7C00);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
No, dividing by 4 isn't slow, any decent compiler turns a division by a power of two into a bitshift.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161524 - DekuTree64 - Tue Aug 05, 2008 10:43 pm</h4>
    <div class="postbody"><span class="postbody">If you don't mind a little darkening of the image, you can even do all the channels at once:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static __inline u16 average_color(u16 a, u16 b, u16 c, u16 d) 
<br/>
{ 
<br/>
   const u16 mask = RGB(7,7,7);
<br/>
   return (a/4 &amp; mask) + (b/4 &amp; mask) + (c/4 &amp; mask) + (d/4 &amp; mask);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Normally each channel ranges 0-31, so after div by 4, they're 0-7. But because of the divide, the low 2 bits of each channel gets shifted into the upper 2 bits of the one below it, so those bits have to be masked off.
<br/>
You can make it even faster by putting a and b in one u32, and c and d in another u32 so you can add 2 pixels at once, and then add those sums together.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static __inline u16 average_color(u32 ab, u32 cd) 
<br/>
{ 
<br/>
   const u32 mask = RGB(7,7,7) | (RGB(7,7,7) &lt;&lt; 16);
<br/>
   u32 temp = (ab/4 &amp; mask) + (cd/4 &amp; mask);
<br/>
   return (u16)(temp + (temp &gt;&gt; 16));
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
There's an even better trick though, that won't cause any darkening, and can be used with alpha blending too. I call it the poor man's MMX. It's not much faster than Dwedit's version unless you do 2 pixels at once, but basically the idea is to separate every other channel so there is an unused space between each value. So if you have a pair of pixels in a u32 as bgrbgr, you separate them like 0g0b0r and b0r0g0. Then you can do some multiplies and shifts and adds that affect all 3 values in each u32, and then OR them back together.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161529 - simonjhall - Wed Aug 06, 2008 12:00 am</h4>
    <div class="postbody"><span class="postbody">Fantastic stuff! I'll have to remember that! However, (it's late here, and I'm tired) how is there darkening in the first version of yours?<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161530 - Dwedit - Wed Aug 06, 2008 12:09 am</h4>
    <div class="postbody"><span class="postbody">It's darkening because you divide by 4 before adding them together.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161531 - DekuTree64 - Wed Aug 06, 2008 12:23 am</h4>
    <div class="postbody"><span class="postbody">Yeah, if all pixels were white (31), you still end up with 28 because you're effectively setting the low 2 bits to 0 before adding.
<br/>
<br/>
Another trick to sort of fix darkening problems like that, is to OR the upper bits of each channel into the lower bits, so 0-7 scales somewhat linearly to 0-31 (with a bit of randomness because those lower bits may not be 0 before the OR):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static __inline u16 average_color(u32 ab, u32 cd) 
<br/>
{ 
<br/>
   const u32 mask = RGB(7,7,7) | (RGB(7,7,7) &lt;&lt; 16); 
<br/>
   u32 temp = (ab/4 &amp; mask) + (cd/4 &amp; mask);
<br/>
   temp += temp &gt;&gt; 16;
<br/>
   temp |= (temp &gt;&gt; 3) &amp; RGB(3,3,3);
<br/>
   return (u16)temp;
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161533 - TwentySeven - Wed Aug 06, 2008 12:54 am</h4>
    <div class="postbody"><span class="postbody">Neat discussion!
<br/>
<br/>
Assuming the obvious, you can't do this offline and just have an asset stored at the correct resolution?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161554 - keldon - Wed Aug 06, 2008 7:57 am</h4>
    <div class="postbody"><span class="postbody">You can also use the classic <span style="font-weight: bold">((coloura &amp; RGB(30,30,30))/2)+((colourb &amp; RGB(30,30,30))/2))</span> in two steps for the four pixels. You can also use <span style="font-weight: bold">(colour &amp; RGB(31,0,31)) | ((colour &amp; RGB (0,31,0)) &lt;&lt; 16)</span> to add and shift freely in full comfort of integer precision!
<br/>
<br/>
p.s. that's a pretty neat trick to scale Deku ... oh and I see you already mentioned seperating (poor-man MMX), only your way is better as it deals with two colours at once.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161559 - simonjhall - Wed Aug 06, 2008 8:54 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">It's darkening because you divide by 4 before adding them together.</td> </tr></table><span class="postbody">Ah, that's what I thought. Though, isn't that more like it reduces the colour resolution rather than the brightness?<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161560 - keldon - Wed Aug 06, 2008 9:17 am</h4>
    <div class="postbody"><span class="postbody">(31+31) / 2 = 31
<br/>
(31/2) + (31/2) = 30</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161562 - kusma - Wed Aug 06, 2008 10:21 am</h4>
    <div class="postbody"><span class="postbody">Here's my attempt:
<br/>
<br/>
Two pixels in parallel, accurate result (minus rounding). Not tested.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u32 avg4(u32 a, u32 b, u32 c, u32 d)
<br/>
{
<br/>
   u32 e = a &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   e    += b &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   e    += c &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   e    += d &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   
<br/>
   u32 f = (a &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   f    += (b &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   f    += (c &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   f    += (d &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   
<br/>
   return (e &gt;&gt; 2) | f;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
The idea is to mask out every second color channel, and doing the additions in two passes to get all channels done.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161563 - DekuTree64 - Wed Aug 06, 2008 10:48 am</h4>
    <div class="postbody"><span class="postbody">Kusma: I'm confused. Shouldn't there only be 2 inputs (4 pixels as 2 pairs), and add the upper and lower 16 bits together at some point?
<br/>
<br/>
And Keldon, thanks for the single-pixel variation :)
<br/>
For some reason I hadn't thought of putting the pixel's own green value in the upper bits. Will be handy if I ever need to do per-pixel alpha in software.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161564 - Cearn - Wed Aug 06, 2008 11:32 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">Yeah, if all pixels were white (31), you still end up with 28 because you're effectively setting the low 2 bits to 0 before adding.
<br/>
<br/>
Another trick to sort of fix darkening problems like that, is to OR the upper bits of each channel into the lower bits, so 0-7 scales somewhat linearly to 0-31 (with a bit of randomness because those lower bits may not be 0 before the OR):
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static __inline u16 average_color(u32 ab, u32 cd) 
<br/>
{ 
<br/>
   const u32 mask = RGB(7,7,7) | (RGB(7,7,7) &lt;&lt; 16); 
<br/>
   u32 temp = (ab/4 &amp; mask) + (cd/4 &amp; mask);
<br/>
   temp += temp &gt;&gt; 16;
<br/>
   temp |= (temp &gt;&gt; 3) &amp; RGB(3,3,3);
<br/>
   return (u16)temp;
<br/>
}</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
Joining in the choir: that is really very clever.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u32 avg4(u32 a, u32 b, u32 c, u32 d)
<br/>
{
<br/>
   u32 e = a &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   e    += b &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   e    += c &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   e    += d &amp; (RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16));
<br/>
   
<br/>
   u32 f = (a &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   f    += (b &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   f    += (c &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   f    += (d &amp; (RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16))) &gt;&gt; 2;
<br/>
   
<br/>
   return (e &gt;&gt; 2) | f;
<br/>
}</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
That doesn't quite work. Using an R_B_G_ mask (0x7C1F03E0), blue is in bits 26-30. The result of the four additions would span bits 26-3<span style="font-weight: bold">2</span>; it would overflow. Second, you still need to apply a mask after the division by 4. 
<br/>
<br/>
This should work:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//! Rotate bits right. Yes, this does lead to a ror instruction.
<br/>
static inline u32 ROR(u32 x, uint ror)   
<br/>
{   return (x&lt;&lt;(32-ror)) | (x&gt;&gt;ror);            }
<br/>
<br/>
//! Averages 4 colors.
<br/>
u16 color_average(u16 a, u16 b, u16 c, u16 d)
<br/>
{
<br/>
   u32 ab, cd, avg;
<br/>
   const u32 mask= 0x03E07C1F;
<br/>
<br/>
   // Combine 2 colors into one u32
<br/>
   ab= a | b&lt;&lt;16;
<br/>
   cd= c | d&lt;&lt;16;
<br/>
<br/>
   // Split into _G_R_B and add
<br/>
   ab= (mask &amp; ab) + (mask &amp; ROR(ab, 16));
<br/>
   cd= (mask &amp; cd) + (mask &amp; ROR(cd, 16));
<br/>
<br/>
   // Average _G_R_B
<br/>
   avg= mask &amp; ((ab+cd)&gt;&gt;2);
<br/>
<br/>
   // Combine to RGB___ and cast to u16
<br/>
   return (avg | avg&lt;&lt;16)&gt;&gt;16;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
I think it's possible to round as well by adding mask/2 somewhere, but I haven't tested that yet. Oh, and what about the alpha-bit.
<br/>
<br/>
About alpha blending, I did a routine for that a few years ago <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=53322#53322" target="_blank">here</a>.
<br/>
<br/>
On a final note: sometimes GCC produces very silly ARM code for ANDing large constants. Instead of loading the constant once and using a single instruction for the AND (or AND NOT), it'll split it over multiple byte-wise ANDs. YMMV.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161565 - kusma - Wed Aug 06, 2008 11:59 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Kusma: I'm confused. Shouldn't there only be 2 inputs (4 pixels as 2 pairs), and add the upper and lower 16 bits together at some point? 
<br/>
</td> </tr></table><span class="postbody">
<br/>
I was actually thinking that you'd do two complete sets in parallel, but I guess that complicates the fetching-logic a bit.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">That doesn't quite work. Using an R_B_G_ mask (0x7C1F03E0), blue is in bits 26-30. The result of the four additions would span bits 26-3<span style="font-weight: bold">2</span>; it would overflow.</td> </tr></table><span class="postbody">
<br/>
Notice the right-shift by two before summing for the value f.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">Second, you still need to apply a mask after the division by 4.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Good point, that's a bug. Should be pretty easily solvable ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161567 - keldon - Wed Aug 06, 2008 3:01 pm</h4>
    <div class="postbody"><span class="postbody">Hmm; I only just cottoned on that those extra 5 bits allow for a 5 bit (positive) multiplication on each colour component.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161568 - kusma - Wed Aug 06, 2008 3:15 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u32 avg4(u32 a, u32 b, u32 c, u32 d)
<br/>
{
<br/>
   const u32 e_mask = RGB(31,0,31) | (RGB( 0,31,0) &lt;&lt; 16);
<br/>
   u32 e = a &amp; e_mask;
<br/>
   e    += b &amp; e_mask;
<br/>
   e    += c &amp; e_mask;
<br/>
   e    += d &amp; e_mask;
<br/>
   
<br/>
   const u32 f_mask = RGB( 0,31,0) | (RGB(31,0,31) &lt;&lt; 16);
<br/>
   u32 f = (a &amp; f_mask) &gt;&gt; 2;
<br/>
   f    += (b &amp; f_mask) &gt;&gt; 2;
<br/>
   f    += (c &amp; f_mask) &gt;&gt; 2;
<br/>
   f    += (d &amp; f_mask) &gt;&gt; 2;
<br/>
   
<br/>
   return ((e &gt;&gt; 2) &amp; e_mask) | (f &amp; f_mask);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
There. Now it's even tested! Here's the test-code (Yes yes, a bit dirty.. but who cares?):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u32 avg4_ref(u32 a, u32 b, u32 c, u32 d)
<br/>
{
<br/>
   u32 r_low = (GET_R(a) + GET_R(b) + GET_R(c) + GET_R(d)) / 4;
<br/>
   u32 g_low = (GET_G(a) + GET_G(b) + GET_G(c) + GET_G(d)) / 4;
<br/>
   u32 b_low = (GET_B(a) + GET_B(b) + GET_B(c) + GET_B(d)) / 4;
<br/>
   
<br/>
   u32 r_hi = (GET_R(a &gt;&gt; 16) + GET_R(b &gt;&gt; 16) + GET_R(c &gt;&gt; 16) + GET_R(d &gt;&gt; 16)) / 4;
<br/>
   u32 g_hi = (GET_G(a &gt;&gt; 16) + GET_G(b &gt;&gt; 16) + GET_G(c &gt;&gt; 16) + GET_G(d &gt;&gt; 16)) / 4;
<br/>
   u32 b_hi = (GET_B(a &gt;&gt; 16) + GET_B(b &gt;&gt; 16) + GET_B(c &gt;&gt; 16) + GET_B(d &gt;&gt; 16)) / 4;
<br/>
<br/>
   return RGB(r_low, g_low, b_low) | (RGB(r_hi, g_hi, b_hi) &lt;&lt; 16);
<br/>
}
<br/>
<br/>
#include &lt;stdlib.h&gt;
<br/>
<br/>
<br/>
int main(int argc, char* argv[])
<br/>
{
<br/>
   for (int i = 0; i &lt; 10000000; ++i)
<br/>
   {
<br/>
      u32 a = RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) | RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) &lt;&lt; 16;
<br/>
      u32 b = RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) | RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) &lt;&lt; 16;
<br/>
      u32 c = RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) | RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) &lt;&lt; 16;
<br/>
      u32 d = RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) | RGB(rand() &amp; 31, rand() &amp; 31, rand() &amp; 31) &lt;&lt; 16;
<br/>
<br/>
      u32 res = avg4(a,b,c,d);
<br/>
      u32 ref = avg4_ref(a,b,c,d);
<br/>
      if (res != ref)
<br/>
      {
<br/>
         printf("err - got &lt;%02x %02x %02x&gt;, expected &lt;%02x %02x %02x&gt;\n",
<br/>
            GET_R(res), GET_G(res), GET_B(res),
<br/>
            GET_R(ref), GET_G(ref), GET_B(ref)
<br/>
            );
<br/>
      }
<br/>
   }
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161578 - tepples - Wed Aug 06, 2008 7:33 pm</h4>
    <div class="postbody"><span class="postbody">You'll have to mask e and f before returning.
<br/>
<br/>
Here's <span style="font-style: italic">tested</span> code to perform palette fading, copied straight from the source code of luminesweeper. You should be able to adapt the general algorithm for this 2x2 linear shrink.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void set_palette_dimmed(void *in_dst,
<br/>
                        const void *in_src,
<br/>
                        unsigned int dim_to,
<br/>
                        unsigned int dim_level)
<br/>
{
<br/>
  u32 *dst = in_dst;
<br/>
  const u32 *src = in_src;
<br/>
  unsigned int n;
<br/>
  unsigned int to_expanded = (dim_to &amp; 0xFFFF) | (dim_to &lt;&lt; 16);
<br/>
  unsigned int to_0 = ((to_expanded &amp; 0x7C1F03E0) &gt;&gt; 4) * dim_level;
<br/>
  unsigned int to_1 = ((to_expanded &amp; 0x03E07C1F)) * dim_level;
<br/>
<br/>
  /* optimization for fade all the way out */
<br/>
  if(dim_level == 0)
<br/>
  {
<br/>
    dma_memcpy(in_dst, in_src, 32);
<br/>
    return;
<br/>
  }
<br/>
<br/>
  dim_level = 16 - dim_level;
<br/>
<br/>
  for(n = 8; n &gt; 0; n--)
<br/>
  {
<br/>
    unsigned int from = *src++;
<br/>
    unsigned int from_0 = ((from &amp; 0x7C1F03E0) &gt;&gt; 4) * dim_level;
<br/>
    unsigned int from_1 = ((from &amp; 0x03E07C1F)) * dim_level;
<br/>
<br/>
    from_0 = ((from_0 + to_0)) &amp; 0x7C1F03E0;
<br/>
    from_1 = ((from_1 + to_1) &gt;&gt; 4) &amp; 0x03E07C1F;
<br/>
<br/>
    *dst++ = from_0 | from_1;
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#161582 - kusma - Wed Aug 06, 2008 8:02 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">You'll have to mask e and f before returning.</td> </tr></table><span class="postbody">
<br/>
...like the last version I posted does...</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
