<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Troubles building a simple camera class - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Troubles building a simple camera class</h2>
<div id="posts">
<div class="post">
    <h4>#46643 - connor9 - Tue Jun 28, 2005 4:08 pm</h4>
    <div class="postbody"><span class="postbody">I'm trying to build a simple camera class. It's a simple camera that you can tell to move forward along it's viewing direction, roll, pitch and yaw along it's respective axes. The problem I'm running into is that as you use the camera  the view volume becomes skewed, as if the directions that specify viewing direction, up and right are becoming non orthogonal. Printing out the dot product of each of these vectors confirms that the camera is slowly ruining it's vectors. 
<br/>
<br/>
I assume it's a problem of data precision and that I'm probably using fixed point numbers completely incorrectly. 
<br/>
<br/>
Here's the code to the simple camera class:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void Camera::setModelViewMatrix() {
<br/>
    m4x4 viewMatrix;
<br/>
    
<br/>
    viewMatrix.m[0] = u[0];   
<br/>
    viewMatrix.m[1] = v[0];
<br/>
    viewMatrix.m[2] = n[0];
<br/>
    viewMatrix.m[3] = CAM0;
<br/>
    viewMatrix.m[4] = u[1];
<br/>
    viewMatrix.m[5] = v[1];
<br/>
    viewMatrix.m[6] = n[1];
<br/>
    viewMatrix.m[7] = CAM0;
<br/>
    viewMatrix.m[8] = u[2];
<br/>
    viewMatrix.m[9] = v[2];
<br/>
    viewMatrix.m[10] = n[2];
<br/>
    viewMatrix.m[11] = CAM0;
<br/>
    viewMatrix.m[12] = -dotf32(eye,u);
<br/>
    viewMatrix.m[13] = -dotf32(eye,v);
<br/>
    viewMatrix.m[14] = -dotf32(eye,n);
<br/>
    viewMatrix.m[15] = CAM1;
<br/>
    
<br/>
    glLoadMatrix4x4(&amp;viewMatrix);
<br/>
}
<br/>
<br/>
void Camera::setView(f32 eye_in[3], f32 look_in[3], f32 up_in[3]) {
<br/>
    eye[0] = eye_in[0];
<br/>
    eye[1] = eye_in[1];
<br/>
    eye[2] = eye_in[2];
<br/>
<br/>
    n[0] = eye[0] - look_in[0];
<br/>
    n[1] = eye[1] - look_in[1];
<br/>
    n[2] = eye[2] - look_in[2];
<br/>
    
<br/>
    crossf32(up_in,n,u);
<br/>
    normalizef32(n);
<br/>
    normalizef32(u);
<br/>
    
<br/>
    crossf32(n,u,v);
<br/>
    setModelViewMatrix();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Set view is called to initialize the camera. Sort of an initial gluLookAt. Each frame various camera.roll(angle), camera.moveForward(distance) actions are called and the the matrix is loaded by calling camera.setModelViewMatrix(); Oh, it's not shown in the camera class but before setModelViewMatrix() is called the matrix stack is set to model view.
<br/>
<br/>
The following is only the roll implementation. As you roll the camera the dot product of u and v becomes non-zero. 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void Camera::roll(int angle) { 
<br/>
    f32 sine = SIN[angle &amp;  LUT_MASK];
<br/>
    //f32 cosine = sqrtf32((CAM1 - sine2));    
<br/>
    f32 cosine = COS[angle &amp; LUT_MASK];
<br/>
<br/>
    f32 t[3];
<br/>
<br/>
    t[0] = u[0];
<br/>
    t[1] = u[1];
<br/>
    t[2] = u[2];
<br/>
            
<br/>
    u[0] = mulf32(cosine,t[0]) - mulf32(sine,v[0]);
<br/>
    u[1] = mulf32(cosine,t[1]) - mulf32(sine,v[1]);
<br/>
    u[2] = mulf32(cosine,t[2]) - mulf32(sine,v[2]);
<br/>
        
<br/>
    v[0] = mulf32(sine,t[0]) + mulf32(cosine,v[0]);
<br/>
    v[1] = mulf32(sine,t[1]) + mulf32(cosine,v[1]);
<br/>
    v[2] = mulf32(sine,t[2]) + mulf32(cosine,v[2]);
<br/>
}
<br/>
<br/>
void Camera::moveForward(f32 distance) {    
<br/>
<br/>
    eye[0] += mulf32(distance,n[0]);
<br/>
    eye[1] += mulf32(distance,n[1]);
<br/>
    eye[2] += mulf32(distance,n[2]);
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
LUT_MASK is defined in camera.h
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define LUT_MASK (0x1FF)
<br/>
</td> </tr></table><span class="postbody">
<br/>
CAM0 and CAM1 are defined as the 1.0 and 0.0 in a fixed point f32 number.
<br/>
<br/>
My question is how can I make this class work without warping the viewing parameters. Or what is a better method of implementing a camera class on the DS that still gives me easy access to my camera's current position and view vector?
<br/>
<br/>
Thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#47066 - LunarCrisis - Mon Jul 04, 2005 7:11 pm</h4>
    <div class="postbody"><span class="postbody">Although the imprecisions of the matrix variables is often negligible, as you repeatedly perform more and more operations on the matrix (as you are doing every time you move the camera), the error in the matrix elements keeps getting bigger, and you start getting these wierd effects. The only solution I can think of is to keep track of the position and angles (vertical, lateral, and roll) yourself and recalculate the matrix from scratch each time any of them changes.<br/>_________________<br/>If a tree falls in the forest and no one is there to hear it, why the heck do you care?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#47067 - tepples - Mon Jul 04, 2005 7:18 pm</h4>
    <div class="postbody"><span class="postbody">Or you can do this occasionally: <ol type="1"><li>Calculate the forward and up vectors from the matrix. </li><li>Make the forward vector into a unit vector. </li><li>Make the up vector orthogonal by calculating the projection of the up vector onto the forward vector (which equals forward times (forward dot up)) and subtracting this from the up vector. </li><li>Make the up vector into a unit vector. </li><li>Calculate the matrix from the forward and up vectors. </li></ol><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#47072 - connor9 - Mon Jul 04, 2005 7:36 pm</h4>
    <div class="postbody"><span class="postbody">Thanks tepples! That sent me on the right direction and I've got it fixed now.
<br/>
<br/>
Basically I reorthogonalize the matrix when the error reaches a certain threashhold. This value can be set.
<br/>
<br/>
Thanks for the help. Now that I've got this working I'll put it up here for anyone to modify and use. This is a basic camera class that let's you specify camera movement through the use of simple commands like pitch, yaw, and roll. Perfect for a flight simulator game which I noticed someone was interested in making.
<br/>
<br/>
<a class="postlink" href="http://connor.completelyfreehosting.com/tf/camera.zip" target="_blank">http://connor.completelyfreehosting.com/tf/camera.zip</a>
<br/>
<br/>
The camera class itself is fairly neat but the added matrix functions I made are really messy but they work. They just don't have good naming conventions or consistent use of returning a value through a pointer or as the return type. But it works well and could be of use to other people who want a simple class to drop in and fly about their world.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#47233 - corsec - Wed Jul 06, 2005 5:59 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>connor9 wrote:</b></span></td> </tr> <tr> <td class="quote">Perfect for a flight simulator game which I noticed someone was interested in making. </td> </tr></table><span class="postbody">
<br/>
<br/>
That would be me, and I will definitly look at your code.
<br/>
<br/>
However, I am currently working on the sprites, because that is a bit easier.<br/>_________________<br/>Currently working on a flight simulator set in 1916.
<br/>
<a href="http://ucsub.colorado.edu/~hustvedt/ds.html" target="_blank">http://ucsub.colorado.edu/~hustvedt/ds.html</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
