<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Wait for interrupt help - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > Wait for interrupt help</h2>
<div id="posts">
<div class="post">
    <h4>#118293 - Bloodypriest - Sun Feb 11, 2007 10:48 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
for the last few days, I've been trying to write a sleep mode handler. I based my code on those two threads: <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=12011&amp;highlight=hinge" target="_blank">http://forum.gbadev.org/viewtopic.php?t=12011&amp;highlight=hinge</a> and <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=6980&amp;highlight=sleep+interrupt" target="_blank">http://forum.gbadev.org/viewtopic.php?t=6980&amp;highlight=sleep+interrupt</a>. It works but only on ARM7; ARM9 locks-up and the LCD won't power up again. After trying different things, I've determined that it's the CP15_WaitForInterrupt function that I'm calling to put the ARM9 in very-low power mode that never returns. 
<br/>
<br/>
Can someone help me figure this out? I've tried everything I could think of to make it work.
<br/>
<br/>
Here's my code:
<br/>
<br/>
<span style="font-weight: bold">Arm7 code</span>:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void enterSleepMode(void)
<br/>
{
<br/>
   u32 old_ie;
<br/>
<br/>
   old_ie = REG_IE;
<br/>
<br/>
   REG_IE = IRQ_LID|IRQ_KEYS|IRQ_IPC_SYNC;
<br/>
   REG_KEYCNT=BIT(14)|255;
<br/>
   REG_IME = 1;
<br/>
<br/>
   setLed(PM_LED_SLEEP);
<br/>
   setPowerSaveMode(1);
<br/>
<br/>
   IPC_SendSync(1);         // Signal ARM9: Power-down
<br/>
   swiSleep();
<br/>
   IPC_SendSync(2);         // Signal ARM9: Power-up
<br/>
<br/>
   setPowerSaveMode(0);
<br/>
<br/>
   REG_IE = old_ie;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-weight: bold">ARM9 code</span>:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static void ipcSyncInterruptHandler(void)
<br/>
{
<br/>
   int ctl = IPC_GetSync();
<br/>
<br/>
   if (ctl == 1) {
<br/>
//      iprintf("\x1b[13;0HControl 1 pass\n");
<br/>
      powerOFF(POWER_LCD);
<br/>
      CP15_WaitForInterrupt();
<br/>
   }
<br/>
   else if (ctl == 2) {
<br/>
      sleepMs(100);
<br/>
<br/>
      powerON(POWER_LCD);
<br/>
//      iprintf("\x1b[14;0HControl 2 pass\n");
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
CP15_WaitForInterrupt comes from Moonshell's CP15.s and is defined as:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.global CP15_WaitForInterrupt
<br/>
CP15_WaitForInterrupt:
<br/>
      mov   r0, #0
<br/>
      mcr   p15, 0, r0, c7, c0, 4
<br/>
      bx   lr
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119322 - nio101 - Wed Feb 21, 2007 10:28 pm</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
<br/>
I wish somebody could help... I'm looking for the very same low power standby feature too, but haven't been able to find anything working...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119331 - Mighty Max - Wed Feb 21, 2007 11:01 pm</h4>
    <div class="postbody"><span class="postbody">There is a problem in the ARM9 code:
<br/>
<br/>
If you are using libnds, then you are going into the wait-for-irq while IME is disabled. This generates some problems:
<br/>
<br/>
- the CP15 wait never returns
<br/>
- if it would return, the irq handler would not enter the irqHandler again, no IPC_Sync_IRQ would have been flagged in REG_IF, thus not turning on the LCD Power
<br/>
<br/>
The easiest workaround for the later two (except chainging the irq dispatcher) would be in the irq routine setting the I flag again in cpsr (preventing nested irqs) and afterthat turning IME/IE up again.
<br/>
<br/>
The IME disabled causes some more problems when trying to sync while the other side is in any other irq. 
<br/>
<br/>
I've sent wintermute a report about this problems some weeks ago when i noticed this on some "missing" irqs but yet he didnt reply to it yet.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119345 - wintermute - Thu Feb 22, 2007 2:43 am</h4>
    <div class="postbody"><span class="postbody">Big clue for me here might be this
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static void ipcSyncInterruptHandler(void) 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Given the name of this function I'd assume it's an interrupt handler.
<br/>
<br/>
Waiting for an interrupt during an interrupt handler is quite likely to never succeed.
<br/>
<br/>
The libnds interrupt dispatcher does not enable nested interrupts by default for various reasons. You might be able to get away with adding an explicit REG_IME = 1; before the wait.
<br/>
<br/>
There's also no need to use custom assembly for the low power wait - that's what swiIntrWait does.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
/*! \fn swiIntrWait(int waitForSet, uint32 flags)
<br/>
<br/>
   \brief wait for interrupt(s) to occur
<br/>
<br/>
   \param waitForSet
<br/>
      0: Return if the interrupt has already occured
<br/>
      1: Wait until the interrupt has been set since the call
<br/>
   \param flags
<br/>
      interrupt mask to wait for
<br/>
<br/>
*/
<br/>
<br/>
void swiIntrWait(int waitForSet, uint32 flags);
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119346 - wintermute - Thu Feb 22, 2007 2:56 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mighty Max wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The easiest workaround for the later two (except chainging the irq dispatcher) would be in the irq routine setting the I flag again in cpsr (preventing nested irqs) and afterthat turning IME/IE up again.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Why change the I flag in CPSR again? For this sleep code ideally all interrupts should be disabled other than the one you're interested in.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The IME disabled causes some more problems when trying to sync while the other side is in any other irq. 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This shouldn't be an issue with the latest dispatcher code. REG_IF is cleared on the way in to the handlers again so irqs really shouldn't be getting lost.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I've sent wintermute a report about this problems some weeks ago when i noticed this on some "missing" irqs but yet he didnt reply to it yet.</td> </tr></table><span class="postbody">
<br/>
<br/>
Didn't receive your report, sorry. If you have some code that shows missing irqs with latest dispatcher I'll be glad to take a look.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119349 - Bloodypriest - Thu Feb 22, 2007 4:28 am</h4>
    <div class="postbody"><span class="postbody">So to make it work, I should use swiWaitForIntr instead of the custom CP15 code and enable nested interrupts is that it?
<br/>
<br/>
BTW are setting REG_IME=1 and clearing the I flag sufficient to enable nested interrupts or do I need to do something else?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119352 - Mighty Max - Thu Feb 22, 2007 7:39 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>wintermute wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Why change the I flag in CPSR again?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I was too lazy yesterday to check whether you had cleared it before calling the handlers, so i wanted to stay "safe" ;)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
This shouldn't be an issue with the latest dispatcher code. REG_IF is cleared on the way in to the handlers again so irqs really shouldn't be getting lost.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
It still is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   71    mov   r3, #0x4000000      @ REG_BASE
<br/>
   72 
<br/>
   73    ldr   r1, [r3, #0x208]   @ r1 = IME
<br/>
   74    str   r3, [r3, #0x208]   @ disable IME
<br/>
(...)
<br/>
  143    ldmfd   sp!, {r0-r1,r3}      @ {spsr, IME, REG_BASE}
<br/>
  144    str   r1, [r3, #0x208]   @ restore REG_IME
<br/>
  145    msr   spsr, r0      @ restore spsr
<br/>
  146    mov   pc,lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
This is problematic, because:
<br/>
Unlike the I Flag, IME prevents an incoming irq request beeing recognized in IF, where you clear IF within the irq handler doesnt matter this way. Neither does the cp15 get any notice from the irq, thus not returning on wait for IRQ while IME=0
<br/>
<br/>
The whole time the ARM spends in the dispatcher (and the called IRQ handlers) the cpu will not notice any other irq. This espacially creates problems when other IRQs (like fifo, ipc sync) are to be created short after the vsync. They are most likely to be completely lost.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119394 - wintermute - Thu Feb 22, 2007 5:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mighty Max wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
This is problematic, because:
<br/>
Unlike the I Flag, IME prevents an incoming irq request beeing recognized in IF, where you clear IF within the irq handler doesnt matter this way. Neither does the cp15 get any notice from the irq, thus not returning on wait for IRQ while IME=0
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I've written some code to test your supposition.
<br/>
<br/>
The first test proves that REG_IF gets bits set even with REG_IME disabled.
<br/>
<br/>
The second test proves that REG_IF gets updated during a handler.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
<br/>
void WaitVBL() {
<br/>
   while ( REG_VCOUNT != 192);
<br/>
   while ( REG_VCOUNT == 192);
<br/>
}
<br/>
<br/>
vu32 framecounter = 0;
<br/>
vu32 vcounter = 0;
<br/>
<br/>
void vblankHandler() {
<br/>
<br/>
   framecounter++;
<br/>
<br/>
   // wait for the vcount irq to be flagged
<br/>
   while ( !(REG_IF &amp; IRQ_VCOUNT));
<br/>
   
<br/>
   int x = REG_VCOUNT;
<br/>
   
<br/>
   // wait for the next scanline
<br/>
   while ( REG_VCOUNT == x);
<br/>
<br/>
}
<br/>
<br/>
void vcountHandler() {
<br/>
<br/>
   vcounter++;
<br/>
}
<br/>
<br/>
<br/>
int main(void) {
<br/>
<br/>
   irqInit();
<br/>
<br/>
   videoSetMode(0);
<br/>
<br/>
   consoleDemoInit();
<br/>
<br/>
   
<br/>
   irqEnable(IRQ_VBLANK);
<br/>
<br/>
   // disable interrupts
<br/>
   REG_IME = 0;
<br/>
   // clear all pending interrupts
<br/>
   REG_IF = IRQ_ALL;
<br/>
   
<br/>
   // first test check for REG_IF bits being set with REG_IME = 0
<br/>
   while(1) {
<br/>
      scanKeys();
<br/>
      if (keysDown() &amp; KEY_A ) break;
<br/>
      WaitVBL();
<br/>
      printf("\x1b[2;0HREG_IF = %08X",REG_IF);
<br/>
      REG_IF = IRQ_VBLANK;
<br/>
   }
<br/>
   
<br/>
   irqSet(IRQ_VBLANK,vblankHandler);
<br/>
   irqSet(IRQ_VCOUNT,vcountHandler);
<br/>
<br/>
   irqEnable(IRQ_VCOUNT);
<br/>
   
<br/>
   // vcount irq on line 40
<br/>
   SetYtrigger(40);
<br/>
<br/>
   // second test vblank handler spins on REG_IF IRQ_VCOUNT bit 
<br/>
   while(1) {
<br/>
   
<br/>
      swiWaitForVBlank();
<br/>
      printf("\x1b[4;0Hvcount %d, frame %d",vcounter, framecounter);
<br/>
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
<br/>
}
<br/>
 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
There are a couple of potential pitfalls.
<br/>
<br/>
1. A handler takes longer than the interrupt period ( i.e. a vblank handler takes more than a single frame to process). In this case the handler will effectively take all your CPU if it's the first handler to be installed.
<br/>
<br/>
2. A handler delays for 2 or more periods of another interrupt. In this case only one of the other interrupts will be processed.
<br/>
<br/>
The second case can be alleviated by enabling REG_IME during the handler so that other interrupts can take place.
<br/>
<br/>
The dispatcher does not enable nested interrupts by default for the simple reason that there is then no way to install an interrupt which cannot be interrupted.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119395 - wintermute - Thu Feb 22, 2007 5:38 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Bloodypriest wrote:</b></span></td> </tr> <tr> <td class="quote">So to make it work, I should use swiWaitForIntr instead of the custom CP15 code and enable nested interrupts is that it?
<br/>
<br/>
BTW are setting REG_IME=1 and clearing the I flag sufficient to enable nested interrupts or do I need to do something else?</td> </tr></table><span class="postbody">
<br/>
<br/>
With the libnds irq system setting REG_IME to 1 is sufficient, the dispatcher handles the rest.
<br/>
<br/>
swiWaitForIntr just does much the same thing as your custom CP15 code. Personally I prefer to use functions supplied by the system rather than add complex or obscure custom code to a project where it might confuse others.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119405 - NeX - Thu Feb 22, 2007 7:54 pm</h4>
    <div class="postbody"><span class="postbody">I came up with a solution that doesn't stop CPU processing - something I don't know how to do - but turns off the screens and pauses the game.  
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if((keys &amp; KEY_LID)) {powerOFF(POWER_ALL);while((keys &amp; KEY_LID)){scanKeys();keys = keysHeld();}powerON(POWER_ALL);}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119410 - HyperHacker - Thu Feb 22, 2007 8:22 pm</h4>
    <div class="postbody"><span class="postbody">That's going to be using 100% CPU power though. Throw an swiWaitForVBlank() in that loop.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119415 - NeX - Thu Feb 22, 2007 8:55 pm</h4>
    <div class="postbody"><span class="postbody">That's probably a good idea... why didn't I think of that?
<br/>
<br/>
Seriously!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119551 - Bloodypriest - Sat Feb 24, 2007 6:27 am</h4>
    <div class="postbody"><span class="postbody">Thanks, it works now. In the end, I had to lift the swiWaitForIntr from the interrupt handler. 
<br/>
<br/>
Wintermute, I tested setting REG_IME to 1 before calling swiWaitForIntr like you said and while it did allow the 2nd IPC Sync IRQ to occur and the power to turn back on, it did not allow swiWaitForIntr to seemingly return. Quite strange since to produce this result, it probably had to return once from swiWaitForIntr. It looks like it did the following :
<br/>
<br/>
1. Enter IPC_IRQ handler
<br/>
2. Enter swiWaitForIntr
<br/>
3. swiWaitForIntr gets interrupted by nested IPC_IRQ
<br/>
4. Complete nested IPC_IRQ
<br/>
5. resume waiting with swiWaitForIntr
<br/>
<br/>
I was able to consistently reproduce the results. Might this be worth a look?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119577 - tepples - Sat Feb 24, 2007 1:18 pm</h4>
    <div class="postbody"><span class="postbody">swiWaitForIntr checks a memory location when waiting for an interrupt. This location should always contain the set of interrupt sources that were recently acknowledged. How is your ISR handling this location?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119613 - Bloodypriest - Sat Feb 24, 2007 7:11 pm</h4>
    <div class="postbody"><span class="postbody">Correct me if I'm wrong but I believe libnds' swiIntrWait function already handle that memory location on it's own. Here is how I am calling it :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
REG_IME = 1;
<br/>
swiIntrWait(1,IRQ_IPC_SYNC);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
It works when it's lifted out of my interrupt handler but doesn't return when called from inside my interrupt handler (or rather seems to return, handle the interrupt, then resume waiting).</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
