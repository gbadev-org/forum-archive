<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>18 bit LCDs - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > 18 bit LCDs</h2>
<div id="posts">
<div class="post">
    <h4>#159454 - sverx - Tue Jul 01, 2008 1:35 pm</h4>
    <div class="postbody">Hi there<br/>
 I was just curious, I've read <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#dstechnicaldata">GBATek specs</a> and <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=4494">this topic</a>, they both say that the NDS LCDs are 18 bpp...<br/>
<br/>
Does that mean that <em class="text-italics">blending</em> two backgrounds with two different palettes (each 15bpp) the result will be an image with a 18bpp palette? (I didn't want to say an 18 bpp image because it's not so, you can't set the value for each pixel...)<br/>
<br/>
Ideas? Opinions? Code? ;)<br/>
<br/>
Ciao :)</div>    
</div>
<div class="post">
    <h4>#159455 - elhobbs - Tue Jul 01, 2008 2:17 pm</h4>
    <div class="postbody">I am not sure what type of effect you would be able to achieve with this in mind. however, it does produce slightly smoother blending for multiple backgrounds in 2d and for alpha blending and hardware lights in 3d.</div>    
</div>
<div class="post">
    <h4>#159458 - silent_code - Tue Jul 01, 2008 3:44 pm</h4>
    <div class="postbody">A lot of cheap and "fast" (low response time) consumer level TFT displays (PC and TV) are 18bit, too. So?<br/>
It's just the display pannels and color mapping, colors are still handled in whatever bit depth used by the graphics hardware, no big deal.<br/>
<br/>
Most people don't even notice it until they start to "make art" and realize the color range seems odd. Or they play UnrealEngine3 games (it happens to be a lot more visible in those games, maybe due to the engine's gamma correction or whatever) and see the ugly dithering the displays produce in dark areas. :^D<br/>
<br/>
That's one factor of why some displays cost a lot more than others: they simply have true 30bit or 32bit (or at least very good 24bit) panels.<br/>
<br/>
IIrc, the NDS' color ranges are like this: (15 + 1)bit colors, 24bit 3D computations (converted back to 16bit color afterwards!) and 18bit displays.<br/>
You really don't have any control over the color depth of the displays and I guess, it's not even taken into account when blending occurs... the hardware then simply mapps 15bit (yes, it's 15 this time!) to 18bit colors.<br/>
<br/>
Although I don't have in depth knowledge to assure you that it's just like that on the NDS, I know that's how things work in other devices.</div>    
</div>
<div class="post">
    <h4>#159465 - Cydrak - Tue Jul 01, 2008 5:21 pm</h4>
    <div class="postbody">Nah. Unless my eyes deceive, it really does render 18bpp. The shaded polys are too smooth, and there is more banding if you capture and redisplay them. In 2D, an 8/8 blend with black or white shows up to 32 levels, even though the range is halved.<br/>
<br/>
Most interesting is ordinary white; if I turn on blending I can see it's a little "shy"--true saturated white is a notch brighter. I guess it just doubles the 3*5 bits. (There is no kink in the midrange, as one gets by rounding, either.)<br/>
<br/>
What could you do with this? The smallest blend is 1/16, and blending *does* round--to 5 levels. Values 4-11 (of 31) give the second darkest. So, maybe if you had a 4bpp layer with RGBs of 0/8, you can selectively "add 1" to each channel. Then you would have your low 3bpp, and 248 colors left for the bitmap. (If you use a palette there at all.)<br/>
<br/>
That wouldn't work for textures, of course, but one could imagine overblending 50% with full primaries instead.</div>    
</div>
<div class="post">
    <h4>#159472 - silent_code - Tue Jul 01, 2008 6:58 pm</h4>
    <div class="postbody">Perception is a ... you know what: very subjective matter. ;^)<br/>
<br/>
A (at best) remotely related example:<br/>
<br/>
I know of two guys who made their semester audio project together and although they had to make separate final productions (everything else during preproduction would be shared), they ran out of time and submitted the exact same thing to the same teacher.<br/>
One got X3%, the other got X5% (X is > 5, both passed), but you wouldn't believe how much the "cathegory grades" for each aspect of the production differed! Although it was the exact same thing!<br/>
<br/>
Knowing that, the grades seemed so random - all due to "warped" perception and uncontious subjectivity. Take it from someone who know what "warped" perception actually look, smells, feels, tastes and sounds like. ;^)<br/>
<br/>
<br/>
But back on topic: By that I didn't want to say you misinterpret things - I can't judge that.<br/>
<br/>
Right now, I'm very interested in the facts, so:<br/>
<br/>
For example: What format are the render buffer lines in? 18bit? 16bit? 24bit? If it's 16bit, then all the 18bit magic happens in the color mapping (16bit -> 18bit). If it's 18bit... that would be odd, so let's assume 24bit instead: then the 24bit 3D rendering would be mapped directly to 18bit.<br/>
<br/>
It's true that captured images look a little dull and less colorful (both due to less gradients) compared to "live" renderes. That would imply, that the conversion is indeed 24bit -> 18bit from render buffer to display, and not 24bit -> 16bit -> 18bit (which wouldn't be that unreasonable at all and that's how the captured images get displayed!)<br/>
<br/>
But even that doesn't give you any controll over the color range... And blending is min((0..16 + 0..16) / 2), 16).<br/>
<br/>
... Blending is a very specific topic and my experience with capturing tells me, that everything is getting rounded down and clamped, so choose your values wisely to make it fit your image, not ruin it. ;^)<br/>
<br/>
Well, does anyone have any other ideas?</div>    
</div>
<div class="post">
    <h4>#159501 - Cydrak - Wed Jul 02, 2008 2:32 am</h4>
    <div class="postbody">Hmm... I got <em class="text-italics">too</em> curious. Mind the random photos! Had to grab something...<br/>
<br/>
<a class="postlink" href="http://draci.chaosnet.org/code/ex-18bpp.zip">18 bpp display demo</a><br/>
<br/>
I think this would look awesome in paint apps, where the color banding is actually really obvious to me. Or dark/toony cutscene artwork, like Zelda has or something. Photos are more of a mixed bag.<br/>
<br/>
Either way, lookit that gradient. 64 greyshades, mmm... @_@</div>    
</div>
<div class="post">
    <h4>#159533 - fluff - Wed Jul 02, 2008 12:24 pm</h4>
    <div class="postbody">Cool stuff! :) That's quite a difference in appearance...<br/>
<br/>
I haven't used it myself, but isn't there a comic book viewer of some sort for the ds? Seems like that too could make good use of this.</div>    
</div>
<div class="post">
    <h4>#159537 - silent_code - Wed Jul 02, 2008 1:12 pm</h4>
    <div class="postbody">This is indeed a very interesting approach. You should write about it and explaint it a little bit more in depth. :^)<br/>
<br/>
Do you think blending is done in 24bit?</div>    
</div>
<div class="post">
    <h4>#159555 - sverx - Wed Jul 02, 2008 4:58 pm</h4>
    <div class="postbody"><blockquote><div><cite>Cydrak wrote:</cite><a class="postlink" href="http://draci.chaosnet.org/code/ex-18bpp.zip">18 bpp display demo</a></div></blockquote>

You did it??? That's amazing... I'm going to test it on the hardware as soon as possible, it doesn't work with the emulator (at least with no$gba -at least it seems to me-)<br/>
<br/>
Anyway what you place in the palette of the second background it's unclear to me... did you build 8 color with the different possible combinations of the 3 least significant bit and you 'add' (blend) it to the other image? So the 1st image is exactly the same (16/16) and the other one is what was 'lost' in the 18->15 bit transformation?<br/>
<br/>
I've got to understand how it works, I was going to write a test myself but using 2 blended 'full' (256-colors) palettes, blending together the 8/16 of both... but I think you've got a smarter idea :)<br/>
<br/>
Ciao :)</div>    
</div>
<div class="post">
    <h4>#159594 - Cydrak - Wed Jul 02, 2008 8:46 pm</h4>
    <div class="postbody"><blockquote><div><cite>sverx wrote:</cite>You did it??? That's amazing... I'm going to test it on the hardware as soon as possible, it doesn't work with the emulator (at least with no$gba -at least it seems to me-) </div></blockquote>
Ah yeah, emulators will probably round it down to get 15bpp again. Even NO$GBA does that for some reason.<br/>
<blockquote><div><cite>sverx wrote:</cite>did you build 8 color with the different possible combinations of the 3 least significant bit and you 'add' (blend) it to the other image? So the 1st image is exactly the same (16/16) and the other one is what was 'lost' in the 18-&gt;15 bit transformation?</div></blockquote>
Yes, exactly!<br/>
<blockquote><div><cite>silent_code wrote:</cite>Do you think blending is done in 24bit?</div></blockquote>
Not sure, really. Although it's fun to speculate about the hardware, I'm mainly interested in what I can see. Unfortunately it isn't possible to run an 18-bit capture, so I've just been counting greyshades! (On DSLites, the darkest levels are very distinct.)<br/>
<br/>
I'm not certain but I expect it's as simple as possible: (((5bit channel<<1) * (factor 0..16)) + 8) >> 4, with the results summed and clamped. I'm fairly sure the rounding (+8) is in there, due to "centered" spacing of the gradient with low blend factors. By blending various colors at 1/16 it may be possible to test, e.g., whether the downshift occurs before or after the sum.<br/>
<blockquote><div><cite>silent_code wrote:</cite>This is indeed a very interesting approach. You should write about it and explaint it a little bit more in depth. :^)</div></blockquote>
Thanks. :) There really isn't much to explain. Any method of showing two layers should work; all I think is required is the 1A + 1/16B blend.<br/>
<br/>
In my program the normal layer is "A". It has the usual 15 bit pixels. I just used a bitmap for clarity and generality. If you have preconverted artwork, extended palettes should work--that's 4096 "18 bit" colors at half the pixel size. For dark scenes, I'm sure this would still be an improvement.<br/>
<br/>
"B" is the special layer, and the only reason I got fancy is to use the compact 4bpp tilemaps. Of that, 1bpp is ignored, wasting 6K or so. The other 3bpp are the low "RGB" bits, which index 8 matching colors in BG_PALETTE.<br/>
<br/>
From there the process looks like this (*3 channels, for RGB):<br/>
1) "A" supplies 5 bit data (range 0..31).<br/>
2) Hardware shifts left to get 6 bits (range is now 0..62).<br/>
3) Hardware multiplies by 16/16 so "A" is unchanged.<br/>
4) "B" supplies 5 bit values of 0 and 8.<br/>
5) Hardware shifts these left: now 0 and 16.<br/>
6) Hardware multiplies by 1/16: now 0 and 1.<br/>
7) Summing combines the two.<br/>
<br/>
Another way to look at it:<br/>
- Input: A (5 bit channel), 8*B (low bit)<br/>
- Conversion: 2*A * 16/16 + 2*(8*B) * 1/16<br/>
- Output: 2*A + B (6 bits)<br/>
<br/>
Btw, I observed this to give the full 64 values. RGB5(31,31,31) seems to display as RGB6(62,62,62), because it takes one more "shade" to saturate the blend.</div>    
</div>
<div class="post">
    <h4>#159598 - silent_code - Wed Jul 02, 2008 9:43 pm</h4>
    <div class="postbody">This is <strong class="text-strong">very</strong> impressive when seen on hardware!<br/>
<br/>
Thank you! :^D<br/>
<br/>
I guess we can savely assume blending happens in super 15bit color range.<br/>
<br/>
EDIT: gbatek states that the 3D rendered image is in 18bit! (Then it was just lighting or rendering, that was calculated in 24bit... something *was* 24bit!)<br/>
Fog is a blending post processing effect and because all blending is likely to happen in one place, it is 18bit.<br/>
<br/>
Lesson learned. :^) This is pure fun to me. :^D<br/>
<br/>
And thanks for the info!<br/>
<br/>
I know I could read the sources, but I am rather busy with my own <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=159591#159591">stuff</a>, so could you write (just the general appreach) about how you converted the 24bit image to a (15 + 3)bit one? Unless I haven't overlooked it, you didn't mention it. :^)</div>    
</div>
<div class="post">
    <h4>#159611 - Cydrak - Thu Jul 03, 2008 12:46 am</h4>
    <div class="postbody"><blockquote><div><cite>silent_code wrote:</cite>and because all blending is likely to happen in one place, it is 18bit. </div></blockquote>
You would think so, but I doubt it! There are at least three types of blending I can think of: BLEND_CR, POLY_ALPHA and fog. I posted a <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=151596&amp;highlight=blendcr#151596">3D blending example</a> awhile back. The details are weird, but when BG shows through polys... then 3D RGB will be correct, but alpha may not be.<br/>
<blockquote><div><cite>silent_code wrote:</cite>so could you write (just the general appreach) about how you converted the 24bit image to a (15 + 3)bit one? Unless I haven't overlooked it, you didn't mention it. :^)</div></blockquote>
For each channel I drop bits 0 and 1. Bit 2 goes on the 3bpp layer, and bits 3-7 go with the 15bpp as usual. Is that what you mean?
<div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>// Palette for the 3bpp layer &amp;#40;in the source this is just written out&amp;#41;
for&amp;#40;rgb = 0; rgb &lt; 16; rgb++&amp;#41;
    pal3&amp;#91;rgb&amp;#93; = RGB15&amp;#40; 8*&amp;#40;rgb&gt;&gt;2 &amp; 1&amp;#41;, 8*&amp;#40;rgb&gt;&gt;1 &amp; 1&amp;#41;, 8*&amp;#40;rgb &amp; 1&amp;#41; &amp;#41;;

foreach&amp;#40;pixel24&amp;#41; &amp;#123;
  int r = pixel24     &amp; 0xff;  // depends on your pixel format!
  int g = pixel24&gt;&gt; 8 &amp; 0xff;
  int b = pixel24&gt;&gt;16 &amp; 0xff;
  
  // This is basically x * 64/256 or x&gt;&gt;2.
  // I considered doing a rounded x * 63/255, but it's not a
  // clean 2^n, so results would prolly be less uniform.
  
  int pixel15 = 0x8000 | RGB15&amp;#40;r&gt;&gt;3, g&gt;&gt;3, b&gt;&gt;3&amp;#41;;
  int pixel3  = 8 | &amp;#40;r &amp; 4&amp;#41; | &amp;#40;g&gt;&gt;1 &amp; 2&amp;#41; | &amp;#40;b&gt;&gt;2 &amp; 1&amp;#41;;
  
  // Now toss pixel15 into a palette or a bitmap,
  // and pixel3 into a tile &amp;#40;of course, you'll need a map too&amp;#41;.
&amp;#125;</code></pre></div>
As for layers, I have 16bpp + 4bpp, but that's not the only option. I used a pair of 8bpp for the gradient test--a waste, but it works just fine.<br/>
<br/>
I <em class="text-italics">think</em> you could even pull off affine mode, even if it's 8bpp-only. Fill in a <em class="text-italics">pair</em> of extended palettes, like I did with the smaller one above... but use low/high nibbles of the index. That should let you pack two 4bpp tiles together (so effectively the palette# becomes part of your tile#). Sadly not my idea--NES Elite makes a good example.<br/>
<blockquote><div><cite>silent_code wrote:</cite>Lesson learned. :^) This is pure fun to me. :^D </div></blockquote>
Agreed, the DS is a blast to work with! It's also been a serious learning experience, having to think, devise experiments, and work things out when you <em class="text-italics">can't</em> just barge in with a debugger... (Yup, I waited too long--no NO$GBA for me. :-( )</div>    
</div>
<div class="post">
    <h4>#159635 - sverx - Thu Jul 03, 2008 9:24 am</h4>
    <div class="postbody"><blockquote><div><cite>Cydrak wrote:</cite>RGB5(31,31,31) seems to display as RGB6(62,62,62), because it takes one more "shade" to saturate the blend.</div></blockquote>

mmm... that means that everywhere when we display a pixel that has a  RGB5(31,31,31) color the display isn't using the brightest white it can display but the last (the brightest) gray 'before' the white? Weird! ;)<br/>
<br/>
I gave a look to your code and it's really self explaining, so now we just need to find a name for that mode and spread the knowledge :) (For instance I guess the image viewers/video players applications will have a 'plus' using that mode... I've seen the difference in your image named "iridescent" and it's almost incredible... :) )<br/>
<br/>
Ciao :)</div>    
</div>
<div class="post">
    <h4>#159637 - tepples - Thu Jul 03, 2008 11:54 am</h4>
    <div class="postbody">It's too bad Colors! fizzled out.<br/>
<br/>
Could we simulate 7 bits per channel by combining this 6-bit blending mode with flickering?</div>    
</div>
<div class="post">
    <h4>#159642 - silent_code - Thu Jul 03, 2008 2:29 pm</h4>
    <div class="postbody">Well, yes, that was what I wanted to know. Thank you! :^D<br/>
<br/>
Now, for another question: For "synthetic" images and illustrations, it's simply AMAZING in terms of quality gain! But with photos, there seems to be no real advantage of using the technique. At least I couldn't see any increase in image quality on the NDSp. :^(<br/>
<br/>
So, the question is: Is it worth it? Do video players really need it? Will the increased color depth affect anything? We are talking about highly compressed video streams, that's not exactly illustrations with a lot of gradients (which this technique improves "over the top" - at least! ;^D ), but ever changing (at around 15 hz) blocks of very mostly simmilar colors.<br/>
<br/>
I don't have much experience (if any, really) with video stream coding, but I think I got the concept... So, I'd like to read, what more experienced people have to write about it.<br/>
<br/>
Well, yet another question: Can you think about a possible technique (build on top of this one - which I would describe as "Dual Layer 18bit Blending" [DL18bB] <lol> ;^p) to improve gradients in 3D scenes? Obviously there are some comlications, e.g. processing a lot of date (the whole image, which would be captured, thus 15bit anyway... I didn't have the time to think a lot about this. ;^)<br/>
I guess there's just capture blending to make the 3D scene shiny and distract the eye from the horrible color bending. ;^D</div>    
</div>
<div class="post">
    <h4>#159643 - sverx - Thu Jul 03, 2008 2:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Could we simulate 7 bits per channel by combining this 6-bit blending mode with flickering?</td> </tr></table><span class="postbody">
<br/>
<br/>
If you mean display one 18bpp image every two frames and another 18bpp image (with little differences from the 1st) the other frame... well, theoretically it's possible, IMHO. But I think a little flicker will be visible and maybe it will be annoying... :|</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177833 - sverx - Tue Mar 26, 2013 10:12 am</h4>
    <div class="postbody"><span class="postbody">Sorry for reviving this very old topic... the matter is that I exploited this a little more and the results are quite impressive (but you've got to see it on hardware to believe it)
<br/>
<br/>
details here: <a href="http://adshomebrewersdiary.blogspot.com/2013/03/one-hundred-twenty-seven-shades-of-grey.html" target="_blank">http://adshomebrewersdiary.blogspot.com/2013/03/one-hundred-twenty-seven-shades-of-grey.html</a>
<br/>
<br/>
... I hope you like it :)<br/>_________________<br/><a class="postlink" href="http://bit.ly/yiQrz9" target="_blank">libXM7</a>|<a class="postlink" href="http://bit.ly/yJwcOo" target="_blank">NDS programming tutorial (Italiano)</a>|<a class="postlink" href="http://disjointedstudio.blogspot.com/" target="_blank">Waimanu DS / GBA</a>|<a class="postlink" href="http://adshomebrewersdiary.blogspot.com" target="_blank">A DS Homebrewer's Diary</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
