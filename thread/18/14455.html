<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>[mini-tuto] How to rotate an object around its local axis - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > [mini-tuto] How to rotate an object around its local axis</h2>
<div id="posts">
<div class="post">
    <h4>#144560 - Noda - Sat Nov 03, 2007 9:17 pm</h4>
    <div class="postbody"><span class="postbody">Hi! After my problem concerning that question had been solved (see <a href="http://forum.gbadev.org/viewtopic.php?t=14394" target="_blank">http://forum.gbadev.org/viewtopic.php?t=14394</a>), I've been told to write a mini-tuto with the solution, and I thought it was a good idea, so here it is ;)
<br/>
<br/>
In my case, the goal was to have a ball rolling on a surface, so I'll take that as an example.
<br/>
<br/>
<span style="font-weight: bold">MINI-FAQ:</span>
<br/>
<br/>
- Q: Why can't I use glRotate() to simple rotate my object?
<br/>
- A: glRotate() is based on the world's axis, so when it will work for a single axis rotation, but when you want to rotate an object along mulple axis at the same time, the first rotation affects the other axis causing your rotation to be wrong. That's why you need to use object's local axis to do the rotation.
<br/>
<br/>
<span style="font-weight: bold">
<br/>
HOW TO:</span>
<br/>
<br/>
There's different methods to do this, but I'll explain only the one I used.
<br/>
<br/>
First you need to have a matrix for your object, storing its current rotation. 
<br/>
Let's call it the object matrix, O.  
<br/>
At first you initialize it with its original rotation (identity in the general case).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    m3x3 objmat;
<br/>
    // initialize ball rotation
<br/>
    matLoadIdentity(&amp;matobj);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Then you have to build the rotation matrix, R: it's the one that will be used to rotate your object. The rotation that will be applied here is relative to the current rotation state of the object (stored in O), so you have to use relative angles here.
<br/>
<br/>
Here is how it is built:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    m3x3 matrot;
<br/>
<br/>
    int32 cosX = cosf32(xa);
<br/>
    int32 cosY = cosf32(ya);
<br/>
    int32 cosZ = cosf32(za);
<br/>
    int32 sinX = sinf32(xa);
<br/>
    int32 sinY = sinf32(ya);
<br/>
    int32 sinZ = sinf32(za);
<br/>
<br/>
    matrot.m[0] = mulf32(cosZ, cosY);
<br/>
    matrot.m[3] = mulf32(cosZ, mulf32(sinY, sinX)) - mulf32(sinZ, cosX);
<br/>
    matrot.m[6] = mulf32(sinZ, sinX) + mulf32(cosZ, mulf32(sinY, cosX));
<br/>
<br/>
    matrot.m[1] = mulf32(sinZ, cosY);
<br/>
    matrot.m[4] = mulf32(cosZ, cosX) + mulf32(sinZ, mulf32(sinY, sinX));
<br/>
    matrot.m[7] = mulf32(sinZ, mulf32(sinY, cosX)) - mulf32(cosZ, sinX);
<br/>
<br/>
    matrot.m[2] = -sinY;
<br/>
    matrot.m[5] = mulf32(cosY, sinX);
<br/>
    matrot.m[8] = mulf32(cosY, cosX);</td> </tr></table><span class="postbody">
<br/>
<br/>
After that, you want to rotate your object: it's done by multiplying your object matrix by the rotation matrix.
<br/>
<br/>
O' = O * R. 
<br/>
<br/>
Note that the order of the multiplication is important, as with matrix, A*B is diiferent from B*A!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    m3x3 matnew;
<br/>
    matMult(&amp;matobj, &amp;matrot, &amp;matnew);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Now we have the new rotation applied for our object, let's save it into our object matrix:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">matCopy(&amp;matobj, &amp;matnew);</td> </tr></table><span class="postbody">
<br/>
<br/>
Another step that need to be done (but not necessarily every frame), is to re-orthogonalize and re-normalize the matrix. Because we are using here 20.12 fixed point precision (the NDS original format), the matrix gets somewhat distorted due to rounding errors, that's whay you need regulary apply this step to the object matrix.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">matOrthogonalize(&amp;matobj);</td> </tr></table><span class="postbody">
<br/>
<br/>
Now everything is set up to draw our object:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    // push the current matrix onto the stack (save state)
<br/>
    glPushMatrix();
<br/>
<br/>
      glTranslate3f32(x, y, z);     // move the object
<br/>
      glMultMatrix3x3(&amp;matobj);  // rotate the object
<br/>
<br/>
      // draw you model here
<br/>
<br/>
    glPopMatrix(A);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Then you're done!
<br/>
Note that the rotation is here applied before the rotation, it's strange because it should have been after but if you put it after the point of rotation will be affected (it should be the opposite). Anyways, that's how it's working for me, it's not really a problem but I had to point it.
<br/>
<br/>
Here is now for you the code of the functions I used, I did not detailled them before to simplify the explications.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// orthogonalize &amp; normalize the given 3x3 matrix
<br/>
void matOrthogonalize(m3x3 *mat) 
<br/>
{
<br/>
    int32 *x = &amp;mat-&gt;m[0];
<br/>
    int32 *y = &amp;mat-&gt;m[3];
<br/>
    int32 *z = &amp;mat-&gt;m[6];
<br/>
<br/>
    // calculate the 2nd axis from the 1st &amp; the 3rd 
<br/>
    crossf32(z, x, y);
<br/>
<br/>
    // calculate the 3rd axis from the 1st &amp; the 2nd
<br/>
    crossf32(x, y, z);
<br/>
<br/>
    // normalize the axis
<br/>
    normalizef32(x);
<br/>
    normalizef32(y);
<br/>
    normalizef32(z);
<br/>
}
<br/>
<br/>
// multiply two 3x3 matrix
<br/>
void matMult(m3x3 *mat1, m3x3 *mat2, m3x3 *mat) 
<br/>
{
<br/>
    int i, j, k;
<br/>
    
<br/>
    for(i=0; i&lt;9; i++)
<br/>
        mat-&gt;m[i] = 0;
<br/>
    
<br/>
    for(i=0; i&lt;3; i++)
<br/>
        for(j=0; j&lt;3; j++)
<br/>
            for (k=0; k&lt;3; k++)
<br/>
                mat-&gt;m[3*i + j] += mulf32(mat1-&gt;m[3*i + k], mat2-&gt;m[3*k + j]);
<br/>
}
<br/>
<br/>
// reset the given 3x3 matrix to identity
<br/>
void matLoadIdentity(m3x3 *mat)
<br/>
{
<br/>
    mat-&gt;m[0] = 1 &lt;&lt; 12;
<br/>
    mat-&gt;m[3] = 0;
<br/>
    mat-&gt;m[6] = 0;
<br/>
<br/>
    mat-&gt;m[1] = 0;
<br/>
    mat-&gt;m[4] = 1 &lt;&lt; 12;
<br/>
    mat-&gt;m[7] = 0;
<br/>
<br/>
    mat-&gt;m[2] = 0;
<br/>
    mat-&gt;m[5] = 0;
<br/>
    mat-&gt;m[8] = 1 &lt;&lt; 12;
<br/>
}
<br/>
<br/>
// copy the second 3x3 matrix into the first one
<br/>
void matCopy(m3x3 *matdest, m3x3 *matsrc)
<br/>
{
<br/>
    int i;
<br/>
    for(i=0; i&lt;9; i++)
<br/>
        matdest-&gt;m[i] = matsrc-&gt;m[i];
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Hope that will be useful to some, enjoy ;)
<br/>
<br/>
Thanks to sajiimori, Rajveer &amp; silent_code for helping me getting the solution of this problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#144618 - sajiimori - Sun Nov 04, 2007 8:43 pm</h4>
    <div class="postbody"><span class="postbody">So this uses Euler angles -- pitch, yaw, roll, which you called xa, ya, and za -- to rotate an object along its local axes?  If so, it's important to note the order in which the rotations are applied, for the same reasons that rotation order was important when using world axes: earlier rotations affect later ones.
<br/>
<br/>
You can remove a normalize call from matOrthogonalize.  I posted an example in the original thread.
<br/>
<br/>
Definitely grab a faster matrix multiply from somewhere.  You can also remove the extra copy by multiplying straight into the final destination, if the multiply function is designed to read once and write once.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#144629 - sajiimori - Sun Nov 04, 2007 11:44 pm</h4>
    <div class="postbody"><span class="postbody">Here's a thread with some information about reversing the order of transformations on GL-like platforms:
<br/>
<a class="postlink" href="http://www.gamedev.net/community/forums/topic.asp?topic_id=469955&amp;whichpage=1&amp;#3089272" target="_blank">http://www.gamedev.net/community/forums/topic.asp?topic_id=469955&amp;whichpage=1&amp;#3089272</a>
<br/>
<br/>
Honestly, I've never really understood it -- I've been skating by with rules of thumb.
<br/>
<br/>
Edit: I just found this explanation, which helped me a lot!
<br/>
<a class="postlink" href="http://glprogramming.com/red/chapter03.html#name2" target="_blank">http://glprogramming.com/red/chapter03.html#name2</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#144678 - Noda - Mon Nov 05, 2007 6:08 pm</h4>
    <div class="postbody"><span class="postbody">Nice find about the order of matrix multiplications ;)
<br/>
<br/>
Concerning the code, I know it's not optimized, but it was designed to be easy to understand &amp; functional ;) (I could also have used the hardware matrix unit to make the multiplication)
<br/>
<br/>
By the way, could it be possible to have a pinned post with a link to all tutorials posted on Gbaddev? that could be nice and useful to avoid wasting time with the search function..</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#144693 - sajiimori - Mon Nov 05, 2007 8:57 pm</h4>
    <div class="postbody"><span class="postbody">On the topic of understandability: I'm still not sure what the code does.  Are you using Euler angles to rotate an object along its local axes, and if so, in what order are the angles applied?  (XYZ, ZXY, etc)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#144732 - Noda - Tue Nov 06, 2007 3:53 am</h4>
    <div class="postbody"><span class="postbody">The code I've posted takes angles in degrees and rotates the axis in this order: Z -&gt; Y -&gt; X.
<br/>
I know this leads to the same problem as glRotate, but the fact is that it's not noticable, as the object matrix is then updated ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145038 - Moby Disk - Sat Nov 10, 2007 8:48 pm</h4>
    <div class="postbody"><span class="postbody">It looks to me like doing the matrix multiplications yourself would result in the same exact problem.  In the past, I've used quaternions instead of euler angles to solve this problem.
<br/>
<br/>
Matrix and Quaternion FAQ:
<br/>
<a class="postlink" href="http://www.j3d.org/matrix_faq/matrfaq_latest.html" target="_blank">http://www.j3d.org/matrix_faq/matrfaq_latest.html</a>
<br/>
<br/>
I made an implementation of quaternions for the PC years ago. At some point I'll be doing 3D on the DS and I'll want to port it.  
<br/>
<a class="postlink" href="http://www.mobydisk.com/softdev/software/geogl/index.html" target="_blank">http://www.mobydisk.com/softdev/software/geogl/index.html</a>
<br/>
<br/>
When you all do matrix operations on the DS, are you using fixed-point, or do you use floating point and then convert to fixed?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145073 - Noda - Sun Nov 11, 2007 4:50 am</h4>
    <div class="postbody"><span class="postbody">The fact is that it's working using this simple method ;-)
<br/>
<br/>
And for sur the matrix operation are done in fixed point.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
