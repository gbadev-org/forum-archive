<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>BSP vs Octree vs Portal - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > BSP vs Octree vs Portal</h2>
<div id="posts">
<div class="post">
    <h4>#149398 - Mr Snowflake - Sat Jan 19, 2008 4:33 pm</h4>
    <div class="postbody"><span class="postbody">Hi guys
<br/>
<br/>
I was wondering for a good 3D file type for the levels/maps of a 3D game. I was looking in to bsp files from quake, but I read somewhere on this forum, these aren't really good suited for the DS. So now I'm in need of a file type/structure to load and display 3D levels from. The file type should also have a map editor, as I'm not planning on creating my own... :).
<br/>
<br/>
[edit]Title changed read <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=149492#149492" target="_blank">later post</a>.<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"><br/><br/>Last edited by Mr Snowflake on Mon Jan 21, 2008 1:05 am; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#149402 - tepples - Sat Jan 19, 2008 7:42 pm</h4>
    <div class="postbody"><span class="postbody">Bitmap.
<br/>
<br/>
Each pixel in the bitmap represents one cubic tile, as viewed from overhead. You determine which cells to draw and which cells not to draw by <a class="postlink" href="http://en.wikipedia.org/wiki/Ray_casting" target="_blank">tracing rays from the player's point of view</a>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149454 - Mr Snowflake - Sun Jan 20, 2008 11:47 am</h4>
    <div class="postbody"><span class="postbody">Is that usable on the DS? And how usefull is it?
<br/>
<br/>
[edit]I was thinking more along the lines of a file format which is used by Metroid Prime: Hunters of some sorts.<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149460 - tepples - Sun Jan 20, 2008 2:22 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mr Snowflake wrote:</b></span></td> </tr> <tr> <td class="quote">Is that usable on the DS? And how usefull is it?</td> </tr></table><span class="postbody">
<br/>
A 2D array is precisely the format that <span style="font-style: italic">Wolfenstein 3D</span> and <span style="font-style: italic">Animal Crossing: Wild World</span> use for maps. As for the models that represent the contents of cells, those might be stored in DS display list format.
<br/>
<br/>
My philosophy: If you have no idea how to do something, just get it working. Then you'll be able to see the limitations of a given method in order to ask for more directed help. In this case, once you get ray casting into a 2D array working, you'll be able to understand my description of what the Build engine of <span style="font-style: italic">Duke Nukem 3D</span> and other portal engines do.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149462 - Mr Snowflake - Sun Jan 20, 2008 2:44 pm</h4>
    <div class="postbody"><span class="postbody">I know wolfenstein uses it, but then you don't have heights, so no slopes or anything. But it's indeed a good thing to start.<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149464 - tepples - Sun Jan 20, 2008 2:54 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Mr Snowflake wrote:</b></span></td> </tr> <tr> <td class="quote">I know wolfenstein uses it, but then you don't have heights, so no slopes or anything.</td> </tr></table><span class="postbody">
<br/>
Once you do get the main rendering capability in, you can say that, for example, 137 is this sort of slope, 149 is that sort of slope, 151 is some sort of pillar within a cell, 152 is a stove, etc.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149467 - kiwibonga - Sun Jan 20, 2008 3:28 pm</h4>
    <div class="postbody"><span class="postbody">Metroid Prime Hunters uses something similar to BSP -- each room is actually a 3D model. What's particular about it is that when you open a door, it loads the next room and adds it to the scene. When the door behind you closes, it removes the previous room from memory. It can't ever have more than two rooms loaded in memory this way, it's basically a nice way to provide seamless gameplay by avoiding loading times and ensuring a low polygon count without resorting to complex culling algorithms (which tend to constrict your level design by making you create maze-like levels in small spaces). The only time you'll see loading in the GC metroids, for instance, is when you move from one major area to the other, where a lot of textures have to be reloaded. To push the number of polygons you can display, if you have a huge room, you can simply make all rooms directly adjascent to it small corridors, that way you have a guaranteed low poly count.
<br/>
<br/>
I think that system is probably the best for the DS, because it allows you to always know how many polygons you'll have in a given space, and push the hardware to the limits. You can have overhangs, floating platforms, caves, and slopes that don't look like they were cut right out of the ground with a cake knife.
<br/>
<br/>
What's severely limiting about it is usually that by the time you're done with your maps, you'll realize your enemies have to look like a bunch of glued pyramids and sticks... And the low resolution textures you apply to them will be pretty gross and jagged...
<br/>
<br/>
That's why I'm making a PC game right now... The DS was too depressing :P<br/>_________________<br/><a href="http://www.kiwibonga.com" target="_blank">http://www.kiwibonga.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149476 - sajiimori - Sun Jan 20, 2008 8:13 pm</h4>
    <div class="postbody"><span class="postbody">Using plain old display lists is the easiest thing for 3D background visuals.  Collision is another story...
<br/>
<br/>
Somebody should really produce a free, fast background collision library for DS!  A lot of people seem to get stuck on it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149492 - Mr Snowflake - Mon Jan 21, 2008 1:04 am</h4>
    <div class="postbody"><span class="postbody">Well, I discovered the question I asked was pretty bad :). I should have asked: Which 3D Partition Scheme is best to use on the DS for indoor maps? BSP, Octrees or Portals or maybe some other technique I don't know about.
<br/>
<br/>
You could probably use a Q2 bsp tree and delete/discard all data you won't use for the DS, but as I read bsp is probably a bit to dated for use on the DS which has a Z-buffer. But you have more knowledge on the workings of the DS, so I'd like your opinion on this.<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149494 - kusma - Mon Jan 21, 2008 1:29 am</h4>
    <div class="postbody"><span class="postbody">I guess your answer depends heavily on your input-data... One thing to keep in mind, is that you don't want something that force you to render in small batches. You'd want to make some medium-sized batches that allow vertex-reuse and triangle-stripping, while not giving too much occluded data. For an in-door renderer, I think a portal/PVS renderer might be a good choice.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149497 - sajiimori - Mon Jan 21, 2008 5:03 am</h4>
    <div class="postbody"><span class="postbody">First, consider exporting the entire background as a single model and rendering it whole.
<br/>
<br/>
If you know for a fact that you can't draw it that way, consider manually breaking it into large sections and using hand-placed triggers to show/hide the sections.  This may seem primitive, but it allows you to carefully budget the number of polys in the scene, which is critical on the DS.
<br/>
<br/>
Hardly any DS games use higher-tech solutions than that, but if you really want to get fancy for some reason, portals are probably the way to go.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149519 - Mr Snowflake - Mon Jan 21, 2008 3:07 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">First, consider exporting the entire background as a single model and rendering it whole.</td> </tr></table><span class="postbody">I do not completely understand this. What do you mean by background? You mean 1 'room' as one model?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">If you know for a fact that you can't draw it that way, consider manually breaking it into large sections and using hand-placed triggers to show/hide the sections.  This may seem primitive, but it allows you to carefully budget the number of polys in the scene, which is critical on the DS.</td> </tr></table><span class="postbody">This could be considered as some kind of basic portal engine? Without the expensive frustum culling.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Hardly any DS games use higher-tech solutions than that, but if you really want to get fancy for some reason, portals are probably the way to go.</td> </tr></table><span class="postbody">How would a portal engine be doing, if you just render the portals which I see from my camera point and don't do any frustum culling. I loose a lot of possible vertices I could render, but I don't have the cpu speed penalty of the frustum culling.
<br/>
<br/>
It's probably best to test some stuff myself :).<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149524 - kiwibonga - Mon Jan 21, 2008 5:26 pm</h4>
    <div class="postbody"><span class="postbody">Portals, as in you draw a snapshot of a "hidden" scene within a scene? I don't see how that can be less expensive than simply plugging Section 2 behind the door to Section 1 :s<br/>_________________<br/><a href="http://www.kiwibonga.com" target="_blank">http://www.kiwibonga.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149525 - Mr Snowflake - Mon Jan 21, 2008 6:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kiwibonga wrote:</b></span></td> </tr> <tr> <td class="quote">Portals, as in you draw a snapshot of a "hidden" scene within a scene? I don't see how that can be less expensive than simply plugging Section 2 behind the door to Section 1 :s</td> </tr></table><span class="postbody">
<br/>
It won't be less expensive cpu time wise, but I costs more vertices, which are limited on the DS.<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149527 - M3d10n - Mon Jan 21, 2008 7:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kiwibonga wrote:</b></span></td> </tr> <tr> <td class="quote">Portals, as in you draw a snapshot of a "hidden" scene within a scene? I don't see how that can be less expensive than simply plugging Section 2 behind the door to Section 1 :s</td> </tr></table><span class="postbody">
<br/>
<br/>
I think he means portals as in rendering a room only if the door that leads to it is visible. I have yet to test it, but portals could be a fairly fast way to implement indoor levels on the DS. If your rooms only have a couple portals leading to other rooms, the frustum culling should be worth it.
<br/>
<br/>
It works like this: you have your level structured as "rooms". Then you have "portals" which connects two rooms together. Each room contains a list of portals connected to it.
<br/>
<br/>
Then you have a iterative render() function for each room, which does the following:
<br/>
<br/>
1) Render the room;
<br/>
2) For each portal in the room:
<br/>
3) Do a frustum test. If the portal is not visible, test the next portal.
<br/>
4) If the portal is visible, clip the viewport and projection matrix to fit the portal bounding box and call render() on the room the portal leads to.
<br/>
<br/>
Hand placed portals are a good fit for the DS, and if they are simple planes, you can boxTest() them. The hardest part is adjusting the viewport/projection matrix to fit the portal, but this is the most important part: it limits the recursion and vastly reduces the amount of rendered polygons on each iteration, since only polygons visible through the portal will be rendered (which is crucial for the DS).
<br/>
<br/>
I don't get how portals can be considered "high tech" since they've been used way before 3D acceleration became commonplace. On system where you have heavy geometry restrictions, like the DS, they sound like good alternatives.
<br/>
<br/>
Just look at Dementium. The rooms are very detailed, and they are obviously using portals, since they prevent the game from rendering polygons which are behind the corners.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149530 - sajiimori - Mon Jan 21, 2008 8:05 pm</h4>
    <div class="postbody"><span class="postbody">Mr Snowflake,
<br/>
<br/>
By "background", I mean the whole map.  As far as using hand-placed triggers that show/hide map sections, I wouldn't use the word "portal" there -- the approach is really different.
<br/>
<br/>
For instance, the maps on my last game were broken up into sections (by the artists), with doors between them.  The scripters tagged the doors with the section IDs that are in front and behind them, and the code decided which models should be visible based on these tags.
<br/>
<br/>
<br/>
M3d10n, I meant "high tech" in a very relative way -- the solutions I've used are exceedingly basic!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149533 - Mr Snowflake - Mon Jan 21, 2008 8:23 pm</h4>
    <div class="postbody"><span class="postbody">Ah, I see, you really meant triggers, I thought you meant something like a pvs :). My bad.
<br/>
<br/>
Rendering the whole map won't cut it, of the whole map should do in under 3000 vertices...
<br/>
<br/>
But your proposal is actually pretty good, maybe some kind of portal/trigger engine is the best sollution: use triggers if you have doors and of you just have rooms connecting without doors, use portals...<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149548 - DiscoStew - Mon Jan 21, 2008 10:11 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">For instance, the maps on my last game were broken up into sections (by the artists), with doors between them.  The scripters tagged the doors with the section IDs that are in front and behind them, and the code decided which models should be visible based on these tags.</td> </tr></table><span class="postbody">
<br/>
<br/>
Reminds me a lot of the 3D Zelda games, particularly in the dungeons.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149572 - Mr Snowflake - Tue Jan 22, 2008 2:05 am</h4>
    <div class="postbody"><span class="postbody">Ok, now we have established a way to efficiently draw a 3D world. How should collision be handled? Using a BSP tree or Octree from file or generate it when loading. Probably read it from file, but is there a real difference in preformance or memory usage between both?<br/>_________________<br/><a class="postlink" href="http://www.mrsnowflake.be" target="_blank">http://www.mrsnowflake.be</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149573 - sajiimori - Tue Jan 22, 2008 2:57 am</h4>
    <div class="postbody"><span class="postbody">If you do it right, BSP is the fastest and most compact thing around for collision.  There's no need for tests against polygons.  You don't even have to store vertices.
<br/>
<br/>
The Quake BSP code is good for reference.  You can get a big speed boost by doing manual recursion instead of native C recursion, and fixed-point allows planes to be represented in 10 bytes rather than 20.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
