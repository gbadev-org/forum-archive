<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Oct-trees and linked lists - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Oct-trees and linked lists</h2>
<div id="posts">
<div class="post">
    <h4>#115486 - Rajveer - Tue Jan 16, 2007 3:46 pm</h4>
    <div class="postbody"><span class="postbody">Hi guys, I have a 3D world which I need to partition using an octtree data structure. Apparently its easy, but not for me! I'm a bit confused, and would really like a good tutorial on it WITH source code for me to read up on but cant find one. Anybody able to help?
<br/>
<br/>
At the moment I know the theory behind the oct-tree data structure and how it uses 8 linked lists for each node e.t.c but finding it hard to begin.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115489 - kusma - Tue Jan 16, 2007 3:54 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Rajveer wrote:</b></span></td> </tr> <tr> <td class="quote">At the moment I know the theory behind the oct-tree data structure and how it uses 8 linked lists for each node e.t.c but finding it hard to begin.</td> </tr></table><span class="postbody">
<br/>
<br/>
...But it doesn't! Each node has pointers to eight sub-nodes, not 8 linked lists in itself.
<br/>
<br/>
Something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
template &lt;typename T&gt;
<br/>
class Node
<br/>
{
<br/>
public:
<br/>
   std::vector&lt;T&gt; data;
<br/>
   Node *subnodes[8];
<br/>
};
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115490 - Lick - Tue Jan 16, 2007 3:59 pm</h4>
    <div class="postbody"><span class="postbody">Try 'octree' instead of oct-tree. ;)
<br/>
<br/>
edit: yeah kusma is right. Each node simply has an array of 8 childnodes(ptrs).<br/>_________________<br/><a class="postlink" href="http://licklick.wordpress.com" target="_blank">http://licklick.wordpress.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115494 - tepples - Tue Jan 16, 2007 6:08 pm</h4>
    <div class="postbody"><span class="postbody">A lot of "3D" games don't have a lot of height in the dimension parallel to gravity. For these, you might be better off with a <a class="postlink" href="http://en.wikipedia.org/wiki/Quadtree" target="_blank">quadtree</a> than with an <a class="postlink" href="http://en.wikipedia.org/wiki/Octree" target="_blank">octree</a>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115550 - Rajveer - Wed Jan 17, 2007 2:28 am</h4>
    <div class="postbody"><span class="postbody">Cheers for the reply's guys :)
<br/>
<br/>
Ahh I see what you mean kusma, that makes sense. So I'd begin by creating a data structure for a node, which holds pointers to 8 further nodes, and pointers/variables for data. Then I'd create a function to create the octree, which would create a start node containing pointers to its children and test for each polygon where abouts in the base cube it lies, and recursively call an add function which adds 8 new nodes to existing cubes which need to be split. Or something like that :S
<br/>
<br/>
Think I'll have to write alot of pseudo code to get my head round it!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115576 - Ant6n - Wed Jan 17, 2007 9:01 am</h4>
    <div class="postbody"><span class="postbody">i like kd-trees
<br/>
anyhoo, the best rersources about that i found at flipcode. site seems down right now, but a wayback machine should help.
<br/>
<a href="http://72.14.205.104/search?q=cache:KdgcJxIo1dEJ:www.flipcode.com/articles/+flipcode&amp;hl=en&amp;gl=ca&amp;ct=clnk&amp;cd=2&amp;client=firefox-a" target="_blank">http://72.14.205.104/search?q=cache:KdgcJxIo1dEJ:www.flipcode.com/articles/+flipcode&amp;hl=en&amp;gl=ca&amp;ct=clnk&amp;cd=2&amp;client=firefox-a</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115605 - Payk - Wed Jan 17, 2007 8:10 pm</h4>
    <div class="postbody"><span class="postbody">I just use something similar to a 2d tilebased system. Its enough for my project :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116147 - Rajveer - Mon Jan 22, 2007 3:04 pm</h4>
    <div class="postbody"><span class="postbody">Ok I've been thinking about it, and just want to voice my thought so someone can check them.
<br/>
<br/>
At the moment my polygons and polygon data are stored in a data structure as follows:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct
<br/>
{
<br/>
   f32 vertex0[3], vertex1[3], vertex2[3];
<br/>
   t16 tex0[2], tex1[2], tex2[2];
<br/>
   f32 normal[3];
<br/>
   f32 edgeplane0[3];
<br/>
   f32 edgeplane1[3];
<br/>
   f32 edgeplane2[3];
<br/>
} polydata;
<br/>
<br/>
polydata Level1Poly[x]; //x is the no of polygons</td> </tr></table><span class="postbody">
<br/>
<br/>
where vertex0-vertex2 are the vertices, each with x y and z components, tex0-tex2 are 2d texture coords, normal is the normal to the plane and edgeplanes are the edges of the planes previously worked out for less processing.
<br/>
<br/>
Now for each node of the octree I have to store this data for the polygons. First I will find the max and min x,y and z coords of all the polygons to find the two corners of the first node. Once I've found these I can create the box and workout the size of it. I'm not too confident in programming, and this is the most complex thing I've had to do, so please bear with my "newbishness" ;) I have to:
<br/>
<br/>
Test each polygon to see whether it fits inside the original box (which it obviously will) and then find out how many polygons lie within the box. If its greater than the preset value, split the box into 8 smaller cubes and test for each polygons if it fits within these boxes e.t.c.
<br/>
<br/>
So for each node, I'd have an array of polygons with the details for each, and a counter to count the total number of polygons in the node. On some sites I've read that the nodes will have a pointer to data, but it doesnt matter right? Also, I'd store 8 pointers to its nodes, which will be null if there are no nodes after it (leaf).
<br/>
<br/>
Also, what I'm thinking is that I'd create the first node and a "createNode" function which will create nodes within nodes (the recursion), and I'd keep calling this createNode function each time the current node has more polygons than the preset. Does this sound right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116188 - dannyboy - Tue Jan 23, 2007 1:29 am</h4>
    <div class="postbody"><span class="postbody">A couple of comments:
<br/>
1. You could make it a class instead of a struct, and thus have the data and functions for processing the data better intergrated.
<br/>
2. Are you not going to keep track of the vertex normals?
<br/>
3. You could also define a Vector class with respective operations to further break things down.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116246 - silent_code - Tue Jan 23, 2007 5:35 pm</h4>
    <div class="postbody"><span class="postbody">you could reduce memory usage with vertex pointers or indexing to a vertex array (aka vertex pool) instead of saving vertices per triangle. make a vertex struct (that also includes its normal) and use three indices to access vertex data (e.g. three short ints or bytes for medium size meshes - we're talking about nds programming, so meshes won't have thousands of vertices anyway). it's possible this could increase memory usage because you have those addicional indices or pointers, but most of the time it won't: you often have lot's of adjacent vertices that will get cut down to like 1.5 * triangle_count or less, instead of 3 * triangle_count.
<br/>
it'll also make animation easier: you just transform one vertex, not two, three or more - depends on how much triangles include that vertex.
<br/>
<br/>
as far as i understand you, you're right. with trees, you can either define how deep it gets or how much data each leaf should contain. when splitting into child boxes, you'll have to check each triangle if it is (1) fully inside the boundig box (bb), (2) fully outside the bb or (3) partly in and out. cases one and two are straight forward, but case 3 needs some extra math. you'll have to cut the triangle into sevaral pieces, depending on how much other bbs contain it (a hughe tri can span sevaral nodes).
<br/>
you can do that e.g. by giving each child a copy of the parent's triangles and the child will cut away (for good!) all parts that stick out of it's bb, leaving the correct data. make sure you handle texture coordinates and vertex normals right, so there's no visual difference afterwards. non leafs have no data, but the child pointers (at least when talking about level geometry).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116253 - tepples - Tue Jan 23, 2007 6:09 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>silent_code wrote:</b></span></td> </tr> <tr> <td class="quote">you could reduce memory usage with vertex pointers or indexing to a vertex array (aka vertex pool) instead of saving vertices per triangle. make a vertex struct (that also includes its normal)</td> </tr></table><span class="postbody">
<br/>
This will work for surfaces that are supposed to look curved, such as an icosahedron approximating a sphere, as the normal is identical on all triangles that share the vertex. But surfaces with actual corners, such as a cube approximating the shape of a crate on top of a pallet, need to have a separate normal for each triangle that shares the vertex. What would be the flexible way to accommodate these two scenarios?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116256 - ikaris - Tue Jan 23, 2007 7:48 pm</h4>
    <div class="postbody"><span class="postbody">Here's a tutorial that I found...
<br/>
<br/>
hope it helps.
<br/>
<br/>
<a href="http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=1073389&amp;SiteID=1" target="_blank">http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=1073389&amp;SiteID=1</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116261 - Rajveer - Tue Jan 23, 2007 9:11 pm</h4>
    <div class="postbody"><span class="postbody">Cheers for all the replies everyone, I appreciate all the responses!
<br/>
<br/>
I wrote some pseudo-code in between lectures today and have been thinking a bit more about it, and I have some questions.
<br/>
<br/>
1) Why would making it a class instead of a struct make data integration for functions easier?
<br/>
2) Does the code for checking if a node contains polygons exist within the function to create the node?
<br/>
3) To calculate the new texture coordinates of intersecting polygons would I use some sort of linear interpolation?
<br/>
4) How would I store data in the octree nodes i.e. use pointers to data or actually store it within the nodes? (I'll have to create a new data set anyways because of new polygons created from the intersecting code)
<br/>
<br/>
At the moment I'm seeing it this way:
<br/>
<br/>
* Find the max and min of all the vertices and construct a cube from them
<br/>
* Create a start node which stores:
<br/>
   - Pointers to 8 subnodes
<br/>
   - Data of the node's polygons (would this not be a linked list?) including all vertices, normal info e.t.c
<br/>
   - Max, min and centre points of the node
<br/>
   - Polygon counter for the number of polygons in the node
<br/>
* Use a recursion function to:
<br/>
   - Add a new node
<br/>
   - Check for the current node all of the polygons, if they are contained/not contained or intersect
<br/>
   - Call itself 8 times if the number of polygons exceeds a set amount, creating 8 subnodes
<br/>
<br/>
Does this look wrong or totally wrong?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116320 - kusma - Wed Jan 24, 2007 12:17 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>silent_code wrote:</b></span></td> </tr> <tr> <td class="quote">you could reduce memory usage with vertex pointers or indexing to a vertex array (aka vertex pool) instead of saving vertices per triangle. make a vertex struct (that also includes its normal)</td> </tr></table><span class="postbody">
<br/>
This will work for surfaces that are supposed to look curved, such as an icosahedron approximating a sphere, as the normal is identical on all triangles that share the vertex. But surfaces with actual corners, such as a cube approximating the shape of a crate on top of a pallet, need to have a separate normal for each triangle that shares the vertex. What would be the flexible way to accommodate these two scenarios?</span></td> </tr></table><span class="postbody">
<br/>
<br/>
This is very off-topic IMO, but what the hell ;)
<br/>
<br/>
Separate vertex and normal indexing is the most flexible solution IMO, but the most practical way is GPU-style explosion of a mesh and merging vertices where all attributes are identical. This way you can do efficient result-caching on computations, but re-generating normals for a given deformed surface will require extra information to avoid extra smoothing-seams.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116450 - Rajveer - Thu Jan 25, 2007 9:35 pm</h4>
    <div class="postbody"><span class="postbody">Ok guys got some (rather nasty and simple) code I have a problem with, anybody able to take a quick look at my code and help me? It will be alot better/more optimised after I get it to work which is my aim at the moment, its incomplete, also I haven't included all the variables I will need in the node struct e.t.c. so I have alot to do, but cant get this to work at the moment (basically I'm just trying to set up the head node, and check which polygons are likely to intersect it/be contained in it, then check if the number is higher than 10 which is should be):
<br/>
<br/>
Node structure:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
struct node
<br/>
{
<br/>
   f32 maxx, maxy, maxz, minx, miny, minz;
<br/>
   int polycount;
<br/>
   struct node* subnode[8];
<br/>
};</td> </tr></table><span class="postbody">
<br/>
<br/>
Calculates max and min of the first node, and makes a proper cube...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void buildOctree()
<br/>
{
<br/>
//Find max and min x, y and z coords
<br/>
   f32 maxx = 0, maxy = 0, maxz = 0, minx = 0, miny = 0, minz = 0;
<br/>
   int n = 0;
<br/>
   for(n = 0; n &lt; polylimit; n++)
<br/>
   {
<br/>
      if(Level1Poly[n].vertex0[0] &gt; maxx)
<br/>
      {maxx = Level1Poly[n].vertex0[0];}
<br/>
      if(Level1Poly[n].vertex1[0] &gt; maxx)
<br/>
      {maxx = Level1Poly[n].vertex1[0];}
<br/>
      if(Level1Poly[n].vertex2[0] &gt; maxx)
<br/>
      {maxx = Level1Poly[n].vertex2[0];}
<br/>
      
<br/>
      if(Level1Poly[n].vertex0[1] &gt; maxy)
<br/>
      {maxy = Level1Poly[n].vertex0[1];}
<br/>
      if(Level1Poly[n].vertex1[1] &gt; maxy)
<br/>
      {maxy = Level1Poly[n].vertex1[1];}
<br/>
      if(Level1Poly[n].vertex2[1] &gt; maxy)
<br/>
      {maxy = Level1Poly[n].vertex2[1];}
<br/>
      
<br/>
      if(Level1Poly[n].vertex0[2] &gt; maxz)
<br/>
      {maxz = Level1Poly[n].vertex0[2];}
<br/>
      if(Level1Poly[n].vertex1[2] &gt; maxz)
<br/>
      {maxz = Level1Poly[n].vertex1[2];}
<br/>
      if(Level1Poly[n].vertex2[2] &gt; maxz)
<br/>
      {maxz = Level1Poly[n].vertex2[2];}
<br/>
      
<br/>
      //
<br/>
      
<br/>
      if(Level1Poly[n].vertex0[0] &lt; minx)
<br/>
      {minx = Level1Poly[n].vertex0[0];}
<br/>
      if(Level1Poly[n].vertex1[0] &lt; minx)
<br/>
      {minx = Level1Poly[n].vertex1[0];}
<br/>
      if(Level1Poly[n].vertex2[0] &lt; minx)
<br/>
      {minx = Level1Poly[n].vertex2[0];}
<br/>
      
<br/>
      if(Level1Poly[n].vertex0[1] &lt; miny)
<br/>
      {miny = Level1Poly[n].vertex0[1];}
<br/>
      if(Level1Poly[n].vertex1[1] &lt; miny)
<br/>
      {miny = Level1Poly[n].vertex1[1];}
<br/>
      if(Level1Poly[n].vertex2[1] &lt; miny)
<br/>
      {miny = Level1Poly[n].vertex2[1];}
<br/>
      
<br/>
      if(Level1Poly[n].vertex0[2] &lt; minz)
<br/>
      {minz = Level1Poly[n].vertex0[2];}
<br/>
      if(Level1Poly[n].vertex1[2] &lt; minz)
<br/>
      {minz = Level1Poly[n].vertex1[2];}
<br/>
      if(Level1Poly[n].vertex2[2] &lt; minz)
<br/>
      {minz = Level1Poly[n].vertex2[2];}
<br/>
   }
<br/>
<br/>
//Find max lengths of x, y and z coords, and biggest length
<br/>
<br/>
   f32 lengthx, lengthy, lengthz, lengthmax;
<br/>
   
<br/>
   lengthx = maxx - minx;
<br/>
   lengthy = maxy - miny;
<br/>
   lengthz = maxz - minz;
<br/>
   lengthmax = 0;
<br/>
   
<br/>
   if(lengthx &gt; lengthmax)
<br/>
   {lengthmax = lengthx;}
<br/>
   if(lengthy &gt; lengthmax)
<br/>
   {lengthmax = lengthy;}
<br/>
   if(lengthz &gt; lengthmax)
<br/>
   {lengthmax = lengthz;}   
<br/>
<br/>
//Form a cube by ammending the max and min coords with lengthmax
<br/>
<br/>
   if(lengthx &lt; lengthmax)
<br/>
   {
<br/>
      maxx += (lengthmax - lengthx);
<br/>
      lengthx = maxx - minx;
<br/>
   }
<br/>
   if(lengthy &lt; lengthmax)
<br/>
   {
<br/>
      maxy += (lengthmax - lengthy);
<br/>
      lengthy = maxy - miny;
<br/>
   }
<br/>
   if(lengthz &lt; lengthmax)
<br/>
   {
<br/>
      maxz += (lengthmax - lengthz);
<br/>
      lengthz = maxz - minz;
<br/>
   }
<br/>
   
<br/>
//Create the first node (head)
<br/>
   
<br/>
   struct node* head = NULL;
<br/>
   head = malloc(sizeof(struct node));
<br/>
   
<br/>
   head-&gt;maxx = maxx;
<br/>
   head-&gt;maxy = maxy;
<br/>
   head-&gt;maxz = maxz;
<br/>
   head-&gt;minx = minx;
<br/>
   head-&gt;miny = miny;
<br/>
   head-&gt;minz = minz;
<br/>
      
<br/>
//Create the head (polylist and further nodes within it)
<br/>
<br/>
   addNode(&amp;head);   
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Add node function
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void addNode(struct node** noderef)
<br/>
{
<br/>
   int tempintersectlist[polylimit];
<br/>
   int temppolycount;
<br/>
   int n = 0;
<br/>
   
<br/>
//Check if poly vertices are within node max/min, and if yes add to intersect list (before testing
<br/>
//where polygons intersect the node e.t.c., first checking how many polygons are in the node)
<br/>
   
<br/>
   for(n = 0; n &lt; polylimit; n++)
<br/>
   {
<br/>
      if((Level1Poly[n].vertex0[0] &lt; *noderef-&gt;maxx)&amp;&amp;(Level1Poly[n].vertex0[0] &gt; *noderef-&gt;minx))
<br/>
      {
<br/>
         if((Level1Poly[n].vertex0[1] &lt; *noderef-&gt;maxy)&amp;&amp;(Level1Poly[n].vertex0[1] &gt; *noderef-&gt;miny))
<br/>
         {
<br/>
            if((Level1Poly[n].vertex0[2] &lt; *noderef-&gt;maxz)&amp;&amp;(Level1Poly[n].vertex[2] &gt; *noderef-&gt;minz))
<br/>
            {
<br/>
               temppolycount++;
<br/>
               templist[n] = n;
<br/>
            }
<br/>
         }
<br/>
      }
<br/>
      
<br/>
      else if((Level1Poly[n].vertex1[0] &lt; *noderef-&gt;maxx)&amp;&amp;(Level1Poly[n].vertex1[0] &gt; *noderef-&gt;minx))
<br/>
      {
<br/>
         if((Level1Poly[n].vertex1[1] &lt; *noderef-&gt;maxy)&amp;&amp;(Level1Poly[n].vertex1[1] &gt; *noderef-&gt;miny))
<br/>
         {
<br/>
            if((Level1Poly[n].vertex1[2] &lt; *noderef-&gt;maxz)&amp;&amp;(Level1Poly[n].vertex[2] &gt; *noderef-&gt;minz))
<br/>
            {
<br/>
               temppolycount++;
<br/>
               templist[n] = n;
<br/>
            }
<br/>
         }
<br/>
      }
<br/>
      
<br/>
      else if((Level1Poly[n].vertex2[0] &lt; *noderef-&gt;maxx)&amp;&amp;(Level1Poly[n].vertex2[0] &gt; *noderef-&gt;minx))
<br/>
      {
<br/>
         if((Level1Poly[n].vertex2[1] &lt; *noderef-&gt;maxy)&amp;&amp;(Level1Poly[n].vertex2[1] &gt; *noderef-&gt;miny))
<br/>
         {
<br/>
            if((Level1Poly[n].vertex2[2] &lt; *noderef-&gt;maxz)&amp;&amp;(Level1Poly[n].vertex[2] &gt; *noderef-&gt;minz))
<br/>
            {
<br/>
               temppolycount++;
<br/>
               templist[n] = n;
<br/>
            }
<br/>
         }
<br/>
      }
<br/>
   
<br/>
      
<br/>
   }//End for
<br/>
   
<br/>
   if(temppolycount &gt; 10)
<br/>
   {
<br/>
      //Split node into a further 8 nodes
<br/>
      
<br/>
   }
<br/>
   
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
When compiling, I get the following error in my addNode function:
<br/>
<br/>
error: request for member 'maxx' in something not a structure or union
<br/>
<br/>
(around 18 times each time either maxx, maxy e.t.c. are called) Anybody able to take a look at my code and help me?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
