<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Model format - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Model format</h2>
<div id="posts">
<div class="post">
    <h4>#79722 - tciny - Sat Apr 15, 2006 5:05 pm</h4>
    <div class="postbody"><span class="postbody">Hey,
<br/>
<br/>
I'm planning to create a model format for use on the DS that has a proper Maya exporter, nice importer and so forth...
<br/>
I want the format to support skeletal animation for characters and the only thing I'm not sure of yet is wether to support soft skinning or not. (Meaning one vertex can be influenced by multiple joints).
<br/>
The difference would be that with rigid binding it'd be possible to use the glTranslate and glRotate commands the devkit provides wheres soft skinning would mean that I'd have to do the matrix calculations in software.
<br/>
<br/>
Long story short: Does the DS handle matrix manipulation like in glTranslate and glRotate in hardware or is it software emulated anyway?!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79723 - Mighty Max - Sat Apr 15, 2006 5:07 pm</h4>
    <div class="postbody"><span class="postbody">Take a look here: <a href="http://www.bottledlight.com/ds/index.php/Video/GeometryEngine" target="_blank">http://www.bottledlight.com/ds/index.php/Video/GeometryEngine</a><br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79726 - tepples - Sat Apr 15, 2006 5:19 pm</h4>
    <div class="postbody"><span class="postbody">Pretty much, you'll want to export to DS display list format. A lot of research into this format went into model viewers for the dump of <span style="font-style: italic">Metroid Prime Hunters: First Hunt</span>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79729 - tciny - Sat Apr 15, 2006 5:27 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for your quick replys. 
<br/>
Would you happen have a like for some docs on that display list format? :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#79946 - Chris Holmes - Mon Apr 17, 2006 1:40 pm</h4>
    <div class="postbody"><span class="postbody">Why don't you use the Maya GE2 exporter?  It's not enabled by default, but it has been included since about Maya 2.  GE2 is a _very_ simple to use/edit format as it's plain-text.  If you need a parser for that, I've already got one written.
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80073 - tciny - Tue Apr 18, 2006 5:07 pm</h4>
    <div class="postbody"><span class="postbody">Because I'd like the files to stay as small as possible. Plain text has the problem of being slow to parse and wastful in terms of storage...
<br/>
<br/>
I havent done any such low level proramming yet and I'm having a trouble figuring out what to do with the CPU registers listed in the docs. Could anyone please explain this to me real quick? :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80082 - ecurtz - Tue Apr 18, 2006 5:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tciny wrote:</b></span></td> </tr> <tr> <td class="quote">I havent done any such low level proramming yet and I'm having a trouble figuring out what to do with the CPU registers listed in the docs. Could anyone please explain this to me real quick? :)</td> </tr></table><span class="postbody">
<br/>
<br/>
The registers correspond to the 3D commands that the DS is able to execute. So for example, to set the model transform matrix you would write to the MATRIX_SET (or whatever it is) 16 times for the values in your matrix. If you're not an experienced programmer trying to write an exporter is going to be NO FUN. If you're willing to wait I have one for the open source Misfit Model 3d program that is at about 80% functionality (hierarchical rotation keyframes are fubared, most other basic stuff works.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80084 - tciny - Tue Apr 18, 2006 6:33 pm</h4>
    <div class="postbody"><span class="postbody">I've written several maya exporters, modeling tools, opengl apps etc. thats no problem. It's just that I have a rather artistic background so docs with only memory locations in them intimidate me ;)
<br/>
<br/>
My problem is I dont quite get yet how to assign something to a register... should I just assign a value to it?! Like
<br/>
vfixed *blah = new vfixed();
<br/>
*blah = 5;
<br/>
MATRIX_MULT4x4 = blah;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80107 - ecurtz - Tue Apr 18, 2006 8:58 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, pretty much, take a look at the methods in lidnds...
<br/>
<br/>
<a class="postlink" href="http://cvs.sourceforge.net/viewcvs.py/devkitpro/libnds/source/arm9/videoGL.c?view=markup" target="_blank">videoGL.c</a>
<br/>
<br/>
Once you get the stuff figured out you can then compile all the commands into a stream and copy it all to a single register, that's the final format that Metroid et al. use. That's essentially an id for 4 operations crammed into a int32 followed by the data for those operations.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80272 - tciny - Thu Apr 20, 2006 10:34 pm</h4>
    <div class="postbody"><span class="postbody">Thanks! Works great :)
<br/>
<br/>
What bothers me tho, is that I cant read the current matrix :/
<br/>
Is there a way to do this?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80295 - ecurtz - Fri Apr 21, 2006 3:18 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void glGetFixed(GL_GET_TYPE param, fixed* f) {
<br/>
//---------------------------------------------------------------------------------
<br/>
  int i;
<br/>
<br/>
  switch (param) {
<br/>
    case GL_GET_MATRIX_ROTATION:
<br/>
      for(i = 0; i &lt; 9; i++)
<br/>
        f[i] = MATRIX_READ_ROTATION[i];
<br/>
      break;
<br/>
    case GL_GET_MATRIX_PROJECTION:
<br/>
      for(i = 0; i &lt; 16; i++)
<br/>
        f[i] = MATRIX_READ_PROJECTION[i];
<br/>
      break;
<br/>
    default: 
<br/>
      break;
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not sure if these work, but have no reason to suspect they don't.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80321 - tciny - Fri Apr 21, 2006 9:48 am</h4>
    <div class="postbody"><span class="postbody">Just so I get this right:
<br/>
MATRIX_READ_ROTATION will actually read the currently active world matrix? Because the "read rotation" makes it seem like the name was picked really odd...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80585 - ecurtz - Sun Apr 23, 2006 4:57 pm</h4>
    <div class="postbody"><span class="postbody">By the way this is what my current animation structures look like. They are still very much work in progress. Metroid was using Euler angles for its rotations (at least in base pose) so maybe that's a better way to go, I'm sure they thought about performance more than I have. One obvious change is that palette data and texture data should be split so that you can use different combinations.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef struct
<br/>
{
<br/>
   int parent;
<br/>
   quat rot_quat;
<br/>
   vector trans_vec;
<br/>
} __attribute__((packed))
<br/>
ModelBone;
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   short texid;
<br/>
   short palid;
<br/>
   int   start_ofs;
<br/>
   int   size;
<br/>
} __attribute__((packed))
<br/>
ModelObject;
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   unsigned short frame;
<br/>
   quat16 rot_quat;
<br/>
} __attribute__((packed))
<br/>
RotFrame;
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   unsigned short frame;
<br/>
   vector16 trans_vec;
<br/>
} __attribute__((packed))
<br/>
TransFrame;
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   unsigned int frames;
<br/>
   RotFrame*  rot_ofs;
<br/>
   TransFrame*   trans_ofs;
<br/>
   int*   scale_ofs;
<br/>
}
<br/>
ModelAnim;
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   unsigned short      format;
<br/>
   unsigned short      width;
<br/>
   unsigned short      height;
<br/>
   unsigned short      palette_cnt;
<br/>
   unsigned int      palette_ofs;
<br/>
   unsigned int      data_ofs;
<br/>
}
<br/>
PNGImage;
<br/>
<br/>
typedef struct
<br/>
{
<br/>
   int bone_cnt;
<br/>
   ModelBone* bone_ofs;
<br/>
   int object_cnt;
<br/>
   ModelObject* object_ofs;
<br/>
   int anim_cnt;
<br/>
   ModelAnim* anim_ofs;
<br/>
}
<br/>
ModelHeader;
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80693 - tciny - Mon Apr 24, 2006 9:06 pm</h4>
    <div class="postbody"><span class="postbody">Just some thoughts I had while reading:
<br/>
<br/>
In ModelBone, I think for the parent even a byte would be enough seeing how performance is... :)
<br/>
<br/>
Also, when you rig a model properly you dont need an X,Y and Z component for translation but only a distance, which is always measured along X. So one float/short/... would be sufficent here.
<br/>
<br/>
As for the keyframes: It depends on what you want to achieve, but generally I'd say squash n stretch isnt something you'll need very often so I think you dont need the translate keyframes... or at least give them an own array of offsets so you dont need to store them for every rotation keyframe.
<br/>
<br/>
Its nice to see other people had the same idea; sharing thoughts about how to implement things can be really helpful imho.
<br/>
<br/>
Am I correct when I read from your code that each body part is a single mesh? Because what I'd like to do is transform a single mesh on a vertex basis. It makes the rendering faster because there arent as much intersections between polys and it also looks a lot better...
<br/>
Right now the only problem I have is the geo engine of the DS and how matrix operations are handeled.
<br/>
What I intended to do was:
<br/>
<br/>
Give every bone a worldMatrix attribute.
<br/>
Now for each frame:
<br/>
<br/>
Iterate over all joints and calculate their woldMatrices. So if you calculated joint Nr. 4 and it has Nr. 2 as parent you'd grab the matrix of #2, add your deformations and store that as worldMatrix for #4. etc.
<br/>
<br/>
After all bones have had their worldMatrix refreshed, iterate over all vertices and store their new position in a buffer for drawing later on. (this unfortunately cant be done immediately). If a vertex only has one bone as influence that transform it using that matrix. If it has multiple influences compute the solutions for all bones and then blend them respectively.
<br/>
<br/>
After all vertices have been transformed use the vertex buffer to draw the mesh, then free the memory.
<br/>
<br/>
<br/>
The problem I'm having is retrieving the current matrix and transforming single vertices with a given matrix without drawing them... I dont want to apply the projection matrix at that point.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80746 - ecurtz - Tue Apr 25, 2006 4:48 am</h4>
    <div class="postbody"><span class="postbody">There's a 32 entry matrix stack, so you can do glRestoreMatrix() to get the parent transform for a joint back into the current matrix.
<br/>
<br/>
I'm not really a 3d guy, so I'll have to think about your translation comment - don't we need a full translation to offset the "beginning" of the bone from its parent?
<br/>
<br/>
The translation keyframes are already separated from the rotation ones on the theory that they'll be much rarer.
<br/>
<br/>
Each body is indeed a single mesh, the matrix stack means that the whole thing can be submitted in the condensed dlist form including switching the matrix on the fly. I'm pretty sure trying to do weighted vertices would totally kill your performance.
<br/>
<br/>
There's no reason to cut down the parent to a byte unless you want to use the other byte for flags or something. The rest of the fields need to get aligned for the reads anyway.
<br/>
<br/>
Here's the current (rough) demo code.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int DrawGLScene()                                 // Here's Where We Do All The Drawing
<br/>
{
<br/>
   if (modelPtr-&gt;bone_cnt &gt; 0) {
<br/>
      ModelBone* bonePtr = modelPtr-&gt;bone_ofs;
<br/>
      for (int b = 0; b &lt; modelPtr-&gt;bone_cnt; b++) {
<br/>
         if ( bonePtr[b].parent &gt;= 0 ) {
<br/>
            glRestoreMatrix(bonePtr[b].parent);
<br/>
         } else {
<br/>
            setBaseMatrix();
<br/>
         }    
<br/>
<br/>
         if (modelPtr-&gt;anim_cnt &gt; 0) {
<br/>
            ModelAnim* animPtr = modelPtr-&gt;anim_ofs;
<br/>
            
<br/>
            int currentFrame = animFrame &gt;&gt; 2;
<br/>
            while (currentFrame &gt;= animPtr-&gt;frames)
<br/>
               currentFrame -= animPtr-&gt;frames;
<br/>
            
<br/>
            // Calculate the rotation
<br/>
            if (animPtr-&gt;rot_ofs) {
<br/>
               RotFrame* rotPtr = &amp;animPtr-&gt;rot_ofs[b];
<br/>
               // First frame has marker index rather than frame (which is 0)
<br/>
               if (rotPtr-&gt;frame) {
<br/>
                  // Not normalizing portions because of the quat normalize
<br/>
                  int portion_prev;
<br/>
                  int portion_next;
<br/>
                  RotFrame* nextPtr = &amp;animPtr-&gt;rot_ofs[rotPtr-&gt;frame];
<br/>
                  if (nextPtr-&gt;frame &gt; currentFrame) {
<br/>
                     portion_prev = nextPtr-&gt;frame - currentFrame;
<br/>
                     portion_next = currentFrame;
<br/>
                  }
<br/>
                  else {
<br/>
                     do {
<br/>
                        nextPtr++;
<br/>
                     } while (nextPtr-&gt;frame &lt; currentFrame);
<br/>
                     rotPtr = nextPtr--;
<br/>
                     
<br/>
                     portion_prev = nextPtr-&gt;frame - currentFrame;
<br/>
                     portion_next = currentFrame - rotPtr-&gt;frame;
<br/>
                  }
<br/>
                  
<br/>
                  quat interp_quat;
<br/>
                  interp_quat.w = (rotPtr-&gt;rot_quat.w * portion_prev) + (nextPtr-&gt;rot_quat.w * portion_next);
<br/>
                  interp_quat.x = (rotPtr-&gt;rot_quat.x * portion_prev) + (nextPtr-&gt;rot_quat.x * portion_next);
<br/>
                  interp_quat.y = (rotPtr-&gt;rot_quat.y * portion_prev) + (nextPtr-&gt;rot_quat.y * portion_next);
<br/>
                  interp_quat.z = (rotPtr-&gt;rot_quat.z * portion_prev) + (nextPtr-&gt;rot_quat.z * portion_next);
<br/>
                  quat_normalize(&amp;interp_quat);
<br/>
                  
<br/>
                  glMultQuatAsM4x3(&amp;interp_quat);
<br/>
               }
<br/>
               else {
<br/>
                  glMultQuatAsM4x3(&amp;rotPtr-&gt;rot_quat);
<br/>
               }
<br/>
            }
<br/>
            else {
<br/>
               glMultQuatAsM4x3(&amp;bonePtr[b].rot_quat);
<br/>
            }
<br/>
            
<br/>
            // Calculate the translation
<br/>
            if (animPtr-&gt;trans_ofs) {
<br/>
               TransFrame* transPtr = &amp;animPtr-&gt;trans_ofs[b];
<br/>
               // First frame has marker index rather than frame (which is 0)
<br/>
               if (transPtr-&gt;frame) {
<br/>
                  f32 portion_prev;
<br/>
                  f32 portion_next;
<br/>
                  TransFrame* nextPtr = &amp;animPtr-&gt;trans_ofs[transPtr-&gt;frame];
<br/>
                  if (nextPtr-&gt;frame &gt; currentFrame) {
<br/>
                     f32 inv_length = divf32(f32one, inttof32(nextPtr-&gt;frame));
<br/>
                     portion_prev = (nextPtr-&gt;frame - currentFrame) * inv_length;
<br/>
                     portion_next = currentFrame * inv_length;
<br/>
                  }
<br/>
                  else {
<br/>
                     do {
<br/>
                        nextPtr++;
<br/>
                     } while (nextPtr-&gt;frame &lt; currentFrame);
<br/>
                     transPtr = nextPtr--;
<br/>
                     
<br/>
                     f32 inv_length = divf32(f32one, inttof32(nextPtr-&gt;frame - transPtr-&gt;frame));
<br/>
                     portion_prev = (nextPtr-&gt;frame - currentFrame) * inv_length;
<br/>
                     portion_next = (currentFrame - transPtr-&gt;frame) * inv_length;
<br/>
                  }
<br/>
                  
<br/>
                  vector interp_vec;
<br/>
                  interp_vec.x = mulf32(transPtr-&gt;trans_vec.x, portion_prev) + mulf32(nextPtr-&gt;trans_vec.x, portion_next);
<br/>
                  interp_vec.y = mulf32(transPtr-&gt;trans_vec.y, portion_prev) + mulf32(nextPtr-&gt;trans_vec.y, portion_next);
<br/>
                  interp_vec.z = mulf32(transPtr-&gt;trans_vec.z, portion_prev) + mulf32(nextPtr-&gt;trans_vec.z, portion_next);
<br/>
<br/>
                  // Using glMultQuatAsM4x3 above, complete the matrix here
<br/>
                  MATRIX_MULT4x3 = interp_vec.x;
<br/>
                  MATRIX_MULT4x3 = interp_vec.y;
<br/>
                  MATRIX_MULT4x3 = interp_vec.z;
<br/>
               }
<br/>
               else {
<br/>
                  MATRIX_MULT4x3 = transPtr-&gt;trans_vec.x;
<br/>
                  MATRIX_MULT4x3 = transPtr-&gt;trans_vec.y;
<br/>
                  MATRIX_MULT4x3 = transPtr-&gt;trans_vec.z;
<br/>
               }
<br/>
            }
<br/>
            else {
<br/>
               MATRIX_MULT4x3 = bonePtr[b].trans_vec.x;
<br/>
               MATRIX_MULT4x3 = bonePtr[b].trans_vec.y;
<br/>
               MATRIX_MULT4x3 = bonePtr[b].trans_vec.z;
<br/>
            }
<br/>
            /*
<br/>
            if (animPtr-&gt;scale_ofs) {
<br/>
            }
<br/>
            */
<br/>
         }
<br/>
         else {
<br/>
            glMultQuat(&amp;bonePtr[b].rot_quat);
<br/>
            glTranslatev((GLvector*) &amp;bonePtr[b].trans_vec);
<br/>
         }
<br/>
         
<br/>
         glStoreMatrix(b);
<br/>
      }
<br/>
   }
<br/>
   else {
<br/>
      setBaseMatrix();
<br/>
      glPushMatrix();
<br/>
   }
<br/>
<br/>
   ModelObject* objPtr = modelPtr-&gt;object_ofs;
<br/>
   for (int obj = 0; obj &lt; modelPtr-&gt;object_cnt; obj++ ) {
<br/>
      glBindTexture( GL_TEXTURE_2D, texture[objPtr[obj].texid] );
<br/>
      glColorTable( GL_RGB, palette[objPtr[obj].palid] );
<br/>
<br/>
      int count = objPtr[obj].size;
<br/>
      int* dlist = (int*)((byte*) modelPtr + objPtr[obj].start_ofs);
<br/>
      
<br/>
      //glCallList((u32*) objPtr[obj]-&gt;dlist_ofs);
<br/>
      while(count--)
<br/>
         GFX_FIFO = *dlist++;
<br/>
   }
<br/>
<br/>
   return TRUE;         
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#81479 - tciny - Sat Apr 29, 2006 1:10 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for posting the code, its an interesting read.
<br/>
<br/>
About the translation: If you want to support "dirty" rigs, then yes, you'll need all translates. But if the character was set up properly it doesnt have any y and z translantes on any of the bones. Its like giving a normal vector (rotation) and the distance (x translate).
<br/>
<br/>
I'll do some benchmarking once I have some time on my hands (currently writing my diploma thesis)... but from what I've read so far I think performance should be ok... I dont expect it to be as fast as an object based system, but when you really want to show high-res characters its worth it... I hope :)
<br/>
I'm thinking about switching between smooth-binding and per object binding on a LOD basis...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86901 - Valmond - Sat Jun 10, 2006 10:20 am</h4>
    <div class="postbody"><span class="postbody">Hi !
<br/>
<br/>
ecurtz pointed me to this discussion, and it's indeed an interesting read.
<br/>
(thanks !)
<br/>
<br/>
what I have understood is that any kind of skinning should be done
<br/>
along these lines :
<br/>
<br/>
Calculate (as usual) the matrices for the bones
<br/>
Draw (with a displaylist probably) all Triangles who are affected by only one bone
<br/>
Calculate and draw the other ones (multiple bones per tri, or even multiple bones per vertex) "by hand".
<br/>
<br/>
In the "by hand" part, vertexes could be stored sorted "by bone" and easily get
<br/>
calculated (especially if not softskinning, ie. weight always is 1.0) by
<br/>
the geometric engine (couldn't you do geometric-lists ?) as the matrices
<br/>
are already calculated, then flush triangles (by hand again :) with these vertexes.
<br/>
<br/>
<br/>
Right ?
<br/>
<br/>
/Valmond</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
