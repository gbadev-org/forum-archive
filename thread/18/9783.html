<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Sorting Data on DS - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Sorting Data on DS</h2>
<div id="posts">
<div class="post">
    <h4>#85917 - knight0fdragon - Sat Jun 03, 2006 3:23 am</h4>
    <div class="postbody"><span class="postbody">what algorithm would be best with the DS
<br/>
<br/>
right now im using selection sort,  I would like to use quick sort, but im worried about the recursion
<br/>
<br/>
so what methods do others prefer<br/>_________________<br/><a href="http://www.myspace.com/knight0fdragonds" target="_blank">http://www.myspace.com/knight0fdragonds</a>
<br/>
<br/>
MK DS FC: Dragon 330772 075464 
<br/>
AC WW FC: Anthony SamsClub 1933-3433-9458 
<br/>
MPFH: Dragon 0215 4231 1206</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#85918 - sajiimori - Sat Jun 03, 2006 3:53 am</h4>
    <div class="postbody"><span class="postbody">Quicksort can be done iteratively.  There are tons of implementations out there.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#85919 - tepples - Sat Jun 03, 2006 4:28 am</h4>
    <div class="postbody"><span class="postbody">Quicksort can degrade to O(n^2) for pathological cases. By the time you've selected pivots to avoid the obvious pathological cases, you've already added enough overhead to switch to Heapsort. Heapsort and Shell sort give good guarantees of maximum runtime, which is important in a real-time environment.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#85930 - sajiimori - Sat Jun 03, 2006 6:48 am</h4>
    <div class="postbody"><span class="postbody">The expected rarity of pathological cases, combined with the non-fatal (though undesirable) effect of dropping a frame during gameplay might make average-case performance the deciding factor, tipping the balance in favor of quicksort.
<br/>
<br/>
If speed becomes a problem, try some different methods.  For now, do whatever's easiest.  For DS games, I've never had the need to replace a sorting algorithm for efficiency reasons.  It just never came up.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#85995 - spencer723 - Sat Jun 03, 2006 7:09 pm</h4>
    <div class="postbody"><span class="postbody">I find Merge sorts are extremely fast, but I don't really know how much CPU speed you will need for that</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86007 - sniper - Sat Jun 03, 2006 8:03 pm</h4>
    <div class="postbody"><span class="postbody">radixsort is also good even for less than 1000 entries.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86023 - tepples - Sat Jun 03, 2006 11:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>spencer723 wrote:</b></span></td> </tr> <tr> <td class="quote">I find Merge sorts are extremely fast, but I don't really know how much CPU speed you will need for that</td> </tr></table><span class="postbody">
<br/>
Merge sort is as fast as the good case of Quicksort, and it's likely to be more cache friendly (because of the linear access), but it uses enough space for a second copy of the data set.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86058 - knight0fdragon - Sun Jun 04, 2006 3:31 am</h4>
    <div class="postbody"><span class="postbody">i was always under the assumption that radix sort was just not efficient from a computational stand point, where as for people and machines it is really fast<br/>_________________<br/><a href="http://www.myspace.com/knight0fdragonds" target="_blank">http://www.myspace.com/knight0fdragonds</a>
<br/>
<br/>
MK DS FC: Dragon 330772 075464 
<br/>
AC WW FC: Anthony SamsClub 1933-3433-9458 
<br/>
MPFH: Dragon 0215 4231 1206</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86120 - tepples - Sun Jun 04, 2006 3:25 pm</h4>
    <div class="postbody"><span class="postbody">The original PlayStation uses bucket sort, a special case of radix sort, for z-sorting 3D triangles.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86465 - yackom - Wed Jun 07, 2006 11:45 am</h4>
    <div class="postbody"><span class="postbody">quicksort is the best sorting algorithm on adverage.. the problem is that if your using large datasets (why in the hell would use sort something large on the ds? i dont know) you might blow the stack it has adverage case O(logn) stack space, and worse case O(n).
<br/>
<br/>
if you do have problems with that i suggest using in-situ merging algorithms with take constant O(1) space complexity. Though the challenge in getting one working is much higer.
<br/>
<br/>
edit:
<br/>
also bucketsort does have linear time, it requires a block of memory the size of the domain of the data. which is unlikely to be the case since the ds has very limited amounts of memory</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86505 - knight0fdragon - Wed Jun 07, 2006 4:47 pm</h4>
    <div class="postbody"><span class="postbody">it involves some compression routines im writing, so depending on what the data is it may vary.  I am going with the iterative quick sort, I will try to implement the radix sort if memory is allowed
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yackom wrote:</b></span></td> </tr> <tr> <td class="quote">quicksort is the best sorting algorithm on adverage.. the problem is that if your using large datasets (why in the hell would use sort something large on the ds? i dont know) you might blow the stack it has adverage case O(logn) stack space, and worse case O(n).
<br/>
<br/>
if you do have problems with that i suggest using in-situ merging algorithms with take constant O(1) space complexity. Though the challenge in getting one working is much higer.
<br/>
<br/>
edit:
<br/>
also bucketsort does have linear time, it requires a block of memory the size of the domain of the data. which is unlikely to be the case since the ds has very limited amounts of memory</td> </tr></table><span class="postbody"><br/>_________________<br/><a href="http://www.myspace.com/knight0fdragonds" target="_blank">http://www.myspace.com/knight0fdragonds</a>
<br/>
<br/>
MK DS FC: Dragon 330772 075464 
<br/>
AC WW FC: Anthony SamsClub 1933-3433-9458 
<br/>
MPFH: Dragon 0215 4231 1206</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86926 - silent_code - Sat Jun 10, 2006 5:29 pm</h4>
    <div class="postbody"><span class="postbody">normally merge sort is cool, becuase once the data is presorted (like after the first sort) it doen't have to do much comparsions on the data set. the downside is the memory requirements...
<br/>
<br/>
iterative quicksort sounds interesting for the nds... i wonder how it performs? does someone have any implementations on the nds to compare the best / worst / average / presorted cases of each algo?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86930 - Dwedit - Sat Jun 10, 2006 6:00 pm</h4>
    <div class="postbody"><span class="postbody">You don't really need to duplicate the data for mergesort.  Maybe a really bad implementation would do that.  But in an implemetation I used which sorted a bunch of strings, I used two tables of ints, each representing the array index of a string.  The table of ints needed to be duplicated, but not the strings themselves.
<br/>
<br/>
I specifically chose iterative mergesort because of its near zero stack usage.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86943 - Mighty Max - Sat Jun 10, 2006 9:29 pm</h4>
    <div class="postbody"><span class="postbody">This implementation DUPLICATES the data it sorts. You just shifted what the data is. In your case it is not needed that the strings are really sorted, only the indexes, which you doubled.
<br/>
<br/>
There might be other cases you actually need strings to be in the correct order (i.e. to speed up things in sequential accessed medias, alltho you'd do something else here too)
<br/>
<br/>
<br/>
To the question itself, i'm in the opinion that the sorting algorithm should be selected by problem, not on what device it runs (on RAMs, which the DS is)<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86950 - knight0fdragon - Sat Jun 10, 2006 10:27 pm</h4>
    <div class="postbody"><span class="postbody">well the one thing i noticed is that large arrays in functions end up crashing my code, so perhaps theres a limit to the stack space that can cause problems with quicksort.  data i am sorting is prob on avg 6k<br/>_________________<br/><a href="http://www.myspace.com/knight0fdragonds" target="_blank">http://www.myspace.com/knight0fdragonds</a>
<br/>
<br/>
MK DS FC: Dragon 330772 075464 
<br/>
AC WW FC: Anthony SamsClub 1933-3433-9458 
<br/>
MPFH: Dragon 0215 4231 1206</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86987 - silent_code - Sun Jun 11, 2006 5:43 am</h4>
    <div class="postbody"><span class="postbody">please feel free to correct me, but the standard implementation of quicksort is quite bad with presorted data in terms of comparsons. it's truely quick with unsorted datasets... so check for alternatives, no matter what sorting algo "sounds" the best (and quick doesn't mean it's ALLWAYS quick).
<br/>
you might need to introduce other data structures.
<br/>
<br/>
some keyword would be a "red black tree". don't ask me, i just heard/read it being mentioned somewhere. some guy said/wrote he used it for sorting onscreen object for drawing order. it was a 2d-isometric-ish game if i remember right. don't know what hardware/platform it was designed for. maybe it was some article on the net, i really don't remember. might be interesting looking into it, though.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86991 - knight0fdragon - Sun Jun 11, 2006 6:18 am</h4>
    <div class="postbody"><span class="postbody">man i want to stay away from red black trees, not becuase of the algorithm, but because of the teacher that taught me it and the horrors and nightmares that I went though for 4 years<br/>_________________<br/><a href="http://www.myspace.com/knight0fdragonds" target="_blank">http://www.myspace.com/knight0fdragonds</a>
<br/>
<br/>
MK DS FC: Dragon 330772 075464 
<br/>
AC WW FC: Anthony SamsClub 1933-3433-9458 
<br/>
MPFH: Dragon 0215 4231 1206</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#87015 - tepples - Sun Jun 11, 2006 1:17 pm</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://eternallyconfuzzled.com/tuts/andersson.html" target="_blank">AA trees</a> are simpler than red-black trees and with about the same performance, and there is public domain source code for them.
<br/>
<br/>
But if you're doing sorting where you'll read out the values in order, you don't want a tree but a priority queue, that is, a heap.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
