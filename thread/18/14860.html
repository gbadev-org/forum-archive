<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How fast is my scrolling with dynamic tile loading? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > How fast is my scrolling with dynamic tile loading?</h2>
<div id="posts">
<div class="post">
    <h4>#149176 - JanoSicek - Wed Jan 16, 2008 11:27 am</h4>
    <div class="postbody"><span class="postbody">Hello
<br/>
<br/>
I am writing a scrolling engine on tiled backgrounds for arbitrary sized maps and up to 65535 tiles per background. I am using three layers: BG0, BG1 and BG2.
<br/>
<br/>
At the END of each VBLANK I check which tiles I need to load, and put them in a buffer. Then at start of VBLANK I load the tiles in the VRAM and switch to the precomputed new map (double buffering)
<br/>
<br/>
The problem is that this process is quite slow for me.
<br/>
A small scroll of 8 pixels to the right consumes about 60 horizontal scanlines worth of time to preprocess what to load. The loading then consumes about 2 scanlines, so that's fine.
<br/>
<br/>
A big scroll (or jump) for 64 pixels, consumes more than 192 scanlines, making the scrolling skip the frame (60fps -&gt; 30 fps)
<br/>
And an arbitrary jump in the map consumes 300+ scanlines, sometimes skipping two frames (60fps -&gt; 20 fps)
<br/>
<br/>
Is my implementation too slow?
<br/>
It is quite problematic to implement the dynamic tile loading. I am storing all tiles loaded in a hash table (2048 buckets, each is 16bit wide, linear probing)
<br/>
<br/>
Total I have 3072 tiles for all three background layers, as they are independent of each other.
<br/>
<br/>
I was optimizing this process quite a lot, so I'm quite happy that I can do a single layer scroll in about 20 scanlines, which is about 1200 microseconds. Is this enough for a game? Will I have enough ticks left to do the 'game' itself? 
<br/>
<br/>
Also, if you have the source of some fast scroller which can work with more than 1024 tiles, can you point me to it?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149178 - PypeBros - Wed Jan 16, 2008 1:05 pm</h4>
    <div class="postbody"><span class="postbody">Maybe you could try to pre-process the level map so that you can split tiles in "frequent" or "infrequent" and swap banks of "infrequent" tiles as you enter/leave the neighbourhood of a graphic element that requires the new "subset" of tiles.
<br/>
<br/>
Perfect example would be e.g. a Beat'm'up game, where you have parts of your tileset that appears everywhere (road, trees, etc.) and other parts that are used together to build a larger image (e.g. a temple), but you don't use temples tiles together with village tiles, even in a single level. That could let you introduce "hints" in your level such as "drop village tiles and replace them by temple tiles when we approach the "temple &gt;" sign...
<br/>
<br/>
Is there any reason why you expect scrolling "jumps" of &gt;16 pixels per frame ? Can you live with a fade-in/fade-out transition between two buffers in those cases?<br/>_________________<br/><a class="postlink" href="http://sylvainhb.blogspot.com/p/sprite-editor.html" target="_blank"> SEDS: Sprite Edition on DS</a> :: <a class="postlink" href="http://sylvainhb.blogspot.com/search/label/modplayer" target="_blank">modplayer</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149185 - Dwedit - Wed Jan 16, 2008 1:40 pm</h4>
    <div class="postbody"><span class="postbody">Here's my suggestion.
<br/>
So we have "virtual" tiles, which is what is specified, and "physical" tiles that actually sit in VRAM.
<br/>
Use two tables:
<br/>
* Lookup table from virtual tiles to physical tiles.
<br/>
* Back table from physical tiles to virtual tiles
<br/>
* Count table for each physical tile.  This keeps track of how many times a physical tile appears in the map.
<br/>
Then we have a "FIFO queue", really just use a counter for tile numbers.  When we add new tiles, we check the count table to see if we can replace that tile or not, and skip over tiles which are on the map.
<br/>
<br/>
Adding tiles to the map always knocks off an old tile.  Be sure to initialize the count table correctly to what's actually in the tilemap. 
<br/>
When adding tiles to the map the procedure is:
<br/>
* knock off the old tile
<br/>
- - decrease its entry in count table
<br/>
* add new tile
<br/>
- - Look it up in the lookup table
<br/>
- - Tile Exists?
<br/>
- - - Cool, Increase its entry in count table
<br/>
- - Tile doesn't exist?
<br/>
- - - Look in count table under cursor
<br/>
- - - Count is zero?
<br/>
- - - - Make the lookup for the old tile invalid (you need the back table for this)
<br/>
- - - - Set the lookup for the new tile
<br/>
- - - - Increase entry in count table
<br/>
- - - Count isn't zero?
<br/>
- - - - Skip that, move the cursor to the next tile, repeat
<br/>
<br/>
You can possibly reduce the size and complexity of the lookup tables by using "Metatiles", which are composed of multiple 8x8 tiles.  Maybe 16x16, or 32x32.  Have them be composed of sequential physical 8x8 tiles in a box shape.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149189 - JanoSicek - Wed Jan 16, 2008 2:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Here's my suggestion.
<br/>
So we have "virtual" tiles, which is what is specified, and "physical" tiles that actually sit in VRAM.
<br/>
Use two tables:
<br/>
* Lookup table from virtual tiles to physical tiles.
<br/>
* Back table from physical tiles to virtual tiles
<br/>
* Count table for each physical tile.  This keeps track of how many times a physical tile appears in the map.
<br/>
Then we have a "FIFO queue", really just use a counter for tile numbers.  When we add new tiles, we check the count table to see if we can replace that tile or not, and skip over tiles which are on the map.
<br/>
<br/>
Adding tiles to the map always knocks off an old tile.  Be sure to initialize the count table correctly to what's actually in the tilemap. 
<br/>
When adding tiles to the map the procedure is:
<br/>
* knock off the old tile
<br/>
- - decrease its entry in count table
<br/>
* add new tile
<br/>
- - Look it up in the lookup table
<br/>
- - Tile Exists?
<br/>
- - - Cool, Increase its entry in count table
<br/>
- - Tile doesn't exist?
<br/>
- - - Look in count table under cursor
<br/>
- - - Count is zero?
<br/>
- - - - Make the lookup for the old tile invalid (you need the back table for this)
<br/>
- - - - Set the lookup for the new tile
<br/>
- - - - Increase entry in count table
<br/>
- - - Count isn't zero?
<br/>
- - - - Skip that, move the cursor to the next tile, repeat
<br/>
</td> </tr></table><span class="postbody">
<br/>
This is very similar to what I've been doing.
<br/>
My arrays:
<br/>
u16 loadedtile[1024] - what tile is loaded in each of 1024 slots?
<br/>
u8 loadedage[1024] - how long since its last use
<br/>
u16 hashtable[2048] - this is reverse lookup if we want to know the slot in which a tile 0-65536 is loaded.
<br/>
<br/>
At the start of each scroll, I increase loadedage by 1 for all 1024 slots.
<br/>
Then for the screen 33x25 I check:
<br/>
a) tile currently in the map is the wanted one = loadedtile[whatswritten]==shouldbeloaded
<br/>
we only set loadedage[whatswritten] to 0
<br/>
<br/>
b) tile in map is incorrect one, and the tile that should be loaded is in some slot = loadedtile[hashtable[hash(shouldbeloaded)]]==shouldbeloaded
<br/>
we write this slot to the map and set its age to 0
<br/>
map=slot
<br/>
loadedage[slot]=0
<br/>
<br/>
c) tile in map is incorrect one, and the tile is not loaded anywhere
<br/>
we write this tile to the buffer of tiles to load
<br/>
<br/>
After checking the whole map, if we need to load some tiles, we evict the same number of tiles with highest loadedage[x] and then load the new tiles in these slots. 
<br/>
<br/>
The hash table is kept up to date at all times of course.
<br/>
<br/>
But even this effective algorithm is taking more than 1 whole frame when scrolling three backgrounds at once...
<br/>
<br/>
Of course, if you scroll only in small increments, then it works smoothly. However if you move the background by pen, and do a very quick movement, you can move it by 100+ pixels, and then it consumes 2/3 frames to redraw the scene.
<br/>
<br/>
Fact: If you do such a big jump, it does not really matter if it is drawn slowly, as the big jump broke the smoothness anyway. However I am afraid that the whole game will slow down and it will be noticable -- if you do quick scrolling left and right, you will slow down all monsters and processes in the game...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149193 - Dwedit - Wed Jan 16, 2008 3:48 pm</h4>
    <div class="postbody"><span class="postbody">You should only be concerned with the columns or rows which change as a result of scrolling.
<br/>
<br/>
The LRU algorithm where you age a bunch of tiles, and the need to iterate over the whole tilemap is really slowing your algorithm down.  Iterating over big arrays is slow.  If you eliminate LRU, then you don't need to iterate over the tilemap anymore.  You can use the tile count system instead to determine which tiles are not replaceable, since the tile count system only looks at when tiles are added and removed, not scanning over an entire map.
<br/>
<br/>
I suggest you give my algorithm a try.  It doesn't need to age tiles, and doesn't need to iterate over a tilemap.  You can also replace the big virtual-&gt;physical lookup table with a hash table, if the hash table doesn't have much 
<br/>
<br/>
A full lookup table for 65536 tiles is 128K large.  A 2048 entry hash table would easily be under 16K in the worst case.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149194 - JanoSicek - Wed Jan 16, 2008 3:56 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">You should only be concerned with the columns or rows which change as a result of scrolling.
<br/>
<br/>
The LRU algorithm where you age a bunch of tiles, and the need to iterate over the whole tilemap is really slowing your algorithm down.  Iterating over big arrays is slow.  If you eliminate LRU, then you don't need to iterate over the tilemap anymore.  You can use the tile count system instead to determine which tiles are not replaceable, since the tile count system only looks at when tiles are added and removed, not scanning over an entire map.
<br/>
<br/>
I suggest you give my algorithm a try.  It doesn't need to age tiles, and doesn't need to iterate over a tilemap.  You can also replace the big virtual-&gt;physical lookup table with a hash table, if the hash table doesn't have much 
<br/>
<br/>
A full lookup table for 65536 tiles is 128K large.  A 2048 entry hash table would easily be under 16K in the worst case.</td> </tr></table><span class="postbody">
<br/>
It looks like I will have to ditch LRU. Then I can only check new rows which scroll onto the screen and old rows which are scrolled away from the screen. 
<br/>
<br/>
At the moment I have a hash table for lookup. As I need only 1024 tiles, my hash table has size of 2048 to have small number of collisions. Each bucket is 2 bytes wide, so it is 4kB total per screen.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#149197 - PypeBros - Wed Jan 16, 2008 5:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>JanoSicek wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
At the moment I have a hash table for lookup. As I need only 1024 tiles, my hash table has size of 2048 to have small number of collisions. Each bucket is 2 bytes wide, so it is 4kB total per screen.</td> </tr></table><span class="postbody">
<br/>
<br/>
&lt;2,cent&gt;
<br/>
i'm not sure i got why you are bothering about removing the "most aged" tile.
<br/>
Your screen can display only 768 tiles at a time, right (32x24), and you'll likely to need a couple of extra tiles for 'to appear' tiles in the next frame.
<br/>
<br/>
Indeed, just counting references to tiles and putting those tile numbers whose ref. have reach 0 in some sort of "ready-for-reuse" list, as dwedit suggested, would do the trick (imvho).
<br/>
<br/>
@dwedit: amazing how much your algorithm looks like page replacement algorithms in MMU code for operating system kernels ^_^<br/>_________________<br/><a class="postlink" href="http://sylvainhb.blogspot.com/p/sprite-editor.html" target="_blank"> SEDS: Sprite Edition on DS</a> :: <a class="postlink" href="http://sylvainhb.blogspot.com/search/label/modplayer" target="_blank">modplayer</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
