<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Messed up sprite? bin file - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Messed up sprite? bin file</h2>
<div id="posts">
<div class="post">
    <h4>#138591 - ubercatch22 - Sun Aug 26, 2007 5:08 am</h4>
    <div class="postbody"><span class="postbody">when i excute my .nds file it work but my sprite are horribly dissorted
<br/>
<br/>
heres a urlto the image of it
<br/>
<br/>
<a href="http://i183.photobucket.com/albums/x51/Ubercatch/disportspitesds.jpg" target="_blank">http://i183.photobucket.com/albums/x51/Ubercatch/disportspitesds.jpg</a>
<br/>
<br/>
can any one help? oh heres the code as well(code was taken from a example from the 2055 dev kit because of the bin type file since i cant get  
<br/>
my .pcx images to work)
<br/>
<br/>
i use adobe photoshop cs3 extended for the .pcx but i get the error that the compiler cant find the file even know it is there.
<br/>
<br/>
[code
<br/>
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;nds.h&gt;
<br/>
<br/>
// these files are generated automatically by the bin2o rule
<br/>
#include "palette_bin.h"
<br/>
#include "man_bin.h"
<br/>
<br/>
#define NUM_SPRITES 128	
<br/>
<br/>
SpriteEntry OAMCopySub[128];
<br/>
<br/>
<br/>
//simple sprite struct
<br/>
typedef struct {
<br/>
	int x,y;				//location 
<br/>
	int dx, dy;			//speed
<br/>
	SpriteEntry* oam;	
<br/>
	int gfxID; 				//graphics lovation
<br/>
}Sprite;
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void MoveSprite(Sprite* sp) {
<br/>
//---------------------------------------------------------------------------------
<br/>
	int x = sp-&gt;x &gt;&gt; 8;
<br/>
	int y = sp-&gt;y &gt;&gt; 8;
<br/>
<br/>
	sp-&gt;oam-&gt;attribute[1] &amp;= 0xFE00;
<br/>
	sp-&gt;oam-&gt;attribute[1] |= (x &amp; 0x01FF);
<br/>
<br/>
	sp-&gt;oam-&gt;attribute[0] &amp;= 0xFF00;
<br/>
	sp-&gt;oam-&gt;attribute[0] |= (y &amp; 0x00FF);
<br/>
<br/>
} 
<br/>
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void initOAM(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
	int i;
<br/>
<br/>
	for(i = 0; i &lt; 128; i++) {
<br/>
		OAMCopySub[i].attribute[0] = ATTR0_DISABLED;
<br/>
	}	
<br/>
}
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void updateOAM(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
	unsigned int i;
<br/>
<br/>
	for(i = 0; i &lt; 128 * sizeof(SpriteEntry) / 4 ; i++)
<br/>
	{
<br/>
		((uint16*)OAM_SUB)[i] = ((uint16*)OAMCopySub)[i];
<br/>
	}
<br/>
}
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void irqVBlank(void) {	
<br/>
//---------------------------------------------------------------------------------
<br/>
}
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
int main(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
<br/>
	uint16* back = VRAM_A;
<br/>
	uint16* front = VRAM_B;
<br/>
<br/>
	Sprite sprites[NUM_SPRITES];
<br/>
<br/>
	int i, delta = 0;
<br/>
	int ix = 0;
<br/>
	int iy = 0;
<br/>
	int screen = 1;
<br/>
	uint16* map0 = (uint16*)SCREEN_BASE_BLOCK_SUB(1);
<br/>
	uint16* map1 = (uint16*)SCREEN_BASE_BLOCK_SUB(2);
<br/>
	uint16 red;
<br/>
<br/>
	//turn on the power to the system
<br/>
	powerON(POWER_ALL);
<br/>
<br/>
	//set main display to render directly from the frame buffer
<br/>
	videoSetMode(MODE_FB1);
<br/>
<br/>
	//set up the sub display
<br/>
	videoSetModeSub(MODE_0_2D | 
<br/>
					DISPLAY_SPR_1D_LAYOUT | 
<br/>
					DISPLAY_SPR_ACTIVE | 
<br/>
					DISPLAY_BG0_ACTIVE |
<br/>
					DISPLAY_BG1_ACTIVE );
<br/>
<br/>
	//vram banks are somewhat complex
<br/>
	vramSetMainBanks(VRAM_A_LCD, VRAM_B_LCD, VRAM_C_SUB_BG, VRAM_D_SUB_SPRITE);
<br/>
<br/>
	// a vblank interrupt is needed to use swiWaitForVBlank()
<br/>
	// since the dispatcher handles the flags no handler is required
<br/>
	irqInit();
<br/>
	irqSet(IRQ_VBLANK, irqVBlank);
<br/>
<br/>
	// Sprite initialisation
<br/>
	for(i = 0; i &lt; 256; i++)
<br/>
		SPRITE_PALETTE_SUB[i] = ((u16*)palette_bin)[i];
<br/>
<br/>
	for(i = 0; i&lt; 32*16; i++)
<br/>
		SPRITE_GFX_SUB[i] = ((u16*)man_bin)[i];
<br/>
<br/>
	//turn off sprites
<br/>
	initOAM();
<br/>
<br/>
	for(i = 0; i &lt; NUM_SPRITES; i++) {
<br/>
		//random place and speed
<br/>
		sprites[i].x = rand() &amp; 0xFFFF;
<br/>
		sprites[i].y = rand() &amp; 0x7FFF;
<br/>
		sprites[i].dx = (rand() &amp; 0xFF) + 0x100;
<br/>
		sprites[i].dy = (rand() &amp; 0xFF) + 0x100;
<br/>
<br/>
		if(rand() &amp; 1)
<br/>
			sprites[i].dx = -sprites[i].dx;
<br/>
		if(rand() &amp; 1)
<br/>
			sprites[i].dy = -sprites[i].dy;
<br/>
<br/>
		sprites[i].oam = &amp;OAMCopySub[i];
<br/>
		sprites[i].gfxID = 0;
<br/>
<br/>
		//set up our sprites OAM entry attributes
<br/>
		sprites[i].oam-&gt;attribute[0] = ATTR0_COLOR_256 | ATTR0_SQUARE;  
<br/>
		sprites[i].oam-&gt;attribute[1] = ATTR1_SIZE_32;
<br/>
		sprites[i].oam-&gt;attribute[2] = sprites[i].gfxID;
<br/>
		}
<br/>
<br/>
	//set up two backgrounds to scroll around
<br/>
	SUB_BG0_CR = BG_COLOR_256 | (1 &lt;&lt; SCREEN_SHIFT);
<br/>
	SUB_BG1_CR = BG_COLOR_256 | (2 &lt;&lt; SCREEN_SHIFT);
<br/>
<br/>
	BG_PALETTE_SUB[0] = RGB15(10,10,10);
<br/>
	BG_PALETTE_SUB[1] = RGB15(0,16,0);
<br/>
	BG_PALETTE_SUB[2] = RGB15(0,0,31);
<br/>
<br/>
	//load the maps with alternating tiles (0,1 for bg0 and 0,2 for bg1)
<br/>
	for(iy = 0; iy &lt; 32; iy++)
<br/>
		for(ix = 0; ix &lt;32; ix++) {
<br/>
			map0[iy * 32 + ix] = (ix ^ iy) &amp; 1;
<br/>
			map1[iy * 32 + ix] = ((ix ^ iy) &amp; 1)&lt;&lt;1;
<br/>
		}    
<br/>
<br/>
	//fill 2 tiles with different colors
<br/>
	for(i = 0; i &lt; 64 / 2; i++) {
<br/>
		BG_GFX_SUB[i+32] = 0x0101;
<br/>
		BG_GFX_SUB[i+32+32] = 0x0202;
<br/>
	}	
<br/>
<br/>
	while (1) {
<br/>
		//scroll the background
<br/>
		SUB_BG0_X0 = delta ;
<br/>
		SUB_BG0_Y0 = delta++ ;
<br/>
<br/>
		//move the sprites
<br/>
		for(i = 0; i &lt; NUM_SPRITES; i++) {
<br/>
			sprites[i].x += sprites[i].dx;
<br/>
			sprites[i].y += sprites[i].dy;
<br/>
<br/>
			//check for collision with the screen boundries
<br/>
			if(sprites[i].x &lt; (1&lt;&lt;8) || sprites[i].x &gt; (247 &lt;&lt; 8))
<br/>
				sprites[i].dx = -sprites[i].dx;
<br/>
<br/>
			if(sprites[i].y &lt; (1&lt;&lt;8) || sprites[i].y &gt; (182 &lt;&lt; 8))
<br/>
				sprites[i].dy = -sprites[i].dy;
<br/>
<br/>
			//reposition the sprites
<br/>
			MoveSprite(&amp;sprites[i]);
<br/>
		}
<br/>
<br/>
<br/>
<br/>
		//do the plasma/fire
<br/>
		for(ix = 0; ix &lt; SCREEN_WIDTH; ix++) {
<br/>
			back[ix + SCREEN_WIDTH * (SCREEN_HEIGHT - 1)] = rand()&amp; 0xFFFF;
<br/>
			back[ix + SCREEN_WIDTH * (SCREEN_HEIGHT - 2)] = rand()&amp; 0xFFFF;
<br/>
		}
<br/>
<br/>
		back++;
<br/>
<br/>
		for(iy = 1; iy &lt; SCREEN_HEIGHT - 2 ; iy++) {
<br/>
			for(ix = 1; ix &lt; SCREEN_WIDTH - 1; ix++)  {
<br/>
				red = 0;
<br/>
<br/>
				red += front[0];
<br/>
				red += front[2];
<br/>
<br/>
				front += SCREEN_WIDTH;
<br/>
<br/>
				red += front[0];
<br/>
				red += front[1];
<br/>
				red += front[2];
<br/>
<br/>
				front += SCREEN_WIDTH;
<br/>
<br/>
				red += front[0];
<br/>
				red += front[1];
<br/>
				red += front[2];
<br/>
<br/>
				front -= (2 * SCREEN_WIDTH) - 1;	
<br/>
<br/>
				back[0] =  (red &gt;&gt; 3);	
<br/>
				back++;
<br/>
			}
<br/>
			back += 2;
<br/>
			front += 2;
<br/>
<br/>
		}
<br/>
<br/>
		swiWaitForVBlank();
<br/>
<br/>
		updateOAM();
<br/>
<br/>
		//flip screens
<br/>
		if(screen) {
<br/>
			videoSetMode(MODE_FB1);
<br/>
			front = VRAM_B;
<br/>
			back = VRAM_A;
<br/>
			screen = 0;
<br/>
		} 
<br/>
		else 
<br/>
		{
<br/>
			videoSetMode(MODE_FB0);	
<br/>
			front = VRAM_A;
<br/>
			back = VRAM_B;
<br/>
			screen = 1;
<br/>
		}
<br/>
<br/>
		}
<br/>
		return 0;
<br/>
<br/>
}
<br/>
<br/>
[/code]
<br/>
[/img][url][/url]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#138593 - SaruCoder - Sun Aug 26, 2007 6:17 am</h4>
    <div class="postbody"><span class="postbody">It looks like the sprite raster data isn't mapped properly.  Sprite gfx data is divided into 8x8 pixel tiles.  So, popping in a raster image directly won't display properly.
<br/>
<br/>
I recommend you try using wingrit after you create your pcx or bmp.  It'll remap your sprite gfx data into the correct order, and load it into a (u8/u16/u32) array in a .c file.  I find those are easier to use then converting pcx or bmps to a bin file.
<br/>
<a class="postlink" href="http://www.coranac.com/projects.php#grit" target="_blank">http://www.coranac.com/projects.php#grit</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#138594 - ubercatch22 - Sun Aug 26, 2007 6:25 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>SaruCoder wrote:</b></span></td> </tr> <tr> <td class="quote">It looks like the sprite raster data isn't mapped properly.  Sprite gfx data is divided into 8x8 pixel tiles.  So, popping in a raster image directly won't display properly.
<br/>
<br/>
I recommend you try using wingrit after you create your pcx or bmp.  It'll remap your sprite gfx data into the correct order, and load it into a (u8/u16/u32) array in a .c file.  I find those are easier to use then converting pcx or bmps to a bin file.
<br/>
<a class="postlink" href="http://www.coranac.com/projects.php#grit" target="_blank">http://www.coranac.com/projects.php#grit</a></td> </tr></table><span class="postbody">
<br/>
<br/>
can you explain the sprite raster a little more. i seems that u16 is best for the sprite where it is still disprted but not the worst</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#138595 - SaruCoder - Sun Aug 26, 2007 8:29 am</h4>
    <div class="postbody"><span class="postbody">You know how in some countries, text is read left to right, and in some places it's read top to bottom (starting at the back of the book too)?
<br/>
<br/>
It's the same principles here, the nds/gba reads in a image differently.
<br/>
<br/>
The image raster for PCX and BMPs are read left to right, then top to bottom.  Like how a TV works.  It starts at the top-left, and reads side to side.
<br/>
<br/>
NDS/GBA however breaks down a image into 8x8 pixel tiles, and then treats each block as an raster image.
<br/>
<br/>
For example, if you have a 64x64 BMP raster image, the NDS/GBA will read the first 64 pixels (#of pixels in a 8x8 tile).  Then it'll think it's the first tile and it'll render a 8x8 tile of gobbledegoop instead of rendering it as the top line of your BMP.
<br/>
<br/>
So that's the "technical" details in a nutshell.  But you don't need to worry about that when you use wingrit, but it's good to know.
<br/>
<br/>
And yes, stick to u16 because that's how SPRITE_GFX(_SUB) are aligned.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#138598 - LiraNuna - Sun Aug 26, 2007 10:41 am</h4>
    <div class="postbody"><span class="postbody">what are copying into VRAM is probably a raw PCX file.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">i use adobe photoshop cs3 extended for the .pcx but i get the error that the compiler cant find the file even know it is there. </td> </tr></table><span class="postbody">
<br/>
This is because there is no rule for the bin2o macro (I bet the compiler errors something along the line of "no rule to make target filename.pcx.o")
<br/>
What you should do, is to convert the PCX file into a data asset the DS GPU can work with. As SaruCoder said, a sprite is made out of 8x8 tiles linearly (also called 1D mode), of course this can be changed, but other modes are rarely used.
<br/>
<br/>
To convert sprites, I recommend using gfx2gba using the command
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">gfx2gba -c256 -t8 image.pcx</td> </tr></table><span class="postbody">
<br/>
-c256 is 256 color output, (I saw you were using ATTR0_COLOR_256)
<br/>
-t8 means square tiles of 8x8. 
<br/>
<br/>
you will get two files as output - image.raw and image.pal. rename them to .bin and include them in the 'data' folder. [/code]<br/>_________________<br/>Private property.
<br/>
Violators will be shot, survivors will be shot again.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
