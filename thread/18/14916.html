<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Artifacts on Upper Left Corners of Sprites (SOLVED) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Artifacts on Upper Left Corners of Sprites (SOLVED)</h2>
<div id="posts">
<div class="post">
    <h4>#149828 - rook02 - Fri Jan 25, 2008 8:00 pm</h4>
    <div class="postbody"><span class="postbody">Hello. I haven't posted in a while, becaues I've been busy fooling around with the OAM, trying things out for myself, seeing what I can do with it, etc. However, it seems that I've run into more problems.
<br/>
<br/>
I'm trying to make a function that takes a png file and puts it straight into the OAM as a sprite. I've been doing okay, until artifacts started appearing on the upper left corners of some of the sprites, and I can't seem to figure out what's causing them. I'm not sure... I might have screwed something up...
<br/>
<br/>
I don't think it's the PNG reading process because I can draw the PNG files correctly using framebuffer. So it might have something to do with the way I copied the the sprites into the memory...
<br/>
<br/>
<br/>
This is my VRAM Bank setup:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">      vramSetMainBanks(VRAM_A_MAIN_BG_0x06000000,
<br/>
                   VRAM_B_MAIN_BG_0x06020000,
<br/>
                   VRAM_C_SUB_BG_0x06200000,
<br/>
                   VRAM_D_LCD);
<br/>
<br/>
      vramSetBankE(VRAM_E_MAIN_SPRITE);
<br/>
<br/>
      videoSetMode(MODE_5_2D | 
<br/>
                DISPLAY_BG2_ACTIVE | 
<br/>
                DISPLAY_BG3_ACTIVE | 
<br/>
                DISPLAY_SPR_ACTIVE | 
<br/>
                DISPLAY_SPR_1D      | 
<br/>
                DISPLAY_SPR_1D_SIZE_64 
<br/>
                );</td> </tr></table><span class="postbody">
<br/>
<br/>
This is the bottom of my method... it chucks pixels and stuff into the OAM...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> 
<br/>
static int CONTENT_SPRITE_ADDRESS = 0;
<br/>
   ...
<br/>
   ...
<br/>
// throw things into OAM
<br/>
   dmaCopy ( CONTENT_GLOBAL_PALETTE, SPRITE_PALETTE, 256 * sizeof ( unsigned short ) );
<br/>
   dmaCopy ( container.pixels, &amp;SPRITE_GFX[ CONTENT_SPRITE_ADDRESS * 32 ], container.pixel_count * sizeof ( unsigned char ) );
<br/>
   container.oam_address = CONTENT_SPRITE_ADDRESS;
<br/>
   // increment for next use
<br/>
   CONTENT_SPRITE_ADDRESS += container.pixel_count &gt;&gt; 6;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This has kept tracking tile addresses easy (1 index for each 8x8 tile), as far as I've tested... but like I said... I think I screwed up something recently, and I'm not sure what it is. It returns a Container struct that has info on the image as well as its tile address in the OAM (container-&gt;oam_address)
<br/>
<br/>
Here's the other half...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static int GRAPHICS_SPRITE_INDEX = 0;
<br/>
void DrawSprite(Container* sprite, SpriteEntry * sprites )
<br/>
{   
<br/>
   // Attribute 0
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].posY = 0;
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].isRotoscale = false;
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].rsDouble = false;
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].objMode = OBJMODE_NORMAL;
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].isMosaic = false;
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].colMode = OBJCOLOR_256;
<br/>
   // determine if tall, wide or square
<br/>
   if ( sprite-&gt;width &gt; sprite-&gt;height )
<br/>
   {
<br/>
   ...
<br/>
   ...
<br/>
   else
<br/>
   {
<br/>
      sprites[GRAPHICS_SPRITE_INDEX].objShape = OBJSHAPE_SQUARE;
<br/>
   }
<br/>
<br/>
<br/>
   //Attribute 1
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].posX = 0;
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].rsMatrixIdx = ATTR1_ROTDATA(0);
<br/>
   // instead of a super complicated if-else chain, I'lll just use the number of pixels to figure out the size
<br/>
   if ( sprite-&gt;pixel_count &lt;= 128 )
<br/>
   {
<br/>
   ...
<br/>
   ...
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
      sprites[GRAPHICS_SPRITE_INDEX].objSize = OBJSIZE_64;
<br/>
   }
<br/>
   
<br/>
   // Attribute 2
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].tileIdx = (u16) sprite-&gt;oam_address;
<br/>
    sprites[GRAPHICS_SPRITE_INDEX].objPriority = OBJPRIORITY_0;
<br/>
    //sprites[GRAPHICS_SPRITE_INDEX].objPal = 0;
<br/>
   
<br/>
   GRAPHICS_SPRITE_INDEX ++;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Hmm... Can anyone help me figure this out? Thanks...
<br/>
<br/>
EDIT
<br/>
<br/>
Fixed by using swiCopy instead of dmaCopy...
<br/>
<br/>
&gt;.&lt;
<br/>
<br/>
I get the errors with the really random kind of solutions...</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
