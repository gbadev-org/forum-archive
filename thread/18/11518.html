<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>libnds For the PC - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > libnds For the PC</h2>
<div id="posts">
<div class="post">
    <h4>#106816 - Lazy1 - Mon Oct 23, 2006 7:11 pm</h4>
    <div class="postbody"><span class="postbody">I have been thinking about this for a while, having a seperate version of libnds which would allow a nds program to be compiled as native PC code.
<br/>
<br/>
I think direct hardware access would raise an error which could be captured, decoded and handled within the library - but I'm not too sure about that.
<br/>
<br/>
There are a few issues remaining with the idea, but it would really speed up development if you could just compile and run on the same PC as your developing on rather than having to copy it to your DS every time.
<br/>
<br/>
Any thoughts?
<br/>
It would be like an emulator, but instead only emulates the DS hardware while running native code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#106818 - silent_code - Mon Oct 23, 2006 7:21 pm</h4>
    <div class="postbody"><span class="postbody">i once wrote a look and feel nds simulator for a project. it still needed some changes in the code to compile for nds, but you got the idea of how it would look and play like on the nds. it was sort of a prototype running on a pc. ;)
<br/>
<br/>
i'm currently developping a toolset that'll make it easier to move these prototypes to nds. no release yet, as this is part of another project, but it will definitely be released asap.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#106870 - melw - Tue Oct 24, 2006 8:55 am</h4>
    <div class="postbody"><span class="postbody">You may want to use an opposite approach - make a simple SDL application (something that runs on Win32, OSX, Linux, GP2X, you name it) and make a conversion from there to libnds where needed. Doing the minimum, i.e. input system for buttons and mouse (i.e. touchscreen) and framebuffer for showing the graphics is something like one weekend at max. and it's easy to expand from there. You can even just define different targets in your makefile and compile to whatever platform you like.
<br/>
<br/>
I've been using this kind of system for nearly a year and haven't touched an emulator since then... Making cross-platform 3d graphics implementation is also possible since the libnds is close enough to OpenGL, even if lacking here and there.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#106889 - Lazy1 - Tue Oct 24, 2006 2:52 pm</h4>
    <div class="postbody"><span class="postbody">That is almost exactly what I had in mind, except I need to be able to trap and handle accesses to non existant DS hardware.
<br/>
For example, say the app wants to write to POWER_CR.
<br/>
The application would segfault, I could decode the instruction and update the local POWER_CR variable which would affect the application.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#106899 - GPFerror - Tue Oct 24, 2006 4:13 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>melw wrote:</b></span></td> </tr> <tr> <td class="quote">You may want to use an opposite approach - make a simple SDL application (something that runs on Win32, OSX, Linux, GP2X, you name it) and make a conversion from there to libnds where needed. Doing the minimum, i.e. input system for buttons and mouse (i.e. touchscreen) and framebuffer for showing the graphics is something like one weekend at max. and it's easy to expand from there. You can even just define different targets in your makefile and compile to whatever platform you like.
<br/>
<br/>
I've been using this kind of system for nearly a year and haven't touched an emulator since then... Making cross-platform 3d graphics implementation is also possible since the libnds is close enough to OpenGL, even if lacking here and there.</td> </tr></table><span class="postbody">
<br/>
<br/>
Well it is possible to use my libSDL port for the ds as well, and if more people used it it would have better features, right now touchscreen is only used for debug output. Sound is still in its infancy and filesupport is hardcoded to either use romfs or fatlib. 
<br/>
<br/>
It uses a mode6 1024X512 8bit background or 512X512 16bit background which uses scaling to match your setscreen size, I have used it for porting stuff from the pc etc to the ds.
<br/>
<br/>
The latest SDL version can be downloaded from <a href="http://gpf.dcemu.co.uk/ndsSDL.shtml" target="_blank">http://gpf.dcemu.co.uk/ndsSDL.shtml</a>
<br/>
<br/>
But I think TheLazy1 approach sound very interesting and I have seen similiar approaches on other consoles and its very usefull. Untill there is better emulator support with gdb debugging this sounds like a good solutution.
<br/>
<br/>
Troy(GPF)
<br/>
<a href="http://gpf.dcemu.co.uk" target="_blank">http://gpf.dcemu.co.uk</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#106976 - masscat - Wed Oct 25, 2006 12:13 pm</h4>
    <div class="postbody"><span class="postbody">I looked at this approach a while back. Here is some linux code for catching segmentation faults:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;stdio.h&gt;
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;signal.h&gt;
<br/>
#include &lt;ucontext.h&gt;
<br/>
<br/>
int a_global_var = 10;
<br/>
<br/>
static void
<br/>
seg_fault_catcher( int signum, siginfo_t *info, void *data) {
<br/>
  ucontext_t *context = (ucontext_t *)data;
<br/>
<br/>
  printf("Segmentation fault\n");
<br/>
  printf("context uc_flags 0x%lx\n", context-&gt;uc_flags);
<br/>
  fflush( stdout);
<br/>
<br/>
  a_global_var = 15;
<br/>
<br/>
  abort();
<br/>
}
<br/>
<br/>
<br/>
int main() {
<br/>
  struct sigaction new_action = {
<br/>
    .sa_handler = NULL,
<br/>
    .sa_sigaction = seg_fault_catcher,
<br/>
    .sa_flags = SA_SIGINFO,
<br/>
    .sa_restorer = NULL
<br/>
  };
<br/>
<br/>
  int small_array[10];
<br/>
  int i;
<br/>
<br/>
  sigemptyset ( &amp;new_action.sa_mask);
<br/>
<br/>
  sigaction( SIGSEGV, &amp;new_action, NULL);
<br/>
<br/>
  printf("Hello world\n");
<br/>
<br/>
  printf("%p\n", &amp;a_global_var);
<br/>
  printf("%p\n", seg_fault_catcher);
<br/>
<br/>
  while ( a_global_var == 10) {
<br/>
    *(int *)0x4000000 = 10;
<br/>
  }
<br/>
<br/>
  printf("Good bye\n");
<br/>
  return (0);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
And that is about as far as I took it. My advice would be to look at GDB (GNU debugger) code for examples of how to run a process under control, catching its errors and changing its state as the two problems are very similar.
<br/>
I like this approach as you get a 'free' PC version of your NDS game as well as the ability to use better debug tools.
<br/>
<br/>
On another note, I am putting a GDB stub into the desume emulator at the moment. This should allow sophisticated debugging techniques such as break on read and write of memory addresses.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#106978 - sgeos - Wed Oct 25, 2006 12:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">That is almost exactly what I had in mind, except I need to be able to trap and handle accesses to non existant DS hardware.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I think you'd be better off building an API that can be used with both the PC and the DS.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107017 - Lazy1 - Wed Oct 25, 2006 6:37 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lazy1 wrote:</b></span></td> </tr> <tr> <td class="quote">That is almost exactly what I had in mind, except I need to be able to trap and handle accesses to non existant DS hardware.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I think you'd be better off building an API that can be used with both the PC and the DS.
<br/>
<br/>
-Brendan</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Problem is that for some reason DS coders are reluctant to use such libraries and the dev community seems to look down on those who do.
<br/>
Just look at PA-LIB.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107041 - silent_code - Wed Oct 25, 2006 10:36 pm</h4>
    <div class="postbody"><span class="postbody">don't care about other people if it helps you. you don't have to make it public or something. even if you do, everyone can decide for himself what to use, e.g. MegaETK is a kick ass game and it was done with PAlib. [i personally don't use PAlib and i also don't plan to use it.] you can't tell me that someone says bad things about ETK, plus he won that goddamn contest ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107046 - Lazy1 - Wed Oct 25, 2006 11:05 pm</h4>
    <div class="postbody"><span class="postbody">What I mean is, don't ask for PALIB help on IRC...
<br/>
They'll flame the crap out of you, then suggest libnds.
<br/>
<br/>
Besides, there isn't much direct HW access done anyway.
<br/>
It's mainly setting BG scrolling registers during vblank or whatever, maybe writes to vram but that would be slow as hell using this method and you shouldn't be writing to vram like that anyway (unless it's a special case).
<br/>
<br/>
The goal wouldn't be a 100% accurate emulator, just something to do rapid development on.
<br/>
<br/>
Masscat: I tried something like that, but was never able to skip over the instruction or figure out how to decode it.
<br/>
My guess would be to have platform specific code decompile the instruction and update the local register copy itself.
<br/>
<br/>
I guess I have alot more reading to do on signals. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107053 - tepples - Thu Oct 26, 2006 12:11 am</h4>
    <div class="postbody"><span class="postbody">First of all, create a single framework that can be used to develop on the GBA and PC. The GBA is a simpler system, and it should be easier to get it up and running quickly. This will give you ideas about how to do the DS source compatibility layer right.
<br/>
<br/>
Hint 1: Make the C or C++ equivalent of a <a class="postlink" href="http://en.wikipedia.org/wiki/JavaBeans" target="_blank">bean</a>. For instance, don't expose a global variable DISPCNT; instead make functions such as getDISPCNT() and setDISPCNT() for all hardware registers, so that your PC based PPU emulator can more easily intercept them. Then in the GBA side, just make the get() and set() into inline functions.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107056 - Lazy1 - Thu Oct 26, 2006 1:09 am</h4>
    <div class="postbody"><span class="postbody">You raise a good point there, I wouldn't need to have the register addresses the same as nds.
<br/>
So, I wouldn't need to trap/decode memory accesses at all or atleast not in the way I first thought.
<br/>
<br/>
There are still a few issues, but they aren't that big of a deal:
<br/>
<br/>
- No assembly source
<br/>
- No direct writes to vram
<br/>
- No way to force 66mhz operation, you'd have to sync to vblank for accuracy
<br/>
<br/>
I have no idea about arm7 code, maybe have a seperate PC library for that and have it run as another process and use IPC to communicate with the main application.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107079 - PypeBros - Thu Oct 26, 2006 9:18 am</h4>
    <div class="postbody"><span class="postbody">i have to admit that i'm a bit perplexed by your approach. Okay, it's a common things in emulators to write out native code to speed up emulation (like in those N64 emulators), or simply to let the current processor do the job <span style="font-style: italic">when hosting and emulated processors are the same</span> (that's what QEMU does, for instance).
<br/>
<br/>
But here, the processors are very differents and the one you want to emulate runs orders of magnitude slower than the host, and emulating the CPU is hardly the most complicated thing to do ...
<br/>
<br/>
At the end, you'd be running something that's <span style="font-style: italic">not</span> the program you'd like to see running on the DS (e.g. it may have a very different memory footprints and suffer different weird bugs), and you'd still have to wait for a full SIGSEGV delivery everytime you do something special (like reprogramming any register that needs to behave in a 'special' way). Not mentionning the ugly case where your system doesn't let you map memory at VRAM and where you'd have to catch a SIGSEGV for every pixel you change :-/
<br/>
<br/>
So if you want to have a "compatibility" library to run new software X both on the DS and on anything else, i'd suggest you focus on a library with a higher level of abstraction (such as PA_Lib?) -- that is, your C program should never do some direct I/O to the registers -- so that the library can completely hide what's going on below.
<br/>
<br/>
Or alternatively, you just write a portable game engine like Sarrien, ScummVM or the one behind Another World and Flash back ...<br/>_________________<br/><a class="postlink" href="http://sylvainhb.blogspot.com/p/sprite-editor.html" target="_blank"> SEDS: Sprite Edition on DS</a> :: <a class="postlink" href="http://sylvainhb.blogspot.com/search/label/modplayer" target="_blank">modplayer</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107110 - Lazy1 - Thu Oct 26, 2006 7:06 pm</h4>
    <div class="postbody"><span class="postbody">I see your point, but this wouldn't be designed for accuracy as it would only emulate a few system registers and the display system.
<br/>
It's more for rapid development if you get an idea and you want to work on it quickly without having to do musical CF cards every time you want to test it.
<br/>
<br/>
I know the architecture is extremely different, but I don't see that as a big issue. You could always use dualis, but this would mean you just compile and run your DS app from the command line just like any other PC application.
<br/>
<br/>
The issue of writing to hardware registers has been resolved, the register definitions will be pointing to global variables instead.
<br/>
The only issue remaining is direct writes to vram which I don't think is done that often, if you have gfx or a map to copy DMA would be a better option and it could be easily simulated with no performance penalty.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
