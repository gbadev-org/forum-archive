<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Parts of screen refuse to update - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Parts of screen refuse to update</h2>
<div id="posts">
<div class="post">
    <h4>#71511 - HyperHacker - Mon Feb 13, 2006 7:06 am</h4>
    <div class="postbody"><span class="postbody">This is a problem that has plauged every DS app I've written so far. I set both screens to mode 5 and use BG3 to display graphics; it simply works like a 256x192 16BPP bitmap. Because drawing directly into VRAM produces flicker, I keep a second bitmap in memory, and use dmaCopyWords to copy it into VRAM during VBlank.
<br/>
<br/>
The problem is, sometimes certain portions of the screen around the corners simply will not update. If I draw something, then erase it to black, pieces of what I drew are still visible even though reading from the bitmap in memory shows that the pixel value is 0x8000, which should be black. They keep displaying the old image until I draw something else there, which is especially odd, as it should be copying the bitmap into VRAM every VBlank whether I've modified it or not. The parts that don't get updated seem to be random, but have some patterns:
<br/>
<ul><li>Starting from the very top left and very bottom left corners (positions 0,0 and 0,191) there are always at least two pixels in a horizontal line that don't update.
<br/>
</li><li>The problem always occurrs near the corners of the screen.
<br/>
</li><li>The non-updated portions are often rectangular, and always wrap around the edge of the screen (starting on the right, and continuing on to the next row on the left, as the bitmap is a one-dimensional array).</li></ul>
<br/>
<br/>
I can draw as many different things as I want, and they all show up fine, until I try to clear the screen to black (0x8000) at which point some of the pixels just don't change. This can be seen in my <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=8522" target="_blank">GBA Booter</a> app; switching from any border to None will leave pieces of the border on the screen. What's more is it's not just black. If I try to clear the screen to any colour at all, it will do this, but when I'm actually drawing images, it works fine. Also this never happens if I only clear outside of those areas (as mentioned, it only happens in the corners). The problem isn't in the function that does the clearing either, as I've used several different methods including writing directly to the bitmap.
<br/>
<br/>
The problem seems to be that certain writes to the bitmap are being ignored. However I've used all manner of methods to ensure they aren't:
<br/>
<ul><li>Displaying the pixels' colour value on the screen and ensuring that it's correct
<br/>
</li><li>Delaying DMA until all writes to the bitmap are complete
<br/>
</li><li>Delaying writes to the bitmap until DMA is complete
<br/>
</li><li>Adding a while loop to the function that clears the bitmap to keep writing each pixel until its value actually is the value being written</li></ul>
<br/>
<br/>
I'm completely stumped as to what the heck is going on here. @_@
<br/>
<br/>
Relevant code, all on ARM9:
<br/>
Setting up video and interrupts:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
<br/>
   videoSetModeSub(DISPLAY_SCREEN_OFF); //Yes, I'm only using one screen on the DS. Crazy ain't it?
<br/>
   vramSetMainBanks(VRAM_A_MAIN_BG_0x6000000, VRAM_B_MAIN_BG_0x6000000, VRAM_C_LCD, VRAM_D_LCD); //Put both VRAM banks at the same place, so borders work
<br/>
   MainScreenBuf = CreateGraphicBuffer(SCREEN_WIDTH,SCREEN_HEIGHT);
<br/>
   Coords = (8 &lt;&lt; 16) | 16;
<br/>
<br/>
   while(IPC-&gt;arm9desc != A9_GBASCREEN);
<br/>
   IPC-&gt;arm9desc = 0;
<br/>
<br/>
   if(IPC-&gt;arm9data)
<br/>
   {
<br/>
      TopScreen = false;
<br/>
      lcdMainOnBottom();
<br/>
      IPC-&gt;arm7data = PM_BACKLIGHT_TOP;
<br/>
   }
<br/>
   else
<br/>
   {
<br/>
      TopScreen = true;
<br/>
      lcdMainOnTop();
<br/>
      IPC-&gt;arm7data = PM_BACKLIGHT_BOTTOM;
<br/>
   }
<br/>
<br/>
   IPC-&gt;arm7desc = A7_POWEROFF;
<br/>
   while(IPC-&gt;arm9desc != A9_ACK);
<br/>
   IPC-&gt;arm9desc = 0;
<br/>
<br/>
   BG3_CR = BG_BMP16_256x256;
<br/>
   BG3_XDX = 1 &lt;&lt; 8;
<br/>
   BG3_XDY = 0;
<br/>
   BG3_YDX = 0;
<br/>
   BG3_YDY = 1 &lt;&lt; 8;
<br/>
   BG3_CX = 0;
<br/>
   BG3_CY = 0;
<br/>
<br/>
   SUB_BG3_CR = BG_BMP16_256x256;
<br/>
   SUB_BG3_XDX = 1 &lt;&lt; 8;
<br/>
   SUB_BG3_XDY = 0;
<br/>
   SUB_BG3_YDX = 0;
<br/>
   SUB_BG3_YDY = 1 &lt;&lt; 8;
<br/>
   SUB_BG3_CX = 0;
<br/>
   SUB_BG3_CY = 0;
<br/>
<br/>
   //Init interrupts
<br/>
   REG_IME = 0; //Disable interrupts while changing them
<br/>
   IRQ_HANDLER = Interrupt; //Set handler callback
<br/>
   REG_IE = IRQ_VBLANK | IRQ_HBLANK; //Interrupt on vblank only
<br/>
   REG_IF = ~0;
<br/>
   DISP_SR = DISP_VBLANK_IRQ | DISP_HBLANK_IRQ;
<br/>
   REG_IME = 1; //Enable interrupts
<br/>
<br/>
   swiWaitForVBlank();
<br/>
   swiWaitForVBlank();
<br/>
   swiWaitForVBlank(); //Let things set up</td> </tr></table><span class="postbody">
<br/>
<br/>
VBlank handler:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   else if(REG_IF &amp; IRQ_VBLANK) //VBlank interrupt
<br/>
   {
<br/>
      KeysPressed = IPC-&gt;buttons_pressed; //Best to keep a local copy, since the ARM7 may modify it
<br/>
      KeysHeld = IPC-&gt;buttons_held;
<br/>
<br/>
      if(SwapBuffers)
<br/>
      {
<br/>
         //while(MainScreenBuf-&gt;InUse);
<br/>
         //MainScreenBuf-&gt;InUse++;
<br/>
         dmaCopyWords(0,MainScreenBuf-&gt;Pixels,BG_GFX,(SCREEN_WIDTH*SCREEN_HEIGHT) &lt;&lt; 1);
<br/>
         //while(dmaBusy(0)) swiDelay(1);
<br/>
         //MainScreenBuf-&gt;InUse--;
<br/>
         SwapBuffers = false;
<br/>
      }
<br/>
<br/>
      VBLANK_INTR_WAIT_FLAGS |= IRQ_VBLANK; //Signal that vblank interrupt has been processed
<br/>
      REG_IF |= IRQ_VBLANK; //Signal that vblank interrupt processing is done. We need to trigger a write even though this shouldn't change the value.
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
(and yes, I am setting SwapBuffers, also tried ignoring it and just updating every frame.)
<br/>
<br/>
Graphic functions involved:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*
<br/>
Creates a graphic buffer
<br/>
CPU: ARM9
<br/>
Inputs:
<br/>
   -Width, Height = Size of buffer
<br/>
Returns: Pointer to buffer or NULL on fail.
<br/>
Notes:
<br/>
   -Only 16-bit-colour buffers are currently supported.
<br/>
   -Be sure to free the buffer when you're done with it. (Just free(Buffer) will do.)
<br/>
   -Buffer's content is undefined when created. If you need it to start filled with
<br/>
    a given colour, fill it yourself after creating it.
<br/>
<br/>
*/
<br/>
GraphicBuffer* CreateGraphicBuffer(uint16 Width, uint16 Height)
<br/>
{
<br/>
   GraphicBuffer* G = (GraphicBuffer*)memalign(4,sizeof(GraphicBuffer) + (((uint32)Width * (uint32)Height) &lt;&lt; 1));
<br/>
   if(!G) return NULL;
<br/>
   G-&gt;Width = Width;
<br/>
   G-&gt;Height = Height;
<br/>
   return G;
<br/>
}
<br/>
<br/>
<br/>
/*
<br/>
Clears a graphic buffer to a specified colour
<br/>
CPU: ARM9
<br/>
Inputs:
<br/>
   -Buffer: Pointer to graphic buffer
<br/>
   -Colour: RGB15 colour
<br/>
*/
<br/>
void ClearGraphicBuffer(GraphicBuffer* Dest, uint16 Colour)
<br/>
{
<br/>
   Colour |= 0x8000;
<br/>
   int i;
<br/>
   uint16* P = Dest-&gt;Pixels;
<br/>
   for(i=0;i&lt;(Dest-&gt;Width * Dest-&gt;Height);i++)
<br/>
   {
<br/>
      (*P) = Colour;
<br/>
      P++;
<br/>
   }
<br/>
}
<br/>
<br/>
<br/>
/*
<br/>
Draws a solid rectangle on a graphic buffer
<br/>
CPU: ARM9
<br/>
Inputs:
<br/>
   -Dest = Destination buffer
<br/>
   -DX, DY = Destination coords
<br/>
   -W, H = Dimensions of rectangle
<br/>
   -Colour = RGB15 colour
<br/>
*/
<br/>
void FillRect(GraphicBuffer* Dest, uint16 DX, uint16 DY, uint16 W, uint16 H, uint16 Colour)
<br/>
{
<br/>
   Colour |= 0x8000;
<br/>
   int x,y;
<br/>
   uint16* DP = Dest-&gt;Pixels + DX + (DY * Dest-&gt;Width);
<br/>
   for(y=0;y&lt;H;y++)
<br/>
   {
<br/>
      for(x=0;x&lt;W;x++)
<br/>
         (*(DP + x)) = Colour;
<br/>
      DP += Dest-&gt;Width;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71529 - DekuTree64 - Mon Feb 13, 2006 8:30 am</h4>
    <div class="postbody"><span class="postbody">Sounds like parts of your buffer are still in the cache, and need to be flushed out before DMA will see them. Looks like DC_FlushRange is the function to do that.
<br/>
<br/>
It may actually be faster to copy the buffer to VRAM with CPUFastSet (or a custom ldmia/stmia loop) instead, since flushing data from the cache does take time too. I'd be interested to know the results if you try any speed tests on it.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71530 - HyperHacker - Mon Feb 13, 2006 8:40 am</h4>
    <div class="postbody"><span class="postbody">That does seem logical, since I'm doing a lot of reading and writing of the corner pixels (generating a diagonal gradient). What's this DC_FlushRange though?
<br/>
<br/>
I'll try a custom loop tomorrow. I need to sleep now.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71794 - wintermute - Tue Feb 14, 2006 3:43 pm</h4>
    <div class="postbody"><span class="postbody">DC_FlushRange flushes an area of cache to memory to allow DMA and arm7 to read it.
<br/>
<br/>
<a href="http://devkitpro.sourceforge.net/devkitProWiki/libnds/a00027.html" target="_blank">http://devkitpro.sourceforge.net/devkitProWiki/libnds/a00027.html</a><br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71893 - HyperHacker - Wed Feb 15, 2006 5:06 am</h4>
    <div class="postbody"><span class="postbody">OK, so... I tried to write that loop:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">uint16* UncachedPixels;
<br/>
[...]
<br/>
else if(REG_IF &amp; IRQ_VBLANK) //VBlank interrupt
<br/>
{
<br/>
   KeysPressed = IPC-&gt;buttons_pressed; //Best to keep a local copy, since the ARM7 may modify it
<br/>
   KeysHeld = IPC-&gt;buttons_held;
<br/>
<br/>
   if(SwapBuffers)
<br/>
   {
<br/>
      UncachedPixels = MainScreenBuf-&gt;Pixels + 0x400000;
<br/>
      //dmaCopyWords(0,MainScreenBuf-&gt;Pixels,BG_GFX,(SCREEN_WIDTH*SCREEN_HEIGHT) &lt;&lt; 1);
<br/>
      __asm(".arm\n"
<br/>
         "ldr r1,UncachedPixels\n"
<br/>
         "ldr r2,BG_GFX\n"
<br/>
         "ldr r3,=49152\n" //256x192
<br/>
         "loop:\n"
<br/>
         "ldrh r0,[r1, #2]!\n" //Read from r1 and add 2 to it
<br/>
         "strh r0,[r2, #2]!\n" //Store at r2 and add 2 to it
<br/>
         "sub r3,r3,#1\n" //r3--
<br/>
         "bne loop\n"
<br/>
         ".pool\n"
<br/>
         );
<br/>
      SwapBuffers = false;
<br/>
   }
<br/>
   [...]</td> </tr></table><span class="postbody">
<br/>
Probably all wrong, but anyway... After a bit of tinkering I got rid of all the errors it complained of... and then it came up with more. (God how I hate that.) What the hex does "Error: internal_relocation (type: OFFSET_IMM) not fixed up" mean? I get it almost every time I try to do ASM. &gt;_&lt;
<br/>
<br/>
[edit] Hah, it is a cache problem. Putting DC_FlushRange in fixed it. I still want to get the ASM loop working though, as I imagine this is rather slow (and even if not, I want it as fast as possible).
<br/>
<br/>
Strange though, I tried just passing the pointer + 0x400000 to dmaCopyWords(), but it didn't make a difference. (As Chishm told me a while ago, 0x02400000-0x02800000 is an uncached mirror of 0x02000000-0x02400000.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71898 - chishm - Wed Feb 15, 2006 5:56 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>HyperHacker wrote:</b></span></td> </tr> <tr> <td class="quote">Strange though, I tried just passing the pointer + 0x400000 to dmaCopyWords(), but it didn't make a difference. (As Chishm told me a while ago, 0x02400000-0x02800000 is an uncached mirror of 0x02000000-0x02400000.)</td> </tr></table><span class="postbody">
<br/>
Uncached from the CPU's perspective. Reading / writing the uncached memory range from the CPU will always bypass the cache, but using the cached region may put it into dcache. DMA can only access the main memory, so to it, the cache doesn't even exist and it is as though both ranges are uncached. However, because it can't access the cache, any changes not flushed will not be seen by the DMA copy.<br/>_________________<br/><a class="postlink" href="http://chishm.drunkencoders.com" target="_blank">http://chishm.drunkencoders.com</a>
<br/>
<a class="postlink" href="http://dldi.drunkencoders.com" target="_blank">http://dldi.drunkencoders.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71900 - DekuTree64 - Wed Feb 15, 2006 6:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>HyperHacker wrote:</b></span></td> </tr> <tr> <td class="quote">What the hex does "Error: internal_relocation (type: OFFSET_IMM) not fixed up" mean?</td> </tr></table><span class="postbody">
<br/>
Usually means undefined identifier or syntax error of some sort, which in this case is probably BG_GFX. You'll need to use the straight address without any C-style casts around it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Hah, it is a cache problem. Putting DC_FlushRange in fixed it.</td> </tr></table><span class="postbody">
<br/>
Yay, that was just a first guess based on the symptoms :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I still want to get the ASM loop working though, as I imagine this is rather slow.</td> </tr></table><span class="postbody">
<br/>
Yup, ldrh/strh is a major waste of time. At least use ldr/str, but ldmia/stmia is best. I'd recommend doing the copy loop in a .s file, rather than messing with that icky looking inline asm. Try compiling this in a .s for starters:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.global FastCopy
<br/>
.arm
<br/>
.align 2
<br/>
FastCopy:
<br/>
stmfd sp!, {r4-r11, lr}   @ Save regs on stack (r0-r3,r12 don't need to be preserved)
<br/>
<br/>
@ Do stuff here
<br/>
<br/>
ldmfd sp!, {r4-r11, lr}   @ Restore regs
<br/>
bx lr // Return to caller</td> </tr></table><span class="postbody">
<br/>
And extern it in a .cpp file like 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">extern "C" void FastCopy(const void *src, void *dest, u32 bytes);</td> </tr></table><span class="postbody">
<br/>
Or nix the "C" if it's a .c file. Those 3 parameters will be in r0-r2, and you're free to modify them however you like.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71902 - HyperHacker - Wed Feb 15, 2006 6:44 am</h4>
    <div class="postbody"><span class="postbody">Haha, you're right again. I thought BG_GFX was just a constant, but it's actually a macro with a cast. No wonder. :-p
<br/>
<br/>
Now I haven't really worked with ARM before... I understand those ops save and restore r4 through r11 and lr (r13?) at sp (r14?) and then update sp, correct? So I would want to then do something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">stmfd sp!,{r4-r11,lr}
<br/>
loop:
<br/>
ldmia r0!,{r3-r14}
<br/>
stmia r1!,{r3-r14}
<br/>
sub r2,r2,#1
<br/>
bne loop
<br/>
ldmfd sp!,{r4-r11,lr}
<br/>
bx lr</td> </tr></table><span class="postbody">
<br/>
Is that right? I'm gonna try it now...
<br/>
<br/>
Argh. I hacked it up a bit to fit in where I had it inline before (gonna move it to a .s file and make it an actual function once it works):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__asm(".arm\n"
<br/>
"ldr r0,UncachedPixels\n"
<br/>
"ldr r1,=0x6000000\n"
<br/>
"ldr r2,=49152\n"
<br/>
"stmfd sp!,{r4-r11,lr}\n"
<br/>
"loop:\n"
<br/>
"ldmia r0!,{r3-r13}\n"
<br/>
"stmia r1!,{r3-r13}\n"
<br/>
"sub r2,r2,#10\n"
<br/>
"bmi loop\n"
<br/>
"ldmfd sp!,{r4-r11,lr}\n"
<br/>
".pool\n"
<br/>
);</td> </tr></table><span class="postbody">
<br/>
Still getting that internal_relocation error. &gt;_&lt;
<br/>
<br/>
[edit] Some quick commenting out of code revealed that the first line is the problem. Without that it assembles fine (but of course doesn't do much). Apparently I'm not going about accessing UncachedPixels correctly; how should I be doing this? (Even though I plan to turn this into a generic FastCopy function later, I'd still love to know.)
<br/>
<br/>
[another edit] Ah, I've tried pretty much every symbol on the keyboard in front of 'UncachedPixels' to no avail. Best I got was "address expected" using @. Google turns up two methods: <span style="font-style: italic">register uint16* UncachedPixels asm("r0")</span> which should put it into r0 automatically, but it doesn't seem to work (the program runs but no display on the screen), and <span style="font-style: italic">uint16* UncachedPixels external name 'UncachedPixels'</span> which it just rejects right off the bat. (Looking at the page I'm not even sure that was for C.) Also a lot of pages mentioning to use _ or % or $, which don't work, and even more telling me how to use floating-point registers.
<br/>
Also I fixed a bit of the code up there.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71909 - gladius - Wed Feb 15, 2006 8:18 am</h4>
    <div class="postbody"><span class="postbody">ldr r0,variableName gets converted into ldr,[pc + offset].  If the variable is out of the range of the pc (offset has a limited range) then that instruction won't work.  You can do something like this to fix that problem:
<br/>
<br/>
ldr r0,=variableName
<br/>
ldr r0,[r0]
<br/>
<br/>
However, you also need to make sure a pool section is defined close enough to the ldr as well.  Inline assembly is a pita.  Far easier to make it a function and let the compiler sort out putting the right variable in r0 at the right time, then you can just access it from the file like so:
<br/>
<br/>
In the C file:
<br/>
<br/>
void myFunc(u32 blah);
<br/>
...
<br/>
myFunc(UncachedPixels);
<br/>
<br/>
In the Asm file:
<br/>
.GLOBAL myFunc
<br/>
myFunc:
<br/>
@ now r0 contains blah and I may do what I please :)
<br/>
bx lr</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71911 - HyperHacker - Wed Feb 15, 2006 8:34 am</h4>
    <div class="postbody"><span class="postbody">Ooh, this is a good one.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gladius wrote:</b></span></td> </tr> <tr> <td class="quote">ldr r0,=UncachedPixels
<br/>
ldr r0,[r0]</td> </tr></table><span class="postbody">
<br/>
Gets an 'undefined reference to UncachedPixels' error on line 888, when the only references to it are on 876 and 872. Again no amount of different symbols are able to get it recognized. Although the variable is declared right before the ASM, so this shouldn't make much difference. Using the DMA method I printed the address of UncachedPixels, and tried just hardcoding it into the ASM to see if even that would work... it went into an endless loop, which it normally doesn't. (Usually it just runs but nothing shows on the screen.) The only thing I noticed was that it should be subtracting 44 rather than 10, since the registers are 32-bit and I use 11 of them, but that didn't help.
<br/>
<br/>
How exactly would I include an ASM source file anyway? And out of curiosity, are ARM7 and ARM9 interchangable instruction-wise? (That is, could the same code run on both, assuming it didn't depend on things only available to one?)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71916 - DekuTree64 - Wed Feb 15, 2006 9:11 am</h4>
    <div class="postbody"><span class="postbody">Gladius' method only works for globals, so if UncachedPixels is a local variable, you have to specify it with funky inline asm-ness:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">asm(
<br/>
"mov r0, %0\n"
<br/>
"ldr r1, =0x6000000\n"
<br/>
// ... rest of the code
<br/>
: // Outputs
<br/>
: "r" (UncachedPixels) // Inputs
<br/>
: ); // Registers corrupted</td> </tr></table><span class="postbody">
<br/>
Ick.
<br/>
<br/>
Building .s files is much like building .c files. Just call gcc and it will figure it out by the extension.
<br/>
<br/>
ARM7 and ARM9 are for the most part code-compatible, although ARM9 does have a few extra instructions (blx, clz, DSP instructions), and can do ARM/THUMB state switch on loads to the pc, rather than having to load to a temp and then bx. Not sure if gcc uses any of that though.
<br/>
<br/>
Also- don't load to r13, that's the stack pointer. You can do it if you save it to a global or somewhere pc-relative first, but it's still dangerous since some interrupt handlers switch to the user stack, and interrupts can happen at any point unless you disable them.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#72015 - HyperHacker - Thu Feb 16, 2006 12:21 am</h4>
    <div class="postbody"><span class="postbody">Yech, that is a mess. When I assemble the .s file with gcc, how do I include it? Right now I compile arm7.c and arm9.c (which include whatever files they need) into arm7.o and arm9.o, compile those into arm7.elf and arm9.elf, use objcopy to turn them into arm7.bin and arm9.bin, and link them together with ndstool. Where would the .s file fit in here? I imagine gcc would give me a .o output, and then I objcopy it somewhere?
<br/>
<br/>
[edit] Woot, I got it working inline.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__asm(".arm\n"
<br/>
   "ldr r0,=MainScreenBuf\n" //We can't say MainScreenBuf-&gt;Pixels
<br/>
   "ldr r1,=0x400004\n" //so add 4 to get to Pixels and 0x400000 to get to uncached RAM
<br/>
   "ldr r0,[r0]\n"
<br/>
   "add r0,r0,r1\n"
<br/>
   "ldr r1,=0x6000000\n" //destination
<br/>
   "ldr r2,=98304\n" //length
<br/>
   "stmfd sp!,{r3-r12,lr}\n"
<br/>
   "loop:\n"
<br/>
   "ldmia r0!,{r3-r12,lr}\n"
<br/>
   "stmia r1!,{r3-r12,lr}\n"
<br/>
   "subs r2,r2,#44\n" //copy 44 bytes at a time (!), and we need those flags updated
<br/>
   "bpl loop\n"
<br/>
   "ldmfd sp!,{r3-r12,lr}\n"
<br/>
   ".pool\n"
<br/>
);</td> </tr></table><span class="postbody">I know it's probably over-copying (in fact I'm seeing some bugs likely caused by memory corruption), but hey, it works. ;-) I'll fix it up later, once it's in its own function. I figured out the trick to getting at those pixels - MainScreenBuf is global, and although I can't do "=MainScreenBuf-&gt;Pixels", I can do "=MainScreenBuf" and add 4 (the number of bytes before Pixels) plus 0x400000 (for uncached memory). Hackish, but like I said I'll fix it up later.
<br/>
Only thing is it's still having that cache problem... I guess DC_FlushRange is the only way to fix it?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#72035 - wintermute - Thu Feb 16, 2006 2:16 am</h4>
    <div class="postbody"><span class="postbody">Using the uncached region of memory by adding 0x400000 is utterly pointless if you're just going to read it. In order to avoid cache problems you need to use the uncached region for both reading and writing or make use of the DC_Flush and/or DC_Invalidate functions.
<br/>
<br/>
The function you've shown here would have worked had you not tried to copy from uncached memory.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#72074 - HyperHacker - Thu Feb 16, 2006 6:25 am</h4>
    <div class="postbody"><span class="postbody">Ah, so that's it... Simple enough, just a few tweaks to my graphics code. Thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#74755 - HyperHacker - Tue Mar 07, 2006 11:44 am</h4>
    <div class="postbody"><span class="postbody">Yargh... Writes to uncached memory are just being completely ignored. :-(
<br/>
<br/>
[edit] Did some more testing. No matter what I write, reading returns some strange value. What I have is a pixel-plotting function, drawing to a buffer in memory, and then the buffer is copied to VRAM during vblank. What I do is draw a pixel in colour 0x1234, then read back its colour and display it. The pixel drawing code sets the high bit, so it should come back as 0x9234. Instead, if I write to uncached memory, then read from cached, I get 0. What's really weird is if I read from uncached, and set the high bit, I get 0xF114... but if I don't set it, I get the address I was writing to! Which is even weirder because it's a full 32-bit address, when the function that reads only returns uint16! ?_?
<br/>
<br/>
Maybe there's some sort of pointer problem in my code?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*
<br/>
Draws a pixel on a graphic buffer
<br/>
CPU: ARM9
<br/>
Inputs:
<br/>
   -Buffer: Pointer to graphic buffer
<br/>
   -X, Y: Position to draw at
<br/>
   -Colour: RGB15 colour
<br/>
*/
<br/>
void DrawPixel(GraphicBuffer* Dest, uint16 X, uint16 Y, uint16 Colour)
<br/>
{
<br/>
   if((X &gt;= Dest-&gt;Width) || (Y &gt;= Dest-&gt;Height)) return; //Don't draw off-screen
<br/>
   uint16* B = (Dest-&gt;Pixels + 0x400000) + X + (Y * Dest-&gt;Width);
<br/>
   (*B) = Colour | 0x8000;
<br/>
}
<br/>
<br/>
<br/>
/*
<br/>
Returns the colour value of a pixel on a graphic buffer
<br/>
CPU: ARM9
<br/>
Inputs:
<br/>
   -Buffer: Pointer to graphic buffer
<br/>
   -X, Y: Position of pixel
<br/>
Returns: RGB15 value of colour with high bit set, or 0 if out of bounds
<br/>
*/
<br/>
uint16 GetPixel(GraphicBuffer* Dest, uint16 X, uint16 Y)
<br/>
{
<br/>
   if((X &gt;= Dest-&gt;Width) || (Y &gt;= Dest-&gt;Height)) return 0;
<br/>
   uint16* B = (Dest-&gt;Pixels + 0x400000) + X + (Y * Dest-&gt;Width);
<br/>
   return (*B); //| 0x8000;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Also, the code which copies this data to VRAM must be getting different results (same whether it reads from cached or uncached), as anything written to uncached memory doesn't show up at all, meaning it's reading zero (or at least some low value).
<br/>
<br/>
[another edit] Interesting results here.
<br/>
uint16 x = 0x69;
<br/>
uint16* xp = &amp;x + 0x400000;
<br/>
printxy2(MainScreenBuf,0,(Coords &gt;&gt; 16),(Coords &amp; 0xFFFF),"%08X %08X %08X",x,(*xp),xp);
<br/>
<br/>
If I omit the " + 0x400000" on the second line, the output is the value of x twice, then its address, as you would expect. With it included, the output is the value of x once, and its address twice! O_o</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
