<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>NitroEngine: 2D Draw GetPixel - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > NitroEngine: 2D Draw GetPixel</h2>
<div id="posts">
<div class="post">
    <h4>#177363 - hacker013 - Fri May 11, 2012 8:54 pm</h4>
    <div class="postbody"><span class="postbody">heyhey ^^,
<br/>
<br/>
I wanted to use difference in pixel color for collision, because my game only use some basic colors. So I googled how to get pixel color in opengl, there is the function available called glReadPixel, but unfortunaly it wasn't supported by libnds. So I got an idea, I new NitroEngine supported screenshots. So I found the code which NitroEngine used to retreive the colors from vram. I created the following code from that code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 drawGetColor(int x, int y)
<br/>
{
<br/>
   u16 color = 0;
<br/>
         
<br/>
   if(NE_Dual) 
<br/>
   {
<br/>
      if(y&gt;191)
<br/>
      {
<br/>
         color=VRAM_C[256*192-(y-192+1)*256+x];
<br/>
      } else {
<br/>
         color=VRAM_D[256*192-(y+1)*256+x];
<br/>
      }
<br/>
   } else {
<br/>
      color=VRAM_D[256*192-(y+1)*256+x];
<br/>
   }
<br/>
         
<br/>
   return color;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
But this function always returns always 0, I use the basic dual screen setup from NitroEngine. Could somebody point me out what I'm doing wrong?
<br/>
<br/>
~Hacker013<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177366 - AntonioND - Sat May 12, 2012 9:08 pm</h4>
    <div class="postbody"><span class="postbody">Do you switch the VRAM banks to LCD mode before reading from them?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177370 - sverx - Mon May 14, 2012 10:00 am</h4>
    <div class="postbody"><span class="postbody">when a VRAM bank is 'allocated' to some mode (bg memory, for instance) it's no longer accessible thru its VRAM_x location...<br/>_________________<br/><a class="postlink" href="http://bit.ly/yiQrz9" target="_blank">libXM7</a>|<a class="postlink" href="http://bit.ly/yJwcOo" target="_blank">NDS programming tutorial (Italiano)</a>|<a class="postlink" href="http://disjointedstudio.blogspot.com/" target="_blank">Waimanu DS / GBA</a>|<a class="postlink" href="http://adshomebrewersdiary.blogspot.com" target="_blank">A DS Homebrewer's Diary</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177373 - wintermute - Tue May 15, 2012 4:58 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>hacker013 wrote:</b></span></td> </tr> <tr> <td class="quote">heyhey ^^,
<br/>
<br/>
Could somebody point me out what I'm doing wrong?
<br/>
<br/>
~Hacker013</td> </tr></table><span class="postbody">
<br/>
<br/>
Using pixel colors for collision ...
<br/>
<br/>
For most game uses a simple bounding box is more than sufficient, I've *never* seen a case where pixel checking does anything more than make code slow for no good reason.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177374 - Dwedit - Tue May 15, 2012 6:27 pm</h4>
    <div class="postbody"><span class="postbody">Worms and other landscape destruction games use pixel collision for their game logic.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177375 - sverx - Wed May 16, 2012 1:16 pm</h4>
    <div class="postbody"><span class="postbody">I bet Lemmings uses that too...<br/>_________________<br/><a class="postlink" href="http://bit.ly/yiQrz9" target="_blank">libXM7</a>|<a class="postlink" href="http://bit.ly/yJwcOo" target="_blank">NDS programming tutorial (Italiano)</a>|<a class="postlink" href="http://disjointedstudio.blogspot.com/" target="_blank">Waimanu DS / GBA</a>|<a class="postlink" href="http://adshomebrewersdiary.blogspot.com" target="_blank">A DS Homebrewer's Diary</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177384 - SchmendrickSchmuck - Tue May 22, 2012 3:03 pm</h4>
    <div class="postbody"><span class="postbody">DSLiero uses pixel collision as well; It's kind of necessary when having a randomly destructible terrain. Though admittedly there aren't many games that have this.
<br/>
<br/>
@hacker013: As mentioned before, in order to get pixel data from textures or other VRAM sources, you need to set the VRAM bank to LCD mode.
<br/>
Perhaps you could give a more concrete example of what it is you're trying to do? There may be other solutions to your problem.
<br/>
<br/>
Either way, if you really want to get a pixel value from a texture:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u16* data = (u16*)glGetTexturePointer(texId);
<br/>
int vramTemp = vramSetPrimaryBanks(VRAM_A_LCD, VRAM_B_LCD, VRAM_C_LCD, VRAM_D_LCD);
<br/>
int vramSubTemp = vramSetBanks_EFG(VRAM_E_LCD, VRAM_F_LCD, VRAM_G_LCD);
<br/>
int index = posX + posY * texWidth;
<br/>
int color = data[index];
<br/>
vramRestorePrimaryBanks(vramTemp);
<br/>
vramRestoreBanks_EFG(vramSubTemp);
<br/>
return color;
<br/>
</td> </tr></table><span class="postbody">
<br/>
Note that when using 8bit textures you'll need to work some magic:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u16 colors = data[index &gt;&gt; 1];
<br/>
int color = 0;
<br/>
if(index &amp; 1)
<br/>
    color = (colors &amp; 0xFF00) &gt;&gt; 8;
<br/>
else
<br/>
    color = colors &amp; 0x00FF;
<br/>
</td> </tr></table><span class="postbody">
<br/>
EDIT: posted code that sets color &gt;.&lt;<br/>_________________<br/><a href="http://DSLiero.DennisvanZwieten.com" target="_blank">http://DSLiero.DennisvanZwieten.com</a> - Liero for NDS!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177385 - Miked0801 - Tue May 22, 2012 10:38 pm</h4>
    <div class="postbody"><span class="postbody">I'm of the opinion the pixel collision is also not the way to go.  It's slow and only works in 2D space.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177401 - hacker013 - Wed May 30, 2012 4:49 pm</h4>
    <div class="postbody"><span class="postbody">Bounding box are only squares but my game isn't rectangular formed. But I already changed the code to: 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
32 drawGetColor(int x, int y)
<br/>
{
<br/>
   u32 color = 0;
<br/>
   
<br/>
   NE_SpecialEffectPause(true);
<br/>
   
<br/>
   if(!NE_Dual)
<br/>
   {
<br/>
      vramSetBankD(VRAM_D_LCD);
<br/>
      
<br/>
      REG_DISPCAPCNT=DCAP_BANK(3)|DCAP_ENABLE|DCAP_SIZE(3);
<br/>
      while(REG_DISPCAPCNT &amp; DCAP_ENABLE);
<br/>
   }
<br/>
   
<br/>
   uint32 vramTemp = 0;
<br/>
   if(NE_Dual) { vramTemp = vramSetMainBanks(VRAM_A_LCD, VRAM_B_LCD, VRAM_C_LCD, VRAM_D_LCD); }
<br/>
   
<br/>
   if(NE_Dual) 
<br/>
   {
<br/>
      if(y&gt;191)
<br/>
      {
<br/>
         color=VRAM_C[256*192-(y-192+1)*256+x];
<br/>
      } else {
<br/>
         color=VRAM_D[256*192-(y+1)*256+x];
<br/>
      }
<br/>
   } else {
<br/>
      color=VRAM_D[256*192-(y+1)*256+x];
<br/>
   }
<br/>
   
<br/>
   if(NE_Dual) vramRestoreMainBanks(vramTemp);
<br/>
   
<br/>
   NE_SpecialEffectPause(false);
<br/>
   
<br/>
   //u8 b=(color&amp;31)&lt;&lt;3;
<br/>
   //u8 g=((color&gt;&gt;5)&amp;31)&lt;&lt;3;
<br/>
   //u8 r=((color&gt;&gt;10)&amp;31)&lt;&lt;3;
<br/>
   
<br/>
   //color=RGB15(r, g, b);
<br/>
   
<br/>
   //printf("White: %d, pixel: %d\n", NE_White, color);
<br/>
         
<br/>
   return color;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I think the pixels are stored as 8bit rgb but I'm not sure.. The code still doesn't work :(<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177403 - SchmendrickSchmuck - Wed May 30, 2012 5:06 pm</h4>
    <div class="postbody"><span class="postbody">I think there's a few issues with this:
<br/>
1)</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">256*192-(y-192+1)*256+x</td> </tr></table><span class="postbody">
<br/>
Why are there two *256 in there? Seems to be pretty easy to go out of bounds with an array index like this
<br/>
<br/>
2) What are you trying to do? Get a pixel from the screen, or a pixel from a texture? The two would need entirely different approaches. Your first question suggested the first (for which you can pretty much copy/paste my previous post to work), but if you want a pixel from the screen you'll have to find something else (similar though)
<br/>
<br/>
3) Which coordinates are you passing to drawGetColor? They seem to need to be screen coordinates.
<br/>
<br/>
4) This approach seems unnecessarily slow since it takes a screenshot for each color call
<br/>
<br/>
Either way, since this seems to use screen data, the colors are likely stored in 16bit format<br/>_________________<br/><a href="http://DSLiero.DennisvanZwieten.com" target="_blank">http://DSLiero.DennisvanZwieten.com</a> - Liero for NDS!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177404 - hacker013 - Wed May 30, 2012 8:31 pm</h4>
    <div class="postbody"><span class="postbody">I based my code on this code (working)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
//----------------------------------------------------------------
<br/>
//                      Screenshots
<br/>
//----------------------------------------------------------------
<br/>
<br/>
inline void NE_write16(u16* address, u16 value) {
<br/>
<br/>
   u8* first=(u8*)address;
<br/>
   u8* second=first+1;
<br/>
<br/>
   *first=value&amp;0xff;
<br/>
   *second=value&gt;&gt;8;
<br/>
}
<br/>
<br/>
inline void NE_write32(u32* address, u32 value) {
<br/>
<br/>
   u8* first=(u8*)address;
<br/>
   u8* second=first+1;
<br/>
   u8* third=first+2;
<br/>
   u8* fourth=first+3;
<br/>
<br/>
   *first=value&amp;0xff;
<br/>
   *second=(value&gt;&gt;8)&amp;0xff;
<br/>
   *third=(value&gt;&gt;16)&amp;0xff;
<br/>
   *fourth=(value&gt;&gt;24)&amp;0xff;
<br/>
}
<br/>
<br/>
extern bool NE_Dual;
<br/>
<br/>
int NE_ScreenshotBMP(char * filename) 
<br/>
{   
<br/>
   FILE* file=fopen(filename, "wb");
<br/>
<br/>
   if(file == NULL) 
<br/>
      {
<br/>
      NE_DebugPrint("NE_ScreenshotBMP: %s could't be opened!", filename);
<br/>
      return 0;
<br/>
      }
<br/>
   
<br/>
   NE_SpecialEffectPause(true);
<br/>
   
<br/>
   if(!NE_Dual)
<br/>
      {
<br/>
      vramSetBankD(VRAM_D_LCD);
<br/>
      
<br/>
      REG_DISPCAPCNT=DCAP_BANK(3)|DCAP_ENABLE|DCAP_SIZE(3);
<br/>
      while(REG_DISPCAPCNT &amp; DCAP_ENABLE);
<br/>
      }
<br/>
<br/>
   int ysize = 0;
<br/>
   
<br/>
   if(NE_Dual) ysize = 384;
<br/>
   else ysize = 192;   
<br/>
   
<br/>
   u8* temp=(u8*)malloc(256*ysize*3+sizeof(NE_INFO_BMP_HEADER)+sizeof(NE_BMP_HEADER));
<br/>
<br/>
   NE_BMP_HEADER* header=(NE_BMP_HEADER*)temp;
<br/>
   NE_INFO_BMP_HEADER* infoheader=(NE_INFO_BMP_HEADER*)(temp+sizeof(NE_BMP_HEADER));
<br/>
<br/>
   NE_write16(&amp;header-&gt;type, 0x4D42);
<br/>
   NE_write32(&amp;header-&gt;size, 256*ysize*3+sizeof(NE_INFO_BMP_HEADER)+sizeof(NE_BMP_HEADER));
<br/>
   NE_write32(&amp;header-&gt;offset, sizeof(NE_INFO_BMP_HEADER)+sizeof(NE_BMP_HEADER));
<br/>
   NE_write16(&amp;header-&gt;reserved1, 0);
<br/>
   NE_write16(&amp;header-&gt;reserved2, 0);
<br/>
<br/>
   NE_write16(&amp;infoheader-&gt;bits, 24);
<br/>
   NE_write32(&amp;infoheader-&gt;size, sizeof(NE_INFO_BMP_HEADER));
<br/>
   NE_write32(&amp;infoheader-&gt;compression, 0);
<br/>
   NE_write32(&amp;infoheader-&gt;width, 256);
<br/>
   NE_write32(&amp;infoheader-&gt;height, ysize);
<br/>
   NE_write16(&amp;infoheader-&gt;planes, 1);
<br/>
   NE_write32(&amp;infoheader-&gt;imagesize, 256*ysize*3);
<br/>
   NE_write32(&amp;infoheader-&gt;xresolution, 0);
<br/>
   NE_write32(&amp;infoheader-&gt;yresolution, 0);
<br/>
   NE_write32(&amp;infoheader-&gt;importantcolors, 0);
<br/>
   NE_write32(&amp;infoheader-&gt;ncolors, 0);
<br/>
<br/>
   uint32 vramTemp = 0;
<br/>
   if(NE_Dual) { vramTemp = vramSetMainBanks(VRAM_A_LCD, VRAM_B_LCD, VRAM_C_LCD, VRAM_D_LCD); }
<br/>
<br/>
   int y, x;
<br/>
   for(y=0;y&lt;ysize;y++)
<br/>
      {
<br/>
      for(x=0;x&lt;256;x++)
<br/>
         {
<br/>
         u16 color = 0;
<br/>
         
<br/>
         if(NE_Dual) 
<br/>
            {
<br/>
            if(y&gt;191) color=VRAM_C[256*192-(y-192+1)*256+x];
<br/>
            else color=VRAM_D[256*192-(y+1)*256+x];
<br/>
            }
<br/>
         else color=VRAM_D[256*192-(y+1)*256+x];
<br/>
<br/>
         u8 b=(color&amp;31)&lt;&lt;3;
<br/>
         u8 g=((color&gt;&gt;5)&amp;31)&lt;&lt;3;
<br/>
         u8 r=((color&gt;&gt;10)&amp;31)&lt;&lt;3;
<br/>
<br/>
         temp[((y*256)+x)*3+sizeof(NE_INFO_BMP_HEADER)+sizeof(NE_BMP_HEADER)]=r;
<br/>
         temp[((y*256)+x)*3+1+sizeof(NE_INFO_BMP_HEADER)+sizeof(NE_BMP_HEADER)]=g;
<br/>
         temp[((y*256)+x)*3+2+sizeof(NE_INFO_BMP_HEADER)+sizeof(NE_BMP_HEADER)]=b;
<br/>
         }
<br/>
      }
<br/>
   
<br/>
   if(NE_Dual) vramRestoreMainBanks(vramTemp);
<br/>
   
<br/>
   DC_FlushAll();
<br/>
   fwrite(temp, 1, 256*ysize*3+sizeof(NE_INFO_BMP_HEADER)+sizeof(NE_BMP_HEADER), file);
<br/>
   fclose(file);
<br/>
   free(temp);
<br/>
   
<br/>
   NE_SpecialEffectPause(false);
<br/>
   
<br/>
   return 1;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
1. Because if I'm correct it loops back from the end of the buffer to the beginning... (The code above those the same) :$
<br/>
<br/>
2. I'm trying to get a pixel from the screen.
<br/>
<br/>
3. The coordinates on the screen.
<br/>
<br/>
4. I don't understand the NDS hardware very well so I used the above code as base.
<br/>
<br/>
I code I based my work on decodes it as 8Bit if I'm correct.
<br/>
<br/>
If you guys know a faster way please tell me. I'm using it in combination with 3D Nitro Engine.<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177407 - PypeBros - Thu May 31, 2012 8:17 am</h4>
    <div class="postbody"><span class="postbody">NDS VRAM is slower to access than main memory, and it doesn't get caching, afaik. If your game logic *requires* pixel-precise collisions, you're much better to have a buffer separated from your VRAM where you keep a mirror of the scene for collision checking.
<br/>
<br/>
Oh, and btw, have you thought about the fact that in many cases, a height map (one/few value(s) per column) is as good as a plain screen mirror ?<br/>_________________<br/><a class="postlink" href="http://sylvainhb.blogspot.com/p/sprite-editor.html" target="_blank"> SEDS: Sprite Edition on DS</a> :: <a class="postlink" href="http://sylvainhb.blogspot.com/search/label/modplayer" target="_blank">modplayer</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177409 - hacker013 - Thu May 31, 2012 12:07 pm</h4>
    <div class="postbody"><span class="postbody">But the screen is fully dynamic so then I would have to copy every frame, the whole buffer to the ram, and then search for the pixel. Wouldn't it be faster then to read directly from VRAM ?<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177411 - SchmendrickSchmuck - Thu May 31, 2012 1:29 pm</h4>
    <div class="postbody"><span class="postbody">I think what he means is use a buffer to put to the screen rather than the other way around, or keep a buffer that undergoes the same changes as the screen.
<br/>
<br/>
Perhaps you could post a screenshot of your current game to give us a better idea of what you want?<br/>_________________<br/><a href="http://DSLiero.DennisvanZwieten.com" target="_blank">http://DSLiero.DennisvanZwieten.com</a> - Liero for NDS!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177415 - hacker013 - Thu May 31, 2012 5:19 pm</h4>
    <div class="postbody"><span class="postbody">The problem was I have everywhere moving objects with different colors. So I thought it would be handy to check if I hit some color with my object to detect the collision.
<br/>
<br/>
Sorry, I don't have screenshot.<br/>_________________<br/><a class="postlink" href="http://imetal.nl/" target="_blank">Website / Blog</a>
<br/>
<br/>
Let the nds be with you.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177430 - AntonioND - Fri Jun 01, 2012 10:55 pm</h4>
    <div class="postbody">What are you trying to do? Are you drawing a 3D scene, capturing it and then reading it from VRAM?<br/>
<br/>
That's a horrible idea, seriously. It's really slow, you'd better use another method.<br/>
<br/>
Screen capturing is only useful if you want 3D on both screens. Other effects are slow and shouldn't be used outside demos or things like that. Doing it for geting data for in game calculations... that's evil.<br/>
<br/>
If you really want to do it, at least copy the buffer to RAM.<br/>
<br/>
But you really should do this without screen capturing...</div>    
</div>
<div class="post">
    <h4>#177433 - hacker013 - Sun Jun 03, 2012 4:43 pm</h4>
    <div class="postbody">How can I otherwise read from the buffer in a array like manner?</div>    
</div>
<div class="post">
    <h4>#177437 - AntonioND - Tue Jun 05, 2012 2:20 pm</h4>
    <div class="postbody"><blockquote><div><cite>hacker013 wrote:</cite>How can I otherwise read from the buffer in a array like manner?</div></blockquote>
Copy it to RAM. Or don't use that method.<br/>
<br/>
Anyway, the code that has been put in this thread will try to capture the screen whenever you want to read a single pixel. The correct thing would be: capture screen once, copy buffer to ram once, read from it everytime you need it, repeat next frame.</div>    
</div>
<div class="post">
    <h4>#177461 - PypeBros - Mon Jun 11, 2012 4:26 pm</h4>
    <div class="postbody"><blockquote><div><cite>AntonioND wrote:</cite>What are you trying to do? Are you drawing a 3D scene, Doing it for geting data for in game calculations... that's evil.
</div></blockquote>

I suppose you realise that if you just render explosion effects over your screen, or what other special effects, the colors you will read will become different from what the "solid world" should have had. I used that trick back in 1996, and I couldn't count the number of occasions where I ended up with some sprites occasionnally moving into some walls because some colours were temporarily replaced by a text box, etc.<br/>
<br/>
If you want to be a minimum serious with your game development, I strongly suggest that you go for something like
<div class="codebox"><p>Code: <a href="#" onclick="selectCode(this); return false;">Select all</a></p><pre><code>destroy&amp;#40;screen, mask&amp;#41;;
destroy&amp;#40;world, mask&amp;#41;;
</code></pre></div>
where "world" is an additional, in-RAM array defining what is solid and what isn't. Some people even add supplementary bits, such as "is it breakable?" "is it slippery?", etc.<br/>
<br/>
For <a class="postlink" href="http://sylvainhb.blogspot.be/search/label/collisions">object-to-object collisions</a>, one typically maintains a separate list of hit-boxes. Trying to rely on the "screen content" (or even an updated 'world') really mess up things here: how do you decide whether to test against someone else before or after it moves ?</div>    
</div>
<div class="post">
    <h4>#177487 - relminator - Fri Jun 29, 2012 4:53 am</h4>
    <div class="postbody">Why not try some sort of geometric collision like SAT(Separating Axis Theorem) for particles?<br/>
<br/>
For BG to particle collision, you could approximate landscapes by lines and use DOT projection to collide and respond much like what you do in SAT (Just use MTV(Minimum Translation Vector) ) .</div>    
</div>
</div>

    </body>
</html>
