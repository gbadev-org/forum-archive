<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>serious problem with md2 loader - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > serious problem with md2 loader</h2>
<div id="posts">
<div class="post">
    <h4>#110429 - Xgame - Tue Nov 28, 2006 4:08 pm</h4>
    <div class="postbody"><span class="postbody">hi to evrybody!
<br/>
I've just ended to port <a class="postlink" href="http://tfc.duke.free.fr/coding/md2-specs-en.html" target="_blank">http://tfc.duke.free.fr/coding/md2-specs-en.html</a> md2 loader to nds.
<br/>
I done that becouse I found this topic: <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=7176&amp;start=0&amp;postdays=0&amp;postorder=asc&amp;highlight=collision" target="_blank">http://forum.gbadev.org/viewtopic.php?t=7176&amp;start=0&amp;postdays=0&amp;postorder=asc&amp;highlight=collision</a>
<br/>
when i read this, i decided to port it on Ds: 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
put md2 in data dir
<br/>
<br/>
#include &lt;myCoolDude_md2.h&gt;
<br/>
<br/>
void loadmd2(u8* file, myObjStruct obj)
<br/>
{
<br/>
..blah blah some init
<br/>
<br/>
//fseak
<br/>
possition = triangle_offset;
<br/>
<br/>
//fread
<br/>
memcpy(&amp;file[possition], obj-&gt;triangles, sizeoftriangles);
<br/>
<br/>
//or just: obj-&gt;triangles = &amp;file[possition];
<br/>
<br/>
file io is much more cumbersum than treating the md2 like an array
<br/>
...
<br/>
blah blah
<br/>
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
.
<br/>
ok, in less than an hour I converted the code for ds ( really easy). when I compile i don't get problem, but when I try to emulate it, it dosen't work. I haven't tryed it on hardware, yet, but I think is a problem of my code.
<br/>
please found bug! </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef float vec3_t[3];
<br/>
<br/>
<br/>
/* md2 header */
<br/>
typedef struct
<br/>
{
<br/>
  int ident;
<br/>
  int version;
<br/>
<br/>
  int skinwidth;
<br/>
  int skinheight;
<br/>
<br/>
  int framesize;
<br/>
<br/>
  int num_skins;
<br/>
  int num_vertices;
<br/>
  int num_st;
<br/>
  int num_tris;
<br/>
  int num_glcmds;
<br/>
  int num_frames;
<br/>
<br/>
  int offset_skins;
<br/>
  int offset_st;
<br/>
  int offset_tris;
<br/>
  int offset_frames;
<br/>
  int offset_glcmds;
<br/>
  int offset_end;
<br/>
<br/>
} md2_header_t;
<br/>
<br/>
<br/>
/* texture name */
<br/>
typedef struct
<br/>
{
<br/>
  char name[64];
<br/>
<br/>
} md2_skin_t;
<br/>
<br/>
<br/>
/* texture coords */
<br/>
typedef struct
<br/>
{
<br/>
  short s;
<br/>
  short t;
<br/>
<br/>
} md2_texCoord_t;
<br/>
<br/>
<br/>
/* triangle info */
<br/>
typedef struct
<br/>
{
<br/>
  unsigned short vertex[3];
<br/>
  unsigned short st[3];
<br/>
<br/>
} md2_triangle_t;
<br/>
<br/>
<br/>
/* compressed vertex */
<br/>
typedef struct
<br/>
{
<br/>
  unsigned char v[3];
<br/>
  unsigned char normalIndex;
<br/>
<br/>
} md2_vertex_t;
<br/>
<br/>
<br/>
/* model frame */
<br/>
typedef struct
<br/>
{
<br/>
  vec3_t scale;
<br/>
  vec3_t translate;
<br/>
  char name[16];
<br/>
  md2_vertex_t *verts;
<br/>
<br/>
} md2_frame_t;
<br/>
<br/>
<br/>
/* gl command packet */
<br/>
typedef struct
<br/>
{
<br/>
  float s;
<br/>
  float t;
<br/>
  int index;
<br/>
<br/>
} md2_glcmd_t;
<br/>
<br/>
<br/>
/* md2 model structure */
<br/>
typedef struct
<br/>
{
<br/>
  md2_header_t header;
<br/>
<br/>
  md2_skin_t *skins;
<br/>
  md2_texCoord_t *texcoords;
<br/>
  md2_triangle_t *triangles;
<br/>
  md2_frame_t *frames;
<br/>
  int *glcmds;
<br/>
<br/>
  GLuint tex_id;
<br/>
<br/>
} md2_model_t;
<br/>
<br/>
<br/>
md2_model_t *md2file;
<br/>
<br/>
/* table of precalculated normals */
<br/>
vec3_t anorms_table[162] = {
<br/>
#include "anorms.h"
<br/>
};
<br/>
<br/>
int LoadMd2(u8* filemdl, md2_model_t *mdl){
<br/>
    int position = 0; //posizione da usare al posto di fseek
<br/>
    //mdl.header = &amp;filemdl[position];
<br/>
    
<br/>
    memcpy(&amp;filemdl[position],&amp;mdl-&gt;header,sizeof (md2_header_t));
<br/>
    //position++; 
<br/>
    
<br/>
<br/>
    
<br/>
     /*
<br/>
      if ((mdl-&gt;header.ident != 844121161) ||
<br/>
      (mdl-&gt;header.version != 8))
<br/>
    {
<br/>
<br/>
      
<br/>
      return 0;
<br/>
    }*/
<br/>
    
<br/>
  mdl-&gt;skins = (md2_skin_t *)malloc (sizeof (md2_skin_t) * mdl-&gt;header.num_skins);
<br/>
  mdl-&gt;texcoords = (md2_texCoord_t *)malloc (sizeof (md2_texCoord_t) * mdl-&gt;header.num_st);
<br/>
  mdl-&gt;triangles = (md2_triangle_t *)malloc (sizeof (md2_triangle_t) * mdl-&gt;header.num_tris);
<br/>
  mdl-&gt;frames = (md2_frame_t *)malloc (sizeof(md2_frame_t) * mdl-&gt;header.num_frames);
<br/>
  mdl-&gt;glcmds = (int *)malloc (sizeof (int) * mdl-&gt;header.num_glcmds);
<br/>
<br/>
  
<br/>
  
<br/>
  position = mdl-&gt;header.offset_skins;
<br/>
  memcpy(&amp;filemdl[position],&amp;mdl-&gt;skins, sizeof (md2_skin_t));
<br/>
  
<br/>
  position = mdl-&gt;header.offset_st;
<br/>
  memcpy(&amp;filemdl[position],&amp;mdl-&gt;texcoords, sizeof (md2_texCoord_t));
<br/>
  
<br/>
  position = mdl-&gt;header.offset_tris;
<br/>
  memcpy(&amp;filemdl[position],&amp;mdl-&gt;triangles, sizeof (md2_triangle_t));
<br/>
  
<br/>
  position = mdl-&gt;header.offset_glcmds;
<br/>
  memcpy(&amp;filemdl[position], &amp;mdl-&gt;glcmds, sizeof (int));
<br/>
   // read frames */
<br/>
  position = mdl-&gt;header.offset_frames;
<br/>
  int i;
<br/>
  for (i = 0; i &lt; mdl-&gt;header.num_frames; ++i)
<br/>
    {
<br/>
      // memory allocation for vertices of this frame */
<br/>
      mdl-&gt;frames[i].verts = (md2_vertex_t *)
<br/>
   malloc (sizeof (md2_vertex_t) * mdl-&gt;header.num_vertices);
<br/>
<br/>
      // read frame data */
<br/>
      memcpy(&amp;filemdl[position], &amp;mdl-&gt;frames[i].scale, sizeof (vec3_t));
<br/>
      //fread (mdl-&gt;frames[i].scale, sizeof (vec3_t), 1, fp);
<br/>
      memcpy(&amp;filemdl[position], &amp;mdl-&gt;frames[i].translate, sizeof (vec3_t));
<br/>
      //fread (mdl-&gt;frames[i].translate, sizeof (vec3_t), 1, fp);
<br/>
      memcpy(&amp;filemdl[position], &amp;mdl-&gt;frames[i].name, sizeof (char));
<br/>
      //fread (mdl-&gt;frames[i].name, sizeof (char), 16, fp);
<br/>
      memcpy(&amp;filemdl[position], &amp;mdl-&gt;frames[i].verts, sizeof (md2_vertex_t));
<br/>
      //fread (mdl-&gt;frames[i].verts, sizeof (md2_vertex_t), mdl-&gt;header.num_vertices, fp);
<br/>
    }
<br/>
  
<br/>
  return 1;
<br/>
}
<br/>
<br/>
void
<br/>
RenderFrame (int n, md2_model_t *mdl)
<br/>
{
<br/>
  int i, j;
<br/>
  GLfloat s, t;
<br/>
  vec3_t v;
<br/>
  md2_frame_t *pframe;
<br/>
  md2_vertex_t *pvert;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames - 1))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* draw the model */
<br/>
  glBegin (GL_TRIANGLES);
<br/>
    /* draw each triangle */
<br/>
    for (i = 0; i &lt; mdl-&gt;header.num_tris; ++i)
<br/>
      {
<br/>
   /* draw each vertex */
<br/>
   for (j = 0; j &lt; 3; ++j)
<br/>
     {
<br/>
       pframe = &amp;mdl-&gt;frames[n];
<br/>
       pvert = &amp;pframe-&gt;verts[mdl-&gt;triangles[i].vertex[j]];
<br/>
<br/>
       /* compute texture coordinates */
<br/>
       s = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].s / mdl-&gt;header.skinwidth;
<br/>
       t = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].t / mdl-&gt;header.skinheight;
<br/>
<br/>
       /* pass texture coordinates to OpenGL */
<br/>
       glTexCoord2f (s, t);
<br/>
<br/>
       /* normal vector */
<br/>
       //glNormal3fv (anorms_table[pvert-&gt;normalIndex]);
<br/>
       glNormal3f(anorms_table[pvert-&gt;normalIndex][0], anorms_table[pvert-&gt;normalIndex][1], anorms_table[pvert-&gt;normalIndex][2]);
<br/>
<br/>
       
<br/>
       
<br/>
<br/>
       /* calculate vertex real position */
<br/>
       v[0] = (pframe-&gt;scale[0] * pvert-&gt;v[0]) + pframe-&gt;translate[0];
<br/>
       v[1] = (pframe-&gt;scale[1] * pvert-&gt;v[1]) + pframe-&gt;translate[1];
<br/>
       v[2] = (pframe-&gt;scale[2] * pvert-&gt;v[2]) + pframe-&gt;translate[2];
<br/>
<br/>
       //glVertex3fv (v);
<br/>
       glVertex3f(v[0], v[1], v[2]);
<br/>
     }
<br/>
      }
<br/>
  glEnd ();
<br/>
}
<br/>
<br/>
<br/>
void
<br/>
RenderFrameItp (int n, float interp, md2_model_t *mdl)
<br/>
{
<br/>
  int i, j;
<br/>
  GLfloat s, t;
<br/>
  vec3_t v_curr, v_next, v, norm;
<br/>
  float *n_curr, *n_next;
<br/>
  md2_frame_t *pframe1, *pframe2;
<br/>
  md2_vertex_t *pvert1, *pvert2;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* draw the model */
<br/>
  glBegin (GL_TRIANGLES);
<br/>
    /* draw each triangle */
<br/>
    for (i = 0; i &lt; mdl-&gt;header.num_tris; ++i)
<br/>
      {
<br/>
   /* draw each vertex */
<br/>
   for (j = 0; j &lt; 3; ++j)
<br/>
     {
<br/>
       pframe1 = &amp;mdl-&gt;frames[n];
<br/>
       pframe2 = &amp;mdl-&gt;frames[n + 1];
<br/>
       pvert1 = &amp;pframe1-&gt;verts[mdl-&gt;triangles[i].vertex[j]];
<br/>
       pvert2 = &amp;pframe2-&gt;verts[mdl-&gt;triangles[i].vertex[j]];
<br/>
<br/>
       /* compute texture coordinates */
<br/>
       s = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].s / mdl-&gt;header.skinwidth;
<br/>
       t = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].t / mdl-&gt;header.skinheight;
<br/>
<br/>
       /* pass texture coordinates to OpenGL */
<br/>
       glTexCoord2f (s, t);
<br/>
<br/>
       /* interpolate normals */
<br/>
       n_curr = anorms_table[pvert1-&gt;normalIndex];
<br/>
       n_next = anorms_table[pvert2-&gt;normalIndex];
<br/>
<br/>
       norm[0] = n_curr[0] + interp * (n_next[0] - n_curr[0]);
<br/>
       norm[1] = n_curr[1] + interp * (n_next[1] - n_curr[1]);
<br/>
       norm[2] = n_curr[2] + interp * (n_next[2] - n_curr[2]);
<br/>
<br/>
       glNormal3f (norm[0], norm[1], norm[2]);
<br/>
<br/>
       /* interpolate vertices */
<br/>
       v_curr[0] = pframe1-&gt;scale[0] * pvert1-&gt;v[0] + pframe1-&gt;translate[0];
<br/>
       v_curr[1] = pframe1-&gt;scale[1] * pvert1-&gt;v[1] + pframe1-&gt;translate[1];
<br/>
       v_curr[2] = pframe1-&gt;scale[2] * pvert1-&gt;v[2] + pframe1-&gt;translate[2];
<br/>
<br/>
       v_next[0] = pframe2-&gt;scale[0] * pvert2-&gt;v[0] + pframe2-&gt;translate[0];
<br/>
       v_next[1] = pframe2-&gt;scale[1] * pvert2-&gt;v[1] + pframe2-&gt;translate[1];
<br/>
       v_next[2] = pframe2-&gt;scale[2] * pvert2-&gt;v[2] + pframe2-&gt;translate[2];
<br/>
<br/>
       v[0] = v_curr[0] + interp * (v_next[0] - v_curr[0]);
<br/>
       v[1] = v_curr[1] + interp * (v_next[1] - v_curr[1]);
<br/>
       v[2] = v_curr[2] + interp * (v_next[2] - v_curr[2]);
<br/>
<br/>
       glVertex3f (v[0], v[1], v[2]);
<br/>
     }
<br/>
      }
<br/>
  glEnd ();
<br/>
}
<br/>
<br/>
<br/>
<br/>
void
<br/>
RenderFrameWithGLCmds (int n, md2_model_t *mdl)
<br/>
{
<br/>
  int i, *pglcmds;
<br/>
  vec3_t v;
<br/>
  md2_frame_t *pframe;
<br/>
  md2_vertex_t *pvert;
<br/>
  md2_glcmd_t *packet;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames - 1))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* pglcmds points at the start of the command list */
<br/>
  pglcmds = mdl-&gt;glcmds;
<br/>
<br/>
  /* draw the model */
<br/>
  while ((i = *(pglcmds++)) != 0)
<br/>
    {
<br/>
      if (i &lt; 0)
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
     i = -i;
<br/>
   }
<br/>
      else
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
   }
<br/>
<br/>
      /* draw each vertex of this group */
<br/>
      for (/* nothing */; i &gt; 0; --i, pglcmds += 3)
<br/>
   {
<br/>
     packet = (md2_glcmd_t *)pglcmds;
<br/>
     pframe = &amp;mdl-&gt;frames[n];
<br/>
     pvert = &amp;pframe-&gt;verts[packet-&gt;index];
<br/>
<br/>
     /* pass texture coordinates to OpenGL */
<br/>
     glTexCoord2f (packet-&gt;s, packet-&gt;t);
<br/>
<br/>
     /* normal vector */
<br/>
      glNormal3f(anorms_table[pvert-&gt;normalIndex][0], anorms_table[pvert-&gt;normalIndex][1], anorms_table[pvert-&gt;normalIndex][2]);
<br/>
<br/>
     /* calculate vertex real position */
<br/>
     v[0] = (pframe-&gt;scale[0] * pvert-&gt;v[0]) + pframe-&gt;translate[0];
<br/>
     v[1] = (pframe-&gt;scale[1] * pvert-&gt;v[1]) + pframe-&gt;translate[1];
<br/>
     v[2] = (pframe-&gt;scale[2] * pvert-&gt;v[2]) + pframe-&gt;translate[2];
<br/>
<br/>
     glVertex3f (v[0], v[1], v[2]);
<br/>
   }
<br/>
<br/>
      glEnd ();
<br/>
    }
<br/>
}
<br/>
<br/>
<br/>
void
<br/>
RenderFrameItpWithGLCmds (int n, float interp, md2_model_t *mdl)
<br/>
{
<br/>
  int i, *pglcmds;
<br/>
  vec3_t v_curr, v_next, v, norm;
<br/>
  float *n_curr, *n_next;
<br/>
  md2_frame_t *pframe1, *pframe2;
<br/>
  md2_vertex_t *pvert1, *pvert2;
<br/>
  md2_glcmd_t *packet;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames - 1))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* pglcmds points at the start of the command list */
<br/>
  pglcmds = mdl-&gt;glcmds;
<br/>
<br/>
  /* draw the model */
<br/>
  while ((i = *(pglcmds++)) != 0)
<br/>
    {
<br/>
      if (i &lt; 0)
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
     i = -i;
<br/>
   }
<br/>
      else
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
   }
<br/>
<br/>
      /* draw each vertex of this group */
<br/>
      for (/* nothing */; i &gt; 0; --i, pglcmds += 3)
<br/>
   {
<br/>
     packet = (md2_glcmd_t *)pglcmds;
<br/>
     pframe1 = &amp;mdl-&gt;frames[n];
<br/>
     pframe2 = &amp;mdl-&gt;frames[n + 1];
<br/>
     pvert1 = &amp;pframe1-&gt;verts[packet-&gt;index];
<br/>
     pvert2 = &amp;pframe2-&gt;verts[packet-&gt;index];
<br/>
<br/>
     /* pass texture coordinates to OpenGL */
<br/>
     glTexCoord2f (packet-&gt;s, packet-&gt;t);
<br/>
<br/>
     /* interpolate normals */
<br/>
     n_curr = anorms_table[pvert1-&gt;normalIndex];
<br/>
     n_next = anorms_table[pvert2-&gt;normalIndex];
<br/>
<br/>
     norm[0] = n_curr[0] + interp * (n_next[0] - n_curr[0]);
<br/>
     norm[1] = n_curr[1] + interp * (n_next[1] - n_curr[1]);
<br/>
     norm[2] = n_curr[2] + interp * (n_next[2] - n_curr[2]);
<br/>
<br/>
     glNormal3f (norm[0], norm[1], norm[2]);
<br/>
<br/>
     /* interpolate vertices */
<br/>
     v_curr[0] = pframe1-&gt;scale[0] * pvert1-&gt;v[0] + pframe1-&gt;translate[0];
<br/>
     v_curr[1] = pframe1-&gt;scale[1] * pvert1-&gt;v[1] + pframe1-&gt;translate[1];
<br/>
     v_curr[2] = pframe1-&gt;scale[2] * pvert1-&gt;v[2] + pframe1-&gt;translate[2];
<br/>
<br/>
     v_next[0] = pframe2-&gt;scale[0] * pvert2-&gt;v[0] + pframe2-&gt;translate[0];
<br/>
     v_next[1] = pframe2-&gt;scale[1] * pvert2-&gt;v[1] + pframe2-&gt;translate[1];
<br/>
     v_next[2] = pframe2-&gt;scale[2] * pvert2-&gt;v[2] + pframe2-&gt;translate[2];
<br/>
<br/>
     v[0] = v_curr[0] + interp * (v_next[0] - v_curr[0]);
<br/>
     v[1] = v_curr[1] + interp * (v_next[1] - v_curr[1]);
<br/>
     v[2] = v_curr[2] + interp * (v_next[2] - v_curr[2]);
<br/>
<br/>
     glVertex3f (v[0], v[1], v[2]);
<br/>
   }
<br/>
<br/>
      glEnd ();
<br/>
    }
<br/>
}
<br/>
<br/>
void
<br/>
Animate (int start, int end, int *frame, float *interp)
<br/>
{
<br/>
  if ((*frame &lt; start) || (*frame &gt; end))
<br/>
    *frame = start;
<br/>
<br/>
  if (*interp &gt;= 1.0f)
<br/>
    {
<br/>
      /* move to next frame */
<br/>
      *interp = 0.0f;
<br/>
      (*frame)++;
<br/>
<br/>
      if (*frame &gt;= end)
<br/>
   *frame = start;
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
this is the code of "Md2loader.h", a file I include in main code.
<br/>
PS
<br/>
for the 1st argoument of "LoadMd2" I use (u8*)tris.
<br/>
I get "tris" including a md2 file, renamed in ".bin".
<br/>
 problem is Here? I don't think, but maybe...
<br/>
[EDIT]
<br/>
With a simple brakepoint system I understood that the bug is in "memcpy"</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#110462 - Payk - Tue Nov 28, 2006 7:55 pm</h4>
    <div class="postbody"><span class="postbody">Hey...
<br/>
2 things
<br/>
1: Use fixpoint to get a much faster result
<br/>
2: Use hardware futures (translate/scale) to get a much faster result 
<br/>
<br/>
Overgiving the translate/scale data to hardware even takes time too!
<br/>
I use to precalc every frame and store in fixed point. So i jut give the matrix the verticepoints and texturecords (and a light color precalced by myy engine using simplified normals ;P )
<br/>
<br/>
If u do same u really can use 2048 polys @ 60FPS (also with regualr fixed point normals and 4 hardware light sources)
<br/>
otherwhise that wont work.
<br/>
If you need help, just ask ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#110577 - Xgame - Wed Nov 29, 2006 2:55 pm</h4>
    <div class="postbody"><span class="postbody">fixpoint are the "3d math" inside Ds, right? so, using them, I could have mor poly displayed. are glScalev and glTranslatev hardware funcion? I never used these code optimizer...   But for the main problem: why memcpy freeze evrythigs?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#110579 - simonjhall - Wed Nov 29, 2006 3:30 pm</h4>
    <div class="postbody"><span class="postbody">The fixed point stuff he's talking about is avoiding the use of float and doubles and replacing them with ints, shorts etc. I think there are fixed-point versions of some of the OpenGL functions. The DS doesn't have a floating-point unit, so whenever you use floats it has to emulate them in software. Which is really slow.
<br/>
<br/>
These GL functions there are most likely done in hardware.
<br/>
<br/>
And if your memcpy is locking up then it's 99% likely that one of the pointers used is invalid, or you're accessing beyond the end of your array or something...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#110582 - Xgame - Wed Nov 29, 2006 4:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">The fixed point stuff he's talking about is avoiding the use of float and doubles and replacing them with ints, shorts etc. I think there are fixed-point versions of some of the OpenGL functions. The DS doesn't have a floating-point unit, so whenever you use floats it has to emulate them in software. Which is really slow.
<br/>
<br/>
These GL functions there are most likely done in hardware.
<br/>
<br/>
And if your memcpy is locking up then it's 99% likely that one of the pointers used is invalid, or you're accessing beyond the end of your array or something...</td> </tr></table><span class="postbody">
<br/>
I don't got any warning when i compile it... maybe an md2 file don't begin from 0 but from 1 or 2.
<br/>
PS
<br/>
but if I use an int for 3d numbers wold be huge! but if it's better...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#111436 - Xgame - Wed Dec 06, 2006 4:35 pm</h4>
    <div class="postbody"><span class="postbody">I moved the project to kosfs, but it isn't working...(ds give 2 black screen) here's the code of loader with KOS funcion. why it dosen't work?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
<br/>
typedef float vec3_t[3];
<br/>
<br/>
<br/>
/* md2 header */
<br/>
typedef struct
<br/>
{
<br/>
  int ident;
<br/>
  int version;
<br/>
<br/>
  int skinwidth;
<br/>
  int skinheight;
<br/>
<br/>
  int framesize;
<br/>
<br/>
  int num_skins;
<br/>
  int num_vertices;
<br/>
  int num_st;
<br/>
  int num_tris;
<br/>
  int num_glcmds;
<br/>
  int num_frames;
<br/>
<br/>
  int offset_skins;
<br/>
  int offset_st;
<br/>
  int offset_tris;
<br/>
  int offset_frames;
<br/>
  int offset_glcmds;
<br/>
  int offset_end;
<br/>
<br/>
} md2_header_t;
<br/>
<br/>
<br/>
/* texture name */
<br/>
typedef struct
<br/>
{
<br/>
  char name[64];
<br/>
<br/>
} md2_skin_t;
<br/>
<br/>
<br/>
/* texture coords */
<br/>
typedef struct
<br/>
{
<br/>
  short s;
<br/>
  short t;
<br/>
<br/>
} md2_texCoord_t;
<br/>
<br/>
<br/>
/* triangle info */
<br/>
typedef struct
<br/>
{
<br/>
  unsigned short vertex[3];
<br/>
  unsigned short st[3];
<br/>
<br/>
} md2_triangle_t;
<br/>
<br/>
<br/>
/* compressed vertex */
<br/>
typedef struct
<br/>
{
<br/>
  unsigned char v[3];
<br/>
  unsigned char normalIndex;
<br/>
<br/>
} md2_vertex_t;
<br/>
<br/>
<br/>
/* model frame */
<br/>
typedef struct
<br/>
{
<br/>
  vec3_t scale;
<br/>
  vec3_t translate;
<br/>
  char name[16];
<br/>
  md2_vertex_t *verts;
<br/>
<br/>
} md2_frame_t;
<br/>
<br/>
<br/>
/* gl command packet */
<br/>
typedef struct
<br/>
{
<br/>
  float s;
<br/>
  float t;
<br/>
  int index;
<br/>
<br/>
} md2_glcmd_t;
<br/>
<br/>
<br/>
/* md2 model structure */
<br/>
typedef struct
<br/>
{
<br/>
  md2_header_t header;
<br/>
<br/>
  md2_skin_t *skins;
<br/>
  md2_texCoord_t *texcoords;
<br/>
  md2_triangle_t *triangles;
<br/>
  md2_frame_t *frames;
<br/>
  int *glcmds;
<br/>
<br/>
  GLuint tex_id;
<br/>
<br/>
} md2_model_t;
<br/>
<br/>
<br/>
md2_model_t *md2file;
<br/>
<br/>
/* table of precalculated normals */
<br/>
vec3_t anorms_table[162] = {
<br/>
#include "anorms.h"
<br/>
};
<br/>
<br/>
int
<br/>
ReadMD2Model (const char *filename, md2_model_t *mdl)
<br/>
{
<br/>
  KOS_FILE *fp;
<br/>
  int i;
<br/>
<br/>
  fp = KOS_fopen (filename, "rb");
<br/>
  if (!fp)
<br/>
    {
<br/>
      //fprintf (stderr, "error: couldn't open \"%s\"!", filename);
<br/>
      return 0;
<br/>
    }
<br/>
<br/>
  /* read header */
<br/>
  KOS_fread (&amp;mdl-&gt;header, 1, sizeof (md2_header_t), fp);
<br/>
<br/>
  if ((mdl-&gt;header.ident != 844121161) ||
<br/>
      (mdl-&gt;header.version != 8))
<br/>
    {
<br/>
      /* error! */
<br/>
      //fprintf (stderr, "error: bad version!");
<br/>
      KOS_fclose (fp);
<br/>
      return 0;
<br/>
    }
<br/>
<br/>
  /* memory allocation */
<br/>
  mdl-&gt;skins = (md2_skin_t *)malloc (sizeof (md2_skin_t) * mdl-&gt;header.num_skins);
<br/>
  mdl-&gt;texcoords = (md2_texCoord_t *)malloc (sizeof (md2_texCoord_t) * mdl-&gt;header.num_st);
<br/>
  mdl-&gt;triangles = (md2_triangle_t *)malloc (sizeof (md2_triangle_t) * mdl-&gt;header.num_tris);
<br/>
  mdl-&gt;frames = (md2_frame_t *)malloc (sizeof(md2_frame_t) * mdl-&gt;header.num_frames);
<br/>
  mdl-&gt;glcmds = (int *)malloc (sizeof (int) * mdl-&gt;header.num_glcmds);
<br/>
<br/>
  /* read model data */
<br/>
  KOS_fseek (fp, mdl-&gt;header.offset_skins, SEEK_SET);
<br/>
  KOS_fread (mdl-&gt;skins, sizeof (md2_skin_t), mdl-&gt;header.num_skins, fp);
<br/>
<br/>
  KOS_fseek (fp, mdl-&gt;header.offset_st, SEEK_SET);
<br/>
  KOS_fread (mdl-&gt;texcoords, sizeof (md2_texCoord_t), mdl-&gt;header.num_st, fp);
<br/>
<br/>
  KOS_fseek (fp, mdl-&gt;header.offset_tris, SEEK_SET);
<br/>
  KOS_fread (mdl-&gt;triangles, sizeof (md2_triangle_t), mdl-&gt;header.num_tris, fp);
<br/>
<br/>
  KOS_fseek (fp, mdl-&gt;header.offset_glcmds, SEEK_SET);
<br/>
  KOS_fread (mdl-&gt;glcmds, sizeof (int), mdl-&gt;header.num_glcmds, fp);
<br/>
<br/>
  /* read frames */
<br/>
  KOS_fseek (fp, mdl-&gt;header.offset_frames, SEEK_SET);
<br/>
  //int i;
<br/>
  for (i = 0; i &lt; mdl-&gt;header.num_frames; ++i)
<br/>
    {
<br/>
      /* memory allocation for vertices of this frame */
<br/>
      mdl-&gt;frames[i].verts = (md2_vertex_t *)
<br/>
   malloc (sizeof (md2_vertex_t) * mdl-&gt;header.num_vertices);
<br/>
<br/>
      /* read frame data */
<br/>
      KOS_fread (mdl-&gt;frames[i].scale, sizeof (vec3_t), 1, fp);
<br/>
      KOS_fread (mdl-&gt;frames[i].translate, sizeof (vec3_t), 1, fp);
<br/>
      KOS_fread (mdl-&gt;frames[i].name, sizeof (char), 16, fp);
<br/>
      KOS_fread (mdl-&gt;frames[i].verts, sizeof (md2_vertex_t), mdl-&gt;header.num_vertices, fp);
<br/>
    }
<br/>
<br/>
  KOS_fclose (fp);
<br/>
  return 1;
<br/>
}
<br/>
<br/>
void
<br/>
RenderFrame (int n, md2_model_t *mdl)
<br/>
{
<br/>
  int i, j;
<br/>
  GLfloat s, t;
<br/>
  vec3_t v;
<br/>
  md2_frame_t *pframe;
<br/>
  md2_vertex_t *pvert;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames - 1))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* draw the model */
<br/>
  glBegin (GL_TRIANGLES);
<br/>
    /* draw each triangle */
<br/>
    for (i = 0; i &lt; mdl-&gt;header.num_tris; ++i)
<br/>
      {
<br/>
   /* draw each vertex */
<br/>
   for (j = 0; j &lt; 3; ++j)
<br/>
     {
<br/>
       pframe = &amp;mdl-&gt;frames[n];
<br/>
       pvert = &amp;pframe-&gt;verts[mdl-&gt;triangles[i].vertex[j]];
<br/>
<br/>
       /* compute texture coordinates */
<br/>
       s = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].s / mdl-&gt;header.skinwidth;
<br/>
       t = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].t / mdl-&gt;header.skinheight;
<br/>
<br/>
       /* pass texture coordinates to OpenGL */
<br/>
       glTexCoord2f (s, t);
<br/>
<br/>
       /* normal vector */
<br/>
       //glNormal3fv (anorms_table[pvert-&gt;normalIndex]);
<br/>
       glNormal3f(anorms_table[pvert-&gt;normalIndex][0], anorms_table[pvert-&gt;normalIndex][1], anorms_table[pvert-&gt;normalIndex][2]);
<br/>
<br/>
       
<br/>
       
<br/>
<br/>
       /* calculate vertex real position */
<br/>
       v[0] = (pframe-&gt;scale[0] * pvert-&gt;v[0]) + pframe-&gt;translate[0];
<br/>
       v[1] = (pframe-&gt;scale[1] * pvert-&gt;v[1]) + pframe-&gt;translate[1];
<br/>
       v[2] = (pframe-&gt;scale[2] * pvert-&gt;v[2]) + pframe-&gt;translate[2];
<br/>
<br/>
       //glVertex3fv (v);
<br/>
       glVertex3f(v[0], v[1], v[2]);
<br/>
     }
<br/>
      }
<br/>
  glEnd ();
<br/>
}
<br/>
<br/>
<br/>
void
<br/>
RenderFrameItp (int n, float interp, md2_model_t *mdl)
<br/>
{
<br/>
  int i, j;
<br/>
  GLfloat s, t;
<br/>
  vec3_t v_curr, v_next, v, norm;
<br/>
  float *n_curr, *n_next;
<br/>
  md2_frame_t *pframe1, *pframe2;
<br/>
  md2_vertex_t *pvert1, *pvert2;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* draw the model */
<br/>
  glBegin (GL_TRIANGLES);
<br/>
    /* draw each triangle */
<br/>
    for (i = 0; i &lt; mdl-&gt;header.num_tris; ++i)
<br/>
      {
<br/>
   /* draw each vertex */
<br/>
   for (j = 0; j &lt; 3; ++j)
<br/>
     {
<br/>
       pframe1 = &amp;mdl-&gt;frames[n];
<br/>
       pframe2 = &amp;mdl-&gt;frames[n + 1];
<br/>
       pvert1 = &amp;pframe1-&gt;verts[mdl-&gt;triangles[i].vertex[j]];
<br/>
       pvert2 = &amp;pframe2-&gt;verts[mdl-&gt;triangles[i].vertex[j]];
<br/>
<br/>
       /* compute texture coordinates */
<br/>
       s = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].s / mdl-&gt;header.skinwidth;
<br/>
       t = (GLfloat)mdl-&gt;texcoords[mdl-&gt;triangles[i].st[j]].t / mdl-&gt;header.skinheight;
<br/>
<br/>
       /* pass texture coordinates to OpenGL */
<br/>
       glTexCoord2f (s, t);
<br/>
<br/>
       /* interpolate normals */
<br/>
       n_curr = anorms_table[pvert1-&gt;normalIndex];
<br/>
       n_next = anorms_table[pvert2-&gt;normalIndex];
<br/>
<br/>
       norm[0] = n_curr[0] + interp * (n_next[0] - n_curr[0]);
<br/>
       norm[1] = n_curr[1] + interp * (n_next[1] - n_curr[1]);
<br/>
       norm[2] = n_curr[2] + interp * (n_next[2] - n_curr[2]);
<br/>
<br/>
       glNormal3f (norm[0], norm[1], norm[2]);
<br/>
<br/>
       /* interpolate vertices */
<br/>
       v_curr[0] = pframe1-&gt;scale[0] * pvert1-&gt;v[0] + pframe1-&gt;translate[0];
<br/>
       v_curr[1] = pframe1-&gt;scale[1] * pvert1-&gt;v[1] + pframe1-&gt;translate[1];
<br/>
       v_curr[2] = pframe1-&gt;scale[2] * pvert1-&gt;v[2] + pframe1-&gt;translate[2];
<br/>
<br/>
       v_next[0] = pframe2-&gt;scale[0] * pvert2-&gt;v[0] + pframe2-&gt;translate[0];
<br/>
       v_next[1] = pframe2-&gt;scale[1] * pvert2-&gt;v[1] + pframe2-&gt;translate[1];
<br/>
       v_next[2] = pframe2-&gt;scale[2] * pvert2-&gt;v[2] + pframe2-&gt;translate[2];
<br/>
<br/>
       v[0] = v_curr[0] + interp * (v_next[0] - v_curr[0]);
<br/>
       v[1] = v_curr[1] + interp * (v_next[1] - v_curr[1]);
<br/>
       v[2] = v_curr[2] + interp * (v_next[2] - v_curr[2]);
<br/>
<br/>
       glVertex3f (v[0], v[1], v[2]);
<br/>
     }
<br/>
      }
<br/>
  glEnd ();
<br/>
}
<br/>
<br/>
<br/>
<br/>
void
<br/>
RenderFrameWithGLCmds (int n, md2_model_t *mdl)
<br/>
{
<br/>
  int i, *pglcmds;
<br/>
  vec3_t v;
<br/>
  md2_frame_t *pframe;
<br/>
  md2_vertex_t *pvert;
<br/>
  md2_glcmd_t *packet;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames - 1))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* pglcmds points at the start of the command list */
<br/>
  pglcmds = mdl-&gt;glcmds;
<br/>
<br/>
  /* draw the model */
<br/>
  while ((i = *(pglcmds++)) != 0)
<br/>
    {
<br/>
      if (i &lt; 0)
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
     i = -i;
<br/>
   }
<br/>
      else
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
   }
<br/>
<br/>
      /* draw each vertex of this group */
<br/>
      for (/* nothing */; i &gt; 0; --i, pglcmds += 3)
<br/>
   {
<br/>
     packet = (md2_glcmd_t *)pglcmds;
<br/>
     pframe = &amp;mdl-&gt;frames[n];
<br/>
     pvert = &amp;pframe-&gt;verts[packet-&gt;index];
<br/>
<br/>
     /* pass texture coordinates to OpenGL */
<br/>
     glTexCoord2f (packet-&gt;s, packet-&gt;t);
<br/>
<br/>
     /* normal vector */
<br/>
      glNormal3f(anorms_table[pvert-&gt;normalIndex][0], anorms_table[pvert-&gt;normalIndex][1], anorms_table[pvert-&gt;normalIndex][2]);
<br/>
<br/>
     /* calculate vertex real position */
<br/>
     v[0] = (pframe-&gt;scale[0] * pvert-&gt;v[0]) + pframe-&gt;translate[0];
<br/>
     v[1] = (pframe-&gt;scale[1] * pvert-&gt;v[1]) + pframe-&gt;translate[1];
<br/>
     v[2] = (pframe-&gt;scale[2] * pvert-&gt;v[2]) + pframe-&gt;translate[2];
<br/>
<br/>
     glVertex3f (v[0], v[1], v[2]);
<br/>
   }
<br/>
<br/>
      glEnd ();
<br/>
    }
<br/>
}
<br/>
<br/>
<br/>
void
<br/>
RenderFrameItpWithGLCmds (int n, float interp, md2_model_t *mdl)
<br/>
{
<br/>
  int i, *pglcmds;
<br/>
  vec3_t v_curr, v_next, v, norm;
<br/>
  float *n_curr, *n_next;
<br/>
  md2_frame_t *pframe1, *pframe2;
<br/>
  md2_vertex_t *pvert1, *pvert2;
<br/>
  md2_glcmd_t *packet;
<br/>
<br/>
  /* check if n is in a valid range */
<br/>
  if ((n &lt; 0) || (n &gt; mdl-&gt;header.num_frames - 1))
<br/>
    return;
<br/>
<br/>
  /* enable model's texture */
<br/>
  glBindTexture (GL_TEXTURE_2D, mdl-&gt;tex_id);
<br/>
<br/>
  /* pglcmds points at the start of the command list */
<br/>
  pglcmds = mdl-&gt;glcmds;
<br/>
<br/>
  /* draw the model */
<br/>
  while ((i = *(pglcmds++)) != 0)
<br/>
    {
<br/>
      if (i &lt; 0)
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
     i = -i;
<br/>
   }
<br/>
      else
<br/>
   {
<br/>
     glBegin (GL_TRIANGLE_STRIP);
<br/>
   }
<br/>
<br/>
      /* draw each vertex of this group */
<br/>
      for (/* nothing */; i &gt; 0; --i, pglcmds += 3)
<br/>
   {
<br/>
     packet = (md2_glcmd_t *)pglcmds;
<br/>
     pframe1 = &amp;mdl-&gt;frames[n];
<br/>
     pframe2 = &amp;mdl-&gt;frames[n + 1];
<br/>
     pvert1 = &amp;pframe1-&gt;verts[packet-&gt;index];
<br/>
     pvert2 = &amp;pframe2-&gt;verts[packet-&gt;index];
<br/>
<br/>
     /* pass texture coordinates to OpenGL */
<br/>
     glTexCoord2f (packet-&gt;s, packet-&gt;t);
<br/>
<br/>
     /* interpolate normals */
<br/>
     n_curr = anorms_table[pvert1-&gt;normalIndex];
<br/>
     n_next = anorms_table[pvert2-&gt;normalIndex];
<br/>
<br/>
     norm[0] = n_curr[0] + interp * (n_next[0] - n_curr[0]);
<br/>
     norm[1] = n_curr[1] + interp * (n_next[1] - n_curr[1]);
<br/>
     norm[2] = n_curr[2] + interp * (n_next[2] - n_curr[2]);
<br/>
<br/>
     glNormal3f (norm[0], norm[1], norm[2]);
<br/>
<br/>
     /* interpolate vertices */
<br/>
     v_curr[0] = pframe1-&gt;scale[0] * pvert1-&gt;v[0] + pframe1-&gt;translate[0];
<br/>
     v_curr[1] = pframe1-&gt;scale[1] * pvert1-&gt;v[1] + pframe1-&gt;translate[1];
<br/>
     v_curr[2] = pframe1-&gt;scale[2] * pvert1-&gt;v[2] + pframe1-&gt;translate[2];
<br/>
<br/>
     v_next[0] = pframe2-&gt;scale[0] * pvert2-&gt;v[0] + pframe2-&gt;translate[0];
<br/>
     v_next[1] = pframe2-&gt;scale[1] * pvert2-&gt;v[1] + pframe2-&gt;translate[1];
<br/>
     v_next[2] = pframe2-&gt;scale[2] * pvert2-&gt;v[2] + pframe2-&gt;translate[2];
<br/>
<br/>
     v[0] = v_curr[0] + interp * (v_next[0] - v_curr[0]);
<br/>
     v[1] = v_curr[1] + interp * (v_next[1] - v_curr[1]);
<br/>
     v[2] = v_curr[2] + interp * (v_next[2] - v_curr[2]);
<br/>
<br/>
     glVertex3f (v[0], v[1], v[2]);
<br/>
   }
<br/>
<br/>
      glEnd ();
<br/>
    }
<br/>
}
<br/>
<br/>
void
<br/>
Animate (int start, int end, int *frame, float *interp)
<br/>
{
<br/>
  if ((*frame &lt; start) || (*frame &gt; end))
<br/>
    *frame = start;
<br/>
<br/>
  if (*interp &gt;= 1.0f)
<br/>
    {
<br/>
      /* move to next frame */
<br/>
      *interp = 0.0f;
<br/>
      (*frame)++;
<br/>
<br/>
      if (*frame &gt;= end)
<br/>
   *frame = start;
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
i'll put ints after get this working.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#111447 - Payk - Wed Dec 06, 2006 5:40 pm</h4>
    <div class="postbody"><span class="postbody">u noticed that the directory starts with rd?
<br/>
i mean "/rd/" is your root folder...
<br/>
how did u init it?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">      REG_IME=0;   
<br/>
      sysSetCartOwner( BUS_OWNER_ARM9 );
<br/>
      fs_init(); 
<br/>
      fs_romdisk_mount("/rd", (uint8*)find_first_romfs_file((uint8*)0x08000000), 0); 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
next thing could be that datas are attached wrong.
<br/>
So i moved all tools which are neececary in a folder called
<br/>
"romtoolz" in the root folder of my development folder.
<br/>
another folder which is called "bundle" is nececary.
<br/>
then run a batch file like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@echo off
<br/>
<br/>
echo -- Packing data into a single KOSFS data file
<br/>
romtoolz\genromfs -d rd2 -f extern.rom
<br/>
<br/>
echo -- Append KSOFS data file onto end of New.ds.gba
<br/>
copy Combined.ds.gba bundle\New.ds.gba.bin
<br/>
romtoolz\padbin 256 bundle\New.ds.gba.bin
<br/>
copy /B bundle\New.ds.gba.bin+extern.rom bundle\Wolves.sc.nds
<br/>
copy /B bundle\New.ds.gba.bin+extern.rom bundle\Wolves.ds.gba
<br/>
<br/>
echo -- Append KOSFS data file onto end of New.nds
<br/>
copy Combined.nds bundle\New.nds.bin
<br/>
romtoolz\padbin 256 bundle\New.nds.bin
<br/>
copy /B bundle\New.nds.bin+extern.rom bundle\Wolves.emu.nds
<br/>
<br/>
pause
<br/>
<br/>
del extern.rom
<br/>
del bundle\New.nds.bin
<br/>
del bundle\New.ds.gba.bin
<br/>
</td> </tr></table><span class="postbody">
<br/>
This way of doing it is from dslua ;P
<br/>
I liked that ..
<br/>
it makes a rom from the folder "rd" (i got more of them...stupid name)
<br/>
then it takes the roms combined.ds.gba and nds, and attaches the rom to it. The result should be in bundle folder.
<br/>
<br/>
whats in the folder romtoolz?
<br/>
Padbin.exe, genromfs.exe , cygwin1.dll and msys-1.0.dll.
<br/>
<br/>
I hope that helped a bit</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#111448 - Payk - Wed Dec 06, 2006 5:44 pm</h4>
    <div class="postbody"><span class="postbody">I highly recommmand some printouts for better troubleshoting.
<br/>
After init u could print "init succesfully"
<br/>
<br/>
and print out if it founds the md2 file. maybe print out the md2 header...how many polys does it uses etc. That always helps to locate the problem ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#111926 - Xgame - Mon Dec 11, 2006 8:01 pm</h4>
    <div class="postbody"><span class="postbody">I finally opened the file; so I read it, but it result wrong(the read data). I'am working over, if you know something about KOS_fread plese let me know.
<br/>
PS
<br/>
maybe is better to use fat?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#111928 - Payk - Mon Dec 11, 2006 8:22 pm</h4>
    <div class="postbody"><span class="postbody">ahh 
<br/>
try fread with "rb" instead of "r"
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">KOS_FILE *fp = KOS_fopen(Filename,"rb") ;</td> </tr></table><span class="postbody">
<br/>
Maybe that makes a difference. It shouldnt normaly, but i found out that it sometimes makes a difference even if u dont use getc command.
<br/>
best is just try that out ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112022 - Xgame - Tue Dec 12, 2006 3:13 pm</h4>
    <div class="postbody"><span class="postbody">it still dosen't work! i print the ident number and it is "0194". is it the real model id or it's the result of a bug( an unright variable type, a wrong size of reading...)?
<br/>
EDIT
<br/>
i'am jumping the version test... soon i'll can say if it's work
<br/>
EDIT2
<br/>
it's seems working, now i'll try in 3d...
<br/>
EDIT 3
<br/>
I loaded an Md2 model! I am sure i loaded it because i create a funcion wich print the pointlist. but I can't draw it, I don't know why. I also draw the nehe 2 scene, but I can't see it. have you got any ideas? I'll do some test later.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
