<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>question regarding paletted 8bit background mode - Answered - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > question regarding paletted 8bit background mode - Answered</h2>
<div id="posts">
<div class="post">
    <h4>#135902 - mr_munk - Fri Jul 27, 2007 9:26 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I have adapted the example code from a tutorial to display an 8bit paletted image. I want to use the image data as a LUT and as an initial test, I am attempting to copy the pixel data from the LUT to the screenbuffer using a for loop, however the resultant image drawn to the screen appears to skip every second line... Can someone help me understand why this is happening? 
<br/>
<br/>
Here is an image of the screen:
<br/>
<br/>
<a href="http://img522.imageshack.us/img522/130/copyiw0.png">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
I think that the LUT contains the correct data because I can DMAcopy the data from the LUT array to the screen successfully; here is a screenshot of the image displayed correctly on screen:
<br/>
<br/>
<a href="http://img524.imageshack.us/img524/5715/dmacopyvn2.png">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
Here are the relevant parts of my code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "sob3_bin.h" //shadow of the beast raw images 192x256x256 8bit
<br/>
#include "master_bin.h"//palette
<br/>
...
<br/>
//load sob3 image into main memory
<br/>
u8* sob3img = new u8[sob3_bin_size]; 
<br/>
dmaCopy(sob3_bin, sob3img, sob3_bin_size);
<br/>
...
<br/>
//point our video buffer to the start of bitmap background video
<br/>
u16* video_buffer_main = (u16*)BG_BMP_RAM(0);
<br/>
   
<br/>
//set video mode to mode 5 with background 3 enabled
<br/>
videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);   
<br/>
   
<br/>
//map vram a to start of main background graphics memory
<br/>
vramSetBankA(VRAM_A_MAIN_BG_0x06000000);
<br/>
<br/>
//set control registers
<br/>
//initialize the background
<br/>
BG3_CR = BG_BMP8_256x256 | BG_BMP_BASE(0);
<br/>
   
<br/>
BG3_XDY = 0;
<br/>
BG3_XDX = 1 &lt;&lt; 8;
<br/>
BG3_YDX = 0;
<br/>
BG3_YDY = 1 &lt;&lt; 8;
<br/>
...
<br/>
dmaCopy(master_bin, BG_PALETTE, 256*2); //load the palette into palette main memory
<br/>
<br/>
//*copy* img 3 to main screen cr mapped memory - doesn't work
<br/>
for(i = 0; i &lt; 256 * 256; i++)
<br/>
{
<br/>
   video_buffer_main[i] = sob3img[i];
<br/>
   iprintf("mem add vb[%d]: %X \n", i, &amp;video_buffer_main[i]);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
In 16bit mode the image draws correctly, although the paletted colours are all wrong. (does 16bit mode support a palette?)
<br/>
<br/>
I have been trying to solve this problem for myself but have made little progress in 3 days, I would welcome any information.</span><span class="gensmall"><br/><br/>Last edited by mr_munk on Fri Jul 27, 2007 12:58 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#135908 - Dwedit - Fri Jul 27, 2007 10:19 am</h4>
    <div class="postbody"><span class="postbody">You are writing 8 bits of data into a 16 bit slot.  The upper 8 bits are all zero, hence your black horizontal stripes every other pixel.
<br/>
<br/>
I suggest you just memcpy the data directly into video memory instead of doing the (incorrect) 8&gt;16 bit expansion you are currently doing.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135912 - mr_munk - Fri Jul 27, 2007 11:29 am</h4>
    <div class="postbody"><span class="postbody">Thanks, I suspected something similar to this, what I don't understand is why the memory slots are 16bit? I assumed (although I could well be wrong) that setting the BG3 control register to 8bit would make it read the slots in 8bit blocks ?
<br/>
<br/>
Eventually I want to use the pixel data as a LUT so I can calculate offsets on a per pixel basis and warp the image, the solution (I think) that you are suggesting is a good one - writing the warped data to a buffer and then memcopying it to the background memory - thanks for that :) However I also want to develop my understanding better - can anyone help me to understand why the memory slots are inherantly 16bit ? Is it because the CR is 16bit and the memory is mapped to the CR ?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135914 - elhobbs - Fri Jul 27, 2007 11:49 am</h4>
    <div class="postbody"><span class="postbody">you must do 16bit writes to vram regardless of the background mode. that is a just how the hardware works. dmaCopy is your best/fastest option.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135916 - mr_munk - Fri Jul 27, 2007 12:57 pm</h4>
    <div class="postbody"><span class="postbody">Thanks :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#135926 - Dwedit - Fri Jul 27, 2007 2:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>mr_munk wrote:</b></span></td> </tr> <tr> <td class="quote">Thanks, I suspected something similar to this, what I don't understand is why the memory slots are 16bit? I assumed (although I could well be wrong) that setting the BG3 control register to 8bit would make it read the slots in 8bit blocks ?
<br/>
<br/>
Eventually I want to use the pixel data as a LUT so I can calculate offsets on a per pixel basis and warp the image, the solution (I think) that you are suggesting is a good one - writing the warped data to a buffer and then memcopying it to the background memory - thanks for that :) However I also want to develop my understanding better - can anyone help me to understand why the memory slots are inherantly 16bit ? Is it because the CR is 16bit and the memory is mapped to the CR ?</td> </tr></table><span class="postbody">
<br/>
In your case, you were doing 16 bit writes because you had declared "u16* video_buffer_main".  If you had used u8* instead, you would be doing 8 bit writes.  It just so happens that the video hardware does not like 8-bit writes, it causes the byte to be written to both halves of a 16 bit word.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
