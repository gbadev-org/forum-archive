<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Environment Mapping - I'm loosing my hair over it ! :O - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Environment Mapping - I'm loosing my hair over it ! :O</h2>
<div id="posts">
<div class="post">
    <h4>#119178 - qw3rty - Tue Feb 20, 2007 2:19 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I try to include environment mapping, but I don't get it !
<br/>
The example provided with devkitpro is very vague unfortunately, and doesn't show the actual vertices sending (glnormal(), glvertex() etc).
<br/>
<br/>
Environment textures seem to rely on the order of the points you send to the hardware - I get completely different results starting the triangles at different points (e.g. top right, vs. bottom left).
<br/>
<br/>
Could anybody who has experience with environment mapping give me some advices ?
<br/>
(An easy example of a triangle or pyramid with environment mapping on it maybe)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119190 - ikaris - Tue Feb 20, 2007 5:45 pm</h4>
    <div class="postbody"><span class="postbody">I'm doing spherical environment mapping in my engine...
<br/>
<br/>
I got the formula from this page:
<br/>
<br/>
<a href="http://www.ozone3d.net/tutorials/glsl_texturing_p04.php#part_41" target="_blank">http://www.ozone3d.net/tutorials/glsl_texturing_p04.php#part_41</a>
<br/>
<br/>
Here's my source code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "fzEnvMap.h"
<br/>
<br/>
void fzEnvMap(fzMesh &amp; mesh, fzVec3 cameraPos)
<br/>
{
<br/>
   unsigned int numTexCoords = mesh.t.Size();
<br/>
   
<br/>
   for (unsigned int i = 0; i &lt; numTexCoords; i++)
<br/>
   {
<br/>
      fzVec3 vtx(mesh.v.Index().x, mesh.v.Index().y, mesh.v.Index().z);
<br/>
      
<br/>
      fzVec3 u = cameraPos - vtx;
<br/>
<br/>
      u.Normalize();
<br/>
<br/>
      fzVec3 nrm(mesh.n.Index().x, mesh.n.Index().y, mesh.n.Index().z);
<br/>
<br/>
      float dot = nrm.DotProduct(vtx);
<br/>
<br/>
      float fTemp = dot * 2.0;
<br/>
<br/>
      fzVec3 vTemp = nrm - vtx;
<br/>
<br/>
      fzVec3 r = ( vTemp * fTemp );
<br/>
<br/>
      float m = sqrt(   (r.x * r.x) + (r.y * r.y) + ( (r.z + 1.0) * (r.z + 1.0) )  );
<br/>
<br/>
      mesh.t.Index().u = floattot16(r.x / m + 0.5);
<br/>
      mesh.t.Index().v = floattot16(r.y / m + 0.5);
<br/>
<br/>
      mesh.v.Next();
<br/>
      mesh.t.Next();
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Hope this helps you !</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119198 - qw3rty - Tue Feb 20, 2007 6:59 pm</h4>
    <div class="postbody"><span class="postbody">Thanks - I also started to implement software "fake" - environment.
<br/>
That at least works as expected :)
<br/>
<br/>
But I wanted to use the 3d-hardware for the environment-mapping ("\examples\nds\Graphics\3D\Misc\Env_Mapping"  in the devkitpro folder contains a demo, but I can't figure it out with that demo alone :( )
<br/>
<br/>
I continue to work on my software environment mapping, it doesn't slow it down that much.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119625 - M3d10n - Sat Feb 24, 2007 9:34 pm</h4>
    <div class="postbody"><span class="postbody">You shouldn't need to do anything extraneous with your geometry for proper environment mapping. Just make sure you're providing proper normals, since they are the major thing to affect the texture coordinates.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119850 - qw3rty - Mon Feb 26, 2007 9:55 pm</h4>
    <div class="postbody"><span class="postbody">I have a fixedpoint spheremapping routine now, that's fast enough for my needs, but I'm still curious how to do it with hardware.
<br/>
<br/>
Could anybody give an easy example of a environment-mapped quad ?
<br/>
(Not a fancy teapot, that's drawn by a DMA of a binary file *sigh*)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#119867 - shash - Mon Feb 26, 2007 11:22 pm</h4>
    <div class="postbody"><span class="postbody">You don't need the actual model of that example, as the important parts are these:
<br/>
<br/>
1) First, setup a texture so that the texture coordinates used per vertex, are calculated from it's normal (<a class="postlink" href="http://nocash.emubase.de/gbatek.htm#ds3dtexturecoordinates" target="_blank">reference</a>):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">glTexImage2D( 0, 0, GL_RGB, TEXTURE_SIZE_128 , TEXTURE_SIZE_128, 0, GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_NORMAL, (u8*)cafe_bin );</td> </tr></table><span class="postbody">
<br/>
<br/>
2) Later, scale the normals from normalized range to texture space, scaling the GL_TEXTURE matrix, and later rotating to match the camera. To sum it up, what this does, in conjuction with the normal texture coordinates generation, is creating texture coordinates from normals. As you have a 128x128 texture, and the normals are in the [-1,1] range, multiplying them by (64,64,1), will put them in the texture range. It's this part:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">glMatrixMode(GL_TEXTURE);
<br/>
glIdentity();
<br/>
GLvector tex_scale = { 64&lt;&lt;16, -64&lt;&lt;16, 1&lt;&lt;16 };
<br/>
glScalev( &amp;tex_scale );
<br/>
glRotateXi(rotateX&gt;&gt;3);
<br/>
glRotateYi(rotateY&gt;&gt;3);</td> </tr></table><span class="postbody">
<br/>
<br/>
3) Send your mesh with proper normals, smooth normals will give you the sphere mapping look in that example. Per face normals will give you a disco ball look. What's important, is that if you want the texture coordinates to be different per vertex, normals must be different, as they are generated from that.<br/>_________________<br/><a href="http://shashemudev.blogspot.com" target="_blank">http://shashemudev.blogspot.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120020 - qw3rty - Wed Feb 28, 2007 11:58 am</h4>
    <div class="postbody"><span class="postbody">Hmmm.... I just tryed the hardware-environment mapping again, and I think now I got it right.
<br/>
<br/>
This is the code, I execute instead of calling the teapot :
<br/>
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
glBindTexture( 0, cafe_texid );
<br/>
      //glCallList((u32*)teapot_bin);
<br/>
      glBegin(GL_TRIANGLES);
<br/>
      glNormal(NORMAL_PACK(-300,-300,300));
<br/>
      glVertex3v16(-1024, -1024,  1024);
<br/>
      glNormal(NORMAL_PACK(+300,+300,300));
<br/>
      glVertex3v16(1024, 1024,  1024);
<br/>
      glNormal(NORMAL_PACK(-300,+300,300));
<br/>
      glVertex3v16(-1024, +1024,  1024);
<br/>
      
<br/>
      glNormal(NORMAL_PACK(300,300,300));
<br/>
      glVertex3v16(1024, 1024,  1024);
<br/>
      glNormal(NORMAL_PACK(-300,-300,300));
<br/>
      glVertex3v16(-1024, -1024,  1024);
<br/>
      glNormal(NORMAL_PACK(300,-300,300));
<br/>
      glVertex3v16(+1024, -1024,  1024);
<br/>
      glEnd();
<br/>
<br/>
      glFlush();
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
What my code does, is to draw two triangles, that form a square.
<br/>
Using the "real" normal (0,0,511) for every corner results in a one-colored square (all vertices are mapped to the same texture coordinate).
<br/>
Using the normals, that point away from the center of the square gives the results expected.
<br/>
But that would mean, I have to adjust my normals according to the "camera-vertex"-vector , right ?
<br/>
(That would be the half way to software sphere mapping !)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120048 - shash - Wed Feb 28, 2007 4:22 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>qw3rty wrote:</b></span></td> </tr> <tr> <td class="quote">(...)
<br/>
Using the "real" normal (0,0,511) for every corner results in a one-colored square (all vertices are mapped to the same texture coordinate).
<br/>
Using the normals, that point away from the center of the square gives the results expected.
<br/>
But that would mean, I have to adjust my normals according to the "camera-vertex"-vector , right ?
<br/>
(...)</td> </tr></table><span class="postbody">
<br/>
<br/>
No: normals can be static. As I already explained above, the texture coords are generated from normals. Same normals means SAME texture coordinates.
<br/>
<br/>
For a "normal" cube, you'll probably want to have per vertex smoothed normals, or else your mapping will be a bit rare. In general, you'll probably already want per vertex normals if you want smooth lighting.<br/>_________________<br/><a href="http://shashemudev.blogspot.com" target="_blank">http://shashemudev.blogspot.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120100 - qw3rty - Thu Mar 01, 2007 1:10 am</h4>
    <div class="postbody"><span class="postbody">Normals can be static for static objects, sure.
<br/>
But I have a dynamic water-surface, hence I can't have static normals.
<br/>
That's why I would've to change the vertex normals according to the camera-vertex-vector, or am I missing something ?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120101 - shash - Thu Mar 01, 2007 1:13 am</h4>
    <div class="postbody"><span class="postbody">Just recalculate your normals as you would do normally for lighting, and it'll be fine. Usually it's as easy as averaging the face normals the vertex shares, and you're done.<br/>_________________<br/><a href="http://shashemudev.blogspot.com" target="_blank">http://shashemudev.blogspot.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120112 - qw3rty - Thu Mar 01, 2007 2:23 am</h4>
    <div class="postbody"><span class="postbody">But once the waves stop, the surface is flat, hence all normals will point directly up.
<br/>
You see the problem ? when all normals point directly up, all vertices will point to the same texture coordiante - hence I need to change them somehow 
<br/>
(and I still believe it's the camera-vertex-vector that influences the normal - I suppose you have to use the camera-vertex-vector reflected at the normal - which would eliminate the advancement of hardware support because at this point you are two lines away from the sphere-map texture-coordinates ).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120118 - shash - Thu Mar 01, 2007 3:32 am</h4>
    <div class="postbody"><span class="postbody">Then you need to create the normals to simulate your waves. Creating them with sin/cos should be fine, I've seen quite a few water "fakes" done with just sin/cos generated normals.<br/>_________________<br/><a href="http://shashemudev.blogspot.com" target="_blank">http://shashemudev.blogspot.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120165 - qw3rty - Thu Mar 01, 2007 12:21 pm</h4>
    <div class="postbody"><span class="postbody">You didn't understnad, what I was meaning :
<br/>
<br/>
On a flat water-surface, with no waves, every vertices normal will point into the exact same direction.
<br/>
But if I use those normals for environment mapping it won't work.
<br/>
<br/>
I don't use sine/cosine for my water-surface, it's a discretised "physical" model, and I don't see how that would help me creating the "environment"-normals.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120183 - shash - Thu Mar 01, 2007 5:51 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>qw3rty wrote:</b></span></td> </tr> <tr> <td class="quote">You didn't understnad, what I was meaning :
<br/>
<br/>
On a flat water-surface, with no waves, every vertices normal will point into the exact same direction.
<br/>
But if I use those normals for environment mapping it won't work.
<br/>
<br/>
I don't use sine/cosine for my water-surface, it's a discretised "physical" model, and I don't see how that would help me creating the "environment"-normals.</td> </tr></table><span class="postbody">
<br/>
<br/>
I thought you were using a simple flat surface to simulate the water, so using simple sin/cos normals would be useful in that case.<br/>_________________<br/><a href="http://shashemudev.blogspot.com" target="_blank">http://shashemudev.blogspot.com</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
