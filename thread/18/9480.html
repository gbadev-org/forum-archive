<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Performance timing - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Performance timing</h2>
<div id="posts">
<div class="post">
    <h4>#82232 - Chris Holmes - Thu May 04, 2006 6:17 pm</h4>
    <div class="postbody"><span class="postbody">I found this thread:
<br/>
<br/>
<a href="http://forum.gbadev.org/viewtopic.php?t=5983" target="_blank">http://forum.gbadev.org/viewtopic.php?t=5983</a>
<br/>
<br/>
But the snippets of provided code aren't working for me.  
<br/>
<br/>
Does anyone have a generic timing class built for the DS?  
<br/>
<br/>
I'm working on one, and I plan to change it to take as a parameter the duration as well as using multiple timers, but I'm not getting the timer firing.
<br/>
<br/>
The code I'm using is pulled from that other thread and looks like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
         irqInit();
<br/>
         irqEnable(IRQ_VBLANK);
<br/>
<br/>
         irqSet(IRQ_TIMER0, TimerFunc); 
<br/>
         TIMER0_CR = TIMER_ENABLE | TIMER_DIV_256;
<br/>
         TIMER0_DATA = TIMER_FREQ_256(100); 
<br/>
         irqEnable(IRQ_TIMER0);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The function TimerFunc is not getting called.
<br/>
<br/>
I think I'm missing something simple and obvious, but I'm not sure what.  The previous post says to set bit 6 of TIMER0_CR, but I also did that and I still didn't get the interrupt firing.
<br/>
<br/>
This isn't working on either Dualis or hardware.
<br/>
<br/>
Thanks for helping,
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82246 - wintermute - Thu May 04, 2006 7:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
volatile int count=0;
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
void TimerFunc() {
<br/>
//---------------------------------------------------------------------------------
<br/>
   count++;
<br/>
}
<br/>
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
int main(void) {
<br/>
//---------------------------------------------------------------------------------
<br/>
<br/>
   irqInit();
<br/>
   irqSet(IRQ_TIMER0, TimerFunc);
<br/>
   TIMER0_CR &amp;= ~TIMER_ENABLE; // not strictly necessary if the timer hasn't been enabled before
<br/>
   TIMER0_DATA = TIMER_FREQ_256(100);
<br/>
   TIMER0_CR = TIMER_ENABLE | TIMER_DIV_256 | TIMER_IRQ_REQ;
<br/>
   irqEnable(IRQ_TIMER0 | IRQ_VBLANK);
<br/>
<br/>
   videoSetMode(0);   //not using the main screen
<br/>
   videoSetModeSub(MODE_0_2D | DISPLAY_BG0_ACTIVE);   //sub bg 0 will be used to print text
<br/>
   vramSetBankC(VRAM_C_SUB_BG);
<br/>
<br/>
   SUB_BG0_CR = BG_MAP_BASE(31);
<br/>
<br/>
   BG_PALETTE_SUB[255] = RGB15(31,31,31);   //by default font will be rendered with color 255
<br/>
<br/>
   //consoleInit() is a lot more flexible but this gets you up and running quick
<br/>
   consoleInitDefault((u16*)SCREEN_BASE_BLOCK_SUB(31), (u16*)CHAR_BASE_BLOCK_SUB(0), 16);
<br/>
<br/>
   while(1) {
<br/>
      swiWaitForVBlank();
<br/>
      iprintf("\x1b[0;0H%d",count);
<br/>
   }
<br/>
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Things to note
<br/>
<ul>
<br/>
<li>The timer is disabled before setting the data, not strictly necessary unless the timer has been previously enabled.
<br/>
</li><li>Timer data is set before the timer is enabled
<br/>
</li><li>Variables adjusted in the interrupt are marked volatile
<br/>
</li><li>The irq request flag is set.
<br/>
</li></ul><br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82257 - Chris Holmes - Thu May 04, 2006 8:52 pm</h4>
    <div class="postbody"><span class="postbody">That worked perfectly, thanks much!
<br/>
<br/>
Is there any way to get fairly precise timing profiles of different bits of code?  There's always the fallback of using the most precise timers available internally and then just running the code 10,000 times (or some arbitrarily large number of times) and taking the total time / 10,000 to guestimate the time it takes.  As long as other interrupts are running and such, it won't be a precise estimate, but if all I care about is to know that algorithm A is roughly 4 times faster than algorithm B, that should be precise enough.
<br/>
<br/>
Alternatively, there is the no$gba emulator that, in theory anyway, can provide very good code profiles.
<br/>
<br/>
Are there any other working DS profilers?
<br/>
<br/>
And thanks again for the help,
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82261 - Mighty Max - Thu May 04, 2006 9:28 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote">all I care about is to know that algorithm A is roughly 4 times faster than algorithm B, that should be precise enough.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
If you need to compare algorithm times, you shouldn't care about scalar differences. It doesn't really matter if for any amount of input algorithm A is 4 times faster then B, because this factor is just the specific implementation, and can easily be changed.
<br/>
<br/>
You should however care if an algorithm multiplies its runningtime, when you increase the limiting factor, or does it keep constant? Lets take an example. Do you know the fibonacci row?
<br/>
<br/>
0 1 1 2 3 5 8 13 21 34 55 89 ....
<br/>
<br/>
Its native algorithm is
<br/>
<br/>
fib(n) = (n&lt;2)?n:fib(n-1)+fib(n-2) ;
<br/>
<br/>
Its time-cost raises in the same manner as the value it calculates.
<br/>
<br/>
Howerer, there is an iterative solution solving fib(n) in (n-1) steps. The timecost is linear to n.
<br/>
<br/>
I wouldnt recomment testing the speed difference like you mentioned. You should keep analysing the algorithm itself. Why? If you do this test with a moderate n=100. You wouldn't want to wait for it. The native fib(n) would call itself 354224848179261915075 times. 
<br/>
<br/>
<br/>
For speeding up implementations, i would recomment using the build-in optimizer.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82264 - Chris Holmes - Thu May 04, 2006 9:43 pm</h4>
    <div class="postbody"><span class="postbody">Or you could say, "Look up Big-Oh notation."
<br/>
<br/>
Since you're obviously curious, what I'm testing is my alternative math libraries for the DS against the current look up table and various ways of implementing them.  There are a couple of ways to handle the lookups: direct lookup of full tables, direct lookup for sine but use the sine table for cosine (incurs a single addition cost), using 1/4 of the sine table and incurring about 2 branches.  Also, while I'm at it, I want to know if gcc is bright enough to treat % power_of_2 as a &gt;&gt; or not.  If it's really doing a divide, that would incur a significat penalty, and that would be bad and slow.
<br/>
<br/>
But while I'm at it, yes, I know what Big-Oh notation is.  I asked about code profiling, not Big-Oh.  There's a difference.
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82268 - wintermute - Thu May 04, 2006 10:06 pm</h4>
    <div class="postbody"><span class="postbody">You mean % power of 2 as &amp; surely?
<br/>
<br/>
gcc can be pretty clever with certain code - the best way to investigate is to have a look at the assembly output for a given piece of code. Add -save-temps to your CFLAGS and the assembly output will be saved.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
unsigned int modulo(unsigned int test) {
<br/>
<br/>
   unsigned int x = test % 128;
<br/>
   unsigned int y = x % 64;
<br/>
   x = y % 32;
<br/>
   return x;
<br/>
}
<br/>
<br/>
   .code 16
<br/>
   .thumb_func
<br/>
   .type   modulo, %function
<br/>
modulo:
<br/>
.LVL0:
<br/>
   mov   r3, #31
<br/>
   and   r0, r0, r3
<br/>
.LVL1:
<br/>
   @ lr needed for prologue
<br/>
   .loc 1 12 0
<br/>
   @ sp needed for prologue
<br/>
   bx   lr
<br/>
.LFE57:
<br/>
   .size   modulo, .-modulo
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
it gets less clever with signed values.
<br/>
<br/>
division and multiplication by powers of two are optimised to shifts where appropriate.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82272 - tepples - Thu May 04, 2006 10:25 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote">Since you're obviously curious, what I'm testing is my alternative math libraries for the DS against the current look up table and various ways of implementing them.  There are a couple of ways to handle the lookups: direct lookup of full tables, direct lookup for sine but use the sine table for cosine (incurs a single addition cost), using 1/4 of the sine table and incurring about 2 branches.</td> </tr></table><span class="postbody">
<br/>
What looks like a branch may not be a branch. If you're compiling to ARM code, GCC can often optimize a branch around a single line of code into a conditional execution. For instance, mapping a full cosine table lookup into a half cosine table (0..180) lookup would be a CMP then a RSBGT or similar, always taking two cycles.
<br/>
<br/>
Also consider space-time tradeoffs: if you optimize one part of the program for space, then you can optimize another part of the program for time. This depends on how often one method is called compared to another method. The difference can be dramatic: when I change tetanus.c from Tetanus On Drugs for GBA to use -O3 (optimize for time) instead of -O2 (optimize for a balance of space and time), it's roughly 10 KB bigger on top of the 35 KB total code size (before appending assets).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Also, while I'm at it, I want to know if gcc is bright enough to treat % power_of_2 as a &gt;&gt; or not.</td> </tr></table><span class="postbody">
<br/>
Depends. If it's unsigned, then it'll probably optimize. It's less likely to do so for signed types because of rounding issues. Look at the asm code that GCC emits (use -save-temps) to make sure.
<br/>
<br/>
The simplest, most reliable method of profiling on the GBA and Nintendo DS is to read VCOUNT at the start and end of an inner loop from within the game (so that differences in cache behavior don't affect anything).<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82354 - Chris Holmes - Fri May 05, 2006 2:49 pm</h4>
    <div class="postbody"><span class="postbody">The problem I have with letting GCC optimize code is that since everyone is using GCC, that gives me a reliable measure of how optimized it will be.  GCC is a pretty lousy optimizing compiler, especially compared to things like Intel's compiler.  When the best GCC can do is code that runs at about half the speed of Intel's compiler, well, that's just not super.  
<br/>
And I generally assume that most everyone is running at -o2, not -o3 or anything different and special.  So if I can optimize something that I consider to be a support library, then it's probably worth a few minutes of my time.
<br/>
<br/>
I didn't think ARM supported conditional operations at all.  That's an awfully CISC thing to put into a RISC core.
<br/>
<br/>
And yes, I'm aware of all the optimizations possible, the time-space trade-off, etc.  I didn't spend all those years recently getting a CS and CmpE degree for nothing.  And those degrees taught me everything that GCC isn't and almost can't do to optimize code.  
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82367 - wintermute - Fri May 05, 2006 5:36 pm</h4>
    <div class="postbody"><span class="postbody">Here's an interesting article.
<br/>
<br/>
<a href="http://www.coyotegulch.com/reviews/linux_compilers/index.html" target="_blank">http://www.coyotegulch.com/reviews/linux_compilers/index.html</a>
<br/>
<br/>
GCC definitely does not produce code that runs at half the speed of Intel's compiler across the board.
<br/>
<br/>
Most 32bit ARM instructions can be conditional, it's a little like some RISC DSPs I've used in that regard.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82368 - Chris Holmes - Fri May 05, 2006 5:54 pm</h4>
    <div class="postbody"><span class="postbody">Well, gcc has definitely made some gains.  But in the end, gcc is almost always playing catch-up and will never be able to match intel's compiler.  The fact that Intel only has to really support one architecture whereas gcc supports a generic back-end is enough to guarantee that.
<br/>
<br/>
<a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank">http://en.wikipedia.org/wiki/ARM_architecture</a>
<br/>
<br/>
Fascinating.  Every opcode (more or less) can be made conditional.  That IS fascinating.  That's interesting.  I bet they have a pipeline just for handling those branch conditions.  Then they can just execute all the instructions and then either commit them or not depending on the branch condition.  That's a very interesting idea.  
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82375 - tepples - Fri May 05, 2006 8:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote">Fascinating.  Every opcode (more or less) can be made conditional.  That IS fascinating.  That's interesting.  I bet they have a pipeline just for handling those branch conditions.  Then they can just execute all the instructions and then either commit them or not depending on the branch condition.</td> </tr></table><span class="postbody">
<br/>
A non-taken instruction always uses one cycle, even if you have a 3-cycle ldr, 2-cycle str, 3-cycle branch, 2+n cycle ldm, 1+n cycle stm, or longer multiply.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82379 - Chris Holmes - Fri May 05, 2006 9:01 pm</h4>
    <div class="postbody"><span class="postbody">Where do you get that from?
<br/>
<br/>
At minimum, there's the cost of the conditional statement.  So a non-taken instruction costs 1 cycle beyond the cost of determining the conditional.  That just means that immediately after fetch, the condition is evaluated and the instruction is dropped from the pipeline if the condition is false.
<br/>
<br/>
And why does it feel like we're arguing about something simple?
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82382 - tepples - Fri May 05, 2006 9:16 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote">Where do you get that from?</td> </tr></table><span class="postbody">
<br/>
ARM7TDMI-S official manual.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">At minimum, there's the cost of the conditional statement.</td> </tr></table><span class="postbody">
<br/>
Which happens in parallel with the rest of the instruction.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">And why does it feel like we're arguing about something simple?</td> </tr></table><span class="postbody">
<br/>
Because unless everyone in a discussion has read the relevant ARM manual, it's hard for them to agree on a consistent set of terminology.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82399 - ecurtz - Sat May 06, 2006 12:11 am</h4>
    <div class="postbody"><span class="postbody">I'd really recommend the Furber book if you're going to be doing a lot of GBA or DS work (not that I have, relatively speaking.) It's a much better introduction than just leaping in with the technical references.
<br/>
<br/>
<a class="postlink" href="http://www.amazon.com/gp/product/0201675196/sr=8-1/qid=1146870440/ref=sr_1_1/103-7536284-2491854?%5Fencoding=UTF8" target="_blank">ARM System-on-Chip Architecture</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82407 - Chris Holmes - Sat May 06, 2006 1:20 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Which happens in parallel with the rest of the instruction.</td> </tr></table><span class="postbody">
<br/>
<br/>
Right.  
<br/>
<br/>
if( [some_random_memory_location_that's_not_cached] == 42 )
<br/>
 i++
<br/>
<br/>
Assuming that GCC turns that into a conditional i++, it's going to take a few cycles to load the memory location and compare it to 42.
<br/>
That result gets saved into a register and that register is used for the next conditional.
<br/>
<br/>
If the conditional is false, then it costs 1 cycle.  I haven't looked, but it's pretty safe to assume that the conditional value has to be stored in a register, which is exactly how they can check the condition in just one cycle.
<br/>
<br/>
Your statement is misleading.  After the conditional is computed, then yes, the next instruction will either execute or only incur a 1 cycle penalty.  That doesn't mean magic happens and you can suddenly execute a 30 cycle conditional expression in 1 cycle.
<br/>
<br/>
Yep, I'm right.  <a href="http://work.de/nocash/gbatek.htm" target="_blank">http://work.de/nocash/gbatek.htm</a>
<br/>
<br/>
The conditional evaluation looks at the flags register.  Therefore, the cost of any conditional opcode is either [conditional cost] + 1 (for not taken) or [conditional cost] + [opcode execution time].
<br/>
<br/>
Therefore, saying that an opcode not taken takes one cycle is extremely misleading.  Sure, it can take 1 cycle if the flags register is already set, but if you have to set it (aka, the condition), then it still requires time to compute the condition to set the flags register.
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82414 - wintermute - Sat May 06, 2006 2:14 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Which happens in parallel with the rest of the instruction.</td> </tr></table><span class="postbody">
<br/>
<br/>
Right.  
<br/>
<br/>
if( [some_random_memory_location_that's_not_cached] == 42 )
<br/>
 i++
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
That's not an instruction. That's a large piece of C.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
int i;
<br/>
<br/>
if ( *( u8 *)42 == 42) i++;
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
compiles to :-
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   mov   r3, #0
<br/>
   ldrb   r2, [r3, #42]   @ zero_extendqisi2
<br/>
   ldr   r1, .L5
<br/>
   cmp   r2, #42
<br/>
   ldreq   r3, [r1, #0]
<br/>
   addeq   r3, r3, #1
<br/>
   streq   r3, [r1, #0]
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
the last three instructions take 1 cycle each when the condition is false.
<br/>
<br/>
Not too shabby really.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Assuming that GCC turns that into a conditional i++, it's going to take a few cycles to load the memory location and compare it to 42.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
load the memory location and compare to 42 are several instructions separate from the increment.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Therefore, saying that an opcode not taken takes one cycle is extremely misleading.  Sure, it can take 1 cycle if the flags register is already set, but if you have to set it (aka, the condition), then it still requires time to compute the condition to set the flags register.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Only if you decide that ARM can somehow shoehorn several C statements into one instruction.
<br/>
<br/>
Saying that an opcode not taken takes one cycle is extremely accurate. There's no other way to interpret it, it does what it says on the tin. Saying that the set conditional happens in parallel is perhaps a bit misleading - it depends what's being tested which is perhaps where you were going when you got a bit sidetracked.
<br/>
<br/>
In any case, if you want to worry about cycle timings at this sort of level perhaps you'd be better off writing assembly directly.
<br/>
<br/>
For many, many tips on gcc optimisation methods look around the forums for posts by Cearn.
<br/>
<br/>
Here's one to start you off
<br/>
<br/>
<a href="http://forum.gbadev.org/viewtopic.php?p=43025&amp;highlight=#43025" target="_blank">http://forum.gbadev.org/viewtopic.php?p=43025&amp;highlight=#43025</a><br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82424 - Chris Holmes - Sat May 06, 2006 4:06 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">the last three instructions take 1 cycle each when the condition is false. 
<br/>
<br/>
Not too shabby really.</td> </tr></table><span class="postbody">
<br/>
<br/>
Like I said, it's a fascinating hardware optimization.  It's just proof that CISC isn't quite dead yet.  
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Saying that an opcode not taken takes one cycle is extremely accurate</td> </tr></table><span class="postbody">
<br/>
<br/>
I agree, but he said instruction, not opcode.  I was just taking issue with his wording.  I would certainly consider if( [location] == 42) to be a single instruction, but that breaks down into multiple opcodes, which is exactly what my point was.
<br/>
<br/>
  Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82430 - Mighty Max - Sat May 06, 2006 7:35 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Chris Holmes wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The conditional evaluation looks at the flags register.  Therefore, the cost of any conditional opcode is either [conditional cost] + 1 (for not taken) or [conditional cost] + [opcode execution time].
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Nope.
<br/>
<br/>
The conditional check is done parallel to preparing the path in the ALU. The condition check uses only a few fast gates, if the condition code was not meet  at the time the alu is prepared for the operation, operation aborts with no extra costs.
<br/>
<br/>
The cost is therefor either
<br/>
1
<br/>
or 
<br/>
[opcode execution time]
<br/>
<br/>
And yes this is totally parallel, as conditional statement is part of the statement and no additional prefix.<br/>_________________<br/><a class="postlink" href="http://mightymax.org/gbamp_multiboot.html" target="_blank">GBAMP Multiboot</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#82453 - wintermute - Sat May 06, 2006 3:06 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
 I would certainly consider if( [location] == 42) to be a single instruction, but that breaks down into multiple opcodes, which is exactly what my point was.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
It's a C statement, not an instruction. It's also not a conditional check it's a comparison.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
