<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>gluPickMatrix - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > gluPickMatrix</h2>
<div id="posts">
<div class="post">
    <h4>#150493 - iprice - Tue Feb 05, 2008 9:00 pm</h4>
    <div class="postbody"><span class="postbody">When I use gluPickMatrix it makes the screen flicker.... I am rendering some MD2 files, then drawing the screen under the cursor and using gluPickMatrix as in the example on ndslibs.... but the quick draw to screen is messy, can I draw off screen for the touch recognition?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150521 - Cydrak - Wed Feb 06, 2008 2:38 am</h4>
    <div class="postbody"><span class="postbody">From nds/Graphics/3D/Misc/Picking/:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">glViewport(...);
<br/>
... matrix setup ...
<br/>
... draw scene ...
<br/>
<br/>
// set the viewport to just off-screen,
<br/>
// this hides all rendering that will be done during picking
<br/>
<span style="font-weight: bold">glViewport(0,192,0,192);</span>
<br/>
<br/>
// setup the projection matrix for picking
<br/>
// -- render only what is below the cursor
<br/>
glMatrixMode(GL_PROJECTION);
<br/>
glLoadIdentity();
<br/>
gluPickMatrix((touchXY.px),(191-touchXY.py),4,4,viewport);
<br/>
gluPerspective(... original settings ...);
<br/>
glMatrixMode(GL_MODELVIEW);
<br/>
<br/>
... draw pickable objs ...
<br/>
... watch poly count/pos test etc ...
<br/>
<br/>
glFlush(0);
<br/>
</td> </tr></table><span class="postbody">
<br/>
Is that the one you mean? I think it's exactly what they do. Picking as normal, but their viewport is crammed into a single pixel above the first scanline, so it's never drawn.
<br/>
<br/>
Note that they do the picking in the same frame as the drawing; glViewport is a command just like the projections, not a global register. So an extra glFlush() is not required.
<br/>
<br/>
(I wish I could say I'd have thought of that picking method, it's really rather clever...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150549 - iprice - Wed Feb 06, 2008 6:31 pm</h4>
    <div class="postbody"><span class="postbody">Yeah I've got that bit, but I draw some MD2 files, and some manual polys...when I am checking for the touch on the MD2s it displays the zoomed in area for polys over the top, sretched over the whole screen for just a flash.....</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#150557 - ritz - Wed Feb 06, 2008 11:26 pm</h4>
    <div class="postbody"><span class="postbody">I had the same issue. You need to hide everything as much as possible. Here's the code that I call (if I'm in pick mode) right after I draw everything and just before I call glFlush(1).
<br/>
<br/>
However, all you really need to do is use BIT(14) | POLY_ALPHA(1) to keep things almost completely hidden and don't use that viewport call (it adds to the flicker). The other stuff I have is kinda just fluff and other things.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
object_t*
<br/>
v_picknose (int ntpkos, object_t **tpkos, int *pxy)
<br/>
{
<br/>
   model_t *psom;
<br/>
   object_t *pso, *cwo;
<br/>
   int vport[4] = {0,0,255,191};
<br/>
   int i, cw, plyram;
<br/>
<br/>
   cw  = 0x7FFFFFFF;
<br/>
   cwo = NULL;
<br/>
<br/>
   glMatrixMode(GL_PROJECTION);
<br/>
   glPushMatrix();
<br/>
   glLoadIdentity();
<br/>
   gluPickMatrix(pxy[0], 191-pxy[1], V_PICKBIAS, V_PICKBIAS, vport);
<br/>
   gluPerspectivef32(V_PFOV, V_PASPECT, V_PZNEAR, V_PZFAR);
<br/>
   glMatrixMode(GL_MODELVIEW);
<br/>
   glPushMatrix();
<br/>
<br/>
   GFX_POLY_FORMAT = POLY_CULL_BACK | BIT(12) | BIT(13) | BIT(14) | V_POLY_ALPHA(1) | POLY_FOG;
<br/>
   GFX_TEX_FORMAT = 0; GFX_COLOR = 0;
<br/>
<br/>
   for (i = 0; i &lt; ntpkos; i++)
<br/>
   {
<br/>
      MATRIX_RESTORE = 28;
<br/>
<br/>
      pso = tpkos[i];
<br/>
      glTranslate3f32(pso-&gt;pos[0], pso-&gt;pos[1], pso-&gt;pos[2]);
<br/>
      glRotateZi(pso-&gt;rot[2]); glRotateYi(pso-&gt;rot[1]); glRotateXi(pso-&gt;rot[0]);
<br/>
<br/>
      psom = pso-&gt;model;
<br/>
      GFX_BOX_TEST = VERTEX_PACK(psom-&gt;bbox[0],psom-&gt;bbox[1]);
<br/>
      GFX_BOX_TEST = VERTEX_PACK(psom-&gt;bbox[2],psom-&gt;bbox[3]);
<br/>
      GFX_BOX_TEST = VERTEX_PACK(psom-&gt;bbox[4],psom-&gt;bbox[5]);
<br/>
<br/>
      while (GFX_TEST_BUSY) ;
<br/>
      if (!GFX_BOX_RESULT)
<br/>
         continue;
<br/>
<br/>
      while (GFX_BUSY) ; // ||GFX_TEST_BUSY
<br/>
      plyram = GFX_POLYGON_RAM_USAGE;
<br/>
<br/>
      GFX_POS_TEST = (psom-&gt;center[0] &amp; 0xFFFF) | (psom-&gt;center[1] &lt;&lt; 16);
<br/>
      GFX_POS_TEST = (psom-&gt;center[2] &amp; 0xFFFF);
<br/>
<br/>
      v_pdrawmod(psom);
<br/>
      while (GFX_BUSY) ; // ||GFX_TEST_BUSY
<br/>
<br/>
      if (GFX_POLYGON_RAM_USAGE &gt; plyram &amp;&amp; GFX_POS_RESULT[3] &lt; cw)
<br/>
         { cw = GFX_POS_RESULT[3]; cwo = pso; }
<br/>
   }
<br/>
<br/>
   glMatrixMode(GL_PROJECTION);
<br/>
   glPopMatrix(1);
<br/>
   glMatrixMode(GL_MODELVIEW);
<br/>
   glPopMatrix(1);
<br/>
<br/>
   return cwo;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
