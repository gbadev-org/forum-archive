<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Display copy corruption - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > Display copy corruption</h2>
<div id="posts">
<div class="post">
    <h4>#63049 - Lazy1 - Thu Dec 08, 2005 4:10 am</h4>
    <div class="postbody"><span class="postbody">[Edit]
<br/>
Resolved stupid bug thx to natrium.
<br/>
Still gotta fix the problem with darkness though :)
<br/>
[/Edit]
<br/>
<br/>
I'm currently porting wolfenstein 3d to the DS, but unfortunately I have this screen on emulators aswell as hardware...
<br/>
<a href="http://img50.imageshack.us/img50/4273/displaybug8sc.jpg">[Images not permitted - Click here to view it]</a>
<br/>
<br/>
Is there anything horribly wrong with my drawing code?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;nds.h&gt;
<br/>
#include &lt;nds/arm9/console.h&gt;
<br/>
#include &lt;nds/bios.h&gt;
<br/>
<br/>
#ifdef ROMDISKFS
<br/>
#define stat_t unused_t
<br/>
#include &lt;kos/fs.h&gt;
<br/>
#include &lt;kos/fs_romdisk.h&gt;
<br/>
#endif
<br/>
<br/>
#undef stat_t
<br/>
#include &lt;stdarg.h&gt;
<br/>
#include "wl_def.h"
<br/>
<br/>
/* Preprocessor definitions/macros */
<br/>
#define NDS_PIXBUF_WIDTH 320
<br/>
#define NDS_PIXBUF_HEIGHT 200
<br/>
#define NDS_BG_WIDTH 512
<br/>
#define NDS_BG_HEIGHT 256
<br/>
<br/>
/* RGB555TO888:
<br/>
 * This macro converts RGB555 into RGB888
<br/>
 *
<br/>
 * colour15:   Unsigned 16 bit integer containing the RGB555 colour
<br/>
 * r:      Unsigned 32 bit integer which receives the red value
<br/>
 * g:      Unsigned 32 bit integer which receives the green value
<br/>
 * b:      Unsigned 32 bit integer which receives the blue value
<br/>
*/
<br/>
#define RGB555TO888( colour15, r, g, b ) \
<br/>
   r = colour15 &amp; ~0xFFE0; \
<br/>
   g = ( colour15 &gt;&gt; 5 ) &amp; ~0xFFE0; \
<br/>
   b = ( colour15 &gt;&gt; 10 ) &amp; ~0xFFE0;
<br/>
<br/>
/* Function prototypes */
<br/>
int nds_screen1_init( void );
<br/>
int nds_screen2_init( void );
<br/>
int nds_system_init( void );
<br/>
void nds_sys_handle_interrupts( void );
<br/>
void nds_sys_onexit( void );
<br/>
void quadmemset( u32* pMemory, u32 iSetvalue, u32 iSize );
<br/>
void quadcopy( u32* pSource, u32* pDest, u32 iSize );
<br/>
int main( void );
<br/>
<br/>
/* Global variables */
<br/>
#ifdef ROMDISKFS
<br/>
extern char wolf3dromdisk[ ];
<br/>
byte* wolf3d = ( byte* ) wolf3dromdisk;   /* Pointer to embedded wolf3d shareware romdisk */
<br/>
#endif
<br/>
<br/>
byte* gfxbuf = NULL;   /* Pointer to the pixel buffer wolf3d writes video data to */
<br/>
<br/>
/* nds_sys_onexit:
<br/>
 * Called if the program either returns or calls exit().
<br/>
 * Since we have nothing to return to, an infinite loop should
<br/>
 * do nicely.
<br/>
*/
<br/>
void nds_sys_onexit( void ) {
<br/>
   printf( "FATAL: Application exiting!\n" );
<br/>
   printf( "Hanging here.\n" );
<br/>
<br/>
   while ( 1 ) swiWaitForVBlank( );
<br/>
}
<br/>
<br/>
/* quadcopy:
<br/>
 * Copies memory 4 bytes at a time.
<br/>
 *
<br/>
 * pSource   : Source memory pointer
<br/>
 * pDest   : Destination memory pointer
<br/>
 * iSize   : Number of bytes to copy ( must by a multiple of 4 )
<br/>
*/
<br/>
void quadcopy( u32* pSource, u32* pDest, u32 iSize ) {
<br/>
   while ( iSize-- ) {
<br/>
      *pDest = *pSource;
<br/>
<br/>
      pDest++;
<br/>
      pSource++;
<br/>
   }
<br/>
}
<br/>
<br/>
/* quadmemset:
<br/>
 * Sets an area of memory 4 bytes at a time.
<br/>
 *
<br/>
 * pMemory   : Pointer to memory which will be set
<br/>
 * iSetvalue   : Value to set memory to
<br/>
 * iSize   : Size of memory ( must be a multiple of 4 )
<br/>
*/
<br/>
void quadmemset( u32* pMemory, u32 iSetvalue, u32 iSize ) {
<br/>
   while ( iSize-- ) {
<br/>
      *pMemory = iSetvalue;
<br/>
      pMemory++;
<br/>
   }
<br/>
}
<br/>
<br/>
/* nds_screen1_init:
<br/>
 * Initializes the main ( top ) screen on the Nintendo DS.
<br/>
 *
<br/>
 * Returns: Always 1
<br/>
*/
<br/>
int nds_screen1_init( void ) {
<br/>
   /* Set mode 5 extended rotation background */
<br/>
   videoSetMode( MODE_5_2D | DISPLAY_BG2_ACTIVE );
<br/>
   vramSetBankA( VRAM_A_MAIN_BG_0x6000000 );
<br/>
<br/>
   /* Set background scaling, ect... */
<br/>
   BG2_CR = BG_BMP8_512x256 | BG_BMP_BASE( 0 );
<br/>
   BG2_XDX = ( ( NDS_PIXBUF_WIDTH / 256 ) &lt;&lt; 8 ) | ( NDS_PIXBUF_WIDTH % 256 );
<br/>
   BG2_YDY = ( ( NDS_PIXBUF_HEIGHT / 192 ) &lt;&lt; 8 ) | ( ( NDS_PIXBUF_HEIGHT % 192 ) + ( NDS_PIXBUF_HEIGHT % 192 ) / 3 );
<br/>
   BG2_XDY = 0;
<br/>
   BG2_YDX = 0;
<br/>
   BG2_CX = 0;
<br/>
   BG2_CY = 0;
<br/>
<br/>
   /* Start off by clearing out the background memory */
<br/>
   quadmemset( ( u32* ) BG_GFX, 0, ( NDS_BG_WIDTH * NDS_BG_HEIGHT ) );
<br/>
<br/>
   return 1;
<br/>
}
<br/>
<br/>
/* nds_screen2_init:
<br/>
 * Initializes the sub ( bottom/touch ) screen on the Nintendo DS.
<br/>
 *
<br/>
 * Returns: Always 1
<br/>
*/
<br/>
int nds_screen2_init( void ) {
<br/>
   /* Set mode 0 for a text background */
<br/>
   videoSetModeSub( MODE_0_2D | DISPLAY_BG0_ACTIVE );
<br/>
   vramSetBankC( VRAM_C_SUB_BG );
<br/>
<br/>
   /* Setup text colour, ect... */
<br/>
   BG_PALETTE_SUB[ 255 ] = RGB15( 31, 31, 31 );   
<br/>
   SUB_BG0_CR = BG_MAP_BASE( 31 );
<br/>
<br/>
   /* Initialize the console with the default font */
<br/>
   consoleInitDefault( ( u16* ) SCREEN_BASE_BLOCK_SUB( 31 ), ( u16* ) CHAR_BASE_BLOCK_SUB( 0 ), 16 );
<br/>
<br/>
   return 1;
<br/>
}
<br/>
<br/>
/* nds_system_init:
<br/>
 * Initializes the Nintendo DS and things like IRQs, ect...
<br/>
 *
<br/>
 * Returns: Always 1
<br/>
*/
<br/>
int nds_system_init( void ) {
<br/>
   powerON( POWER_ALL_2D | POWER_SWAP_LCDS );   /* Enable both 2D cores and swap the lcds around */
<br/>
   keysInit( );               /* Setup key usage */
<br/>
<br/>
   /* Setup the interrupt registers */
<br/>
   REG_IME = 0;
<br/>
   REG_IE = IRQ_VBLANK;
<br/>
   REG_IF = ~0;
<br/>
   IRQ_HANDLER = &amp;nds_sys_handle_interrupts;
<br/>
   REG_IME = 1;
<br/>
<br/>
   DISP_SR = DISP_VBLANK_IRQ;         /* Additional step for vblank */
<br/>
<br/>
   /* Make sure we don't exit into nothingness */
<br/>
   atexit( nds_sys_onexit );
<br/>
<br/>
#ifdef ROMDISKFS
<br/>
   fs_init( );
<br/>
   fs_romdisk_mount( "/", ( const uint8* ) wolf3d, 0 );
<br/>
#endif
<br/>
<br/>
   return 1;
<br/>
}
<br/>
<br/>
/* nds_sys_handle_interrupts:
<br/>
 * Interrupt handler for the nintendo DS.
<br/>
*/
<br/>
void nds_sys_handle_interrupts( void ) {
<br/>
   /* Handle VBlank IRQ */
<br/>
   if ( REG_IF &amp; IRQ_VBLANK ) {
<br/>
      /* Get the current = 4keystate each vblank */
<br/>
      scanKeys( );
<br/>
   
<br/>
      /* VBlank IRQ handled */
<br/>
      VBLANK_INTR_WAIT_FLAGS |= IRQ_VBLANK;
<br/>
      REG_IF |= IRQ_VBLANK;
<br/>
   }
<br/>
}
<br/>
<br/>
/* main:
<br/>
 * ARM9 binary entrypoint.
<br/>
 *
<br/>
 * Returns: Should never return
<br/>
*/
<br/>
int main( void ) {
<br/>
   /* Initialize the system and both screens here */
<br/>
   nds_screen1_init( );
<br/>
   nds_screen2_init( );   
<br/>
   nds_system_init( );
<br/>
<br/>
   /* Print welcome screen */
<br/>
   printf( "Wolfenstein3D SDL port to\n" );
<br/>
   printf( "the Nintendo DS.\n" );
<br/>
   printf( "2005 - Lazy\n" );
<br/>
<br/>
   /* Enter the main application loop */
<br/>
   WolfMain( 1, NULL );
<br/>
<br/>
   /* If we got here something bad happened that caused
<br/>
    * WolfMain to return.
<br/>
    * Since there is no OS to return to we must halt the
<br/>
    * system here by entering an infinite loop.
<br/>
   */
<br/>
   printf( "FATAL: Broke out of WolfMain!\n" );
<br/>
   printf( "Hanging here.\n" );
<br/>
   while ( 1 ) swiWaitForVBlank( );
<br/>
<br/>
   return 1;
<br/>
}
<br/>
<br/>
/* VL_WaitVBL:
<br/>
 * Waits nVblanks, then returns.
<br/>
*/
<br/>
void VL_WaitVBL( int nVblanks ) {
<br/>
   while ( nVblanks-- ) swiWaitForVBlank( );
<br/>
}
<br/>
<br/>
/* VW_UpdateScreen:
<br/>
 * Copies the contents of the pixel buffer to the screen.
<br/>
*/
<br/>
void VW_UpdateScreen( void ) {
<br/>
   u32* pSource = ( u32* ) gfxbuf;
<br/>
   u32* pDest = ( u32* ) BG_GFX;
<br/>
   u32 iRow = 0;
<br/>
<br/>
   /* While we have more rows to draw... */
<br/>
   while ( iRow &lt; NDS_PIXBUF_HEIGHT ) {
<br/>
      /* Copy the pixel data from the pixel buffer into the main background */
<br/>
      //quadcopy( pSource, pDest, NDS_PIXBUF_WIDTH / 4 );
<br/>
      //memcpy( pSource, pDest, NDS_PIXBUF_WIDTH );
<br/>
      swiFastCopy( pSource, pDest, ( ( COPY_MODE_WORD | COPY_MODE_COPY ) &lt;&lt; 24 ) + ( NDS_PIXBUF_WIDTH &gt;&gt; 2 ) );
<br/>
<br/>
      /* Point to the next row */
<br/>
      pSource+= NDS_PIXBUF_WIDTH;
<br/>
      pDest+= NDS_BG_WIDTH;
<br/>
      iRow++;
<br/>
   }
<br/>
}
<br/>
<br/>
/* VL_Startup:
<br/>
 * Initializes the video subsystem.
<br/>
*/
<br/>
void VL_Startup( void ) {
<br/>
   /* Allocates a 320x200 pixel buffer for wolf3d to write to,
<br/>
    * if it fails a warning is printed and the system halted.
<br/>
   */
<br/>
   if ( ( gfxbuf = ( byte* ) malloc( NDS_PIXBUF_WIDTH * NDS_PIXBUF_HEIGHT ) ) == NULL ) {
<br/>
      printf( "VL_Startup: Failed to allocate pixel buffer\n" );
<br/>
      printf( "Hanging here.\n" );
<br/>
<br/>
      while ( 1 ) swiWaitForVBlank( );
<br/>
   }
<br/>
<br/>
   /* AHA! I forgot to set these! */
<br/>
   vwidth = 320;
<br/>
   vheight = 200;
<br/>
}
<br/>
<br/>
/* VL_Shutdown:
<br/>
 * Shuts down the video subsystem.
<br/>
*/
<br/>
void VL_Shutdown( void ) {
<br/>
   /* If the pixel buffer was allocated, free it now */
<br/>
   if ( gfxbuf )
<br/>
      free( gfxbuf );
<br/>
}
<br/>
<br/>
/* VL_SetPalette:
<br/>
 * Sets an updated palette.
<br/>
 *
<br/>
 * pPalette   : Pointer to the 8 bit RGB palette
<br/>
*/
<br/>
void VL_SetPalette( const byte* pPalette ) {
<br/>
   u32 i = 0;
<br/>
   u32 r = 0;
<br/>
   u32 g = 0;
<br/>
   u32 b = 0;
<br/>
<br/>
   /* Wait until vblank before modifying the palette */
<br/>
   swiWaitForVBlank( );
<br/>
<br/>
   /* For every palette entry... */
<br/>
   for ( ; i &lt; 256; i++, pPalette+= 3 ) {
<br/>
      /* Shift each colour 3 bits to the right.
<br/>
       * This divides them by 8 so they'll fit in
<br/>
       * RGB555 format.
<br/>
      */
<br/>
      r = ( ( pPalette[ 0 ] + 4 &lt; 256 ) ? pPalette[ 0 ] + 4 : 256 ) &gt;&gt; 3;
<br/>
      g = ( ( pPalette[ 1 ] + 4 &lt; 256 ) ? pPalette[ 1 ] + 4 : 256 ) &gt;&gt; 3;
<br/>
      b = ( ( pPalette[ 2 ] + 4 &lt; 256 ) ? pPalette[ 2 ] + 4 : 256 ) &gt;&gt; 3;
<br/>
<br/>
      r = r + ( r ^ 1 );
<br/>
      g = g + ( g ^ 1 );
<br/>
      b = b + ( b ^ 1 );
<br/>
<br/>
      /* Clamp colour values */
<br/>
      if ( r &gt; 31 ) r = 31;
<br/>
      if ( g &gt; 31 ) g = 31;
<br/>
      if ( b &gt; 31 ) b = 31;
<br/>
<br/>
      /* Set the palette entry */
<br/>
      BG_PALETTE[ i ] = RGB15( r, g, b ) | ( 1 &lt;&lt; 15 );
<br/>
   }
<br/>
}
<br/>
<br/>
/* VL_GetPalette:
<br/>
 * Copies the current palette into pPalette.
<br/>
 *
<br/>
 * pPalette:   Pointer to receive RGB888 colour data
<br/>
*/
<br/>
void VL_GetPalette( byte* pPalette ) {
<br/>
   u32 i = 0;
<br/>
   u32 r = 0;
<br/>
   u32 g = 0;
<br/>
   u32 b = 0;
<br/>
<br/>
   /* For each palette entry... */
<br/>
   for ( ; i &lt; 256; i++, pPalette+= 3 ) {
<br/>
      /* Use a macro to convert from RGB555 to RGB888 */
<br/>
      RGB555TO888( BG_PALETTE[ i ], r, g, b );
<br/>
<br/>
      /* Clamp colour values */
<br/>
      if ( r &gt; 255 ) r = 255;
<br/>
      if ( g &gt; 255 ) g = 255;
<br/>
      if ( b &gt; 255 ) b = 255;
<br/>
<br/>
      /* Set palette */
<br/>
      pPalette[ 0 ] = r;
<br/>
      pPalette[ 1 ] = g;
<br/>
      pPalette[ 2 ] = b;
<br/>
   }
<br/>
}
<br/>
<br/>
/* INL_Update:
<br/>
 * TODO:
<br/>
 * What is this supposed to do?
<br/>
 * My guess: Updates input?
<br/>
*/
<br/>
void INL_Update( void ) {
<br/>
}
<br/>
<br/>
/* IN_GetMouseDelta:
<br/>
 * TODO:
<br/>
 * What is this supposed to do?
<br/>
 * My guess: Get the relative position from the last mouse move?
<br/>
*/
<br/>
void IN_GetMouseDelta( int* pX, int* pY ) {
<br/>
   if ( pX ) *pX = 0;
<br/>
   if ( pY ) *pY = 0;
<br/>
}
<br/>
<br/>
/* IN_MouseButtons:
<br/>
 * Returns a bitmask of the mouse button state?
<br/>
 *
<br/>
 * Returns: For NDS - always 0
<br/>
*/
<br/>
byte IN_MouseButtons( void ) {
<br/>
   return 0;
<br/>
}
<br/>
<br/>
/* Quit:
<br/>
 * Supposed to quit with an error message but instead
<br/>
 * this one prints the error then loops forever.
<br/>
 *
<br/>
 * pszError:   Error string
<br/>
*/
<br/>
void Quit( char* pszError ) {
<br/>
#ifdef ROMDISKFS
<br/>
   fs_romdisk_unmount( "/" );
<br/>
#endif
<br/>
<br/>
   printf( "Error: %s\n", pszError );
<br/>
   printf( "Hanging here.\n" );
<br/>
<br/>
   while ( 1 ) swiWaitForVBlank( );
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Note: It gets much further than that on hardware, plays the demo for a while but crashes a few seconds into it.
<br/>
On the bright side its more than fullspeed :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
