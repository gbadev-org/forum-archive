<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Painfully Loading MD2 Models - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS development > Painfully Loading MD2 Models</h2>
<div id="posts">
<div class="post">
    <h4>#86250 - dak - Mon Jun 05, 2006 10:00 pm</h4>
    <div class="postbody"><span class="postbody">bah, I hate asking for help but I'm kind of stumped here.  I'm aware that there are MD2 loaders availible to use, but I'm the kind of jackass that needs to create things to get a grip on whats going on.  With the assistance of some OGL literature, I created what seemed to be a pretty straight forward loader while making appropriate changes to fit the handheld.  I used the console to output the general numTri info etc. to make sure things aren't going nuts (everything seems to be in order), but the only thing weird is that the model when displayed on screen looks like a jagged cube.
<br/>
<br/>
   This is my first time working with Nintendo handheld tech as well as with loading a model (tho I do have a good amount of OGL experience).  First thing I tried was playing around with casting things between floats, f32, and v16 (particularly when setting the point lists).  Then I made my draw function render only 5 polygons.  It seems that the polys rendered are just staying in one place, bunching up like pantyhose.  Now I love nothing more than bunched up pantyhose, but this is driving me insane.
<br/>
<br/>
   Well, heres the code; I'll be refreshing like a madman all day to see if anyone can help me out.  btw, perhaps this has something to do with it:  I am awaiting my flash/pass equiptment to come in and am debugging on the latest version of Dualis.
<br/>
<br/>
:D thanks in advanced to those who help and at the least stop by...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// Map Game Cartridge memory to ARM9
<br/>
   WAIT_CR &amp;= ~0x80;
<br/>
   
<br/>
   GBFS_FILE const * filePtr; //FILE *filePtr;
<br/>
   unsigned int fileLen = 0;
<br/>
   uint8* buffer;
<br/>
   
<br/>
   modelData_t *model;
<br/>
   modelHeader_t *modHeader;
<br/>
   texture_t *md2Tex;
<br/>
   
<br/>
   stIdx_t *stPtr;
<br/>
   frame_t *frm;
<br/>
   vector_t *pointListPtr;
<br/>
   mesh_t *triIndex, *bufIndexPtr;
<br/>
   int i, j;
<br/>
   
<br/>
   //Open the model file
<br/>
   filePtr = find_first_gbfs_file((void*)0x08000000);
<br/>
   
<br/>
    buffer = (uint8*)gbfs_get_obj(filePtr, filename, &amp;fileLen);
<br/>
   
<br/>
   //Extract model file header
<br/>
   modHeader = (modelHeader_t*)buffer;
<br/>
   
<br/>
   //Allocate memory for model data
<br/>
   model = (modelData_t*)malloc(sizeof(modelData_t));
<br/>
   
<br/>
   //Allocate memory for all vertices used in model, inc animations
<br/>
   model-&gt;pointList = (vector_t*)malloc(sizeof(vector_t)*modHeader-&gt;numXYZ*modHeader-&gt;numFrames);
<br/>
   
<br/>
   //Store "vital" model data
<br/>
   model-&gt;numPoints = modHeader-&gt;numXYZ;
<br/>
   model-&gt;numFrames = modHeader-&gt;numFrames;
<br/>
   model-&gt;frameSize = modHeader-&gt;frameSize;
<br/>
   
<br/>
   //loop thru number of frames in model file
<br/>
   for (j=0; j&lt;modHeader-&gt;numFrames; j++) {
<br/>
      //offset to the points in this frame
<br/>
      frm = (frame_t*)&amp;buffer[modHeader-&gt;offsetFrames + modHeader-&gt;frameSize * j];
<br/>
      
<br/>
      //calculate the point positions based on frame details
<br/>
      pointListPtr = (vector_t*)&amp;model-&gt;pointList[modHeader-&gt;numXYZ * j];
<br/>
      for (i=0; i&lt;modHeader-&gt;numXYZ; i++) {
<br/>
      pointListPtr[i].point[0] = floattov16(frm-&gt;scale[0] * frm-&gt;fp[i].v[0] + frm-&gt;translate[0]);
<br/>
      pointListPtr[i].point[1] = floattov16(frm-&gt;scale[1] * frm-&gt;fp[i].v[1] + frm-&gt;translate[1]);
<br/>
      pointListPtr[i].point[2] = floattov16(frm-&gt;scale[2] * frm-&gt;fp[i].v[2] + frm-&gt;translate[2]);
<br/>
      
<br/>
      //   pointListPtr[i].point[0] = floattov16((mulf32(floattof32(frm-&gt;scale[0]), inttof32(frm-&gt;fp[i].v[0])) + floattof32(frm-&gt;translate[0]))&gt;&gt;3);
<br/>
      //   pointListPtr[i].point[1] = floattov16((mulf32(inttof32(-1),(mulf32(floattof32(frm-&gt;scale[1]), inttof32(frm-&gt;fp[i].v[1])) + floattof32(frm-&gt;translate[1]))))&gt;&gt;3);
<br/>
      //   pointListPtr[i].point[2] = floattov16((mulf32(floattof32(frm-&gt;scale[2]), inttof32(frm-&gt;fp[i].v[2])) + floattof32(frm-&gt;translate[2]))&gt;&gt;3);
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   //load the model texture
<br/>
   //md2Tex = 
<br/>
   // ---------------------
<br/>
   
<br/>
   //Allocate the list of tri indices
<br/>
   triIndex = (mesh_t*)malloc(sizeof(mesh_t) * modHeader-&gt;numTris);
<br/>
   
<br/>
   //Set total number of tri
<br/>
   model-&gt;numTri = modHeader-&gt;numTris;
<br/>
   model-&gt;triIdx = triIndex;
<br/>
   
<br/>
   //point to tri indices in buffer
<br/>
   bufIndexPtr = (mesh_t*)&amp;buffer[modHeader-&gt;offsetTris];
<br/>
   
<br/>
   //for all tri in each frame
<br/>
   for (i=0; i&lt;modHeader-&gt;numTris; i++) {   // [opt] memcopy
<br/>
      //Store mesh and texture indices
<br/>
      triIndex[i].meshIdx[0] = bufIndexPtr[i].meshIdx[0];
<br/>
      triIndex[i].meshIdx[1] = bufIndexPtr[i].meshIdx[1];
<br/>
      triIndex[i].meshIdx[2] = bufIndexPtr[i].meshIdx[2];
<br/>
      //Then TEX shit
<br/>
      //Then TEX shit
<br/>
      //Then TEX shit
<br/>
   }
<br/>
   
<br/>
   //initialize animation variables
<br/>
   model-&gt;curFrame = 0;
<br/>
   model-&gt;nextFrame = 1;
<br/>
   model-&gt;interpol = 0.0;
<br/>
   
<br/>
   return model;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
-dak[/i]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86326 - dak - Tue Jun 06, 2006 11:06 am</h4>
    <div class="postbody"><span class="postbody">So I rewrote all of it ... different approach (probably better now XD), same problem.  Boxxy looking 3D thinggy : /
<br/>
<br/>
I took my MD2 code and slapped it onto an old OGL project I had on my desktop and attempted to load the exact same file.  Success!!  Apparently the code itself is totally fine, I seem to be missing some detail on either the NDS system or my implementation simply will not work on Dualis.
<br/>
<br/>
If anything, perhaps it has something to do with the whacky v16 type.  Can anyone tell me if there are any tricks to be "aware" of when handling that type, and also, is casting something like the following even realistic with this type?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
v[0] = floattov16((pframe-&gt;scale[0] * pvert-&gt;v[0]) + pframe-&gt;translate[0]);
<br/>
v[1] = floattov16((pframe-&gt;scale[1] * pvert-&gt;v[1]) + pframe-&gt;translate[1]);
<br/>
v[2] = floattov16((pframe-&gt;scale[2] * pvert-&gt;v[2]) + pframe-&gt;translate[2]);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
v -&gt; v16[3]
<br/>
scale and translate -&gt; float[3]
<br/>
pvert-&gt;v  -&gt; unsigned char[3]
<br/>
<br/>
thanks,
<br/>
dak</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86328 - dak - Tue Jun 06, 2006 11:35 am</h4>
    <div class="postbody"><span class="postbody">I figured it out...  
<br/>
:D I have been talking to myself, but its been therapeutic!!
<br/>
<br/>
-dak</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86329 - acox - Tue Jun 06, 2006 11:44 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>dak wrote:</b></span></td> </tr> <tr> <td class="quote">I figured it out...  
<br/>
:D I have been talking to myself, but its been therapeutic!!
<br/>
<br/>
-dak</td> </tr></table><span class="postbody">
<br/>
<br/>
And the answer was?
<br/>
(for the benefit of future searchers)<br/>_________________<br/><a class="postlink" href="http://www.btinternet.com/~ahcox/GBA/" target="_blank">3D on GBA</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86341 - dak - Tue Jun 06, 2006 2:49 pm</h4>
    <div class="postbody"><span class="postbody">I'm new to this whole DS dev mumbo jumbo, so forgive my n00b sauce in advance...
<br/>
<br/>
I was wracking my brain over what was causing my model to be so funky looking.  I tried rewriting the code and even got it working on another platform which meant something sneaky was happening on the DS.  The problem seemed to have been an issue with getting the MD2's floats and turning them into v16 used by the libnds.  Normally, when decompressing a vertex you'd simply do
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
v[0] = pframe-&gt;scale[0] * pvert-&gt;v[0] + pframe-&gt;translate[0];
<br/>
v[1] = pframe-&gt;scale[1] * pvert-&gt;v[1] + pframe-&gt;translate[1];
<br/>
v[2] = pframe-&gt;scale[2] * pvert-&gt;v[2] + pframe-&gt;translate[2];
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Pretty standard stuff, I suppose, but this yeilds a float which works quite nicely with the PC's glVertex3fv( ... ).  Unfortunately (fortunately?) we have glVertex3v16 to work with, so we need to cast things.  I also decided to go with mulf32( ... , ... ) as I figured it may be more efficient (whatev).  It still did not quite work, so I dug deeper into the forums and stumbled onto Webez's code.  There was the answer; After casting each number into f32 and then decompressing, just before converting to a v16 type, you have to shift 3 ( &gt;&gt; 3 ).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
v[0] = (mulf32(floattof32(pframe-&gt;scale[0]), inttof32(pvert-&gt;v[0])) + floattof32(pframe-&gt;translate[0]))&gt;&gt;3;
<br/>
v[1] = (mulf32(floattof32(pframe-&gt;scale[1]), inttof32(pvert-&gt;v[1])) + floattof32(pframe-&gt;translate[1]))&gt;&gt;3;
<br/>
v[2] = (mulf32(floattof32(pframe-&gt;scale[2]), inttof32(pvert-&gt;v[2])) + floattof32(pframe-&gt;translate[2]))&gt;&gt;3;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I can guess why, but I'm sure someone else will wander in and give a much more technically thorough explaination.  I'm much more of a story teller.
<br/>
<br/>
Anyway, thanks goes out to Webez for tackling an MD2 loader before me; I'll be in your shadow for a while :)
<br/>
<br/>
-dak</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86354 - mike260 - Tue Jun 06, 2006 4:24 pm</h4>
    <div class="postbody"><span class="postbody">One way to work around the 16bitness of DS vertices is:
<br/>
<br/>
1) Get the bounding-box of your model
<br/>
2) Scale all the model's verts so this bounding-box just about fits the available precision
<br/>
3) When rendering your model, use glScale to reverse this scale and get your verts back into the correct units.
<br/>
<br/>
For extra points, you can also translate the verts to make even better use of the available precision.
<br/>
<br/>
For extra-combo-multiplier-bonus points, use displaylists and bake the glScale/glTranslate into the displaylist itself; that way it happens completely automatically and your rendering code doesn't even need to know about it.<br/>_________________<br/>"Ever tried? Ever failed? No matter. Try Again. Fail again. Fail better."
<br/>
 -- Samuel Beckett</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86682 - Payk - Thu Jun 08, 2006 5:49 pm</h4>
    <div class="postbody"><span class="postbody">Yes i also so did that like it.
<br/>
<br/>
			Models[num].preframes[N].pretriangles[I].vertex[j].v[0] =floattov16(v[0]/128);
<br/>
			Models[num].preframes[N].pretriangles[I].vertex[j].v[1] =floattov16(v[1]/128);
<br/>
			Models[num].preframes[N].pretriangles[I].vertex[j].v[2] =floattov16(v[2]/128);
<br/>
<br/>
But i changed much in the modelstructures. Now all triangles are stored each frame instead of using indices. Thats about 3,5x bigger (depending how much frames u got) But renderscene is much faster.
<br/>
<br/>
So on that way renderscene just goes like:
<br/>
void RenderMD2ModelMirrowed (int n,int num){
<br/>
  int i, j;
<br/>
<br/>
  if ((n &lt; 0) || (n &gt; Models[num].header.num_frames - 1))
<br/>
    return;
<br/>
  glBegin (GL_TRIANGLES);
<br/>
 	//glColor3f(EnvR,EnvG,EnvB);		
<br/>
    for (i = 0; i &lt; Models[num].header.num_tris; ++i)
<br/>
      {
<br/>
<br/>
			for (j = 0; j &lt; 3; ++j)
<br/>
          {
<br/>
<br/>
			glNormal3f(anorms_table[Models[num].preframes[n].pretriangles[i].vertex[j].normalIndex][0],
<br/>
				anorms_table[Models[num].preframes[n].pretriangles[i].vertex[j].normalIndex][1],
<br/>
				anorms_table[Models[num].preframes[n].pretriangles[i].vertex[j].normalIndex][2]);
<br/>
<br/>
 			glTexCoord2f32 (Models[num].pretexcoords[Models[num].textindex[i].st[j]].t, Models[num].pretexcoords[Models[num].textindex[i].st[j]].s);
<br/>
			glVertex3v16 (Models[num].preframes[n].pretriangles[i].vertex[j].v[0],
<br/>
			Models[num].preframes[n].pretriangles[i].vertex[j].v[1], 
<br/>
			-Models[num].preframes[n].pretriangles[i].vertex[j].v[2]);
<br/>
<br/>
		  }
<br/>
      }
<br/>
  glEnd ();
<br/>
}
<br/>
 So just give normalvec. and vertices for each triangle. No scale no translate no searching right triangles for right frame...just do it...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86822 - dak - Fri Jun 09, 2006 4:39 pm</h4>
    <div class="postbody"><span class="postbody">hmm, I also precalculate my point list, but I did it in a way where the point data itself is not a large as you have stated.  What I did was keep all of the uncompressed data on the buffer (which still points to the filesystem) and used it to fill a vector_t * pointList on memory.
<br/>
<br/>
The vectors are defined as v16 v[3]  --  it used to be f32, but since the smaller size works, I'll be using it :)
<br/>
<br/>
If the calculations were done on the fly then the as far as space used (assuming we have a model with 200 triangles), my count is:
<br/>
<br/>
..mem compressed..
<br/>
200tri * 3vert * 3vec * (sizeof(u8)*4) = 7200bytes
<br/>
(plus an additional 40bytes in the frame_t structure)
<br/>
<br/>
..mem decompressed..
<br/>
200tri * 3vert * 3vec * (sizeof(v16)*3) = 10800bytes
<br/>
<br/>
I'd say thats a pretty reasonable size for a boost of speed.  The only major things I'm storing are (precalculated) pointList, Vert/ST indices, and stList.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86852 - Payk - Fri Jun 09, 2006 10:53 pm</h4>
    <div class="postbody"><span class="postbody">v16 is definitly enough.
<br/>
it offers 65536 possibility vertexes per axis (not vertextes but their position)
<br/>
Since ds has 256x192 i see no reason to use more bits for that (just if u want to zoom in or use a md2 as map which is very stupid because it would c?lculate triangles for not seeable things)
<br/>
For my opinion even 9bit would be fine. A fixed point value (0.9) u just have to convert the vertex positions to that would work good i think.
<br/>
But not sure. But hey that huge they arent in ram. i use trees with 15 triangles and chars with about 50 triangles and 20 frames. they are small in ram. Even my method eats more ram its still under 50kb. (i think the char has 36kb but not sure). i displayed size out some time ago it was 3.5x bigger then as file. but it was faster i did a little benchmark.
<br/>
Tomorrow i gonna try to rape the t10 for vertex pos then i will know if 16bit is neccesary. but i dont think.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86895 - crossraleigh - Sat Jun 10, 2006 8:55 am</h4>
    <div class="postbody"><span class="postbody">You don't have to worry about the DS using 16-bit coordinates when the model format uses 8-bit coordinates! Use a matrix to scale and translate; it will be quicker <span style="font-style: italic">and</span> you won't have overflow errors.
<br/>
<br/>
Furthermore, I don't think it's necessary to create an intermediate buffer each frame; you're better off using the GL commands. The DS doesn't support fans, but it's easy to convert them to strips.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#87516 - Payk - Wed Jun 14, 2006 7:04 am</h4>
    <div class="postbody"><span class="postbody">perhaps its not neccecary for you, but make a benchmark. i did. it doesnt makes that huge difference but when u are going to make own lights u need all optimazions. Also u will have then each exact pos. of vertex in each frame. Very usefull for own lights. I have thought much how to simulate dot lights. This was one of first step to do so. For me its neccecary.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#87545 - Webez - Wed Jun 14, 2006 12:34 pm</h4>
    <div class="postbody"><span class="postbody">The  easiest way to deal with vertex as you have been said is to scale them and then rescale. I always divide them by 100 and then rescale by the same factor with glScale. As for display lists i wouldn't try to use them with a md2 unless you want a file as big as your whole RAM.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#87905 - Payk - Fri Jun 16, 2006 12:17 pm</h4>
    <div class="postbody"><span class="postbody">Ok my way of md2-structure was good idea...like i said it allows own lights...hmhm watch that:
<br/>
<a href="http://payk2005.pa.funpic.de/dotlight.jpg">[Images not permitted - Click here to view it]</a>
<br/>
There are much more then 4 lights possible. They arent dirrectional.
<br/>
That are dotlights, so they have a position and a radius. They just iluminate whats in radius of course. I plan to make some dirrectional lights,too. Same thing: more then 4 of course.
<br/>
Interessted in HowThatStuffWorks?
<br/>
Send me a pm i will explain...a source cant help since it is made for my engine and uses lookuptables and values which fit to it...
<br/>
But i can help u to have them too.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
