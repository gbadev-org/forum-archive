<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>3D collision/physics library - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS development > 3D collision/physics library</h2>
<div id="posts">
<div class="post">
    <h4>#54890 - cybereality - Fri Sep 23, 2005 11:53 am</h4>
    <div class="postbody"><span class="postbody">I haven't got into 3D DS programming yet, but I was wondering if there is any collision/physics functions built into the DS or available as homebrew libraries. If not I may be interested in creating a collision library that could be integrated into NDSLIB at some point. I have a 3D collision function I wrote in javascript that should be simple to port to DS. If anyone else is working on this, maybe we can combine efforts.<br/>_________________<br/><a class="postlink" href="http://www.cybereality.com" target="_blank">// cybereality</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54916 - duencil - Fri Sep 23, 2005 4:47 pm</h4>
    <div class="postbody"><span class="postbody">I don't know of any 3d collision libraries out there that are suitable to the fixed point restrictions of the DS. Anyway, most of the work in collision testing is working out how to do as few tests as possible each frame, and then optimizing to the maximum the tests you do make.  For the first its useful first to organise your 3d world and the objects within it into a hierarchical structure, like a quadtree, octree, bsp, portal system, or whatever.  Actually my preferance is for another structure, the kd-tree.  Then for the second, well it sounds like you have a base to start with.  I want to work on putting together some 3d primitive( probably sphere or box) vs triangle/quad routines in the near future.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54919 - cybereality - Fri Sep 23, 2005 5:34 pm</h4>
    <div class="postbody"><span class="postbody">Cool. Im glad someone else has an interest. I probabally wont even mess around with 3D on the DS until I have a good grasp of the 2D capabilities. I have noticed that collision ends up being a big bottleneck if there isn't a good system in place. In the games I have written from scratch, the collsion/physics always took the longest to code. Most other game code is usually as simple as "player_score++;" but with collision it can create serious problems (player getting stuck in wall, too many entities checking at once, etc.). I would also be interested in the idea of porting an open-source physics library like ODE, Newton or Tokamak to the DS. I would imagine the ARM7 could be used for the physics and the ARM9 for everything else. Im not sure if the DS could handle it, but maybe with a limited number or rigid bodies.<br/>_________________<br/><a class="postlink" href="http://www.cybereality.com" target="_blank">// cybereality</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54958 - TheChuckster - Fri Sep 23, 2005 10:12 pm</h4>
    <div class="postbody"><span class="postbody">Without an FPU, ODE for DS is not going to happen. You could always opt for integer or fixed point addition physics.
<br/>
<br/>
Have three vectors and set acceleration's y-value to -1:
<br/>
<br/>
Do:
<br/>
<br/>
Velocity += Acceleration
<br/>
Position += Velocity
<br/>
<br/>
Yay. Gravity. Adjust the acceleration to add lateral forces and jumping. This will simulate the gravity parabola and acceleration very nicely.
<br/>
<br/>
RESEARCH THE FOLLOWING ON YOUR OWN FOR MORE INFO:
<br/>
<br/>
When a sprite hits a wall or the floor, you need to generate an impulse for collision response. Assuming you have collision detection, come up with a quantity called j based on the relative velocity, the collision normal, and the elacsticity of the collision. Apply that directly to the colliding objects' velocities.
<br/>
<br/>
As for rotation, derive three new quantities (angular vel, accel, orientation) and integrate the same way. (Forgive my psuedo-Calculus terminology. I am still in Trig.) Now if one adds a force at a point other than the center of mass, the object will rotate accordingly. Now with collisions, you want your objects to spin, too. Find a new impulse equation that takes in account torque and apply the resulting torques to your bodies.
<br/>
<br/>
As for contact, I have yet to fully understand it myself. Real 3D physics engines use LCPs or quadratic programming. Above my high school mathematics education even more so than the Calculus concepts.  You can get around this shortcoming by adding a value to the acceleration vector (and velocity vector?) so that the force of gravity is cancelled out and the rigid body does not pass through the ground. Good luck with handling contact points though.
<br/>
<br/>
That pretty much sums up game physics, at least in the 2D world. If anyone learns more about contact or contraints/joints, please fill me in as I have been unsuccessfully trying to learn about/understand those topics myself.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54959 - sajiimori - Fri Sep 23, 2005 10:39 pm</h4>
    <div class="postbody"><span class="postbody">Most real games don't do things like angular velocity.  If you want to talk about "real" 3D engines, try reading the Quake 3 source.  You might be surprised at how simple the simulation is.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
