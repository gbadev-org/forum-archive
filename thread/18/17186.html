<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>When's the right time to use GFX_FLUSH = 0 ? [SOLVED] - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>DS development > When's the right time to use GFX_FLUSH = 0 ? [SOLVED]</h2>
<div id="posts">
<div class="post">
    <h4>#173253 - gusano - Mon Mar 29, 2010 2:04 am</h4>
    <div class="postbody"><span class="postbody">I'm having trouble understanding GFX_FLUSH. Normally what I would do is:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Render();
<br/>
GFX_FLUSH = 0;
<br/>
    .
<br/>
    .
<br/>
    .
<br/>
swiWaitForVBlank();
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
which to me means that I'll do all my rendering with glBegin()...glEnd(), then with GFX_FLUSH = 0 I ask the hardware to swap buffers... which happens until the next vblank (when swiWaitForVBlank() returns?)...
<br/>
<br/>
but from what I've gathered, it seems like the geometry hardware works independent from the CPU... so although I'm calling GFX_FLUSH = 0, the actual render may finish until after the swiWaitForVBlank() call which means that the buffers will swap until 2 vblanks after rendering began.
<br/>
<br/>
can anyone please help me understand the rendering process, and what would be the normal way to use GFX_FLUSH in a 60fps game?
<br/>
<br/>
essentially I've been trying to achieve texture double buffering... I render using textures in bank C, and while that happens, I copy the next frame's texture into bank D. the next frame, rendering happens from bank D and the next texture is loaded into bank C.. and so on... but my current code causes flicker on the DS hardware... on No$GBA it looks fine... so I think I'm not understanding the big picture...
<br/>
<br/>
thanks in advance...</span><span class="gensmall"><br/><br/>Last edited by gusano on Tue Mar 30, 2010 4:42 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#173279 - sajiimori - Mon Mar 29, 2010 6:55 pm</h4>
    <div class="postbody"><span class="postbody">I don't know why you're getting flicker.
<br/>
<br/>
In Render(), you're uploading commands to the gfx hardware.  The gfx hardware processes your commands as you're uploading them, and it stores the results (verts for clipped polys in screen space) to one of its two buffers.
<br/>
<br/>
Meanwhile, the gfx hardware is simultaneously drawing the other buffer to the screen, from top to bottom.  So there are really 3 things happening in parallel.
<br/>
<br/>
If you finish uploading your commands before vblank, but the gfx hardware didn't have enough time to finish processing them before vblank, then you're not running at 60fps -- you need to finish uploading your commands sooner.
<br/>
<br/>
But in practice, although there's a gap between when you finish uploading and when the gfx hardware finishes processing, it's not a very large gap, because you can't queue very many commands.  In other words, the CPU can't get very far ahead, because anytime the gfx hardware is not fast enough to keep up, the CPU simply stalls.
<br/>
<br/>
You should call GFX_FLUSH as soon as you're done sending commands.  On a 60fps game, you don't necessarily need to call swiWaitForVBlank, because trying to upload additional commands after a GFX_FLUSH will automatically block the CPU until the buffer swap is completed.
<br/>
<br/>
But again, in practice, it shouldn't make much difference whether you call swiWaitForVBlank.  You have to finish your frames in 1/60 of a second, and you should always have some extra time left.  It doesn't necessarily matter how you spend that time.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#173282 - gusano - Mon Mar 29, 2010 8:13 pm</h4>
    <div class="postbody"><span class="postbody">Would calling something like glPushMatrix() after GFX_FLUSH cause the CPU to stall if it hasn't finished processing commands?
<br/>
<br/>
EDIT: I'm looking through my code to check for any graphics commands happening after GFX_FLUSH but before Render()... but most likely I don't have any...
<br/>
<br/>
on another note... let me see if I've understood this:
<br/>
<br/>
When you start calling gfx commands, the gfx hardware immediately starts processing them... so an actual render begins as soon as I have my first glBegin()...glVertex3v16()... glEnd() block... (or state setting commands like glPushMatrix() or glColorTable())... When GFX_FLUSH is called, the gfx hardware could still be rendering... it'll eventually be done and at some point... then does the back buffer become the front buffer (page flip) or is the back buffer copied to the front buffer?... if it's copied, then is this what VDraw is?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#173283 - sajiimori - Mon Mar 29, 2010 9:09 pm</h4>
    <div class="postbody"><span class="postbody">Yes, glPushMatrix (and gl-just-about-anything) will wait for any pending buffer swaps to complete.
<br/>
<br/>
The DS doesn't have any framebuffers.  It has vertex buffers.  When you upload commands, the hardware projects and clips them, and fills a vertex buffer with the results.  Every VDraw, it renders the contents of one of the vertex buffers, from top to bottom, as the scanline moves down the screen.
<br/>
<br/>
Even if you don't draw anything new, it keeps rendering the same old polys, every VDraw, because there is no framebuffer.
<br/>
<br/>
When you are "rendering", try to think of it more as "uploading".  The hardware processes your commands, but your stuff doesn't start rendering until the buffers are swapped.  (Meanwhile, the hardware keeps on rendering the contents of the other buffer.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#173284 - gusano - Mon Mar 29, 2010 9:39 pm</h4>
    <div class="postbody"><span class="postbody">Ok, so I upload my state change and draw commands...
<br/>
<br/>
The hardware starts processing those and will fill vertex buffer "A" with the results...
<br/>
<br/>
I set GFX_FLUSH = 0;
<br/>
<br/>
[Meanwhile, it could still be rendering the contents of vertex buffer "B", am I right?]
<br/>
<br/>
Any gl commands called here will stall the cpu...
<br/>
<br/>
VDraw starts, so it'll swap buffers and start rendering the contents of vertex buffer "A"... any subsequent gl calls will cause vertex buffer "B" to be updated...
<br/>
<br/>
VDraw is done and now VBlank begins...
<br/>
<br/>
If I have a custom vblank handler (which I don't), it could do stuff here...
<br/>
<br/>
VBlank is done... back to VDraw (now using vertex buffer "B" to render)
<br/>
<br/>
<br/>
.
<br/>
.
<br/>
.
<br/>
<br/>
is this correct?
<br/>
<br/>
<br/>
<br/>
How does VRAM fit into all this? What exactly is LCD mode on a vram bank? All I know is, I'm supposed to set it to LCD, then change data, then move back to TEXTURE mode (in my case)...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#173286 - sajiimori - Mon Mar 29, 2010 10:22 pm</h4>
    <div class="postbody"><span class="postbody">I think you've got it down.
<br/>
<br/>
VRAM stores textures and palettes, which the gfx hardware uses while rasterizing your polys.  The DS has no way to let the gfx hardware access VRAM at the same time as the CPU.  So, there's a special mode (LCDC -- I don't know what it stands for) that maps parts of VRAM to an address range, to let the CPU access it.  However, that prevents the gfx hardware from reading those parts.  If it tries, you get black lines on the screen.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#173287 - gusano - Mon Mar 29, 2010 10:41 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for your help sajimori, I think what I've been getting is not flicker then... it's black lines due to the gfx hardware reading VRAM while it's on LCDC mode... how can I avoid this?
<br/>
<br/>
I set the vram banks to LCDC when I'm copying my dynamic texture into my next frame vram buffer... When I started out, I set banks A,B,C,D to LCDC but I was only copying to bank C or D... I think I've already tried only setting bank C or D to LCDC mode... but I'll try again because at this point I've changed my code so many times that I'm not sure what I've tried and what I haven't.... haha
<br/>
<br/>
Thanks again!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#173290 - gusano - Tue Mar 30, 2010 3:08 am</h4>
    <div class="postbody"><span class="postbody">Problem solved!!
<br/>
<br/>
When I was copying my dynamic textures into banks C or D I was also setting banks A and B to LCDC mode... so I got black lines... I made it so only the bank I'm updating gets set to LCDC (and back to TEXTURE when I'm done updating)... and it worked!
<br/>
<br/>
Thanks sajimori!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
