<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Optimize Paletteinterpolation routine - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>ASM > Optimize Paletteinterpolation routine</h2>
<div id="posts">
<div class="post">
    <h4>#52604 - Peter - Thu Sep 01, 2005 8:23 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I wrote the following routine to interpolate between two 16 color palettes and store the interpolation in Vram. Unfortunately it's pretty slow and I would like to know if you have any advice for me how to get it faster.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.code 32
<br/>
@.section .iwram, "ax", %progbits
<br/>
.global  hel_PalInterpolate16
<br/>
.type    hel_PalInterpolate16, %function
<br/>
.align
<br/>
<br/>
@ r0 = pPaletteMemory, pointer to target palette (BG or OBJ palette in Vram)
<br/>
@ r1 = pPaletteA, source palette
<br/>
@ r2 = pPaletteB, source palette
<br/>
@ r3 = Step, between 0..31
<br/>
@
<br/>
@ r4 = inner_loop Counter
<br/>
@
<br/>
@ extern void hel_PalInterpolate16(u16 *pPaletteMemory, const void *pPaletteA, const void *pPaletteB, u32 Step);
<br/>
<br/>
hel_PalInterpolate16:
<br/>
<br/>
  @mov r11, r11
<br/>
   
<br/>
  @ save registers on stack
<br/>
  stmfd sp!, {r0-r10}
<br/>
<br/>
   
<br/>
  @ set the loop counter. run from last entry down to 0.
<br/>
  @ decrement by 2 each iteration
<br/>
  mov r4, #30
<br/>
  
<br/>
  @ here starts the inner loop
<br/>
  .inner_loop:
<br/>
  
<br/>
   ldrh r5, [r1, r4]      @ get u16 color value from pPaletteA, lets call it colorA
<br/>
   ldrh r8, [r2, r4]      @ get u16 color value from pPaletteB, lets call it colorB
<br/>
   
<br/>
   @ we have both color values at this point.
<br/>
   @ now we must extract their rgb components
<br/>
   @ start with colorA
<br/>
   mov r7, r5, lsr #10      @ get blue component from colorA
<br/>
   mov r6, r5, lsr #5      @ get green component from colorA
<br/>
   and r6, r6, #31
<br/>
   and r5, r5, #31         @ get red component from colorA
<br/>
  
<br/>
   @ extract components from colorB now
<br/>
   mov r10, r8, lsr #10   @ get blue component from colorB
<br/>
   mov r9, r8, lsr #5      @ get green component from colorB
<br/>
   and r9, r9, #31
<br/>
   and r8, r8, #31         @ get red component from colorB
<br/>
   
<br/>
   @ now substract components of colorA from colorB
<br/>
   @ to get the difference between each component.
<br/>
   @ we store the result in the registers used by components
<br/>
   @ from colorB, since we don't need them after this anymore
<br/>
   sub r8, r8, r5         @ red
<br/>
   sub r9, r9, r6         @ green
<br/>
   sub r10, r10, r7      @ blue
<br/>
   
<br/>
   @ multiply difference with Step and shift 5 bits to the rigth again
<br/>
   @ Step must be between 0..31. if Step equals 0, colors are entirely
<br/>
   @ used from pPaletteA, if it is 31 colros entirely used from pPaletteB
<br/>
   mul r8, r8, r3         @ red
<br/>
   mul r9, r9, r3         @ green
<br/>
   mul r10, r10, r3      @ blue
<br/>
   
<br/>
   @ now we add them to the components from pPaletteA
<br/>
   @ and shift them back to have them in the right unitsize (0..31)
<br/>
   add r5, r5, r8, lsr #5   @ red
<br/>
   add r6, r6, r9, lsr #5   @ green
<br/>
   add r7, r7, r10, lsr #5   @ blue
<br/>
   
<br/>
   @ now create a new 15bit bgr555 value
<br/>
   @ r5 contains the red component, we basically logical OR the
<br/>
   @ green and blue components and shift them to their required positions
<br/>
   orr r5, r5, r6, lsl #5   @ green
<br/>
   orr r5, r5, r7, lsl #10   @ blue
<br/>
   
<br/>
   @ now store the interpolated
<br/>
   @ color to pPaletteMemory
<br/>
   strh r5, [r0, r4]
<br/>
   
<br/>
   @ dec counter and loop until r4 equals zero
<br/>
   subs r4, r4, #2
<br/>
   bne .inner_loop
<br/>
<br/>
<br/>
  @ load registers from stack
<br/>
  ldmfd sp!, {r0-r10}
<br/>
  bx    lr
<br/>
 .size   hel_PalInterpolate16, .-hel_PalInterpolate16
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I measured in 'ticks', where 4399 ticks equal one frame. The routine takes 60 ticks (when it is not located in iwram) and 15 ticks in iwram. I need it to flash 32 palettes in worst case, this is ~2000 ticks which equals almost an half frame. When it's located in iwram, it's of course a lot faster but I'm pretty sure it could be even faster when written with better asm skills than mine :)
<br/>
<br/>
Thanks for your helps</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#52623 - strager - Thu Sep 01, 2005 1:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Peter wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  @ save registers on stack
<br/>
  stmfd sp!, {r0-r10} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  @ load registers from stack
<br/>
  ldmfd sp!, {r0-r10} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
Since registers 0 through 3 are expected to be crumbled, you could prevent those registers from being pushed and popped from the stack.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Peter wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   @ we have both color values at this point.
<br/>
   @ now we must extract their rgb components
<br/>
   @ start with colorA
<br/>
   mov r7, r5, lsr #10      @ get blue component from colorA
<br/>
   mov r6, r5, lsr #5      @ get green component from colorA
<br/>
   and r6, r6, #31
<br/>
   and r5, r5, #31         @ get red component from colorA
<br/>
  
<br/>
   @ extract components from colorB now
<br/>
   mov r10, r8, lsr #10   @ get blue component from colorB
<br/>
   mov r9, r8, lsr #5      @ get green component from colorB
<br/>
   and r9, r9, #31
<br/>
   and r8, r8, #31         @ get red component from colorB
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
I believe this could be optimized an incy bit:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r10, #0x1F    @ Mask
<br/>
<br/>
@ Color A
<br/>
and r5, r5, #0x1F         @ Red
<br/>
<br/>
and r6, r10, r5, lsr #5   @ Green
<br/>
and r7, r10, r5, lsr #10  @ Blue
<br/>
<br/>
@ Color B
<br/>
and r9, r10, r8, lsr #5   @ Green
<br/>
and r10, r10, r8, lsr #10 @ Blue
<br/>
and r8, r8, #0x1F         @ Red
<br/>
</td> </tr></table><span class="postbody">
<br/>
One less instruction. :)
<br/>
<br/>
Another note:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Peter wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   ldrh r5, [r1, r4]      @ get u16 color value from pPaletteA, lets call it colorA
<br/>
   ldrh r8, [r2, r4]      @ get u16 color value from pPaletteB, lets call it colorB 
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   @ now store the interpolated
<br/>
   @ color to pPaletteMemory
<br/>
   strh r5, [r0, r4] 
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
Instead of indexing with r4, you could increment the pointer:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldrh r5, [r1], #1  @ Color A
<br/>
ldrh r8, [r2], #1  @ Color B
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">strh r5, [r0], #1
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I also see a potential bug.  When the loop counter is zero upon loop entry, the function will subtract 2, making it 0xFFFFFFFE, which is non-zero.  The function will then loop that many times.
<br/>
<br/>
More optimizations in store for the future (I must go =]).
<br/>
<br/>
Happy optimizing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#52630 - tum_ - Thu Sep 01, 2005 2:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>strager wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Since registers 0 through 3 are expected to be crumbled, you could prevent those registers from being pushed and popped from the stack.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
also you can use r12, no need to save it.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>strager wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Instead of indexing with r4, you could increment the pointer:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldrh r5, [r1], #1  @ Color A
<br/>
ldrh r8, [r2], #1  @ Color B
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">strh r5, [r0], #1
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
This gives you the idea but don't use this code, it's wrong ;)
<br/>
Incrementing by 1 is no good for ldrh (not mentioning that you need
<br/>
a DEcrement for your loop implementation).
<br/>
I'd recommend to consider reading/processing/writing more than one
<br/>
u16 at a time. That is, to use LDR (or even LDM) instead of LDRH.
<br/>
This is definitely possible but, sorry, I can't write the code
<br/>
for you at the moment.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>strager wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I also see a potential bug.  When the loop counter is zero upon loop entry, the function will subtract 2, making it 0xFFFFFFFE, which is non-zero.  The function will then loop that many times.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
:-) the loop counter is being explicitly set to 30 upon loop entry...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#52640 - gladius - Thu Sep 01, 2005 4:33 pm</h4>
    <div class="postbody"><span class="postbody">Essentially you are doing alpha blending on a 16 bit pixel, which is a subject that has been studied quite a bit.
<br/>
<br/>
Check out <a class="postlink" href="http://www.gamedev.net/reference/articles/article817.asp" target="_blank">http://www.gamedev.net/reference/articles/article817.asp</a> for a version that operates on two pixels at once, which saves you some multiplies, although I'm not sure how much exactly it will speed things up.
<br/>
<br/>
Wish I had time to code an asm version, maybe tonight :).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#52650 - tum_ - Thu Sep 01, 2005 6:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Peter wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   @ now substract components of colorA from colorB
<br/>
   @ to get the difference between each component.
<br/>
   @ we store the result in the registers used by components
<br/>
   @ from colorB, since we don't need them after this anymore
<br/>
   sub r8, r8, r5         @ red
<br/>
   sub r9, r9, r6         @ green
<br/>
   sub r10, r10, r7      @ blue
<br/>
   
<br/>
   @ multiply difference with Step and shift 5 bits to the rigth again
<br/>
   @ Step must be between 0..31. if Step equals 0, colors are entirely
<br/>
   @ used from pPaletteA, if it is 31 colros entirely used from pPaletteB
<br/>
   mul r8, r8, r3         @ red
<br/>
   mul r9, r9, r3         @ green
<br/>
   mul r10, r10, r3      @ blue
<br/>
   
<br/>
   @ now we add them to the components from pPaletteA
<br/>
   @ and shift them back to have them in the right unitsize (0..31)
<br/>
   add r5, r5, r8, lsr #5   @ red
<br/>
   add r6, r6, r9, lsr #5   @ green
<br/>
   add r7, r7, r10, lsr #5   @ blue
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Does the function work correctly? Have you tested it on different inputs?
<br/>
Don't want to get deep into the task but those subtractions look a bit suspicious to me. What if colorB components are less then corresponding
<br/>
colorA ones - you get negative results in r8,r9,r10, then you multiply them... Are you sure you'll still get the correct result?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#52716 - Peter - Fri Sep 02, 2005 8:31 am</h4>
    <div class="postbody"><span class="postbody">Hello, thanks for all the feedback! I'll implement your suggestions probably this weekend, eeks :)
<br/>
<br/>
@tum_
<br/>
i only tested 6 different palettes yet. But I thought the same about what happens when B is smaller then A. However, it works so far. When anything weird happens I know where to look first :P
<br/>
<br/>
Again,  thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#53294 - Cearn - Wed Sep 07, 2005 9:16 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>_tum wrote:</b></span></td> </tr> <tr> <td class="quote">Don't want to get deep into the task but those subtractions look a bit suspicious to me. What if colorB components are less then corresponding 
<br/>
colorA ones - you get negative results in r8,r9,r10, then you multiply them... Are you sure you'll still get the correct result?</td> </tr></table><span class="postbody">
<br/>
Negative numbers are fine, that's what's supposed to happen. That said, shifting does should have been done with an ASR instead of an LSR, but since this only affect the top 5 bits (which you're not using), everything's fine.
<br/>
What isn't fine is the [0,31] range. The step (blend weight, whatever) is a basically .5 fixed number, but should have the range between 0 and 1 inclusive. Meaning [0,32]. It's not a major concern, but strictly speaking the former range isn't accurate.
<br/>
Also, correct me if I'm wrong, but doesn't using 30 as a starting range only do 15 interpolations?
<br/>
<br/>
As for optimisations, the original basically has 24 instructions inside the loop for 34 cycles (24i/34c). I have two alternatives: 
<br/>
* pal_blend16, doing a single color/loop (20i/28c)
<br/>
* pal_blend32, doing two colors/loop (24i/38c, so effectively 19c per individual color)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Basic format:
<br/>
@ DECL: void pal_blend16(COLOR *dst, COLOR *srca, COLOR *srcb, 
<br/>
@    u32 alpha, int nclrs) CODE_IN_IWRAM;
<br/>
@ DECL: void pal_blend32(COLOR *dst, COLOR *srca, COLOR *srcb, 
<br/>
@    u32 alpha, int nclrs) CODE_IN_IWRAM;
<br/>
@ DESC: blends palettes srca and srcb into dst. 
<br/>
@   \param dst. Destination palette
<br/>
@   \param srca, srcb. Source palettes
<br/>
@   \param alpha. Blend weight 0-32
<br/>
@   \param nclrs. Number of colors
<br/>
</td> </tr></table><span class="postbody">
<br/>
pal_blend16 is probably a little non-standard, with only a single MUL for the interpolation, rather than the usual three. The color components are pulled apart to a 10.10.10 format; multiplying by up to 32 will fill up these 10 bits/component without upsetting the others. Yes, this works. Quite fast too.
<br/>
Also, here's a fun little fact about MUL. The format for this is "mul Rd, Rm, Rs" for Rd= Rm*Rs. The number of significant bits of Rs determines the full time; if that's low, the multiplication is faster. The order of multiplicants matters: I'd lose 3 cycles if it were reversed. Thank you GBATek for mentioning this.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ --- Reglist: ---
<br/>
@   r0, r1, r2: dst, srca, srcb
<br/>
@   r12: nclrs
<br/>
@   r4, r5: colors a &amp; b
<br/>
@   r6: mask
<br/>
@   r7 temp
<br/>
@   r3: alpha
<br/>
    .section .iwram,"ax", %progbits
<br/>
    .align 2
<br/>
    .code 32
<br/>
    .global pal_blend16
<br/>
pal_blend16:
<br/>
    ldr     r12, [sp]   @ get nclrs from stack
<br/>
    cmp     r12, #0     @ Ain't workin' if there's
<br/>
    bxeq    lr          @ nothing to do.
<br/>
    stmfd   sp!, {r4-r7}
<br/>
    ldr     r6, =0x01F07C1F         @ load mask
<br/>
.Lpbld3_loop:
<br/>
    @ prep a
<br/>
    ldrh    r7, [r1], #2            @ ---bgr
<br/>
    and     r4, r6, r7, lsl #5      @ ---g--
<br/>
    orr     r4, r4, r7, lsr #10     @ ---g-b
<br/>
    and     r7, r7, r6              @ ---b-r
<br/>
    orr     r4, r4, r7, lsl #20     @ -r-g-b
<br/>
    @ prep b
<br/>
    ldrh    r7, [r2], #2            @ ---bgr
<br/>
    and     r5, r6, r7, lsl #5      @ ---g--
<br/>
    orr     r5, r5, r7, lsr #10     @ ---g-b
<br/>
    and     r7, r7, r6              @ ---b-r
<br/>
    orr     r5, r5, r7, lsl #20     @ -r-g-b
<br/>
    @ a and b are now 10.10.10 rgb with only the lower 5 bits
<br/>
    @ filled. We can mul in range [0,32] with abandon
<br/>
    @ c= a + w*(b-a)/32
<br/>
    sub     r5, r5, r4
<br/>
    mul     r7, r5, r3              @ NOTE: r7,r3,r5 takes longer
<br/>
    add     r4, r4, r7, asr #5
<br/>
    @ convert back to 15bit bgr
<br/>
    and     r4, r4, r6              @ -r-g-b
<br/>
    orr     r4, r4, r4, lsl #15     @ grbg-b
<br/>
    mov     r5, r4, lsr #20         @ ----gr
<br/>
    orr     r4, r5, r4, lsl #10     @ bg-bgr
<br/>
    @ --- write blended, loop
<br/>
    strh    r4, [r0], #2
<br/>
    subs    r12, r12, #1
<br/>
    bgt     .Lpbld3_loop
<br/>
    ldmfd   sp!, {r4-r7}
<br/>
    bx      lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
pal_blend32 is a pretty run of the mill double-color interpolater. Instruction count is reduced a bit by keeping the masks in registers for easier shifted-ANDing, and having color a's components in .5 fixed point so I could use MLA instead of separate MULs and ADDs.
<br/>
The usual alignment matters for words apply here.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ --- Reglist: ---
<br/>
@   r0, r1, r2: (u32*)dst, (u32*)srca, (u32*)srcb 
<br/>
@   r3: alpha
<br/>
@   r4, r5: work color components a &amp; b
<br/>
@   r6, r7: green/a &amp; red/b masks (gm, rm)
<br/>
@   r8, r9, r10: current colors (c=*dst, a=*srca, b=*srcb)
<br/>
@   r12: nclrs
<br/>
    .section .iwram,"ax", %progbits
<br/>
    .align 2
<br/>
    .code 32
<br/>
    .global pal_blend32
<br/>
pal_blend32:
<br/>
    ldr     r12, [sp]               @ get nclrs from stack
<br/>
    movs    r12, r12, lsr #1        @ adjust nclrs for u32 run
<br/>
    bxeq    lr        @ only run if there's something to do
<br/>
    stmfd   sp!, {r4-r10}
<br/>
    mov     r7, #31
<br/>
    orr     r7, r7, r7, lsl #16     @ rm= 0x001F001F
<br/>
    mov     r6, r7, lsl #5          @ gm= 0x03E003E0
<br/>
.Lpbld_loop:
<br/>
    ldr     r9, [r1], #4            @ a0= *pa++
<br/>
    ldr     r10, [r2], #4           @ b0= *pb++
<br/>
    @ --- reds: rc = (ra*32 + alpha*(rb-ra))/32
<br/>
    and     r4, r6, r9, lsl #5      @ a= ra&lt;&lt;5
<br/>
    and     r5, r10, r7             @ b= rb
<br/>
    sub     r5, r5, r4, lsr #5      @ b -= a&gt;&gt;5
<br/>
    mla     r4, r5, r3, r4          @ a += alpha*b
<br/>
    and     r8, r7, r4, asr #5      @ c= rm &amp; (a&gt;&gt;5)
<br/>
    @ --- greens: gc= ga + alpha*(gb-ga)/32
<br/>
    and     r4, r9, r6              @ a= ga
<br/>
    and     r5, r7, r10, lsr #5     @ b= gb&gt;&gt;5
<br/>
    sub     r5, r5, r4, lsr #5      @ b -= a&gt;&gt;5
<br/>
    mla     r4, r5, r3, r4          @ a += alpha*b
<br/>
    and     r4, r4, r6              @ a &amp;= gm
<br/>
    orr     r8, r8, r4              @ c |= a
<br/>
    @ --- blues: bc= ba + alpha*((bb-ba)/32)
<br/>
    and     r4, r6, r9, lsr #5      @ a= ba&gt;&gt;5
<br/>
    and     r5, r7, r10, lsr #10    @ b= bb&gt;&gt;10
<br/>
    sub     r5, r5, r4, lsr #5      @ b -= a&gt;&gt;5
<br/>
    mla     r4, r5, r3, r4          @ a += alpha*b
<br/>
    and     r4, r4, r6              @ a &amp;= gm
<br/>
    orr     r8, r8, r4, lsl #5      @ c |= a&lt;&lt;5
<br/>
    @ --- write blended, loop
<br/>
    str     r8, [r0], #4            @ *pc++= c
<br/>
    subs    r12, r12, #1
<br/>
    bgt     .Lpbld_loop
<br/>
    ldmfd   sp!, {r4-r10}
<br/>
    bx      lr
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#53322 - Cearn - Wed Sep 07, 2005 2:49 pm</h4>
    <div class="postbody"><span class="postbody">20060807 full edit: 
<br/>
<br/>
16 insns/main loop. Two colors/iteration, 30cycles. For single color version, change the color ldr/str to ldrh/strh and remove the initial halving of the counter.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*
<br/>
void pal_blend_asm(COLOR *pa, COLOR *pb, COLOR *pc, 
<br/>
    int nclrs, u32 alpha) CODE_IN_IWRAM;
<br/>
//! Blends palettes pa and pb into pc. 
<br/>
//! \param pa, pb. Source palettes
<br/>
//! \param pc. Destination palette
<br/>
//! \param nclrs Number of colors
<br/>
//! \param alpha Blend weight 0-32
<br/>
//! \note u32 version, 2 clrs/loop. Loop: 16i/30c, Barrel shifter FTW.
<br/>
*/
<br/>
    .section .iwram,"ax", %progbits
<br/>
    .align 2
<br/>
    .arm
<br/>
    .global pal_blend_asm
<br/>
pal_blend_asm:
<br/>
    movs    r3, r3, lsr #1          @ adjust nclrs for u32 run
<br/>
    bxeq    lr                      @ quit on nclrs=0
<br/>
    ldr     r12, [sp]               @ get alpha from stack
<br/>
    stmfd   sp!, {r4-r10}
<br/>
    ldr     r7, =0x03E07C1F         @ MASKLO: -g-|b-r
<br/>
    mov     r6, r7, lsl #5          @ MASKHI: g-|b-r-
<br/>
.Lpbld_loop:
<br/>
        ldr     r8, [r0], #4            @ a= *pa++
<br/>
        ldr     r9, [r1], #4            @ b= *pb++
<br/>
        @ --- -g-|b-r
<br/>
        and     r4, r6, r8, lsl #5      @ x/32: (-g-|b-r)
<br/>
        and     r5, r7, r9              @ y: -g-|b-r
<br/>
        sub     r5, r5, r4, lsr #5      @ z: y-x
<br/>
        mla     r4, r5, r12, r4         @ z: (y-x)*w + x*32
<br/>
        and     r10, r7, r4, lsr #5     @ blend(-g-|b-r)            
<br/>
        @ --- b-r|-g- (rotated by 16 for cheapskatiness)
<br/>
        and     r4, r6, r8, ror #11     @ x/32: -g-|b-r (ror16)
<br/>
        and     r5, r7, r9, ror #16     @ y: -g-|b-r (ror16)
<br/>
        sub     r5, r5, r4, lsr #5      @ z: y-x
<br/>
        mla     r4, r5, r12, r4         @ z: (y-x)*w + x*32
<br/>
        and     r4, r7, r4, lsr #5      @ blend(-g-|b-r (ror16))
<br/>
        @ --- mix -g-|b-r and b-r|-g-
<br/>
        orr     r10, r10, r4, ror #16
<br/>
        @ --- write blended, loop
<br/>
        str     r10, [r2], #4           @ *pc++= c
<br/>
        subs    r3, r3, #1
<br/>
        bgt     .Lpbld_loop        
<br/>
    ldmfd   sp!, {r4-r10}
<br/>
    bx      lr
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
