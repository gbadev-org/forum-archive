<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>AdLib emulation optimization help - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > AdLib emulation optimization help</h2>
<div id="posts">
<div class="post">
    <h4>#170293 - Pate - Wed Sep 16, 2009 6:17 am</h4>
    <div class="postbody"><span class="postbody">Hi!
<br/>
<br/>
I am working on an AdLib emulation running on DS ARM7. It currently can manage 8 channels (each with 2 operators), but the ninth (and final) channel makes it take more CPU cycles than are available. I was hoping you gurus could perhaps take a look at my inner loops and check if I have missed some obvious optimization possibilities.
<br/>
<br/>
I am planning to change the rows of ldr and str commands to ldmia and stmia  after I reorder the slot struct variables and register usage, but that is only done 9 times per frame while the inner loops are done 256*9 times a frame so any optimization in the for_SLOT1 and for_SLOT2 loops would be much appreciated!
<br/>
<br/>
Thanks in advance!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.for_channel:
<br/>
    @-------
<br/>
    @ Load the SLOT-specific data values
<br/>
    @-------
<br/>
    ldrb   r1, [r0, #(ch0_slot1_bits-SLOT1)]        @ r1 = SLOT1 bits (Feedback(3 bits), Con, AM, Vib, EG type, KSR)
<br/>
    ldr    r2, [r0, #(ch0_slot1_wavetable-SLOT1)]   @ r2 = SLOT1 wavetable value
<br/>
    ldr    r3, [r0, #(ch0_slot1_op1_out-SLOT1)]     @ r3 = SLOT1 op1_out value
<br/>
    ldr    r4, [r0, #(ch0_slot1_env_sustain-SLOT1)] @ r5 = SLOT1 sustain level (MAX_ATT_INDEX if release phase)
<br/>
    ldr    r5, [r0, #(ch0_slot1_envelope-SLOT1)]    @ r5 = SLOT1 envelope counter value
<br/>
    ldr    r6, [r0, #(ch0_slot1_Incr-SLOT1)]        @ r6 = SLOT1 Incr value
<br/>
    ldr    r7, [r0, #(ch0_slot1_Cnt-SLOT1)]         @ r7 = SLOT1 Cnt value
<br/>
    ldr    r8, [r0, #(ch0_slot1_volume-SLOT1)]      @ r8 = SLOT1 volume value &lt;&lt; 16
<br/>
    ldr    r9, [r0, #(ch0_slot1_TLL-SLOT1)]         @ r9 = SLOT1 TLL value
<br/>
    ldr    r10, =sin_tab
<br/>
    ldr    r11, =tl_tab
<br/>
    add    r10, r2                                  @ r10 = sin_tab + SLOT1-&gt;wavetable
<br/>
    @-------
<br/>
    @    tmp = lfo_am_table[ OPL-&gt;lfo_am_cnt &gt;&gt; LFO_SH ];
<br/>
    @    if (OPL-&gt;lfo_am_depth)
<br/>
    @        LFO_AM = tmp;
<br/>
    @    else
<br/>
    @        LFO_AM = tmp&gt;&gt;2;
<br/>
    @-------
<br/>
<br/>
    bic    r12, #0xFF00
<br/>
    orr    r12, r1, lsl #8                          @ Put all bit values of SLOT1 into r12 second byte
<br/>
    and    r1, r12, #0xFF                           @ r1 = LFO_AM and lfo_am_depth
<br/>
    
<br/>
    mov    r2,  #3
<br/>
    tst    r1,  #1                                  @ if (OPL-&gt;lfo_am_depth)
<br/>
    moveq  r2,  #5
<br/>
    tst    r12, #(8&lt;&lt;8)                             @ AM bit set?
<br/>
    addne  r9,  r1, lsr r2                          @ Now r9 = SLOT1 volume base (0..511?)
<br/>
    orr    r12, #((ADLIB_BUFFER_SAMPLES-1)&lt;&lt;20)
<br/>
.for_SLOT1:                                         @ for( i=length-1; i &gt;= 0 ; i-- ) {
<br/>
    @-------
<br/>
    @ Calculate the FM part for SLOT 1
<br/>
    @ Output goes always to the output buffer, SLOT2 uses it as phase_modulation or direct output depending on connect
<br/>
    @
<br/>
    @    FREQ_SH = 16
<br/>
    @    FREQ_MASK = 65535
<br/>
    @    SIN_MASK = 1023
<br/>
    @    ENV_QUIET = 384 (= 6144&gt;&gt;4)
<br/>
    @
<br/>
    @    out  = SLOT-&gt;op1_out[0] + SLOT-&gt;op1_out[1];
<br/>
    @    SLOT-&gt;op1_out[0] = SLOT-&gt;op1_out[1];
<br/>
    @    SLOT-&gt;op1_out[1] = 0;
<br/>
    @    *SLOT-&gt;connect1 += SLOT-&gt;op1_out[0];
<br/>
    @    env  = ((SLOT)-&gt;TLL + ((UINT32)(SLOT)-&gt;volume) + (LFO_AM &amp; (SLOT)-&gt;AMmask));
<br/>
    @    if( env &lt; ENV_QUIET )
<br/>
    @    {
<br/>
    @        if (!SLOT-&gt;FB)
<br/>
    @            out = 0;
<br/>
    @        UINT32 p = (env&lt;&lt;4) + sin_tab[SLOT-&gt;wavetable + ((((signed int)((SLOT-&gt;Cnt &amp; ~FREQ_MASK) + (out&lt;&lt;SLOT-&gt;FB))) &gt;&gt; FREQ_SH ) &amp; SIN_MASK) ];
<br/>
    @        if (p &lt; TL_TAB_LEN)
<br/>
    @            SLOT-&gt;op1_out[1] = tl_tab[p];
<br/>
    @    }
<br/>
    @-------
<br/>
    strh   r3, [lr], #2                             @ *SLOT-&gt;connect1 += SLOT-&gt;op1_out[0];
<br/>
    add    r2, r9, r8, lsr #16                      @ r2 = env = ((SLOT)-&gt;TLL + ((UINT32)(SLOT)-&gt;volume) + (LFO_AM &amp; (SLOT)-&gt;AMmask));
<br/>
    tst    r12, #(7&lt;&lt;(8+5))                         @ Feedback = 0?
<br/>
    moveq  r1, r7, lsr #16                          @ Yes, use only SLOT-&gt;Cnt
<br/>
    beq    .op1_no_feedback
<br/>
        @-------
<br/>
        @ Feedback active, calculate r1 = ((signed int)((SLOT-&gt;Cnt &amp; ~FREQ_MASK) + (out&lt;&lt;SLOT-&gt;FB)))
<br/>
        @-------
<br/>
        mov    r1, r12, lsr #(8+5)                  @ r1 = feedback value, 1..7, 7 = smallest feedback, 1 = largest
<br/>
        and    r1, #7
<br/>
        add    r1, r7, r3, asr r1                   @ r1 = SLOT1-&gt;Cnt + (out&lt;&lt;SLOT-&gt;FB)
<br/>
        lsr    r1, #16                              @ r1 &gt;&gt;= FREQ_SH
<br/>
.op1_no_feedback:
<br/>
    bic    r1, #0xFC00                              @ r1 &amp;= SIN_MASK
<br/>
    lsl    r3, #16                                  @ r3 = SLOT-&gt;op1_out[0] = SLOT-&gt;op1_out[1]; SLOT-&gt;op1_out[1] = 0;
<br/>
    ldr    r1, [r10, r1, lsl #2]                    @ r1 = sin_tab[SLOT-&gt;wavetable + ((((signed int)((SLOT-&gt;Cnt &amp; ~FREQ_MASK) + (out&lt;&lt;SLOT-&gt;FB))) &gt;&gt; FREQ_SH ) &amp; SIN_MASK) ];
<br/>
    add    r1, r2, lsl #5                           @ r1 = env&lt;&lt;4 + sin_tab[..], extra &lt;&lt; 1 for halfword accessing
<br/>
    cmp    r1, #(2*TL_TAB_LEN)                      @ if (p &lt; TL_TAB_LEN)
<br/>
        ldrloh r1, [r11, r1]
<br/>
        orrlo  r3, r1                               @ SLOT-&gt;op1_out[1] = tl_tab[p];
<br/>
    @-------
<br/>
    @ Calculate envelope for SLOT 1
<br/>
    @-------
<br/>
    tst    r5, #1                                   @ Are we in ATTACK phase?
<br/>
    bne    op1_attack                               @ Yes, go handle ATTACK phase volume envelope
<br/>
    add    r8, r5, lsr #1                           @ Decrease the volume by the envelope counter
<br/>
    cmp    r8, r4                                   @ Did we go under the SUSTAIN level?
<br/>
    bhi    op1_sustain                              @ Yep, go adjust the volume
<br/>
op1_env_done:    
<br/>
    @-------
<br/>
    @ Calculate phase generator values for SLOT 1
<br/>
    @
<br/>
    @    /* Phase Generator */
<br/>
    @    if(op-&gt;vib)
<br/>
    @    {
<br/>
    @        unsigned int block_fnum = CH-&gt;block_fnum;
<br/>
    @        unsigned int fnum_lfo   = (block_fnum&amp;0x0380) &gt;&gt; 7;
<br/>
    @        signed int lfo_fn_table_index_offset = lfo_pm_table[LFO_PM + 16*fnum_lfo ];
<br/>
    @        if (lfo_fn_table_index_offset)    /* LFO phase modulation active */
<br/>
    @        {
<br/>
    @            block_fnum += lfo_fn_table_index_offset;
<br/>
    @            UINT8 block = (block_fnum&amp;0x1c00) &gt;&gt; 10;
<br/>
    @            op-&gt;Cnt += (OPL-&gt;fn_tab[block_fnum&amp;0x03ff] &gt;&gt; (7-block)) * op-&gt;mul;
<br/>
    @        }
<br/>
    @        else    /* LFO phase modulation  = zero */
<br/>
    @            op-&gt;Cnt += op-&gt;Incr;
<br/>
    @    }
<br/>
    @    else    /* LFO phase modulation disabled for this operator */
<br/>
    @        op-&gt;Cnt += op-&gt;Incr;
<br/>
    @-------
<br/>
    add    r7, r6                                   @ SLOT1-&gt;Cnt += SLOT1-&gt;Incr
<br/>
    @-------
<br/>
    @ Loop to next sample
<br/>
    @-------
<br/>
    subs   r12, #(1&lt;&lt;20)
<br/>
    bpl    .for_SLOT1                               @ }
<br/>
    add    r12, #(1&lt;&lt;20)
<br/>
    @-------
<br/>
    @ Save the final values for SLOT1
<br/>
    @-------
<br/>
    str    r3, [r0, #(ch0_slot1_op1_out-SLOT1)]     @ r3 = SLOT1 op1_out value
<br/>
    str    r4, [r0, #(ch0_slot1_env_sustain-SLOT1)] @ r4 = SLOT1 sustain level (MAX_ATT_INDEX if release phase)
<br/>
    str    r5, [r0, #(ch0_slot1_envelope-SLOT1)]    @ r5 = SLOT1 envelope counter &amp; mode value
<br/>
    str    r7, [r0, #(ch0_slot1_Cnt-SLOT1)]         @ r7 = SLOT1 Cnt value
<br/>
    str    r8, [r0, #(ch0_slot1_volume-SLOT1)]      @ r8 = SLOT1 volume value &lt;&lt; 16
<br/>
    
<br/>
    @-------
<br/>
    @ Calculate all the 256 samples for SLOT 2
<br/>
    @-------
<br/>
    add    r0, #SLOT_SIZE
<br/>
    sub    lr, #ADLIB_BUFFER_SIZE                   @ Rewind buffer pointer back to start
<br/>
    
<br/>
    ldrb   r1, [r0, #(ch0_slot1_bits-SLOT1)]        @ r1 = SLOT2 bits (Feedback, Con, AM, Vib, EG type, KSR)
<br/>
    ldr    r2, [r0, #(ch0_slot1_wavetable-SLOT1)]   @ r2 = SLOT1 wavetable value
<br/>
    ldr    r4, [r0, #(ch0_slot1_env_sustain-SLOT1)] @ r5 = SLOT1 sustain level (MAX_ATT_INDEX if release phase)
<br/>
    ldr    r5, [r0, #(ch0_slot1_envelope-SLOT1)]    @ r5 = SLOT1 envelope value
<br/>
    ldr    r6, [r0, #(ch0_slot1_Incr-SLOT1)]        @ r6 = SLOT1 Incr value
<br/>
    ldr    r7, [r0, #(ch0_slot1_Cnt-SLOT1)]         @ r7 = SLOT1 Cnt value
<br/>
    ldr    r8, [r0, #(ch0_slot1_volume-SLOT1)]      @ r8 = SLOT1 volume value &lt;&lt; 16
<br/>
    ldr    r9, [r0, #(ch0_slot1_TLL-SLOT1)]         @ r9 = SLOT1 TLL value
<br/>
    ldr    r10, =sin_tab
<br/>
    
<br/>
    and    r3, r12, #0xFF                           @ r3 = LFO_AM and lfo_am_depth
<br/>
    bic    r12, #0xFF00
<br/>
    
<br/>
    add    r10, r2                                  @ r10 = sin_tab + SLOT1-&gt;wavetable
<br/>
<br/>
    @-------
<br/>
    @    tmp = lfo_am_table[ OPL-&gt;lfo_am_cnt &gt;&gt; LFO_SH ];
<br/>
    @    if (OPL-&gt;lfo_am_depth)
<br/>
    @        LFO_AM = tmp;
<br/>
    @    else
<br/>
    @        LFO_AM = tmp&gt;&gt;2;
<br/>
    @-------
<br/>
    mov    r2,  #3
<br/>
    tst    r3,  #1                                  @ if (OPL-&gt;lfo_am_depth)
<br/>
    moveq  r2,  #5
<br/>
    tst    r1,  #8                                  @ AM bit set?
<br/>
    addne  r9,  r3, lsr r2                          @ Now r9 = SLOT2 volume base (0..511?)
<br/>
    
<br/>
    orr    r12, r1, lsl #8                          @ Put all bit values of SLOT2 into r12 second byte
<br/>
    
<br/>
    orr    r12, #((ADLIB_BUFFER_SAMPLES-1)&lt;&lt;20)
<br/>
.for_SLOT2:                                         @ for( i=length-1; i &gt;= 0 ; i-- ) {
<br/>
    @-------
<br/>
    @ Calculate the FM part for SLOT 2
<br/>
    @
<br/>
    @     env = ((SLOT)-&gt;TLL + ((UINT32)(SLOT)-&gt;volume) + (LFO_AM &amp; (SLOT)-&gt;AMmask));
<br/>
    @    if( env &lt; ENV_QUIET )
<br/>
    @    {
<br/>
    @        UINT32 p = (env&lt;&lt;4) + sin_tab[SLOT-&gt;wavetable + ((((signed int)((SLOT-&gt;Cnt &amp; ~FREQ_MASK) + (phase_modulation&lt;&lt;16))) &gt;&gt; FREQ_SH ) &amp; SIN_MASK) ];
<br/>
    @        if (p &gt;= TL_TAB_LEN)
<br/>
    @            output[0] += 0;
<br/>
    @        else
<br/>
    @            output[0] += tl_tab[p];
<br/>
    @    }
<br/>
    @-------
<br/>
    ldrh   r3, [lr]                                 @ r3 = either phase_modulation or output[0]
<br/>
    add    r2, r9, r8, lsr #16                      @ r2 = env = ((SLOT)-&gt;TLL + ((UINT32)(SLOT)-&gt;volume) + (LFO_AM &amp; (SLOT)-&gt;AMmask));
<br/>
    tst    r12, #(1&lt;&lt;(8+4))                         @ If Con=1, op1 produces sound directly, else use it as phase modulation
<br/>
    addeq  r1, r7, r3, lsl #16                      @ r1 = ((SLOT-&gt;Cnt) + (phase_modulation&lt;&lt;16))
<br/>
    moveq  r3, #0
<br/>
    movne  r1, r7
<br/>
    lsr    r1, #16                                  @ r1 &gt;&gt;= FREQ_SH
<br/>
    bic    r1, #0xFC00                              @ r1 &amp;= SIN_MASK
<br/>
    ldr    r1, [r10, r1, lsl #2]                    @ r1 = sin_tab[SLOT-&gt;wavetable + ((((signed int)((SLOT-&gt;Cnt &amp; ~FREQ_MASK) + (phase_modulation&lt;&lt;16))) &gt;&gt; FREQ_SH ) &amp; SIN_MASK) ];
<br/>
    add    r1, r2, lsl #5                           @ r1 = env&lt;&lt;4 + sin_tab[..], extra &lt;&lt; 1 for halfword accessing
<br/>
    cmp    r1, #(2*TL_TAB_LEN)                      @ if (p &lt; TL_TAB_LEN)
<br/>
        ldrloh r1, [r11, r1]
<br/>
        addlo  r3, r1                               @    output[0] += tl_tab[p];
<br/>
<br/>
    @-------
<br/>
    @ Store the sample to output buffer
<br/>
    @
<br/>
    @    lt = output[0];
<br/>
    @    lt &gt;&gt;= FINAL_SH;
<br/>
    @    /* limit check */
<br/>
    @    lt = limit( lt , MAXOUT, MINOUT );
<br/>
    @    /* store to sound buffer */
<br/>
    @    buf[i] = lt;
<br/>
    @-------
<br/>
    strh   r3, [lr], #2                             @ buf[i] = output[0];
<br/>
<br/>
    @-------
<br/>
    @ Calculate envelope for SLOT 2
<br/>
    @-------
<br/>
    tst    r5, #1                                   @ Are we in ATTACK phase?
<br/>
    bne    op2_attack                               @ Yes, go handle ATTACK phase volume envelope
<br/>
    add    r8, r5, lsr #1                           @ Decrease the volume by the envelope counter
<br/>
    cmp    r8, r4                                   @ Did we go under the SUSTAIN level?
<br/>
    bhi    op2_sustain                              @ Yep, go adjust the volume
<br/>
op2_env_done:    
<br/>
    @-------
<br/>
    @ Calculate phase generator values for SLOT 2
<br/>
    @
<br/>
    @    /* Phase Generator */
<br/>
    @    if(op-&gt;vib)
<br/>
    @    {
<br/>
    @        unsigned int block_fnum = CH-&gt;block_fnum;
<br/>
    @        unsigned int fnum_lfo   = (block_fnum&amp;0x0380) &gt;&gt; 7;
<br/>
    @        signed int lfo_fn_table_index_offset = lfo_pm_table[LFO_PM + 16*fnum_lfo ];
<br/>
    @        if (lfo_fn_table_index_offset)    /* LFO phase modulation active */
<br/>
    @        {
<br/>
    @            block_fnum += lfo_fn_table_index_offset;
<br/>
    @            UINT8 block = (block_fnum&amp;0x1c00) &gt;&gt; 10;
<br/>
    @            op-&gt;Cnt += (OPL-&gt;fn_tab[block_fnum&amp;0x03ff] &gt;&gt; (7-block)) * op-&gt;mul;
<br/>
    @        }
<br/>
    @        else    /* LFO phase modulation  = zero */
<br/>
    @            op-&gt;Cnt += op-&gt;Incr;
<br/>
    @    }
<br/>
    @    else    /* LFO phase modulation disabled for this operator */
<br/>
    @        op-&gt;Cnt += op-&gt;Incr;
<br/>
    @-------
<br/>
    add    r7, r6                                   @ SLOT-&gt;Cnt += SLOT-&gt;Incr
<br/>
    @-------
<br/>
    @ Loop to next sample
<br/>
    @-------
<br/>
    subs   r12, #(1&lt;&lt;20)
<br/>
    bpl    .for_SLOT2                               @ }
<br/>
    add    r12, #(1&lt;&lt;20)
<br/>
    @-------
<br/>
    @ Save the final values for SLOT2
<br/>
    @-------
<br/>
    str    r4, [r0, #(ch0_slot1_env_sustain-SLOT1)] @ r4 = SLOT1 sustain level (MAX_ATT_INDEX if release phase)
<br/>
    str    r5, [r0, #(ch0_slot1_envelope-SLOT1)]    @ r5 = SLOT1 envelope value
<br/>
    str    r7, [r0, #(ch0_slot1_Cnt-SLOT1)]         @ r7 = SLOT2 Cnt value
<br/>
    str    r8, [r0, #(ch0_slot1_volume-SLOT1)]      @ r8 = SLOT2 volume value &lt;&lt; 16
<br/>
<br/>
    @-------
<br/>
    @ Go handle the next channel unless this was already the last channel.
<br/>
    @-------
<br/>
    add    r0, #SLOT_SIZE
<br/>
    add    lr, #(ADLIB_BUFFER_SIZE)
<br/>
    add    r12, #0x00010000                         @ channel++
<br/>
    and    r4, r12, #0x000F0000
<br/>
    tst    r12, #4                                  @ Do we have rhythm mode on?
<br/>
    moveq  r5, #0x00080000                          @ Nope, handle 9 melodic channels
<br/>
    movne  r5, #0x00060000                          @ Yep, handle 6 melodic channels
<br/>
    cmp    r4, r5
<br/>
    blt    .for_channel
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Pate<br/>_________________<br/><ul><li>Now working on DSx86 <a href="http://dsx86.patrickaalto.com" target="_blank">http://dsx86.patrickaalto.com</a>
<br/>
</li><li>Get LineWarsDS from <a href="http://linewars.patrickaalto.com" target="_blank">http://linewars.patrickaalto.com</a></li></ul></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170295 - Ruben - Wed Sep 16, 2009 6:54 am</h4>
    <div class="postbody"><span class="postbody">I'm not sure if I'm reading this correctly (as I don't understand what you mean by 'slot') but.. are you calculating the envelopes *during* mixing? If so, that will bloat your code a lot: calculate the final scaling value *before* entering the mix loop.
<br/>
<br/>
Also, I see you using a lot of "tst/cmp" inside the mixing loop. If the values in the registers are constant, then I would suggest making separate loops for each condition, to avoid testing during the mixing.
<br/>
<br/>
Also, conditionals are t3h r0ckz0rrz ^_^'
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ Old code
<br/>
.for_SLOT1:
<br/>
    strh   r3, [lr], #2
<br/>
    add    r2, r9, r8, lsr #16
<br/>
    tst    r12, #(7&lt;&lt;(8+5))
<br/>
    moveq  r1, r7, lsr #16
<br/>
    beq    .op1_no_feedback
<br/>
        mov    r1, r12, lsr #(8+5)
<br/>
        and    r1, #7
<br/>
        add    r1, r7, r3, asr r1
<br/>
        lsr    r1, #16
<br/>
.op1_no_feedback:
<br/>
<br/>
@ New code
<br/>
<br/>
.for_SLOT1:
<br/>
    strh   r3, [lr], #2
<br/>
    add    r2, r9, r8, lsr #16
<br/>
    tst    r12, #(7&lt;&lt;(8+5))
<br/>
    moveq  r1, r7, lsr #16
<br/>
        movne  r1, r12, lsr #(8+5)
<br/>
        andne  r1, #7
<br/>
        addne  r1, r7, r3, asr r1
<br/>
        lsrne  r1, #16</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170296 - Pate - Wed Sep 16, 2009 7:09 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ruben wrote:</b></span></td> </tr> <tr> <td class="quote">I'm not sure if I'm reading this correctly (as I don't understand what you mean by 'slot') but.. are you calculating the envelopes *during* mixing?</td> </tr></table><span class="postbody">
<br/>
<br/>
Well, the envelope can change during mixing (like going from attack to decay and then to sustain can all happen within 256 samples), but I see what you mean. I could probably handle each stage separately, if needed.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Also, I see you using a lot of "tst/cmp" inside the mixing loop. If the values in the registers are constant, then I would suggest making separate loops for each condition, to avoid testing during the mixing.</td> </tr></table><span class="postbody">
<br/>
<br/>
Ah, of course! Why didn't I think of that.. I most likely need to test the volume for each sample, but the feedback level and connection mode will stay constant, so having 4 different loops (one for each case) will most likely shave off a lot of cycles!  Many many thanks for this tip!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Also, conditionals are t3h r0ckz0rrz ^_^'
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Really? I mean, even 4 commands is faster to do using conditional execution rather than a branch? I thought the limit was somewhere around 2-3.. What is the number for switching to a branch instead?
<br/>
<br/>
Much thanks again! I feel confident that even that single change will make my code handle all 9 channels without problems. Looking forward to getting home from work so I can start coding it! :-)
<br/>
<br/>
Pate<br/>_________________<br/><ul><li>Now working on DSx86 <a href="http://dsx86.patrickaalto.com" target="_blank">http://dsx86.patrickaalto.com</a>
<br/>
</li><li>Get LineWarsDS from <a href="http://linewars.patrickaalto.com" target="_blank">http://linewars.patrickaalto.com</a></li></ul></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170297 - Ruben - Wed Sep 16, 2009 7:13 am</h4>
    <div class="postbody"><span class="postbody">Well, a branch is 3 cycles. And you've got "tst, moveq, beq" followed by 4 instructions of the opposite condition. If the condition was 0, then it would take 4 cycles + 1 for the tst, and 6 cycles + 1 for the tst in the other case. Without the branch it would be 5 cycles + 1 for the tst, which is in between, so it's a nice eq/ne trade-off.
<br/>
<br/>
EDIT:
<br/>
<br/>
On further inspection:
<br/>
<br/>
After the tst, you've got 4 cycles if it was 0. If it was not 0, then you've got 5 cycles. In short, you can keep the beq to make it faster if it was 0, or keep the conditionals to 'level out' the speed.
<br/>
<br/>
EDIT 2:
<br/>
<br/>
On further inspection again...
<br/>
<br/>
After the test, if the condition was 0, it would take 4 cycles. If it wasn't 0, then you've got *six* cycles, so yes, I would say to get rid of the branch to have a trade-off.</span><span class="gensmall"><br/><br/>Last edited by Ruben on Thu Sep 17, 2009 7:14 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#170305 - Miked0801 - Wed Sep 16, 2009 2:46 pm</h4>
    <div class="postbody"><span class="postbody">I see quite a few mov / tst / lsr type ops.  These almost always can be incorporated into arithmetic ops and removed.  Also, you are working with halfwords - anyway to up that to 32-bits and better take advantage of your CPU (and probably bus size)?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170312 - Pate - Wed Sep 16, 2009 3:57 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">I see quite a few mov / tst / lsr type ops.  These almost always can be incorporated into arithmetic ops and removed.</td> </tr></table><span class="postbody">
<br/>
Hmm.. Can you give an example? I'm just learning ARM ASM, so all tricks are appreciated!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"> Also, you are working with halfwords - anyway to up that to 32-bits and better take advantage of your CPU (and probably bus size)?</td> </tr></table><span class="postbody">
<br/>
<br/>
Like doing 2 samples at a time? That might be worth trying. I tried to fit everything I need in the inner loops into registers, but I would run out of registers when trying to do two samples at the same time.
<br/>
<br/>
Btw, I managed now to have all 9 channels running, after doing the separate loops as suggested by Ruben, and unrolling the inner loops once (so I only test for buffer end once every two samples). I could probably also safely skip the envelope checks and new volume calculation for every second sample.
<br/>
<br/>
Anyways, it is starting to look like this might actually work, thanks again for your help!
<br/>
<br/>
Pate<br/>_________________<br/><ul><li>Now working on DSx86 <a href="http://dsx86.patrickaalto.com" target="_blank">http://dsx86.patrickaalto.com</a>
<br/>
</li><li>Get LineWarsDS from <a href="http://linewars.patrickaalto.com" target="_blank">http://linewars.patrickaalto.com</a></li></ul></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170314 - Ruben - Wed Sep 16, 2009 4:14 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Hmm.. Can you give an example? I'm just learning ARM ASM, so all tricks are appreciated!</td> </tr></table><span class="postbody">
<br/>
Most of the stuff on there is pretty well optimized in this sense, but he means something like
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ Eep, slow
<br/>
mov r0, r1, asr #5
<br/>
add r3, r0, r3
<br/>
<br/>
@ Yay, one opcode faster ^_^'
<br/>
add r3, r3, r1, asr #5</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Like doing 2 samples at a time?</td> </tr></table><span class="postbody">
<br/>
Probably. Depends on if you're using stereo or not. If you're not using stereo, then yes, 2 samples at once, thereby avoiding using 2 costly stores and replace it with 1.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I could probably also safely skip the envelope checks and new volume calculation for every second sample. </td> </tr></table><span class="postbody">You probably could and if you can, you should: if you have played any Japan-originating GBA game that use the 'Sappy' engine, pay attention to the envelopes: these are only updated once per *frame* and it's barely noticeable, so I think you can 'afford' to do this outside of the mixing loop.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170335 - Pate - Thu Sep 17, 2009 5:10 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ruben wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Like doing 2 samples at a time?</td> </tr></table><span class="postbody">
<br/>
Probably. Depends on if you're using stereo or not. If you're not using stereo, then yes, 2 samples at once, thereby avoiding using 2 costly stores and replace it with 1.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, I'm using mono (stereo in the AdLib/SoundBlaster world means having 2 OPL2 chips, each with their own 9 channels/18 operators, so that is pretty much out of reach with ARM7). And, I am already keeping two samples for slot1 in r3 register, where the high halfword is the previous sample and low halfword is the current sample. I'll just need to swap the meaning of those and store the full word, should be a straightforward change. I'll see if something similar could be done with slot2.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">You probably could and if you can, you should: if you have played any Japan-originating GBA game that use the 'Sappy' engine, pay attention to the envelopes: these are only updated once per *frame* and it's barely noticeable, so I think you can 'afford' to do this outside of the mixing loop.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, I'll have to see what effect that has. In the original code from DosBox that I am using as an example, the attack envelope does a table lookup and a MULTIPLY operation for each sample!
<br/>
<br/>
Edit: Actually, the DosBox emulator does a table lookup and multiply at 50000Hz per slot, so at 16384Hz I should do that 3 times per sample to make my code work exactly like the DosBox one. I don't think I will, though. :-)
<br/>
<br/>
Thanks for your tips again, it is very useful to hear other people's optimization ideas, you become so blind to problems in your own code.
<br/>
<br/>
Pate<br/>_________________<br/><ul><li>Now working on DSx86 <a href="http://dsx86.patrickaalto.com" target="_blank">http://dsx86.patrickaalto.com</a>
<br/>
</li><li>Get LineWarsDS from <a href="http://linewars.patrickaalto.com" target="_blank">http://linewars.patrickaalto.com</a></li></ul></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170352 - Pate - Fri Sep 18, 2009 4:57 am</h4>
    <div class="postbody"><span class="postbody">I worked on the code again a bit yesterday, looks like handling two samples at a time is pretty easy for both slots. Thanks again for the idea!
<br/>
<br/>
When I want to replace the low halfword of register r3 with the value in r1, is this the optimal code?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
lsr r3, #16
<br/>
orr r3, r1, r3, lsl #16
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
How about when I need to add a halfword to the low halfword, without affecting the high halfword. Is this the best that can be done?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
ror r3, #16
<br/>
add r3, r1, lsl #16
<br/>
ror r3, #16
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The latter does not look very efficient, but I couldn't figure out a better way to do it...
<br/>
<br/>
Thanks!
<br/>
<br/>
Pate<br/>_________________<br/><ul><li>Now working on DSx86 <a href="http://dsx86.patrickaalto.com" target="_blank">http://dsx86.patrickaalto.com</a>
<br/>
</li><li>Get LineWarsDS from <a href="http://linewars.patrickaalto.com" target="_blank">http://linewars.patrickaalto.com</a></li></ul></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170354 - Ruben - Fri Sep 18, 2009 4:03 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">lsr r3, #16
<br/>
orr r3, r1, r3, lsl #16</td> </tr></table><span class="postbody">
<br/>
Yes, I think that's the best you can get it to.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ror r3, #16
<br/>
add r3, r1, lsl #16
<br/>
ror r3, #16</td> </tr></table><span class="postbody">
<br/>
Let's look at that again...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ror r3, #16         @ DDDDxxxx
<br/>
add r3, r1, lsl #16 @ DDDD += r1
<br/>
ror r3, #16         @ xxxxDDDD
<br/>
<br/>
@ Basically, you want to add a value into
<br/>
@ DDDD, without affecting the upper hword.
<br/>
@ If you're going to be doing this twice,
<br/>
@ you can do this...
<br/>
<br/>
@ Sample 1: r3 swapped to DDDDxxxx
<br/>
mov r1, lsl #16
<br/>
add r3, r1, r3, ror #16
<br/>
<br/>
@ Sample 2: r3 swapped back to xxxxDDDD
<br/>
mov r1, lsl #16
<br/>
add r3, r1, r3, ror #16</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170392 - Pate - Mon Sep 21, 2009 4:58 am</h4>
    <div class="postbody"><span class="postbody">Okay, I guess it's time for an update...
<br/>
<br/>
First off, I only noticed last weekend that all the problems I was having were caused by my playing the SAME buffer that I wrote into, not the other buffer! Argh.. So much for that being the easy part. :-)
<br/>
<br/>
What threw me off was that for some peculiar reason No$GBA sounds better when writing to the wrong buffer! The real hardware warbled horribly while No$GBA sounded reasonably clean with only a few clicks now and then (which I then assumed was caused by the CPU lagging behind the buffer fill). Last weekend I finally noticed that something was badly wrong when even only 2 channels caused similar problems.
<br/>
<br/>
I then finally after many hours of head scratching found that I had the buffers wrong, and when I switched those, real hardware suddenly sounded completely clean, while No$GBA began warbling. Strange...
<br/>
<br/>
Anyways, I then added some checks for CPU load and noticed that at 16kHz my code only took 20% of ARM7 power to handle all 9 channels. So, I immediately upped the mixing speed to 32kHz, and now the code takes around 40% CPU, which I think is fine as I want the ARM7 to do other things besides the AdLib emulation as well.
<br/>
<br/>
I still have various problems in the code that I need to fix, but looks like I have a reasonable speed margin now to add the missing features.
<br/>
<br/>
Thanks again for all your tips!
<br/>
<br/>
Pate<br/>_________________<br/><ul><li>Now working on DSx86 <a href="http://dsx86.patrickaalto.com" target="_blank">http://dsx86.patrickaalto.com</a>
<br/>
</li><li>Get LineWarsDS from <a href="http://linewars.patrickaalto.com" target="_blank">http://linewars.patrickaalto.com</a></li></ul></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
