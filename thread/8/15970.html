<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ARM assembly questions - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > ARM assembly questions</h2>
<div id="posts">
<div class="post">
    <h4>#162045 - yellowstar - Sun Aug 24, 2008 1:19 am</h4>
    <div class="postbody"><span class="postbody">Does anybody know what the URL of the ARM946E-S reference manual is? For the instruction set and ect. And the ARM7TDMI manual, for the instruction set?</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Aug 25, 2008 12:26 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162046 - chuckstudios - Sun Aug 24, 2008 1:28 am</h4>
    <div class="postbody"><span class="postbody"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0201d/DDI0201D_arm946es_r1p1_trm.pdf" target="_blank">http://infocenter.arm.com/help/topic/com.arm.doc.ddi0201d/DDI0201D_arm946es_r1p1_trm.pdf</a>
<br/>
<br/>
and
<br/>
<br/>
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0029g/DDI0029.pdf" target="_blank">http://infocenter.arm.com/help/topic/com.arm.doc.ddi0029g/DDI0029.pdf</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162069 - yellowstar - Sun Aug 24, 2008 9:14 pm</h4>
    <div class="postbody"><span class="postbody">I didn't see any ARM architecture/instruction set description in those documents.(ARM9 atleast)
<br/>
All I saw was reference to a book. I want a .pdf, or something I can download/view on Internet.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162072 - kusma - Sun Aug 24, 2008 9:38 pm</h4>
    <div class="postbody"><span class="postbody">Sounds like you're looking for the <a class="postlink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0100i/index.html" target="_blank">ARM ARM</a>.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162073 - yellowstar - Sun Aug 24, 2008 11:28 pm</h4>
    <div class="postbody"><span class="postbody">Thanks kusma, that's exactly what I was looking for. Nothing about swile in this either, just swi&lt;condition&gt;... Does swile mean execute this swi instruction only if the two values compared with last, if like say: val1 &lt;= val2?(This is in the Arm9 loader, the first piece of assembly run before anything else)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162074 - kusma - Sun Aug 24, 2008 11:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">Thanks kusma, that's exactly what I was looking for. Nothing about swile in this either, just swi&lt;condition&gt;... Does swile mean execute this swi instruction only if the two values compared with last, if like say: val1 &lt;= val2?(This is in the Arm9 loader, the first piece of assembly run before anything else)</td> </tr></table><span class="postbody">
<br/>
<br/>
swile = swi + "le" (less or equal) condition, yeah.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162076 - yellowstar - Mon Aug 25, 2008 12:25 am</h4>
    <div class="postbody"><span class="postbody">In this loader, I see this:(I'm reversing the Nintendo Spot client, from the TSUTAYA Japanese game store) (I'm using a dissassembly from dsd, not obj-dump. Obj-dump seems to produce a different dissassembly, at least for the addresses in the left column. dsd seems to use addresses in the .nds, while obj-dump seems to do addresses for where it would be for a address when running on DS, like in RAM.)
<br/>
<br/>
*Thumb assembly disassembled as ARM removed*
<br/>
<br/>
These oprands for the swile instructions don't look anything like any id in the BIOS/swi table... They look more look addresses to jump to directly in the BIOS, or jump to assembly that then jumps to the actual assembly to be executed. Is this correct? Any idea what these do? I don't have a ARM9 BIOS dump... :\ I can't dump it myself either, I still don't have a flash card. At 0x00004C5C, I see more andeq instructions. Is this the end of the loader? Is the actual assembly for the binary,(not the loader)
<br/>
the assembly that follows these many nop/andeq instructions?(This assembly begins at 00007000)</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:15 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162077 - tepples - Mon Aug 25, 2008 1:24 am</h4>
    <div class="postbody"><span class="postbody">Are you sure those aren't Thumb?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162080 - yellowstar - Mon Aug 25, 2008 2:58 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Are you sure those aren't Thumb?</td> </tr></table><span class="postbody">
<br/>
I don't know for sure. Isn't dsd and obj-dump supposed to detect Thumb/ARM automatically?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162081 - Cydrak - Mon Aug 25, 2008 4:05 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">I don't know for sure. Isn't dsd and obj-dump supposed to detect Thumb/ARM automatically?</td> </tr></table><span class="postbody">
<br/>
The ARM/THUMB distinction is made at runtime. That is, there's no flag in the instructions themselves. The compiler and linker have to keep track, but the info is probably stripped when building the .NDS. So how would you suggest to do it?
<br/>
<br/>
Since you have is a raw binary, the disassembler knows nothing. Teasing apart the pile of code and data is your job. ;-) Of course it can be done, but "reversing" is serious and somewhat specialised work. Expect to spend a lot of time, even if you're comfortable with assembler...
<br/>
<br/>
Anyhow, that's definitely THUMB, but not very interesting code. (See ARM ARM sec 6.2 and look up 0x4770 in the table. If you know what the result is for--as well you should if you're trying this--you'll soon learn to like it. :P)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162082 - yellowstar - Mon Aug 25, 2008 4:28 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">I don't know for sure. Isn't dsd and obj-dump supposed to detect Thumb/ARM automatically?</td> </tr></table><span class="postbody">
<br/>
The ARM/THUMB distinction is made at runtime. That is, there's no flag in the instructions themselves. The compiler and linker have to keep track, but the info is probably stripped when building the .NDS. So how would you suggest to do it?
<br/>
<br/>
Since you have is a raw binary, the disassembler knows nothing. Teasing apart the pile of code and data is your job. ;-) Of course it can be done, but "reversing" is serious and somewhat specialised work. Expect to spend a lot of time, even if you're comfortable with assembler...
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
I thought there was a flag in some instructions signifying whether or not the instruction, and the following instructions, were switched to ARM/Thumb instruction sets? I read that in ARM ARM... Wouldn't Nintendo be stuck with with just Thumb/ARM if the instruction set flag was stripped from the instructions, by there assembler/linker?(The processor wouldn't know whether the code was ARM/Thumb)
<br/>
<br/>
EDIT:
<br/>
But I guess those instructions aren't present at the start of the Arm9 binary in this loader... If those flags really are stripped, that would mean tedious work trying to find if each opcode is ARM, or Thumb...(If those instruction sets are mixed together)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162084 - Cydrak - Mon Aug 25, 2008 5:39 am</h4>
    <div class="postbody"><span class="postbody">The processor doesn't "know" either. It boots in ARM mode, and the BIOS code starts that way too, so it works out. Specific instructions (mainly BX) can switch in and out of THUMB. It's usually done as part of a function call.
<br/>
<br/>
ARM and THUMB are rarely ever mixed within a function, since a switch is required.
<br/>
<br/>
Distinguishing ARM, THUMB and data isn't really the hardest part, if you've written much assembler. Data, or code in the opposite mode should just "feel" wrong. It looks repetitive or random, and often does things that are useless or would obviously crash. (There's three or four of those in your snippet alone!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162107 - yellowstar - Mon Aug 25, 2008 10:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Distinguishing ARM, THUMB and data isn't really the hardest part, if you've written much assembler. Data, or code in the opposite mode should just "feel" wrong. It looks repetitive or random, and often does things that are useless or would obviously crash. (There's three or four of those in your snippet alone!)</td> </tr></table><span class="postbody">
<br/>
Which instructions? I wonder what ldrmib, andcs, and stcne do... I can't find anything in ARM ARM... What does the mib condition mean?(Yeah, this isn't the correct dissassembly, but since these seem to be real instructions, and and I can't finding anything in ARM ARM, I'd like to know what they do)
<br/>
<br/>
So I basically need to determine the instruction set for each function, and then manually disassemble the opcode for the correct instruction set. Wonder if there's any free disassemblers for NDS/Armv5 that can disassemble on select regions of opcodes for a selected instruction set... I tried using <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=116833#116833" target="_blank">this</a> to disassemble the whole .nds, but that didn't have a perfect dissassembly, and it's not open-source either.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162109 - Cearn - Mon Aug 25, 2008 11:52 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Distinguishing ARM, THUMB and data isn't really the hardest part, if you've written much assembler. Data, or code in the opposite mode should just "feel" wrong. It looks repetitive or random, and often does things that are useless or would obviously crash. (There's three or four of those in your snippet alone!)</td> </tr></table><span class="postbody">
<br/>
Which instructions? I wonder what ldrmib, andcs, and stcne do... I can't find anything in ARM ARM... What does the mib condition mean? 
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
Like <span style="font-style: italic">swile</span>, it's not <span style="font-style: italic">ldrmib</span>, <span style="font-style: italic">andcs</span>, or <span style="font-style: italic">stcne</span> instructions, but <span style="font-style: italic">ldr-mi-b</span>, <span style="font-style: italic">and-cs</span> and <span style="font-style: italic">stc-ne</span>, meaning 'load byte is negative', 'and if carry set' and store coprocessor if not equal'. You'll only find the stem of the instructions in an instruction set, without adornments, much like you would only find the infinitive of a verb in a dictionary and not its conjugations. GBATek has a useful <a class="postlink" href="http://nocash.emubase.de/gbatek.htm#arminstructionsummary" target="_blank">summary of the instructions</a>, and how they are composed.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">(Yeah, this isn't the correct dissassembly, but since these seem to be real instructions, and and I can't finding anything in ARM ARM, I'd like to know what they do)
<br/>
</td> </tr></table><span class="postbody">Instructions are just an interpretation of binary data. Any set of words can be disassembled to (mostly) valid instructions -- you could even disassemble a bitmap or sound-file into ARM instructions, or vice versa. However, what you get from such an attempt will basically be meaningless unless your chosen interpretation matches the one intended by the author. This is an important point to realize when dealing with binary data manually.
<br/>
<br/>
Like Cydrak mentioned, you can generally tell if you have the right interpretation once the stuff starts to make some kind of sense. Your data, when interpreted as ARM code, doesn't. In Thumb, it looks like a set of functions for calling software interrupts. Something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
...
<br/>
    swi     0x05
<br/>
    bx      lr
<br/>
    swi     0x06
<br/>
    bx      lr
<br/>
    swi     0x09
<br/>
    bx      lr
<br/>
...
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">So I basically need to determine the instruction set for each function, and then manually disassemble the opcode for the correct instruction set. Wonder if there's any free disassemblers for NDS/Armv5 that can disassemble on select regions of opcodes for a selected instruction set... I tried using <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=116833#116833" target="_blank">this</a> to disassemble the whole .nds, but that didn't have a perfect dissassembly, and it's not open-source either.</td> </tr></table><span class="postbody">
<br/>
I haven't tried this yet, but it seems obj-dump can be set to produce Thumb code with the -M switch (look it up in the <a class="postlink" href="http://www.delorie.com/gnu/docs/binutils/binutils_6.html" target="_blank">obj-dump manual</a>. You could also try loading it as data in an emulator and see what its disassembler makes of it. Desmume's disassembler, for example, lets you switch the view between instruction sets, although it unfortunately doesn't seem to let you save it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162110 - yellowstar - Tue Aug 26, 2008 12:29 am</h4>
    <div class="postbody"><span class="postbody">How do I convert an .nds to an .elf, for using obj-dump? Obj-dump can only use .elf - I tried using .nds before, and I got error "file format not recognized".(That is, does anyone know of a tool to convert the Arm7/9 binaries in an .nds to .elf?)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162111 - tepples - Tue Aug 26, 2008 12:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">I don't know for sure. Isn't dsd and obj-dump supposed to detect Thumb/ARM automatically?</td> </tr></table><span class="postbody">
<br/>
The ARM/THUMB distinction is made at runtime. That is, there's no flag in the instructions themselves. The compiler and linker have to keep track, but the info is probably stripped when building the .NDS. So how would you suggest to do it?</span></td> </tr></table><span class="postbody">
<br/>
Some NES emulators can log which bytes are opcodes and which are data. So why not make a GBA or DS emulator that can log which mode a piece of code was executed in?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162112 - tepples - Tue Aug 26, 2008 12:50 am</h4>
    <div class="postbody"><span class="postbody">Try extracting the ARM9 segment and playing with it in arm-eabi-objcopy, taking note of its --set-start option.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162117 - Cydrak - Tue Aug 26, 2008 2:14 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Some NES emulators can log which bytes are opcodes and which are data. So why not make a GBA or DS emulator that can log which mode a piece of code was executed in?</td> </tr></table><span class="postbody">
<br/>
Whoa! So this is <span style="font-style: italic">really</span> a viable option for most people? ;-) I guess patching Desmume is still easier than static analysis...
<br/>
<br/>
My (rhetorical) question was how an automatic tool like objdump, which obviously has no compile-time or run-time information could be expected to do it (as yellowstar assumed). The emulator solution requires a human to play through the game. While there's nothing wrong with that--IDA is interactive too, and an amazing tool if the free version is any indication--it's quite another thing, isn't it? &gt;_&gt;
<br/>
&lt;/verbose&gt;
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">How do I convert an .nds to an .elf, for using obj-dump?</td> </tr></table><span class="postbody">
<br/>
By hand, I imagine? Well, you shouldn't need to. After extracting the ARM9 binary with ndstool (-x, -9 options IIRC), tell arm-eabi-objdump to use "binary" format and "arm" architecture (-b, -m switches respectively). "-M force-thumb" and "-M reg-names-std" may also be helpful.
<br/>
<br/>
At this point, if you have more than (say) 32-64KB of binary you won't want to disassemble it all--it will be quite unwieldy and old computers tend to choke on it. Instead, just give objdump the address range you want to work with. I haven't done much with large binaries... but as for finding the right spots, all I can say is: take notes, keep a good eye out, and spend some quality time with a hex editor.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162119 - yellowstar - Tue Aug 26, 2008 2:30 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
After extracting the ARM9 binary with ndstool (-x, -9 options IIRC)
<br/>
<br/>
At this point, if you have more than (say) 32-64KB of binary you won't want to disassemble it all--it will be quite unwieldy and old computers tend to choke on it. Instead, just give objdump the address range you want to work with.</td> </tr></table><span class="postbody">
<br/>
Those ndstool parameters didn't do anything. Not a really big problem, I can add some code to Wmb Asm to dump the Arm7/9.(And write custom software to do it, if the need ever arises)
<br/>
<br/>
EDIT:
<br/>
I have successfully dumped the Arm7/9 binaries.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162122 - yellowstar - Tue Aug 26, 2008 2:57 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
arm-eabi-objdump -b -m -M force-thumb -d -S arm9.bin &gt;arm9.s
<br/>
arm-eabi-objdump: arm9.bin: Invalid bfd target
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162135 - Kyoufu Kawa - Tue Aug 26, 2008 7:13 pm</h4>
    <div class="postbody"><span class="postbody">Me, I use IDA. Once you declare a certain offset to contain ARM or Thumb code, it'll spread out through the branches and use the off-by-one rule to determine when to switch. Of course, this works best if you hit crt0 or the main() routine.
<br/>
<br/>
So yeah, I like IDA.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162147 - yellowstar - Tue Aug 26, 2008 10:06 pm</h4>
    <div class="postbody"><span class="postbody">IDA Pro costs ~$500... And I'm not risking losing my reverse engineering progress, assembly comments, ect, on a 30-day trial.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162150 - tepples - Tue Aug 26, 2008 10:48 pm</h4>
    <div class="postbody"><span class="postbody">We already saw what happened to MoonShell. The developer switched to a trial version of a non-libre non-gratis compiler, and when it expired, MoonShell fell unmaintained.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162178 - chishm - Wed Aug 27, 2008 1:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
arm-eabi-objdump -b -m -M force-thumb -d -S arm9.bin &gt;arm9.s
<br/>
arm-eabi-objdump: arm9.bin: Invalid bfd target
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
You almost had it. I'd write the correct code, but it seems I <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=69834#69834" target="_blank">already</a> <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=81687#81687" target="_blank">have</a>.<br/>_________________<br/><a class="postlink" href="http://chishm.drunkencoders.com" target="_blank">http://chishm.drunkencoders.com</a>
<br/>
<a class="postlink" href="http://dldi.drunkencoders.com" target="_blank">http://dldi.drunkencoders.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162192 - yellowstar - Wed Aug 27, 2008 8:40 pm</h4>
    <div class="postbody"><span class="postbody">Thanks chishm, that seems to have worked.
<br/>
*Thumb dissassembly removed*
<br/>
Now I need to lookup these instructions and begin reversing. :-)
<br/>
Two more questions. I have attempted to disassemble Wii Nintendo Channel earlier. CPU is a PowerPC processor, Broadway, based on the Ganecube's Gekko, based on PPC 750, or some model in that range. I know I have the correct .dol. I converted the .dol to .elf with doltool. I attempted to disassemble the binary with obj-dump. However, I see ... in some places throughout the disassembly. And I see another ... at the end of the disassembly. What does the ... from obj-dump mean? Also, would anyone happen to know the link to the ARM926EJ-S ARM?(It's the hidden processor in the Wii, known as Starlet, which runs IOS.)</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:17 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162194 - Cydrak - Wed Aug 27, 2008 9:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">Now I need to lookup these instructions and begin reversing. :-) </td> </tr></table><span class="postbody">
<br/>
Actually, if you have to look them up, then I think you need to spend a few solid months learning to read and write ARM assembler. It may also help to disassemble small programs you compiled yourself. This way you can recognize what the compiler does to different sorts of code, and see what the programmer might have intended.
<br/>
<br/>
So, have you written much ASM? If not, let me put this another way. What you're proposing would be like trying to comprehend, say, a French poem--without having ever spoke French, much less lived anywhere near France. Sure, you could try, but it would not only be highly confusing; understanding a few words is <span style="font-style: italic">worlds</span> away from understanding the metaphors and cultural context. So, if you succeeded, you'd still spend the extra time to study and learn some French in the process, whether you wanted to or not.
<br/>
<br/>
Yeah, the challenge is interesting, but why make it next to impossible? What you're trying to do sounds like no fun at all. :|
<br/>
<br/>
Btw, I think the code near the bottom (which wasn't in your original listing) uses ARM instructions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162202 - yellowstar - Thu Aug 28, 2008 12:04 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">Now I need to lookup these instructions and begin reversing. :-) </td> </tr></table><span class="postbody">
<br/>
Actually, if you have to look them up, then I think you need to spend a few solid months learning to read and write ARM assembler. It may also help to disassemble small programs you compiled yourself. This way you can recognize what the compiler does to different sorts of code, and see what the programmer might have intended.
<br/>
<br/>
So, have you written much ASM? If not, let me put this another way. What you're proposing would be like trying to comprehend, say, a French poem--without having ever spoke French, much less lived anywhere near France. Sure, you could try, but it would not only be highly confusing; understanding a few words is <span style="font-style: italic">worlds</span> away from understanding the metaphors and cultural context. So, if you succeeded, you'd still spend the extra time to study and learn some French in the process, whether you wanted to or not.
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
I hardly wrote any assembler at all... I wrote a tiny amount of asm, but that isn't really enough. I successfully reversed engineered a x86 crack me, learning the instructions as I went, but that was easy since the program was simple and it was rather obvious where code which checks the key input by the user was.(IDA Free, which is restricted to only x86, program flow map) Of course NDS reverse engineering is way different, and this is actually an real challenge, not something easy.(There are much harder crack mes on that web site, but I got bored of it - I wanted to RE console/hand held software, not PC stuff.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162206 - yellowstar - Thu Aug 28, 2008 2:04 am</h4>
    <div class="postbody"><span class="postbody">Here's the dissassembly of the section mentioned earlier disassembled in ARM:
<br/>
*dasm removed*
<br/>
This appears to be valid ARM asm. Dissassembling starting at 0x84e seems to produce nonsense. What's this ip register? I never heard of a ip register on ARM. I couldn't find anything in ARM ARM either. I know about the x86 ip instruction pointer register, however. What is the ARM ip register used for?
<br/>
<br/>
Here's the dissassembly that appears to be nonsense, imo.
<br/>
*dasm removed*
<br/>
<br/>
EDIT:
<br/>
Apparently address 0x4000000 is REG_DISPCNT... So is ip a general purpose register, or something else?</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:19 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162210 - tepples - Thu Aug 28, 2008 3:12 am</h4>
    <div class="postbody"><span class="postbody">Every register but r13-r15 (sp, lr, pc) is "general purpose".
<br/>
<br/>
'ip' is the Cispa word for "past", but on ARM it means r12, one of the five general-purpose registers that a procedure is allowed to change before returning. (The others are r0-r3, which hold arguments.)<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162230 - Cearn - Thu Aug 28, 2008 10:42 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cydrak wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">Now I need to lookup these instructions and begin reversing. :-) </td> </tr></table><span class="postbody">
<br/>
Actually, if you have to look them up, then I think you need to spend a few solid months learning to read and write ARM assembler. It may also help to disassemble small programs you compiled yourself. This way you can recognize what the compiler does to different sorts of code, and see what the programmer might have intended.
<br/>
<br/>
So, have you written much ASM? If not, let me put this another way. What you're proposing would be like trying to comprehend, say, a French poem--without having ever spoke French, much less lived anywhere near France. Sure, you could try, but it would not only be highly confusing; understanding a few words is <span style="font-style: italic">worlds</span> away from understanding the metaphors and cultural context. So, if you succeeded, you'd still spend the extra time to study and learn some French in the process, whether you wanted to or not.</span></td> </tr></table><span class="postbody">
<br/>
Cydrak's righ ... no, let's do this differently. 
<br/>
Cydrak heeft gelijk. Een tekst begrijpen is meer dan alleen de woorden kunnen lezen. Als je de grammatica of algemene uitdrukkingen niet kent  weet je eigenlijk nog niks. Dit geldt nog sterker voor assembly-&gt;C conversie. Zelf als je beide talen goed begrijpt is het een lastig karwei om te zien wat er gaande is, omdat een C-expressie vaak meerdere instructies in beslag neemt en omdat de context van de functies en data waarschijnlijk nog onduidelijk zal zijn.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">This appears to be valid ARM asm. Dissassembling starting at 0x84e seems to produce nonsense. What's this ip register? I never heard of a ip register on ARM. I couldn't find anything in ARM ARM either.</td> </tr></table><span class="postbody">
<br/>
IP, and a few other identifiers, are aliases that GCC likes to use. 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> std | alt
<br/>
-----+-----
<br/>
 r0  | a1
<br/>
 r1  | a2
<br/>
 r2  | a3
<br/>
 r3  | a4
<br/>
 r4  | v1
<br/>
 r5  | v2
<br/>
 r6  | v3
<br/>
 r7  | v4
<br/>
 r8  | v5
<br/>
 r9  | v6
<br/>
 r10 | v7 / sl
<br/>
 r11 | v8 / fp
<br/>
 r12 | ip
<br/>
 r13 | sp 
<br/>
 r14 | lr
<br/>
 r15 | pc
<br/>
</td> </tr></table><span class="postbody">
<br/>
Don't rely on just one document; as you can see it might not have all the information, or be too technical for what you're doing. Also look at the <a class="postlink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042b/IHI0042B_aapcs.pdf" target="_blank">Arm Architecture Procedure Call Standard</a>, and <a class="postlink" href="http://nihilisme.ca:8080/arm/doc/DAI0034vA.pdf" target="_blank">Writing Efficient C for ARM</a> and, oh what the hell why not, <a class="postlink" href="http://www.coranac.com/tonc/text/asm.htm" target="_blank">Tonc's chapter on assembly</a>. If you don't already have a printed copy of the ARM/Thumb quickreference sheets, I'd advise you to get one of those too. 
<br/>
<br/>
Also compile some of the C code you have with -save-temps (and with optimization at -O1 or -O2 but <span style="font-style: italic">without</span> -g; the extra debugging information makes things hard to read), which will make GCC output the generated assembly for the C files in your project. Examining this gives you a better understanding of the things you may come across.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">Here's the disassembly that appears to be nonsense, imo.
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">0000084e &lt;.data+0x84e&gt;:
<br/>
     84e:   c3010000    movwgt   r0, #4096   ; 0x1000
<br/>
     852:   c208e3a0    andgt   lr, r8, #-2147483646   ; 0x80000002
<br/>
     856:   00b6e58c    adceqs   lr, r6, ip, lsl #11
<br/>
     85a:   0000e1dc    ldreqd   lr, [r0], -ip </td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
What you have here is a <a class="postlink" href="http://ghr.nlm.nih.gov/handbook/illustrations/frameshift" target="_blank">frame shift</a>. ARM instructions are always put on word boundaries. You can't start in the middle of an instruction and expect to see something sensible.
<br/>
<br/>
It's unfortunate that everything here uses decimal numbers. In hex, it's clearer what memory the code is accessing. I'm guessing the code does something like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">00000850 &lt;.data+0x850&gt;:
<br/>
     850:   e3a0c301    mov   ip, #67108864         @ REG_BASE
<br/>
     854:   e58cc208    str   ip, [ip, #0x0208]      @ REG_IME= 0
<br/>
.LwaitForVDraw:
<br/>
     858:   e1dc00b6    ldrh   r0, [ip, #0x0006]   @ REG_VCOUNT
<br/>
     85c:   e3500000    cmp   r0, #0   ; 0x0
<br/>
     860:   1afffffc    bne   .LwaitForVDraw
<br/>
     
<br/>
     864:   eb000097    bl   0xac8
<br/>
<br/>
   @ --- Init sp_svc ---            
<br/>
     868:   e3a00013    mov   r0, #0x13
<br/>
     86c:   e121f000    msr   CPSR_c, r0         @ cpuMode= SWI (irq off)
<br/>
     870:   e59f00f0    ldr   r0, .L968
<br/>
     874:   e2800dff    add   r0, r0, #16320         @ 0x3fc0
<br/>
     878:   e1a0d000    mov   sp, r0            @ Set sp_svc
<br/>
<br/>
   @ --- Init sp_irq ---
<br/>
     87c:   e3a00012    mov   r0, #0x12
<br/>
     880:   e121f000    msr   CPSR_c, r0         @ cpuMode= IRQ
<br/>
     884:   e59f00dc    ldr   r0, .L968
<br/>
     888:   e2800dff    add   r0, r0, #16320         @ 0x3fc0
<br/>
     88c:   e2400040    sub   r0, r0, #64         @ 0x40
<br/>
     890:   e240d004    sub   sp, r0, #4            @ set sp_iqr
<br/>
     894:   e31d0004    tst   sp, #4
<br/>
     898:   024dd004    subeq   sp, sp, #4         @ Align to 8
<br/>
<br/>
    @ --- Init sp_usr ---
<br/>
     89c:   e59f10c8    ldr   r1, .L968+4         @ 
<br/>
     8a0:   e0401001    sub   r1, r0, r1
<br/>
     8a4:   e3a0001f    mov   r0, #0x1F 
<br/>
     8a8:   e12ff000    msr   CPSR_fsxc, r0       @ cpuMode= User
<br/>
<br/>
.L968:
<br/>
   .word   ???      // Base sp_irq address ?
<br/>
   .word   ???      // Base sp_usr address ?
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162258 - yellowstar - Thu Aug 28, 2008 8:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">This appears to be valid ARM asm. Dissassembling starting at 0x84e seems to produce nonsense. What's this ip register? I never heard of a ip register on ARM. I couldn't find anything in ARM ARM either.</td> </tr></table><span class="postbody">
<br/>
IP, and a few other identifiers, are aliases that GCC likes to use. 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> std | alt
<br/>
-----+-----
<br/>
 r0  | a1
<br/>
 r1  | a2
<br/>
 r2  | a3
<br/>
 r3  | a4
<br/>
 r4  | v1
<br/>
 r5  | v2
<br/>
 r6  | v3
<br/>
 r7  | v4
<br/>
 r8  | v5
<br/>
 r9  | v6
<br/>
 r10 | v7 / sl
<br/>
 r11 | v8 / fp
<br/>
 r12 | ip
<br/>
 r13 | sp 
<br/>
 r14 | lr
<br/>
 r15 | pc
<br/>
</td> </tr></table><span class="postbody">
<br/>
Don't rely on just one document; as you can see it might not have all the information, or be too technical for what you're doing. Also look at the <a class="postlink" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042b/IHI0042B_aapcs.pdf" target="_blank">Arm Architecture Procedure Call Standard</a>, and <a class="postlink" href="http://nihilisme.ca:8080/arm/doc/DAI0034vA.pdf" target="_blank">Writing Efficient C for ARM</a> and, oh what the hell why not, <a class="postlink" href="http://www.coranac.com/tonc/text/asm.htm" target="_blank">Tonc's chapter on assembly</a>. If you don't already have a printed copy of the ARM/Thumb quickreference sheets, I'd advise you to get one of those too. 
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
Thanks, Cearn and tepples.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Also compile some of the C code you have with -save-temps (and with optimization at -O1 or -O2 but <span style="font-style: italic">without</span> -g; the extra debugging information makes things hard to read), which will make GCC output the generated assembly for the C files in your project. Examining this gives you a better understanding of the things you may come across.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I'll do that.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
It's unfortunate that everything here uses decimal numbers. In hex, it's clearer what memory the code is accessing. I'm guessing the code does something like this:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
...
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
I reversed engineered that assembly myself. I didn't have the time to reverse engineer the rest of that since I was reading an ARM ASM tutorial, and other reasons.(I happened to find an <a class="postlink" href="http://patater.com/gbaguy/gba/ch5.htm" target="_blank">old gba arm asm tutorial</a> when I googled for address 0x4000000)</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:20 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162439 - yellowstar - Wed Sep 03, 2008 12:01 am</h4>
    <div class="postbody"><span class="postbody">Is there a manual somewhere explaining the Arm9/7 co-processor opcodes used in the mcr/mrc ARM instructions? What do Arm9 co-procsssor opcodes 0, 1, 2, 3, and 4 do?(I didn't find anything in the Arm9 manual linked to at the start of this topic)
<br/>
(I'll try reverse engineering a devkitARM .nds after I reverse engineer these official loaders)
<br/>
<br/>
*dasm removed*</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:20 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162441 - Cearn - Wed Sep 03, 2008 12:28 am</h4>
    <div class="postbody"><span class="postbody">It's in the DDI0201 paper chuckstudios linked to, but it's well hidden. The coprocessor you're looking for is CP15, which has to do with the TCM, cache and protection unit among other things. You can find an overview in Section 2.3 and other tidbits some of the chapters after it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162445 - yellowstar - Wed Sep 03, 2008 1:17 am</h4>
    <div class="postbody"><span class="postbody">Thanks Cearn.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162503 - yellowstar - Thu Sep 04, 2008 1:23 am</h4>
    <div class="postbody"><span class="postbody">*dasm removed*
<br/>
How are additional co-processor registers in mrc/mcr handled? These are the ID Code Register, and the Control Register. R0 is zero prior to this, so it can't be some kind of assembly pointer... And R0 and the Co-processor registers are 32-bit, so the Co-processor registers couldn't be squeezed into r0 directly... Is this moving cr1 into r0, then left-shifting r0 by cr0's value, or is it moving/loading cr1 into r0, then adding cr0 to r0, and storing the result in r0?</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:21 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#163632 - yellowstar - Tue Oct 07, 2008 2:59 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ARM ARM on SPR mode bits wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
A2.5.7 The mode bits
<br/>
M[4:0] are the mode bits. These determine the mode in which the processor operates. Their interpretation
<br/>
is shown in Table A2-2.
<br/>
Table A2-2 The mode bits
<br/>
M[4:0] Mode Accessible registers
<br/>
0b10000 User PC, R14 to R0, CPSR
<br/>
0b10001 FIQ PC, R14_fiq to R8_fiq, R7 to R0, CPSR, SPSR_fiq
<br/>
0b10010 IRQ PC, R14_irq, R13_irq, R12 to R0, CPSR, SPSR_irq
<br/>
0b10011 Supervisor PC, R14_svc, R13_svc, R12 to R0, CPSR, SPSR_svc
<br/>
0b10111 Abort PC, R14_abt, R13_abt, R12 to R0, CPSR, SPSR_abt
<br/>
0b11011 Undefined PC, R14_und, R13_und, R12 to R0, CPSR, SPSR_und
<br/>
0b11111 System PC, R14 to R0, CPSR (ARMv4 and above)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Is this real hex? Or is it values of the bits for each mode, with 0b pre-appended to each of these? Are the following comments I added to the Nintendo Spot Arm7 dissassembly correct?
<br/>
<br/>
*dasm removed*</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:22 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#163634 - tepples - Tue Oct 07, 2008 6:28 am</h4>
    <div class="postbody"><span class="postbody">Some languages (not standard C) use the prefix 0b for binary in the same way that C uses 0x for hexadecimal.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163661 - yellowstar - Wed Oct 08, 2008 3:41 am</h4>
    <div class="postbody"><span class="postbody">Does anyone know what addresses 0x4708434 - 0x4708594 and 0xFCffff3A - 0xFD00009A are used for? What values are stored at these addresses?
<br/>
<br/>
*dasm removed*</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:23 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#163678 - Cearn - Wed Oct 08, 2008 5:33 pm</h4>
    <div class="postbody"><span class="postbody">Are you sure you're reading it right? None of those addresses make much sense, so make sure you have your PC-relative offsets right. 
<br/>
<br/>
For example, this
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">      40:   e59f0090    ldr   r0, [pc, #144]   ; Sets r0 to 0xE0846005
<br/>
      44:   e1a0d000    mov   sp, r0          ; Sets mode IRQ's sp to r0,</td> </tr></table><span class="postbody">
<br/>
would set the stack to an odd value, which is <span style="font-style: italic">definitely</span> not allowed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163679 - Miked0801 - Wed Oct 08, 2008 5:39 pm</h4>
    <div class="postbody"><span class="postbody">Dunno, but how are you determining that r0 and r1 are being loaded with those funky values?  I'm guessing those are pool loads, but just checking.
<br/>
<br/>
0x04708434 would be well into mirrored I/O ports on Arm7 or Arm9
<br/>
0xFCFFFF3a should be access restricted.  It's very close to ARM-9 BIOS though which starts at 0xFFFF0000.  Copying 160 bytes makes me think that this is the bootup logo copy code, though I'm making a wild ass guess.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163687 - yellowstar - Wed Oct 08, 2008 11:44 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Dunno, but how are you determining that r0 and r1 are being loaded with those funky values?</td> </tr></table><span class="postbody">
<br/>
I used the address two instructions down from the instruction reading pc, then I added that address to the offset being used. Since XVI32 apparently handles everything in the data inspector as signed values, there is no unsigned option, I used a tool I wrote to find the hex and decimal of the value of the addresses I found from adding these addresses and offsets. 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I'm guessing those are pool loads, but just checking.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Well, all/most of the addresses loaded from seem to be inside a procedure... It's in Thumb however, and I haven't attempted disassembling it. I haven't disassembled or reversed engineered anything other than what I posted, so I'm not 100% sure.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Copying 160 bytes makes me think that this is the bootup logo copy code, though I'm making a wild ass guess.</td> </tr></table><span class="postbody">
<br/>
I said 0x160 bytes. In decimal that would be 352 bytes.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163707 - Miked0801 - Thu Oct 09, 2008 3:45 pm</h4>
    <div class="postbody"><span class="postbody">So no debugger info - no direct register inspection is possible?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163719 - Maxxie - Thu Oct 09, 2008 6:55 pm</h4>
    <div class="postbody"><span class="postbody">I'd guess that you did get the wrong content for the registers.
<br/>
<br/>
0xFCFFFF3a only makes sense when it is used in indirect addressing, which the code you think uses this address doesn't do.
<br/>
0xFCFFFF3A is -0x020000C4 which would make sense for a code address or offset to the arm7 bios or arm9 I/DTCM?
<br/>
<br/>
Actually the previous SP sets also point to the point that you are having the wrong content: 0xE0846005 is more likely an ARM opcode then it is the correct SP.
<br/>
<br/>
The code at 0x44 should grab the value from 0x44+0x08+0x90 = 0xDC
<br/>
0x5C from 0xE0
<br/>
0x60 from 0xE4<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163722 - Cearn - Thu Oct 09, 2008 7:15 pm</h4>
    <div class="postbody"><span class="postbody">The PC-relative loads seem to come from CCh onward. Could you post the data between, say, C0h and F0h? That might shed some light on things.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163731 - yellowstar - Thu Oct 09, 2008 10:38 pm</h4>
    <div class="postbody"><span class="postbody">Apparently I was obtaining the addresses from the wrong offset... I was adding the address two instructions below using the ldr instruction, plus the hex offset in the comment for the ldr instruction. (The comment was added by obj-dump) However, since obj-dump apparently attempts to calculate the offset automatically, so I only need to obtain the data at that offset, I got the wrong offset. However even obj-dump seemed to have failed at calculating the offset - for that Supervisor ldr sp instruction, it calculated 0xd4, while Maxxie calculated 0xdc. The former address contained at obj-dump's calculated offset wasn't aligned correctly, while Maxxie's was: 0x40000. I manually calculated this, and I got the same offset as obj-dump. The difference between Maxxie's offset and obj-dump is 8 bytes. Maxxie, I noticed that you started with address of the first instruction after the ldr sp instruction, not the actual ldr instruction. If this wasn't a mistake, why is this needed?(For ldr instructions loading into sp) *link removed* Here's the first 0x158 bytes of this Arm7 binary.</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:24 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#163747 - Maxxie - Fri Oct 10, 2008 7:46 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">Maxxie, I noticed that you started with address of the first instruction after the ldr sp instruction, not the actual ldr instruction. </td> </tr></table><span class="postbody">
<br/>
<br/>
That was a mistake, sorry.
<br/>
It is the pc of the ldr instruction (= address of the ldr instruction + prefetch size) + offset.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163771 - yellowstar - Fri Oct 10, 2008 8:22 pm</h4>
    <div class="postbody"><span class="postbody">I now get 0xc0ff8003 for Supervisor's sp, and 0x80ff8003 for IRQ's sp. I assume these are wrong since they are not 32-bit aligned, so what's the correct addresses, and where do those come from? Does anyone know what address used in the following dissassembly,  do/are used for?(I tried finding some of the addresses in gbatek, but I didn't really find anything...)
<br/>
<br/>
*dasm removed*</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:25 pm; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#163774 - Maxxie - Fri Oct 10, 2008 8:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">I now get 0xc0ff8003 for Supervisor's sp, </td> </tr></table><span class="postbody">
<br/>
<br/>
Wrong endianess:
<br/>
0xc0, 0xff, 0x80, 0x03 (in byte order) is 0x0380ffc0 (as little endian word) which is a valid and very plausible address on the arm7.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163777 - Cearn - Fri Oct 10, 2008 8:59 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">I now get 0xc0ff8003 for Supervisor's sp, and 0x80ff8003 for IRQ's sp. I assume these are wrong since they are not 32-bit aligned, so what's the correct addresses, and where do those come from? Does anyone know what address used in the following dissassembly,  do/are used for?(I tried finding some of the addresses in gbatek, but I didn't really find anything...)</td> </tr></table><span class="postbody">
<br/>
<br/>
Words and halfwords already have the endianness taken care of. 0380ff00 really is 0x0380ff00 and not 0x00FF8003.
<br/>
<br/>
The addresses do seem to relate to special areas. A cursory glance at GBATek gave me this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">023x:xxxx : Debugger RAM (?)
<br/>
027F:Fxxx : shared main RAM / personal data
<br/>
0280:xxxx : ???
<br/>
037F:xxxx : shared WRAM
<br/>
0380:Fxxx : ARM7-WRAM, stack locations
<br/>
<br/>
FFFF:xxxx : BIOS
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163779 - yellowstar - Fri Oct 10, 2008 10:27 pm</h4>
    <div class="postbody"><span class="postbody">Ah, obj-dump doesn't output "address: &lt;exact hex data from input&gt;", as I thought, it automatically outputs the the hex data as an 32-bit hex number. So manually decoding that data in the dissassembly is unneeded, which was producing those invalid addresses. The dissassembly in my previous post has been updated.
<br/>
<br/>
I found the answer to that mcr/mrc question.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gbatek wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
ARM CP15 Overview
<br/>
<br/>
...
<br/>
<br/>
CP15 Opcodes
<br/>
CP15 can be accessed via MCR and MRC opcodes, with Pn=P15, and &lt;cpopc&gt;=0.
<br/>
<br/>
  MCR{cond} P15,0,Rd,Cn,Cm,&lt;cp&gt;   ;move from ARM to CP15
<br/>
  MRC{cond} P15,0,Rd,Cn,Cm,&lt;cp&gt;   ;move from CP15 to ARM
<br/>
<br/>
Rd can be any ARM register in range R0-R14, R15 should not be used with P15.
<br/>
Cn,Cm,&lt;cp&gt; are used to select a CP15 register, eg. C0,C0,0 = Main ID Register.
<br/>
Other coprocessor opcodes (CDP, LDC, STC) cannot be used with P15.
<br/>
<br/>
CP15 Register List
<br/>
<br/>
  Register     Expl.
<br/>
  C0,C0,0      Main ID Register (R)
<br/>
  C0,C0,1      Cache Type and Size (R)
<br/>
  C0,C0,2      TCM Physical Size (R)
<br/>
  C1,C0,0      Control Register (R/W, or R=Fixed)
<br/>
  C2,C0,0      PU Cachability Bits for Data/Unified Protection Region
<br/>
  C2,C0,1      PU Cachability Bits for Instruction Protection Region
<br/>
  C3,C0,0      PU Write-Bufferability Bits for Data Protection Regions
<br/>
  C5,C0,0      PU Access Permission Data/Unified Protection Region
<br/>
  C5,C0,1      PU Access Permission Instruction Protection Region
<br/>
  C5,C0,2      PU Extended Access Permission Data/Unified Protection Region
<br/>
  C5,C0,3      PU Extended Access Permission Instruction Protection Region
<br/>
  C6,C0..C7,0  PU Protection Unit Data/Unified Region 0..7
<br/>
  C6,C0..C7,1  PU Protection Unit Instruction Region 0..7
<br/>
  C7,Cm,Op2    Cache Commands and Halt Function (W)
<br/>
  C9,C0,0      Cache Data Lockdown
<br/>
  C9,C0,1      Cache Instruction Lockdown
<br/>
  C9,C1,0      TCM Data TCM Base and Virtual Size
<br/>
  C9,C1,1      TCM Instruction TCM Base and Virtual Size
<br/>
  C13,Cm,Op2   Misc Process ID registers
<br/>
  C15,Cm,Op2   Misc Implementation Defined and Test/Debug registers
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164455 - yellowstar - Sun Nov 02, 2008 7:42 pm</h4>
    <div class="postbody"><span class="postbody">What's the machine code for an infinite loop? A branch branching to itself, to the same branch instruction?(The hex for each of the 4 ARM bytes?)(iDeas doesn't immediately stop on a BKPT instruction...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164457 - Maxxie - Sun Nov 02, 2008 10:44 pm</h4>
    <div class="postbody"><span class="postbody">In arm mode:
<br/>
0xEAFFFFFE:  B PC + (-2*4)
<br/>
<br/>
Is 
<br/>
@here: B here<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164459 - yellowstar - Mon Nov 03, 2008 3:23 am</h4>
    <div class="postbody"><span class="postbody">Thanks Maxxie, that worked.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164763 - yellowstar - Tue Nov 18, 2008 9:29 pm</h4>
    <div class="postbody"><span class="postbody">What happens when software writes to REG_IF, outside of any interrupt handler? Does the interrupts specified by the bits written, get "triggered"?(IRQ handler being executed, handling these "interrupts"?)
<br/>
<br/>
EDIT:
<br/>
Does it matter with REG_IF writing from software, for the IPC Recv FIFO Not Empty bit, if the REG_IE bit for IPC Recv FIFO Not Empty interrupt is not yet enabled in REG_IE, but it is already enabled in IPCFIFOCNT?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164772 - Miked0801 - Wed Nov 19, 2008 3:05 pm</h4>
    <div class="postbody"><span class="postbody">Pretty sure as soon as the IF bits are set, the app will jump to interrupt.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164839 - yellowstar - Mon Nov 24, 2008 9:46 pm</h4>
    <div class="postbody"><span class="postbody">There's some compressed server URL embedded in this Arm9 binary. I attempted to decompress it with lzo1x, but an access violation occurred. I'd like to reverse engineer the decompression by code finding a reference to the code which uses it, (Kind of like IDA's XREF) but when searching for the URL's address in the file minus 0x4000,(I also tried adding 0x02000000 to this address, but didn't find anything at all) I can only find the attempted dissassembly of the URL in both ARM/Thumb disassembles.
<br/>
<br/>
EDIT: I attempted to find the 32-bit value used for a string in one of my homebrew programs, and succeeded. I tried searching for various addresses of the compressed URL minus 0x4000, but didn't find anything. So, never mind... Guess the code that loads the compressed URL's address is obfuscated and doesn't directly load this address...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164880 - yellowstar - Sat Nov 29, 2008 6:08 pm</h4>
    <div class="postbody"><span class="postbody">Could someone check what I did wrong with this C++ implementation of L_9a0 in the Arm9 loader? I checked it many times over many days, and still couldn't find the fix...
<br/>
*Arm9 self-decompression dasm removed*
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;stdio.h&gt;
<br/>
#include &lt;strings.h&gt;
<br/>
#include &lt;malloc.h&gt;
<br/>
<br/>
bool move_ram = 0;
<br/>
bool gen_ram = 0;
<br/>
char *arm9_filename = NULL;
<br/>
unsigned char *RAM = NULL;
<br/>
<br/>
void L_9a0(unsigned int start, size_t length, unsigned int clearval);
<br/>
<br/>
void L_98c(unsigned int start, size_t length, unsigned int clearval)
<br/>
{
<br/>
   unsigned int *ptr;
<br/>
   ptr = (unsigned int*)start;
<br/>
   for(size_t i=0; i&lt;length; i+=4)
<br/>
   {
<br/>
      *ptr++ = clearval;
<br/>
   }
<br/>
<br/>
   L_9a0(start, length, clearval);
<br/>
}
<br/>
<br/>
void L_9a0(unsigned int start, unsigned int length, unsigned int clearval)
<br/>
{
<br/>
   unsigned char *source, *dest;
<br/>
   unsigned char val;
<br/>
   int a, b;
<br/>
    int counter;
<br/>
<br/>
   if(clearval==0)return;
<br/>
<br/>
    length += clearval;
<br/>
    dest = (unsigned char*)((int)RAM + (int)0x12C344);
<br/>
    source = (unsigned char*)((int)RAM + (int)0xD5F5B);
<br/>
    start = (unsigned int)((int)RAM + (int)0x4000);
<br/>
<br/>
    while((int)source &gt; (int)start)
<br/>
    {
<br/>
        source = (unsigned char*)((int)source - 1);
<br/>
        val = *source;
<br/>
<br/>
            counter = 8;
<br/>
            while(counter&gt;=0)
<br/>
            {
<br/>
                counter--;
<br/>
                if(counter&lt;0)break;
<br/>
                if((int)source&lt;=(int)start)
<br/>
                {
<br/>
                    return;
<br/>
                }
<br/>
<br/>
                if(val &amp; 0x80)
<br/>
                {
<br/>
                    source = (unsigned char*)((int)source - 1);
<br/>
                    a = *source;
<br/>
                    source = (unsigned char*)((int)source - 1);
<br/>
                    b = *source;
<br/>
<br/>
                    b |= a&lt;&lt;8;
<br/>
                    b &amp;= ~0xF000;
<br/>
                    b += 2;
<br/>
                    a += 32;
<br/>
<br/>
                    while(a&gt;=16)
<br/>
                    {
<br/>
                        dest--;
<br/>
                        *dest = *((unsigned char*)((int)dest + (int)b));
<br/>
                        a-=16;
<br/>
                    }
<br/>
                }
<br/>
                else
<br/>
                {
<br/>
                    dest--;
<br/>
                    source = (unsigned char*)((int)source - 1);
<br/>
                    *dest = *source;
<br/>
                }
<br/>
<br/>
                val = val &lt;&lt; 1;
<br/>
            }
<br/>
    }
<br/>
}
<br/>
<br/>
void L_a4c()
<br/>
{
<br/>
    unsigned int *start = (unsigned int*)((int)RAM + (int)0x12c320);
<br/>
    unsigned int *stop_addr = (unsigned int*)((int)RAM + (int)0x12c344);
<br/>
    unsigned int *source = (unsigned int*)((int)RAM + (int)0xb5800);
<br/>
    unsigned int *dest, val1, end, val2;
<br/>
<br/>
    while((unsigned int)start != (unsigned int)stop_addr)
<br/>
    {
<br/>
        val1 = *start;
<br/>
        start++;
<br/>
        val2 = *start;
<br/>
        start++;
<br/>
<br/>
        end = (val1 - 0x02000000) + (val2 - 0x02000000);
<br/>
        dest = ((unsigned int*)((int)RAM + ((int)val1 - 0x02000000)));
<br/>
<br/>
        while(end &gt; (unsigned int)dest)
<br/>
        {
<br/>
            val2 = *source;
<br/>
            source++;
<br/>
            *dest = val2;
<br/>
            dest++;
<br/>
        }
<br/>
<br/>
        val2 = *start;
<br/>
        start++;
<br/>
        end = (unsigned int)dest + ((int)val2 - 0x02000000);
<br/>
<br/>
        while(end &gt; (unsigned int)dest)
<br/>
        {
<br/>
            *dest = 0;
<br/>
            dest++;
<br/>
        }
<br/>
    }
<br/>
}
<br/>
<br/>
int GetFileLength(FILE* _pfile)
<br/>
{
<br/>
   int l_iSavPos, l_iEnd;
<br/>
<br/>
   l_iSavPos = ftell(_pfile);
<br/>
   fseek(_pfile, 0, SEEK_END);
<br/>
   l_iEnd = ftell(_pfile);
<br/>
   fseek(_pfile, l_iSavPos, SEEK_SET);
<br/>
<br/>
   return l_iEnd;
<br/>
}
<br/>
<br/>
int main(int argc, char *argv[])
<br/>
{
<br/>
    FILE *file = NULL;
<br/>
    int filesize = 0;
<br/>
<br/>
    printf("Arm9loader");
<br/>
<br/>
    if(argc==1)
<br/>
    {
<br/>
    printf(" application by yellowstar 10/26/08\n");
<br/>
    printf("C++ conversion of the memory moving assembly in the official Arm9 loaders.\n");
<br/>
    printf("Usage:\n");
<br/>
    printf("-g&lt;arm9.bin&gt;: Generate the required ram.bin from the Arm9 binary specified.\n");
<br/>
    printf("-m: Move memory around like the official Arm9 loader does, from ram.bin, and write the new arragment to new_ram.bin.\n");
<br/>
    }
<br/>
    else
<br/>
    {
<br/>
        printf("\n");
<br/>
        move_ram = 0;
<br/>
        gen_ram = 0;
<br/>
        RAM = (unsigned char*)malloc(0x400000);
<br/>
        if(RAM==NULL)
<br/>
        {
<br/>
            printf("Failed to allocate memory.\n");
<br/>
            return 1;
<br/>
        }
<br/>
        memset(RAM, 0, 0x400000);
<br/>
<br/>
        for(int argi = 1; argi&lt;argc; argi++)
<br/>
        {
<br/>
            if(strcmp(argv[argi], "-m")==0)
<br/>
            {
<br/>
                move_ram = 1;
<br/>
            }
<br/>
<br/>
            if(argv[argi][0] == '-' &amp;&amp; argv[argi][1] == 'g')
<br/>
            {
<br/>
                gen_ram = 1;
<br/>
                arm9_filename = (char*)malloc(256);
<br/>
                if(arm9_filename==NULL)
<br/>
                {
<br/>
                    printf("Failed to allocate memory.\n");
<br/>
                    return 1;
<br/>
                }
<br/>
<br/>
                memset(arm9_filename, 0, 256);
<br/>
                strcpy(arm9_filename, &amp;argv[argi][2]);
<br/>
<br/>
                file = fopen(arm9_filename, "rb");
<br/>
                if(file==NULL)
<br/>
                {
<br/>
                    printf("Failed to open file %s.\n", arm9_filename);
<br/>
                    return 1;
<br/>
                }
<br/>
<br/>
                filesize = GetFileLength(file);
<br/>
                fread(RAM, 1, filesize, file);
<br/>
                fclose(file);
<br/>
<br/>
                file = fopen("ram.bin", "wb");
<br/>
                fwrite(RAM, 1, 4000000, file);
<br/>
                fclose(file);
<br/>
                free(arm9_filename);
<br/>
            }
<br/>
        }
<br/>
<br/>
        if(!gen_ram)
<br/>
        {
<br/>
            file = fopen("ram.bin", "rb");
<br/>
            if(file!=NULL)
<br/>
            {
<br/>
                fread(RAM, 1, 4000000, file);
<br/>
                fclose(file);
<br/>
            }
<br/>
            else
<br/>
            {
<br/>
                printf("Failed to open ram.bin.\n");
<br/>
                return 1;
<br/>
            }
<br/>
        }
<br/>
<br/>
        if(move_ram)
<br/>
        {
<br/>
            L_9a0(0x02000bb4, 0x400, 0x020d5f64);
<br/>
            //L_a4c();//Commented out because this program crashes with this uncommented, because the wrong data is being used from the modified memory.
<br/>
<br/>
            //memset((void*)((int)RAM + 0xb5800), 0, 0x207a0);
<br/>
<br/>
            file = fopen("new_ram.bin", "wb");
<br/>
            fwrite(RAM, 1, 0x400000, file);
<br/>
            fclose(file);
<br/>
        }
<br/>
    }
<br/>
<br/>
    free(RAM);
<br/>
<br/>
    return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:27 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#164881 - Maxxie - Sat Nov 29, 2008 6:46 pm</h4>
    <div class="postbody"><span class="postbody">r0 is of type pointer on function entry, as it is used to load r1,r2 from it via the ldmia r0,{}
<br/>
So it is not a clear value and the first check is only
<br/>
<br/>
if (pointer == NULL) return;
<br/>
<br/>
Also r1, r2 are NO parameter, their content is trashed with the ldmia.
<br/>
<br/>
I'd advise to remove the comments and start over on this particular function.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164884 - yellowstar - Sat Nov 29, 2008 7:48 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Also r1, r2 are NO parameter, their content is trashed with the ldmia.
<br/>
</td> </tr></table><span class="postbody">
<br/>
When beginning execution from L_9a0, they are parameters for some memory clearing assembly. However with this ref I'm dealing with, those aren't parameters at all.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164885 - Cearn - Sat Nov 29, 2008 8:37 pm</h4>
    <div class="postbody"><span class="postbody">This should be close:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void sub_9A0(u32 *arg0)
<br/>
{
<br/>
    //# NOTE: arg0 probably not really a u32-pointer, but rather 
<br/>
    //# a struct passed by reference or something. In any case, this is 
<br/>
    //# what it says.
<br/>
    u8 *foo= (u8*)arg0;
<br/>
    u32 header= arg0[-2];               // Compression header ???
<br/>
    
<br/>
    u8 *dst= foo+arg0[-1];              // r2
<br/>
    u8 *src= foo-(header&gt;&gt;24);          // r3
<br/>
    u8 *end= foo-(header&amp;0xFFFFFF)      // r1
<br/>
    
<br/>
    u8 *orgDst= dst;    // Save the original destination for later.
<br/>
    
<br/>
    int iBlock=0;
<br/>
    u32 blockFlags=0;
<br/>
        
<br/>
    while(src &gt; end)
<br/>
    {
<br/>
        // Prepare for a new compression block.
<br/>
        if(iBlock==0)
<br/>
            blockFlags= *--src;
<br/>
        
<br/>
        if(blockFlags &amp; 0x80)           // Reverse LZ77 compressed.
<br/>
        {
<br/>
            u16 hdr= src[-1]&lt;&lt;8 | src[-2];
<br/>
            u16 offset= (hdr&amp;0xFFF)+2, len= (hdr&gt;&gt;4)+2;
<br/>
            src += 2;
<br/>
            while(len--)
<br/>
            {
<br/>
                dst[-1]= dst[offset];
<br/>
                --dst;
<br/>
            }
<br/>
        }
<br/>
        else                            // Normal byte stream.
<br/>
            *--dst = *--src;
<br/>
        
<br/>
        blockFlags &lt;&lt;= 1;
<br/>
    }
<br/>
<br/>
    //# TODO: cache flush from`end' to `orgDst'
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Basically, it's a reverse-LZ77 decompresser. There may be some off-by-one errors in there (I always mess those up), this is basically it. The entry parts will have to be modified a little, of course, as that part of the routine was missing from the assembly.
<br/>
<br/>
Sidenote: you really, really don't have to spam your code with type-casts. In most cases, it's unnecessary and makes code more difficult to write and read. They are almost never needed for integers, and only rarely for pointers.
<br/>
For example, this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">source = (unsigned char*)((int)source - 1);
<br/>
 a = *source;
<br/>
</td> </tr></table><span class="postbody">just means this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">a= source[-1];
<br/>
</td> </tr></table><span class="postbody">The meaning of the latter is immediately obvious (though somewhat odd due to the negative offset); the former ... not so much.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164886 - Cearn - Sat Nov 29, 2008 8:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">This should be close:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void sub_9A0(u32 *arg0)
<br/>
{
<br/>
    //# NOTE: arg0 probably not really a u32-pointer, but rather 
<br/>
    //# a struct passed by reference or something. In any case, this is 
<br/>
    //# what it says.
<br/>
    u8 *foo= (u8*)arg0;
<br/>
    u32 header= arg0[-2];               // Compression header ???
<br/>
    
<br/>
    u8 *dst= foo+arg0[-1];              // r2
<br/>
    u8 *src= foo-(header&gt;&gt;24);          // r3
<br/>
    u8 *end= foo-(header&amp;0xFFFFFF)      // r1
<br/>
    
<br/>
    u8 *orgDst= dst;    // Save the original destination for later.
<br/>
    
<br/>
    int iBlock=0;
<br/>
    u32 blockFlags=0;
<br/>
        
<br/>
    while(src &gt; end)
<br/>
    {
<br/>
        // Prepare for a new compression block.
<br/>
        if(iBlock==0)
<br/>
        {
<br/>
            blockFlags= *--src;
<br/>
            iBlock= 8;
<br/>
        }
<br/>
        iBlock--;
<br/>
        
<br/>
        if(blockFlags &amp; 0x80)           // Reverse LZ77 compressed.
<br/>
        {
<br/>
            u16 hdr= src[-1]&lt;&lt;8 | src[-2];
<br/>
            u16 offset= (hdr&amp;0xFFF)+2, len= (hdr&gt;&gt;4)+2;
<br/>
            src += 2;
<br/>
            while(len--)
<br/>
            {
<br/>
                dst[-1]= dst[offset];
<br/>
                --dst;
<br/>
            }
<br/>
        }
<br/>
        else                            // Normal byte stream.
<br/>
            *--dst = *--src;
<br/>
        
<br/>
        blockFlags &lt;&lt;= 1;
<br/>
    }
<br/>
<br/>
    //# TODO: cache flush from`end' to `orgDst'
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Basically, it's a reverse-LZ77 decompresser. There may be some off-by-one errors in there (I always mess those up), this is basically it. The entry parts will have to be modified a little, of course, as that part of the routine was missing from the assembly.
<br/>
<br/>
Sidenote: you really, really don't have to spam your code with type-casts. In most cases, it's unnecessary and makes code more difficult to write and read. They are almost never needed for integers, and only rarely for pointers.
<br/>
For example, this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">source = (unsigned char*)((int)source - 1);
<br/>
 a = *source;
<br/>
</td> </tr></table><span class="postbody">just means this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">a= source[-1];
<br/>
</td> </tr></table><span class="postbody">The meaning of the latter is immediately obvious (though somewhat odd due to the negative offset); the former ... not so much.</span></td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164891 - chishm - Sun Nov 30, 2008 1:13 am</h4>
    <div class="postbody"><span class="postbody">I take it this is the code executed by the ARM9 binary to decompress itself? Here's my version, written over a year ago:
<br/>
<br/>
sourceData should point to the start of the ARM9 binary and headerBottom should be the size of it. The compressed data "header" is actually a trailer, as the data is decompressed from the tail to the head, in place in memory.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">unsigned int get_decompressed_data_size (const unsigned char* sourceData, unsigned int headerBottom) {
<br/>
   unsigned int decompressedLength;
<br/>
   decompressedLength = (((unsigned int*)sourceData)[headerBottom / 4 - 1]) + headerBottom;
<br/>
   return decompressedLength;
<br/>
}
<br/>
<br/>
void decompress_ARM9_binary (const unsigned char* sourceData, unsigned int headerBottom, unsigned char* destData) {
<br/>
   
<br/>
   int srcPos, destPos;
<br/>
<br/>
   int controlByte;
<br/>
<br/>
   int runsLeft; 
<br/>
   unsigned int srcLength, destLength;
<br/>
   int srcStart;
<br/>
<br/>
   srcLength = ((unsigned int*)sourceData)[headerBottom / 4 - 2];
<br/>
   destLength = (((unsigned int*)sourceData)[headerBottom / 4 - 1]) + headerBottom;
<br/>
<br/>
   srcPos = headerBottom - (srcLength &gt;&gt; 24);
<br/>
   destPos = destLength;
<br/>
   srcStart = headerBottom - (srcLength &amp; 0x00FFFFFF);
<br/>
<br/>
   while (srcPos &gt; srcStart) {
<br/>
      controlByte = sourceData[--srcPos];
<br/>
<br/>
      for (runsLeft = 0x08; (runsLeft &gt; 0) &amp;&amp; (srcPos &gt;= 0) &amp;&amp; (destPos &gt;=0); --runsLeft) {
<br/>
<br/>
         if (controlByte &amp; 0x80) {
<br/>
            // copy data run from decompressed buffer
<br/>
            int runRepeats, runLength;   
<br/>
            unsigned char temp;
<br/>
<br/>
            runRepeats = sourceData[--srcPos];
<br/>
            runLength = ((sourceData[--srcPos] | (runRepeats &lt;&lt; 8)) &amp; 0x0fff) + 0x02;
<br/>
            runRepeats = (runRepeats &gt;&gt; 4) + 0x2;
<br/>
   
<br/>
            for ( ; runRepeats &gt;= 0; runRepeats-= 0x1) {
<br/>
               temp = destData[destPos + runLength];
<br/>
               destData[--destPos] = temp;
<br/>
            }
<br/>
         } else {
<br/>
            // copy byte from source compressed data
<br/>
            destData[--destPos] = sourceData[--srcPos];
<br/>
         }
<br/>
<br/>
         controlByte = controlByte &lt;&lt; 1;
<br/>
      } 
<br/>
   } 
<br/>
<br/>
   while ((srcPos &gt;= 0) &amp;&amp; (destPos &gt;= 0)) {
<br/>
      destData[--destPos] = sourceData[--srcPos];
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://chishm.drunkencoders.com" target="_blank">http://chishm.drunkencoders.com</a>
<br/>
<a class="postlink" href="http://dldi.drunkencoders.com" target="_blank">http://dldi.drunkencoders.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164921 - yellowstar - Mon Dec 01, 2008 8:16 pm</h4>
    <div class="postbody"><span class="postbody">Thanks chishm. My L_a4c implementation crashed again, and the procedure at 0x5120 didn't change at all. But the destination region is nowhere near 0x5120, however when viewing that RAM address with iDeas it shows that procedure was changed by 9a0... However I found these <a class="postlink" href="http://code.google.com/p/wmb-asm/wiki/NintendoSpot" target="_blank">URLs</a> thanks to chishm's decompressor implementation.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>chishm wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
while ((srcPos &gt;= 0) &amp;&amp; (destPos &gt;= 0)) {
<br/>
      destData[--destPos] = sourceData[--srcPos];
<br/>
   } 
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
What's this for? The assembly after the decompression code only flushes cache, it doesn't write anything...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Sidenote: you really, really don't have to spam your code with type-casts. In most cases, it's unnecessary and makes code more difficult to write and read. They are almost never needed for integers, and only rarely for pointers.
<br/>
For example, this:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
source = (unsigned char*)((int)source - 1);
<br/>
 a = *source;
<br/>
</td> </tr></table><span class="postbody">
<br/>
just means this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
a= source[-1];
<br/>
</td> </tr></table><span class="postbody">
<br/>
The meaning of the latter is immediately obvious (though somewhat odd due to the negative offset); the former ... not so much.
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
I used to have source--; ,where those source = (unsigned char*)((int)source - 1); are in that code post. I switched some of those to source = (unsigned char*)((int)source - 1); as I thought switching it *might* help,(I was stumped as to why my implementation wouldn't work, and I still am) but that didn't help, and I didn't bother switching it back before that post. However I have now switched it back, and changed the implementation some, and now it crashes...
<br/>
<br/>
EDIT:
<br/>
Chishm, I noticed another thing... At the end of the decompressed binary decompressed by your implementation, there's a bunch of zeroes. However, viewing that memory with iDeas reveals data used by L_a4c... However I checked the values of your implementation's variables, and the values were identical to the values I reverse engineered, so the flaw is elsewhere...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164927 - yellowstar - Tue Dec 02, 2008 1:20 am</h4>
    <div class="postbody"><span class="postbody">I finally got my implementation working. It appears Nintendo tweaked the decompressor since last year. My code outputs the correct data at both the end of the binary, and 0x5120, while chishm's failed at both.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void L_9a0(unsigned int start, unsigned int length, unsigned int clearval)
<br/>
{
<br/>
   unsigned char *source, *dest;
<br/>
   unsigned char val;
<br/>
   unsigned char temp;
<br/>
   int a, b;
<br/>
    int counter;
<br/>
<br/>
   if(clearval==0)return;
<br/>
<br/>
    length += clearval;
<br/>
    dest = (unsigned char*)((int)RAM + (int)0x12C344);
<br/>
    source = (unsigned char*)((int)RAM + (int)0xD5F5B);
<br/>
    start = (unsigned int)((int)RAM + (int)0x4000);
<br/>
<br/>
    while((int)source &gt; (int)start)
<br/>
    {
<br/>
        val = *--source;
<br/>
<br/>
            counter = 8;
<br/>
            while(counter&gt;=0)
<br/>
            {
<br/>
                counter--;
<br/>
                if(counter&lt;0)break;
<br/>
                if((int)source&lt;=(int)start)
<br/>
                {
<br/>
                    return;
<br/>
                }
<br/>
<br/>
                if(val &amp; 0x80)
<br/>
                {
<br/>
                    a = (int)*--source;
<br/>
                    b = (int)*--source;
<br/>
<br/>
                    b |= a&lt;&lt;8;
<br/>
                    b &amp;= ~0xF000;
<br/>
                    b += 2;
<br/>
                    a += 32;
<br/>
<br/>
                    while(a&gt;=0)
<br/>
                    {
<br/>
                        temp = dest[b];
<br/>
                        *--dest = temp;
<br/>
                        a-=16;
<br/>
                    }
<br/>
                }
<br/>
                else
<br/>
                {
<br/>
                    *--dest = *--source;
<br/>
                }
<br/>
<br/>
                val = val &lt;&lt; 1;
<br/>
            }
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164928 - yellowstar - Tue Dec 02, 2008 5:18 am</h4>
    <div class="postbody"><span class="postbody">What's the data at 0x023801b0 - 0x0238f308? The Arm7 is copying the data from that region to 0x037f8000 - 0x03807158, then branching to 0x037f8000. After some debugging, I had both CPUs enter infinite loops, then checked the memory at 0x023801b0, and there was still data at that region. I guess Nintendo's bootloaders write this data to that region before booting, and emulators write that data to that region also?(Which use dumps of Nintendo's data?) Where could I find this data in the DeSmuMe source?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165048 - yellowstar - Sun Dec 07, 2008 9:03 pm</h4>
    <div class="postbody"><span class="postbody">I've found this assembly, but I don't know what mode it's switching to... I don't see any mode listed for this setting in ARM ARM...
<br/>
*dasm removed*</span><span class="gensmall"><br/><br/>Last edited by yellowstar on Mon Dec 15, 2008 9:29 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#165051 - Maxxie - Sun Dec 07, 2008 10:04 pm</h4>
    <div class="postbody"><span class="postbody">It's getting and setting the interrupt and fast interrupt flags of the psr. (If set, the cpu ignores (fast)interrupt request untill they are cleared again)
<br/>
It doesn't change the mode or other flags.
<br/>
<br/>
Parameter is only r0 and supposed to be in the right format (all 0 except a possible bit6,7) r1 is trashed immediately on entry.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165052 - yellowstar - Sun Dec 07, 2008 10:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
It doesn't change the mode or other flags.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Why do you say that? :\
<br/>
A msr CPSR_c can write to the mode bits, and I thought it was writing bits 01111 to the mode bits... r0 on entry is bits 01111110... Doesn't the mode change on Arm9 when modes not defined in ARM ARM are attempted to be written to PSR? ARM ARM says the results are unpredictable if you do that...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Parameter is only r0 and supposed to be in the right format (all 0 except a possible bit6,7) r1 is trashed immediately on entry.</td> </tr></table><span class="postbody">
<br/>
That r1 = 0x40 line meant that r1 = 0x40 after the procedure is executed, not before. All the parameters are listed on the REF line only.(Didn't bother removing that r1 = 0x40 from the post...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165061 - Maxxie - Mon Dec 08, 2008 1:42 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
It doesn't change the mode or other flags.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Why do you say that? :\
<br/>
A msr CPSR_c can write to the mode bits, and I thought it was writing bits 01111 to the mode bits... r0 on entry is bits 01111110... Doesn't the mode change on Arm9 when modes not defined in ARM ARM are attempted to be written to PSR? ARM ARM says the results are unpredictable if you do that...
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Please check the r0 (which bits are those you posted, the upper, the lower?) if you really have other bits set then those in 0xC0. 
<br/>
(thats why i said  "and supposed to be in the right format")
<br/>
<br/>
The code wouldn't make much sense if there are mode parts included in the parameter (You really wouldn't want to OR modes) Actually i am pretty sure you will find that the return value of this function is saved and passed as the new argument in the next call.
<br/>
<br/>
It is a pretty standard code to to make sure non atomic access to data is not interrupted by the very same cpu in IRQ or FIQ. This is to prevent racing situations at accessing data used by the main flow and an interrupt handler.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165071 - yellowstar - Mon Dec 08, 2008 9:01 pm</h4>
    <div class="postbody"><span class="postbody">My bad, apparently the potential bl is being beq'd past, so this procedure is never executed...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165234 - yellowstar - Sun Dec 14, 2008 1:00 am</h4>
    <div class="postbody"><span class="postbody">How does binary addition work, at the bits level? Recently I attempted to patch this Arm9 binary to branch to the end of the binary in memory, patch an instruction, then branch back were it would have branched normally. However I'm not sure how to do it... How does one calculate the immediate_24 value when branching backwards? I also tried injecting the loader along with the decompressed Arm9 binary into an .nds, but No$Gba though the .nds was encrypted, although I tried fixing the Secure CRC16... Where does that 0x023801b0 - 0x0238f308 data come from? Is the the firmware, the BIOS, or whatever is first executed when the DS boots?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165238 - Maxxie - Sun Dec 14, 2008 9:10 am</h4>
    <div class="postbody"><span class="postbody">1) <a href="http://en.wikipedia.org/wiki/Half_adder" target="_blank">http://en.wikipedia.org/wiki/Half_adder</a>
<br/>
2) Should work for forward and backwards jumps:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
 s32 byteOffset = jmpTarget - (jmpSource + 8) ;
<br/>
 if (abs(byteOffset) &gt;= BIT(26)) throw "Branch: Out of range"
<br/>
 u32 B_opcode = (condition &lt;&lt; 28) | 0x0A000000 | ((byteOffset &gt;&gt; 2) &amp; 0x00FFFFFF ;
<br/>
</td> </tr></table><span class="postbody">
<br/>
where jmpSource is the address where the branch is stored. jmpSource + 8 is the PC at the time of its execution.
<br/>
3) dont know<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165244 - yellowstar - Sun Dec 14, 2008 9:34 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Maxxie.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165270 - wintermute - Mon Dec 15, 2008 8:43 pm</h4>
    <div class="postbody"><span class="postbody">Further posts containing disassembly of copyrighted code in this thread will result in a lock.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165271 - yellowstar - Mon Dec 15, 2008 9:31 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>wintermute wrote:</b></span></td> </tr> <tr> <td class="quote">Further posts containing disassembly of copyrighted code in this thread will result in a lock.</td> </tr></table><span class="postbody"> Sorry about that... I may be close to finishing loader RE though, and I wasn't planning on posting anything about non-loader code anyway. All of the dis-assemblies in all of my posts have been removed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165487 - yellowstar - Mon Dec 22, 2008 11:49 pm</h4>
    <div class="postbody"><span class="postbody">Could someone whom knows Perl adapt <a class="postlink" href="http://www.acm.uiuc.edu/sigmil/RevEng/ch05.html" target="_blank">this</a>(disasm.pl) for ARM?(I don't know perl, but I'd like to have a flow chart for this Nintendo Spot client... Not for finding main though, I already found that.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165677 - yellowstar - Sat Jan 03, 2009 2:54 am</h4>
    <div class="postbody"><span class="postbody">Everyone, what methods do you use for finding main when reverse engineering? I thought I found it, but apparently the software is still running in System mode in that procedure... Does anyone know what's the first libc procedure called/executed in official software?(Where it is/a sort of "call stack" to find it? Like say, procedure A calls B, calls L_xxxx, calls ..., calls libc_xxx) (I'm asking because it's taking me a long time to RE the loader...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165679 - Maxxie - Sat Jan 03, 2009 12:15 pm</h4>
    <div class="postbody"><span class="postbody">Why would main() not run in system mode on the DS?
<br/>
<br/>
Callstacks on an arm are a lot more difficult under our arm assemblies then they are on a x86. You need to parse the stack, register and code to locate the call remainders. (The x86 allways put a CALL return address on stack, the arm not. The x86 abi has a base pointer point to the stackframe's base, the arm abi doesn't)<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165711 - yellowstar - Mon Jan 05, 2009 12:00 am</h4>
    <div class="postbody"><span class="postbody">I thought on entry to main, the CPU mode would be User...  By "call stack", I meant a listing on what calls what, ect, based on disassembles, not literally the stack.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165715 - Maxxie - Mon Jan 05, 2009 8:27 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">I thought on entry to main, the CPU mode would be User... </td> </tr></table><span class="postbody">
<br/>
<br/>
There is no need to, no higher instance exists to control it. And often the requirement of full access rights prevents the use of user mode. system is nothing other then user mode with priviledges.
<br/>
system != svc<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166216 - yellowstar - Mon Feb 02, 2009 5:57 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>yellowstar wrote:</b></span></td> </tr> <tr> <td class="quote">What's the data at 0x023801b0 - 0x0238f308? The Arm7 is copying the data from that region to 0x037f8000 - 0x03807158, then branching to 0x037f8000.</td> </tr></table><span class="postbody"> Never mind, solved. Apparently in the .nds header 0x023801b0 is the Arm7 execution and copy to address... I assumed it was 0x03000000...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167801 - yellowstar - Sat Mar 28, 2009 6:42 pm</h4>
    <div class="postbody"><span class="postbody">What's the bytecode for a blx from 0x023fee00, to 0x023bfe00? Maxxie's code failed to generate it this properly. With an adjusted opcode from his code, viewing 0x023fee00 under iDeas, results in this: "blx 0x023ce00".(Generated bytecode is 0xfaff03fe)(Arm blx)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
