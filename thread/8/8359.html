<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Division in THUMB mode? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Division in THUMB mode?</h2>
<div id="posts">
<div class="post">
    <h4>#69613 - Janekxx - Tue Jan 31, 2006 8:28 pm</h4>
    <div class="postbody"><span class="postbody">Hi, maybe some of You have fast division routine written THUMB mode, or maybe some C optimized one?
<br/>
<br/>
Please help me if You can.
<br/>
<br/>
Currenty I'm using this, but it's slooow:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define divnorm(num, den, sign)                 \
<br/>
{                                               \
<br/>
  if (num &lt; 0)                                  \
<br/>
    {                                           \
<br/>
      num = -num;                               \
<br/>
      sign = 1;                                 \
<br/>
    }                                           \
<br/>
  else                                          \
<br/>
    {                                           \
<br/>
      sign = 0;                                 \
<br/>
    }                                           \
<br/>
                                                \
<br/>
  if (den &lt; 0)                                  \
<br/>
    {                                           \
<br/>
      den = - den;                              \
<br/>
      sign = 1 - sign;                          \
<br/>
    }                                           \
<br/>
}
<br/>
<br/>
<br/>
static unsigned long 
<br/>
divmodsi4(int modwanted, unsigned long num, unsigned long den)  
<br/>
{                                               
<br/>
  long int bit = 1;                             
<br/>
  long int res = 0;                             
<br/>
  long prevden;
<br/>
  while (den &lt; num &amp;&amp; bit &amp;&amp; !(den &amp; (1L&lt;&lt;31)))                        
<br/>
    {
<br/>
      den &lt;&lt;=1;                                 
<br/>
      bit &lt;&lt;=1;                                 
<br/>
    }                                           
<br/>
  while (bit)
<br/>
    {                                   
<br/>
      if (num &gt;= den)
<br/>
        {                               
<br/>
          num -= den;                           
<br/>
          res |= bit;                           
<br/>
        }                                               
<br/>
      bit &gt;&gt;=1;                                 
<br/>
      den &gt;&gt;=1;                                 
<br/>
    }                                           
<br/>
  if (modwanted) return num;
<br/>
  return res;
<br/>
}
<br/>
<br/>
<br/>
#define exitdiv(sign, res) if (sign) { res = - res;} return res;
<br/>
<br/>
long 
<br/>
__modsi3 (long numerator, long denominator)
<br/>
{
<br/>
  int sign = 0;
<br/>
  long dividend;
<br/>
  long modul;
<br/>
<br/>
<br/>
  if (numerator &lt; 0) 
<br/>
    {
<br/>
      numerator = -numerator;
<br/>
      sign = 1;
<br/>
    }
<br/>
  if (denominator &lt; 0)
<br/>
    {
<br/>
      denominator = -denominator;
<br/>
    }  
<br/>
  
<br/>
  modul =  divmodsi4 (1, numerator, denominator);
<br/>
  if (sign)
<br/>
    return - modul;
<br/>
  return modul;
<br/>
}
<br/>
<br/>
<br/>
long 
<br/>
__divsi3 (long numerator, long denominator)
<br/>
{
<br/>
  int sign;
<br/>
  long dividend;
<br/>
  long modul;
<br/>
  divnorm (numerator, denominator, sign);
<br/>
<br/>
  dividend = divmodsi4 (0,  numerator, denominator);
<br/>
  exitdiv (sign, dividend);
<br/>
}
<br/>
<br/>
long 
<br/>
__umodsi3 (unsigned long numerator, unsigned long denominator)
<br/>
{
<br/>
  long dividend;
<br/>
  long modul;
<br/>
<br/>
modul= divmodsi4 (1,  numerator, denominator);
<br/>
  return modul;
<br/>
}
<br/>
<br/>
long 
<br/>
__udivsi3 (unsigned long numerator, unsigned long denominator)
<br/>
{
<br/>
  int sign;
<br/>
  long dividend;
<br/>
  long modul;
<br/>
  dividend =   divmodsi4 (0, numerator, denominator);
<br/>
  return dividend;
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://sony.int.pl" target="_blank">sony.int.pl</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#69615 - DekuTree64 - Tue Jan 31, 2006 8:48 pm</h4>
    <div class="postbody"><span class="postbody">You'll be much better off switching to ARM mode than dividing in THUMB. Can be done of course, but will be slow as dirt due to all the conditionals involved. In ARM, a lot of those become single conditional instructions, rather than conditional jumps over instructions.
<br/>
<br/>
Check out the 32/32=32 divide on <a class="postlink" href="http://www.peter-teichmann.de/ahinte.html" target="_blank">this page</a>. You'll have to add colons after all the labels to get it to assemble with gcc, but it's fast (for a division routine, anyway).
<br/>
<br/>
Or do you have a specific need to use THUMB?<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#69649 - Janekxx - Tue Jan 31, 2006 11:01 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for reply, but I know that page :)
<br/>
<br/>
It's very important to me that routine will be in THUMB mode because of memory limitations (not GBA platform - old Sony Jxx phones).<br/>_________________<br/><a class="postlink" href="http://sony.int.pl" target="_blank">sony.int.pl</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#69653 - DekuTree64 - Tue Jan 31, 2006 11:27 pm</h4>
    <div class="postbody"><span class="postbody">Ah, ok. Your C routine looks pretty good then. Here are a couple of micro-optimizations that may or may not help:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static unsigned long 
<br/>
divmodsi4(int modwanted, unsigned long num, unsigned long den)  
<br/>
{                                                
<br/>
  long int bit = 1;                              
<br/>
  long int res = 0;                              
<br/>
  long prevden; 
<br/>
     // Removed the &amp;&amp; bit from this loop, since den &amp; bit31
<br/>
     // will happen at least just as soon (unless den is 0, which 
<br/>
     // is bad anyway, and could be checked for)
<br/>
  while (!(den &amp; (1L&lt;&lt;31)) &amp;&amp; den &lt; num)                        
<br/>
    { 
<br/>
      bit &lt;&lt;=1;  // \_ Switched order of these. Maybe compiler
<br/>
      den &lt;&lt;=1;  // /  will use bpl/bmi to check bit31 of den
<br/>
    }                                            
<br/>
  while (bit) 
<br/>
    {                                    
<br/>
      if (num &gt;= den) 
<br/>
        {                                
<br/>
          num -= den;                            
<br/>
          res |= bit;                            
<br/>
        }                                                
<br/>
      den &gt;&gt;=1;   // \_ Switched the order of these. If your compiler 
<br/>
      bit &gt;&gt;=1;   // /  is smart enough, it will use the flags from
<br/>
    }             //    this shift to do the loop branch
<br/>
  if (modwanted) return num; 
<br/>
  return res; 
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Maybe try checking the assembly output, and if it doesn't use those loop condition tricks I pointed out, then keep the assembly and make the changes yourself :)<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#69658 - poslundc - Tue Jan 31, 2006 11:57 pm</h4>
    <div class="postbody"><span class="postbody">How serious are your memory limitations? Some alternatives you might want to consider:
<br/>
<br/>
- ARM code might be faster and consume less memory for something like this, even if you have a 16-bit bus. (It'd take more knowledge of the target to say for sure.)
<br/>
<br/>
- Use a reciprocal LUT and keep the resolution relatively low if memory is at a real premium... use linear interpolation to get in-between values; it's not terribly accurate but might be good enough for your application. Might not be good with your memory constraints, but it's hard to beat for speed.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#69797 - Janekxx - Wed Feb 01, 2006 11:37 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for C optimalizations I will use it.
<br/>
<br/>
I'm forced to use thumb: libs, etc. , everything for Sony Jxx is made in thumb, I try to force arm mode but always same result - phone reset.
<br/>
<br/>
<br/>
I'm working on 3D engine, (curentlly ~17 fps with 200polygons object :) (slow drawing on phone))<br/>_________________<br/><a class="postlink" href="http://sony.int.pl" target="_blank">sony.int.pl</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#69888 - Janekxx - Thu Feb 02, 2006 8:06 pm</h4>
    <div class="postbody"><span class="postbody">By sugestions of precalculated table I made folowing function for signed division, maybe will be usefull to someone:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int  div_table[]={65536,32768,21845,16384,13107,10923,9362,8192,7282, // pecalculated values table (1/x * 65536)
<br/>
                  6554,5958,5461,5041,4681,4369,4096,3855,3641,3449,
<br/>
                  3277,3121,2979,2849,2731,2621,2521,2427,2341,2260,
<br/>
                  2185,2114,2048,1986,1928,1872,1820,1771,1725,1680,
<br/>
                  1634,1598,1560,1524,1489,1456,1425,1394,1365,1337,
<br/>
                  1311,1285,1260,1237,1214,1192,1170,1150,1130,1111,
<br/>
                  1092,1074,1057,1040,1024,1008,993,978,964,950,
<br/>
                  936,923,910,898,886,874,862,851,840,830,
<br/>
                  819,809,799,790,780,771,762,753,745,736,
<br/>
                  728,720,712,705,697,690,683};
<br/>
<br/>
int super_div(int a, int b){    // fast division from 1 to 96
<br/>
    a *=div_table[b];
<br/>
    return a&gt;&gt;16;
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://sony.int.pl" target="_blank">sony.int.pl</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80460 - keldon - Sat Apr 22, 2006 1:46 pm</h4>
    <div class="postbody"><span class="postbody">There is another clever way used by Jeff <a class="postlink" href="http://devrs.com/gb/files/logmult.txt" target="_blank">for fast software divides and multiplies.
<br/>
</a>
<br/>
<br/>
a / b == antiLog(log(a) - log(b));
<br/>
<br/>
So if you create a <a class="postlink" href="http://faculty.washington.edu/jackels/tutorials/Logs/sld015.htm" target="_blank">log and antilog</a> table you get a fast multiply / divide.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80487 - poslundc - Sat Apr 22, 2006 6:56 pm</h4>
    <div class="postbody"><span class="postbody">I'd thought of using this identity for speedy division before, but it just seemed to be requiring twice the tables and three times the lookups in order to get what would probably be diminished accuracy than a simple reciprocal LUT. Is there a compelling reason to use the former instead of the latter?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80566 - keldon - Sun Apr 23, 2006 2:39 pm</h4>
    <div class="postbody"><span class="postbody">To be honest I just found it interesting that it worked for divides too, and no it isn't really useful for the gba because you have the multiplies. It's only useful [i guess] when you don't have hardware multiplies.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#80815 - Miked0801 - Tue Apr 25, 2006 7:22 pm</h4>
    <div class="postbody"><span class="postbody">Log/AntiLog stuff looks great on paper, but I've found the precision really suffers compared to other methods.  It also requires 2 lookups instead of 1.  It does allow for fast non-integer Pow(x) type functions though (When multiplying logs by scalers, it is the same as take the log number to the power of the scaler and dividing is the same as sqrt)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
