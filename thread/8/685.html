<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Division? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Division?</h2>
<div id="posts">
<div class="post">
    <h4>#3576 - regularkid - Fri Feb 28, 2003 6:19 am</h4>
    <div class="postbody"><span class="postbody">How would I go about doing division in ASM? I could be wrong, but it seems that there is no 'div' command. Any ideas?<br/>_________________<br/>- RegularKid</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3579 - TurboHz - Fri Feb 28, 2003 9:14 am</h4>
    <div class="postbody"><span class="postbody">You can divide either using logical shifts (only when you're dividing by 2,4,8,16...) or using the <span style="font-weight: bold">0x06: Div</span> BIOS call (check the CowBite Specs doc)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3600 - sloat - Fri Feb 28, 2003 10:04 pm</h4>
    <div class="postbody"><span class="postbody">you can also divide by a constant using umull and multiplying by the reciprocal
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
;divide by 10
<br/>
ldr r0, =1234
<br/>
ldr r1, =0x1999999A ;((1/10)*2^32)+1
<br/>
umull r1, r0, r0, r1 ;r0 = 123
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a href="http://sloat.bradsoft.net/" target="_blank">http://sloat.bradsoft.net/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3602 - regularkid - Fri Feb 28, 2003 11:30 pm</h4>
    <div class="postbody"><span class="postbody">Sweet! Thanks! I didn't know that the bios has a divide function. That is great!<br/>_________________<br/>- RegularKid</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12860 - sigma - Sat Nov 29, 2003 12:27 am</h4>
    <div class="postbody"><span class="postbody">Sorry to renew such an old topic, but you can do division with this procedure.
<br/>
<br/>
Given that the bit sizes are <span style="font-weight: bold">n</span> / <span style="font-weight: bold">n</span> = <span style="font-weight: bold">n</span>:
<br/>
1. Shift the dividend one bit left.
<br/>
2. Rotate into a temp area, that is at least <span style="font-weight: bold">n</span>+1 bits.
<br/>
3. Compare the temp value with the divisor.
<br/>
4. If the temp is &gt;= the divisor, subtract the divisor and set the lsb of the dividend. Otherwise, do nothing.
<br/>
5. Repeat <span style="font-weight: bold">n</span> times
<br/>
<br/>
When finished, the previous dividend will now hold the <span style="font-weight: bold">n</span>-bit quotient and the temp area holds the remainder.
<br/>
<br/>
Note that this only works for unsigned divisions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12888 - col - Sat Nov 29, 2003 6:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sigma wrote:</b></span></td> </tr> <tr> <td class="quote">Sorry to renew such an old topic, but you can do division with this procedure.
<br/>
<br/>
Given that the bit sizes are <span style="font-weight: bold">n</span> / <span style="font-weight: bold">n</span> = <span style="font-weight: bold">n</span>:
<br/>
1. Shift the dividend one bit left.
<br/>
2. Rotate into a temp area, that is at least <span style="font-weight: bold">n</span>+1 bits.
<br/>
3. Compare the temp value with the divisor.
<br/>
4. If the temp is &gt;= the divisor, subtract the divisor and set the lsb of the dividend. Otherwise, do nothing.
<br/>
5. Repeat <span style="font-weight: bold">n</span> times
<br/>
<br/>
When finished, the previous dividend will now hold the <span style="font-weight: bold">n</span>-bit quotient and the temp area holds the remainder.
<br/>
<br/>
Note that this only works for unsigned divisions.</td> </tr></table><span class="postbody">
<br/>
<br/>
A long while ago, i had a look at the bios divide - it uses axactly this technique - shift &amp; subtract.
<br/>
it does it nice and fast using ARM asm (from zero waitstate mem ?)
<br/>
<br/>
What i ended up using for my special purpose though was a divide that uses a lookup table of reciprocals, with a little pre and post processing, I got a nice signed 16:16 fixed point divide with enough accuracy for the job and _much_ faster than the bios swi code.
<br/>
(iirc it was &lt; 50 cycles all in and accurate to a few(enough) decimal places)
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12902 - poslundc - Sun Nov 30, 2003 7:06 am</h4>
    <div class="postbody"><span class="postbody">Curious, Col, how big was your LUT?
<br/>
<br/>
Could you use it for normal division, or just reciprocal-multiplication? If the former, how did you go about obtaining the reciprocal of the denominator?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12905 - col - Sun Nov 30, 2003 2:27 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">Curious, Col, how big was your LUT?
<br/>
<br/>
Could you use it for normal division, or just reciprocal-multiplication? If the former, how did you go about obtaining the reciprocal of the denominator?
<br/>
<br/>
Dan.</td> </tr></table><span class="postbody">
<br/>
<br/>
My LUT was 32kbytes of ROM, I used reciprocal multiplication combined with some pre and post processing - to get a worst case error of about 0.00025
<br/>
<br/>
the vast majority of cases were considerably more accurate - the error scaled with the dividend, so very small numbers give very small errors.
<br/>
<br/>
~50cycles including dealing with -ve numbers
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12907 - ampz - Sun Nov 30, 2003 3:04 pm</h4>
    <div class="postbody"><span class="postbody">50 cycles?
<br/>
Does not sound very efficient... Are you sure the BIOS call is not faster?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12910 - col - Sun Nov 30, 2003 3:58 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">50 cycles?
<br/>
Does not sound very efficient... Are you sure the BIOS call is not faster?</td> </tr></table><span class="postbody">
<br/>
<br/>
the bios call best case is probably a little faster, but its worst case is <span style="text-decoration: underline">much</span> slower!
<br/>
<br/>
if i strip out my pre-processing and post processing, the code will be basicall just a lookup and a multiply, so much faster, but the worst case error will be far higher.
<br/>
<br/>
also, i was dividing a signed 16.16 fixed point number by another signed 16.16 fixed point number - using a shift subtract loop to divide numbers with that many bits will kill the cpu :)
<br/>
<br/>
so it really depends what you need. If you just want a rough answer, use a plain reciprocal LUT.  If you are dividing integers by integers,   and you don't mind a poor worst case performance, use the bios call... otherwise, you need a different solution :) somthing like what i have.. or a <span style="text-decoration: underline">very</span> large LUT - or maybe use a cordic rotator algorithm...
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#13022 - Miked0801 - Wed Dec 03, 2003 8:10 pm</h4>
    <div class="postbody"><span class="postbody">Don't use the BIOS divide if you can at all help it.  It's a poor implementation as it's a 5+ cycles per bit divide routine (it's looped instead of unrolled, see below).  The bigger problem though, is that the system generates a SWI interrupt to get at it which pushes all sorts of registers, jumps to about 4 locations, goes through the SWI handler, then gets to the divide.  Yuck.  If you need a fast divide, place an unrolled version in IWRAM and call it there. Best case around 27 cycles, worst around 114 cycles with a binary bit search on the front end.  If that's not good enough, then use a ROM recipricol table.  That's 9 cycles for the 32-bit load from ROM, 1-5 for the MUL, and a couple for register overhead (say 3) so 13 - 18 cycles.  I've used the table method in 3D rendering and it's worked out well (error low enough not to see polygon breakup).
<br/>
<br/>
<br/>
The divide op codes - this way is designed to have the shift value decremented per bit from 31 to 0.  You can do it as a shift 1 each time as well but it takes an extra register I believe.  The BIOS adds a decrement and jump check to each of these instead of unrolling it so it's 40% slower than it could be.
<br/>
<br/>
cmp r0,r1,lsl#0
<br/>
adc r2,r2,r2
<br/>
subcs r0,r0,r1,lsl#0
<br/>
<br/>
;The bios does
<br/>
cmp r2,r0,lsr1
<br/>
movls r2,r2,lsl1
<br/>
bcc to compare
<br/>
<br/>
then some addition processing and looping again.  It's slow...</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
