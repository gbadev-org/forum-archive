<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Updating REG_BG2Y causes screen to glitch - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Updating REG_BG2Y causes screen to glitch</h2>
<div id="posts">
<div class="post">
    <h4>#177677 - chickendude - Thu Nov 29, 2012 8:56 am</h4>
    <div class="postbody"><span class="postbody">I've just started learning GBA assembly and not surprisingly the most complicated part for me so far has been learning what the hardware can do and how to do it. I'm having trouble getting the Y scrolling to work correctly -- the screen scrolls fine but it looks like it first jumps randomly before it scrolls to the new coordinate. The weird thing is if i don't update REG_BG2Y, X scrolling works smoothly. If i do update REG_BG2Y, even if it's with the same Y value as before, i get the weird jumps. Here's a screenshot of what i'm talking about, the first part is updating REG_BG2Y, the second part (horizontal scrolling) with REG_BG2Y commented out.
<br/>
EDIT: Seems i can't insert pictures, here's a link to the picture: <a class="postlink" href="http://www.mirari.fr/SNGs" target="_blank">http://www.mirari.fr/SNGs</a>
<br/>
<br/>
Here's the bit of code for scrolling:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   ldr r0,[r0]         @ Load X
<br/>
   ldr r1,[r1]         @ Load Y
<br/>
   mov r0,r0,LSL #8   @ First 8 bits of REG_BG2X/Y = fraction
<br/>
   mov r1,r1,LSL #8
<br/>
   ldr r3,=REG_BG2X
<br/>
   str r0,[r3],#4      @ Update X and shift to REG_BG2Y
<br/>
   str r1,[r3]         @ Update Y (REG_BG2Y)</td> </tr></table><span class="postbody">
<br/>
<br/>
I don't know if it's got something to do with vSync or if there's something else i'm over looking, i just know that if i comment out the second str instruction it scrolls smoothly, just without vertical scrolling. Ah, and this is in Mode 1, 256-color palette, 256x256 background size.
<br/>
<br/>
Any help would be appreciated, as i'm completely stumped.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177679 - elhobbs - Thu Nov 29, 2012 12:56 pm</h4>
    <div class="postbody"><span class="postbody">I am not an asm expert, but shouldn't reg_bg2y be +4 instead of left shift 4 from reg_bg2x?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177680 - chickendude - Thu Nov 29, 2012 1:21 pm</h4>
    <div class="postbody"><span class="postbody">Maybe the syntax is different with other assemblers, but what that instruction does is post-increment r3 (pointer to REG_BG2X) by 4, so it loads r0 into [r3], then adds 4 to r3. I don't think the str instruction supports shifts... The Y coordinate IS updated and seems to update correctly, the screen just gets distorted slightly before it updates. Anyway, thanks for the reply. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177681 - elhobbs - Thu Nov 29, 2012 2:31 pm</h4>
    <div class="postbody"><span class="postbody">I looked at the nds samples and they appear to wait for vblank before updating scroll.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177682 - chickendude - Thu Nov 29, 2012 4:26 pm</h4>
    <div class="postbody"><span class="postbody">Awesome, it works perfectly now :D I tried implementing a little loop waiting for VBLANK before but i guess i didn't code it correctly. Here's the code and data i used, in case anyone else is interested. I don't think my waitVBLANK routine is very efficient, i think it'd be much better to put it into an interrupt. But at least it works now :)
<br/>
<a class="postlink" href="http://www.mirari.fr/tj7i" target="_blank">scrollingMode1.7z</a>
<br/>
<br/>
Btw, what NDS samples are you talking about?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177685 - elhobbs - Thu Nov 29, 2012 6:41 pm</h4>
    <div class="postbody"><span class="postbody">the ones that are in the devkitpro/examples directory. The windows installer installs them by default I think. <a class="postlink" href="http://devkitpro.org/wiki/Getting_Started/devkitARM" target="_blank">see here</a> for some install details.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177686 - Dwedit - Thu Nov 29, 2012 6:44 pm</h4>
    <div class="postbody"><span class="postbody">Look in C:\devkitpro\examples if you installed devkitarm.   (elhobbs replied first)<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177689 - chickendude - Thu Nov 29, 2012 7:16 pm</h4>
    <div class="postbody"><span class="postbody">Thanks both of you, i found them :) It turns out i didn't download the NDS examples (just the GBA ones).
<br/>
<br/>
EDIT: I set up a VBLANK interrupt to update the screenshifts during VBLANK, but it doesn't quite seem to be doing what i want. Again, the screen will shift, but only the first row is drawn and it gets repeated all down the screen. Did i misunderstand how VBLANK interrupts work? Here's the source to the interrupt:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">interrupt:
<br/>
   ldr r0, =x
<br/>
   ldr r1, =y
<br/>
<br/>
   ldr r0,[r0]         @ Load X
<br/>
   ldr r1,[r1]         @ Load Y
<br/>
   mov r0,r0,LSL #8   @ First 8 bits of REG_BG2X = fraction
<br/>
   mov r1,r1,LSL #8
<br/>
   ldr r3,=REG_BG2X
<br/>
<br/>
   str r0,[r3], #4      @ X
<br/>
   str r1,[r3]         @ Y REG_BG2Y
<br/>
<br/>
   ldr r1, =REG_IF      @ Acknowledge having run interrupt
<br/>
   mov r2, #INT_VBLANK
<br/>
   str r2,[r1]
<br/>
   bx lr</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177691 - Dwedit - Thu Nov 29, 2012 9:39 pm</h4>
    <div class="postbody"><span class="postbody">How are you doing interrupts?  Are you making a function for Libgba's interrupt handler, or are you putting the address into the end of RAM so the BIOS jumps there?<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177692 - chickendude - Fri Nov 30, 2012 6:16 am</h4>
    <div class="postbody"><span class="postbody">I'm not using libgba's handler, i'm just enabling VBLANK interrupts and loading the address of my interrupt (simply the last function in my program) into REG_INTADDR (0x3007FFC). The debugger shows that it does run my interrupt, the problem seems to be that it's running far too often. I assumed a VBLANK wouldn't occur until after having completely finished updating the screen, is that incorrect? I could just do the same check i did before (checking VCOUNT for gt 160), but i think i'm not quite understanding something.
<br/>
<br/>
EDIT: Or is it possible that there's more than one interrupt being triggered? When i add in VBLANK detection it works great:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">interrupt:
<br/>
   ldr r0, =REG_DISPSTAT
<br/>
   ldr r0, [r0]         @ Load the Display Status Register
<br/>
                     @ to check if we're in VBLANK
<br/>
   ands r0, r0, #STAT_VBLANK   
<br/>
   beq quitInterrupt      @ If it's not during VBLANK, quit
<br/>
   ldr r0, =x
<br/>
   ldr r1, =y
<br/>
<br/>
   ldr r0,[r0]            @ X
<br/>
   ldr r1,[r1]            @ Y
<br/>
   mov r0,r0,LSL #8      @ First 8 bits of REG_BG2X = fraction
<br/>
   mov r1,r1,LSL #8
<br/>
   ldr r3,=REG_BG2X
<br/>
<br/>
   str r0,[r3], #4         @ X
<br/>
   str r1,[r3]            @ Y REG_BG2Y
<br/>
quitInterrupt:
<br/>
   ldr r1, =REG_IF         @ Acknowledge having run the interrupt
<br/>
   mov r2, #INT_VBLANK      @ 
<br/>
   str r2,[r1]            @ 
<br/>
   bx lr</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177693 - Dwedit - Fri Nov 30, 2012 9:28 am</h4>
    <div class="postbody"><span class="postbody">Interrupts on the GBA:
<br/>
The real interrupt vector is in the BIOS.  The BIOS pushes 6 words onto the stack, switches the CPU into IRQ mode, then calls the address at 03007FFC.  When the handler returns, it switches back to system mode, then pops 6 words off the stack, and returns to the previously executing code.
<br/>
When it starts executing the interrupt handler, the initial value of r0 also happens to be 04000000 (REG_BASE), so fun times for code optimization junkies.
<br/>
<br/>
Your handler should check REG_IF to see what caused the interrupt, and AND that with REG_IE to see if that interrupt is actually enabled or not.
<br/>
When it handles the interrupt, it needs to clear the bit in REG_IF.
<br/>
<br/>
Sources of interrupts on the GBA:
<br/>
Let's copy-paste gbatek:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
  0     LCD V-Blank                    (0=Disable)
<br/>
  1     LCD H-Blank                    (etc.)
<br/>
  2     LCD V-Counter Match            (etc.)
<br/>
  3     Timer 0 Overflow               (etc.)
<br/>
  4     Timer 1 Overflow               (etc.)
<br/>
  5     Timer 2 Overflow               (etc.)
<br/>
  6     Timer 3 Overflow               (etc.)
<br/>
  7     Serial Communication           (etc.)
<br/>
  8     DMA 0                          (etc.)
<br/>
  9     DMA 1                          (etc.)
<br/>
  10    DMA 2                          (etc.)
<br/>
  11    DMA 3                          (etc.)
<br/>
  12    Keypad                         (etc.)
<br/>
  13    Game Pak (external IRQ source) (etc.)
<br/>
  14-15 Not used
<br/>
</td> </tr></table><span class="postbody">
<br/>
The interrupts also require a separate flag to enable interrupts for those devices.  Vblank, Hblank, and Vcount interrupt enable flags are in both REG_IE, and REG_DISPSTAT.  Interrupt enables for timers are in the timer registers.  Interrupt enables for DMA are in the DMA registers.
<br/>
<br/>
Gotcha:
<br/>
The GBA BIOS keeps track of interrupt flags in 03007FF8 as well.  So whenever you handle an interrupt, set that bit in 03007FF8 (16-bit word) as well.  Easy way to do it:
<br/>
mov r0,#REG_BASE
<br/>
ldr r1,[r0,#REG_IE]   @both REG_IE and REG_IF
<br/>
ands r3,r1,r1,lsr#16  @AND the enabled bits and interrupt flag bits
<br/>
ldrh r2,[r0,#-8]  @read BIOS's flags  (address 03FFFFF8 is a mirror of 03007FF8)
<br/>
orr r2,r2,r3    @mix with interrupts that get handled
<br/>
strh r2,[r0,#-8]  @write back
<br/>
<br/>
Your code will still work fine even if you don't do this.  But if you ever use any of the BIOS functions that halt until an interrupt occurs, you'll need to do this, otherwise it won't work correctly.
<br/>
<br/>
Repeatedly checking VCOUNT to see if you have reached vblank is a good way to waste battery power.  Instead, use a system call to wait for a Vblank interrupt, that way you won't waste power.  (Yes, I know even commercial games poll VCOUNT)
<br/>
Look for SWI 0x05 (THUMB mode) or SWI 0x50000 (ARM mode) to wait for a vblank interrupt.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177694 - headspin - Fri Nov 30, 2012 10:40 am</h4>
    <div class="postbody"><span class="postbody">You will likely need the <a class="postlink" href="http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm" target="_blank">CowBite Virtual Hardware Specifications</a> to find out how the registers work.
<br/>
<br/>
Also if you move to the NDS we have many C header files and routines converted to asm. We have a couple GBA examples but not much. You can visit our website <a class="postlink" href="http://greatflash.co.uk/index.php?board=12.0" target="_blank">here</a>.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177695 - chickendude - Fri Nov 30, 2012 4:08 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Interrupts on the GBA:
<br/>
The real interrupt vector is in the BIOS.  The BIOS pushes 6 words onto the stack, switches the CPU into IRQ mode, then calls the address at 03007FFC.  When the handler returns, it switches back to system mode, then pops 6 words off the stack, and returns to the previously executing code.</td> </tr></table><span class="postbody">This made me look up the bit on BIOS interrupt handling in gbatek, and now i'm wondering if there is any particular reason for pushing r12 (and not, say, r4)...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">When it starts executing the interrupt handler, the initial value of r0 also happens to be 04000000 (REG_BASE), so fun times for code optimization junkies.</td> </tr></table><span class="postbody">That's also very interesting to know, thanks :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Your handler should check REG_IF to see what caused the interrupt, and AND that with REG_IE to see if that interrupt is actually enabled or not.
<br/>
When it handles the interrupt, it needs to clear the bit in REG_IF.</td> </tr></table><span class="postbody">Right now my interrupt just reads the display control register to check for a VBLANK which i assume does pretty close to the same thing, though i suppose multiple interrupts might occur during a VBLANK, so my interrupt might be running more often than need be. And when you say to clear the bit in REG_IF, do you mean to set it to 1? That's what everything else i've read seems to indicate, after the interrupt runs it should set the appropriate bit in REG_IF to 1. This part doesn't make much sense to me. You set it to 1 so that the bit can get reset? From gbatek:
<br/>
"Interrupts must be manually acknowledged by writing a '1' to one of the IRQ bits, the IRQ bit will then be cleared."
<br/>
Maybe the wording here is what's tripping me up.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">The GBA BIOS keeps track of interrupt flags in 03007FF8 as well.  So whenever you handle an interrupt, set that bit in 03007FF8 (16-bit word) as well.</td> </tr></table><span class="postbody">Again, thanks for this, it's good to know (but a lot to keep in mind!).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Repeatedly checking VCOUNT to see if you have reached vblank is a good way to waste battery power.  Instead, use a system call to wait for a Vblank interrupt, that way you won't waste power.  (Yes, I know even commercial games poll VCOUNT)
<br/>
Look for SWI 0x05 (THUMB mode) or SWI 0x50000 (ARM mode) to wait for a vblank interrupt.</td> </tr></table><span class="postbody">That was how i originally did it, but now i tried setting up a VBLANK interrupt to handle it. The problem is it seems to be executing more than just a VBLANK interrupt (even though i've only activated VBLANK interrupts and it seems that only the VBLANK interrupt is set). Moreover, it works fine on VBA but no$gba doesn't recognize my keypresses. The interrupt code gets run, though. Using one of the SWI functions to wait for the next VBLANK interrupt isn't a bad idea, i just want to figure out what exactly i'm doing wrong with the interrupt. And you'd suggest reading REG_IF instead of REG_DISPSTAT?
<br/>
<br/>
@headspin: i already registered an account there yesterday, but it says it needs to be activated first. And without the CowBite site (and the Tonc tutorials) i don't know how i ever would've been able to figure any of this out!
<br/>
<br/>
I have to say, i'm really enjoying ARM assembly and especially learning about the GBA hardware. While the hardware is still a bit new to me, the actual code feels really tight and simple.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177696 - chickendude - Sun Dec 02, 2012 8:02 pm</h4>
    <div class="postbody"><span class="postbody">Should i be concerned if VBA doesn't seem to like my code? No$gba runs it just fine and it works lovely (and is even faster than before). VBA seems to never run the actual screen update loop:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">interrupt:
<br/>
   mov r0, #REG_DISPCNT
<br/>
   ldr r1, [r0,#REG_IE-REG_DISPCNT]   @ r1 = REG_IE (2 octets) et REG_IF (2 octets)
<br/>
   and r0, r1,r1, LSR #16   @ ANDer REG_IE et REG_IF
<br/>
   tst r0, #INT_VBLANK
<br/>
    bxeq lr            @ Si l'interruption n'est pas un VBLANK, quitter
<br/>
   ldr r0, =x
<br/>
   ldr r1, =y
<br/>
<br/>
   ldr r0,[r0]            @ Charger X
<br/>
   ldr r1,[r1]            @ Charger Y
<br/>
   mov r0,r0,LSL #8      @ Premier 8 bits de REG_BG2X = fraction
<br/>
   mov r1,r1,LSL #8
<br/>
   ldr r3,=REG_BG2X
<br/>
   str r0,[r3], #4         @ X
<br/>
   str r1,[r3]            @ Y REG_BG2Y
<br/>
<br/>
@ Annoncer que l'on a fini son travail avec l'interruption
<br/>
   mov r0, #REG_BASE      @ 0x04000000 (REG_DISPCNT)
<br/>
   ldr r1, [r0, #REG_IF-REG_BASE]
<br/>
   mov r2, #INT_VBLANK      @ 
<br/>
   orr r2, r1            @ Desarmer toutes les interruptions (il faut les mettre à 1 pour les désarmer)
<br/>
   str r2, [r0, #REG_IF-REG_BASE]   @ 
<br/>
   ldr r1, [r0, #REG_IE-REG_BASE]   @ r1 = REG_IE (2 octets) et REG_IF (2 octets)
<br/>
   and r3, r1,r1, LSR #16   @ ANDer REG_IE et REG_IF
<br/>
   ldrh r2, [r0, #-8]      @ Les drapeaux d'interruptions du BIOS (0x3FFFFF8 est un miroir de 0x3007FF8)
<br/>
   orr r2, r2, r3         @ (REG_IE &amp; REG_IF) | "BIOS_IF"
<br/>
   strh r2, [r0, #-8]      @ Les écrire (pour que le hardware les efface, il n'a pas de sens, je sais)
<br/>
   bx lr</td> </tr></table><span class="postbody">The code now checks if it's a VBLANK interrupt (and if VBLANK interrupts are currently enabled, though i don't really think that part is really necessary). However, VBA doesn't seem to ever run the actual code inside the interrupt (the interrupt gets run, but the screen never updates). No$gba doesn't have any problems with the code, though, and i can scroll across a nice 512x512 (pixel) tilemap. I wish i could test it out on hardware to see whether or not it works, i thought using a VBLANK interrupt to update the screen was common practice, though i guess it's probably not with this exact method. Still, i wish i knew what was causing the problem(s) with VBA (since i don't have to run it through Wine and can assemble and load it up with a simple script). I imagine emulating the interrupts/display hardware can't be that simple, but it could be an issue with my program.
<br/>
<br/>
I looked through the source to Manic Miner real quickly to see how it was handled there, but it seems like it just waits for VCOUNT to reach the bottom of the screen. Or at least that's what the "waitforVblank" routine seems to do. I did see a really cool trick there, though, to get rid of the bx lr at the end of a routine when you've already gotta save some stuff to the stack :D I love those sorts of things!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177697 - Dwedit - Sun Dec 02, 2012 11:44 pm</h4>
    <div class="postbody"><span class="postbody">Did you provide a BIOS image for VBA and NO$GBA?<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177698 - chickendude - Mon Dec 03, 2012 1:37 pm</h4>
    <div class="postbody"><span class="postbody">I just tried with VBA, but i think it doesn't like my header (or lack thereof), after displaying the Gameboy logo and jumbled Nintendo logo it just freezes. For NO$GBA i haven't tried either but in the "Emulate BIOS functions" option it says "By real GBA.ROM", so i don't know if that means it's using a BIOS image or not. The BIOS is in the folder, though.
<br/>
<br/>
EDIT: I just added the GBA header and it still messes up in VBA and runs fine in NO$GBA.
<br/>
<br/>
EDIT2: I changed the interrupt acknowledgement bit to something based off the code you gave me and now it works fine on both emulators. Before i had one part to reset REG_IF and one part to reset the BIOS flags. I realized that really they should be setting the same bits so i just combined them into one:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ Annoncer que l'on a fini son travail avec l'interruption
<br/>
@ r0 = REG_IE (dÃ©but des registres d'interruption)
<br/>
@ r1 = REG_BASE (REG_DISPCNT)
<br/>
   mov r0, #REG_BASE            @ 0x0400:0000 (REG_DISPCNT)
<br/>
   add r0, #REG_INT_OFF         @ 0x0400:0200 (dÃ©but des registres d'interruption)
<br/>
   ldr r2, [r0]               @ r2 = REG_IE (2 octets) et REG_IF (2 octets)
<br/>
   and r2, r2,r2, LSR #16         @ ANDer REG_IE et REG_IF
<br/>
   ldrh r3, [r1, #-8]            @ Les drapeaux d'interruptions du BIOS (0x3FFFFF8 est un miroir de 0x3007FF8)
<br/>
   orr r2, r2, r3               @ (REG_IE &amp; REG_IF) | "BIOS_IF"
<br/>
   mov r1, #REG_BASE
<br/>
   strh r2, [r1, #-8]            @ Les Ã©crire (pour que le hardware les efface, il n'a pas de sens, je sais)
<br/>
   strh r2, [r0, #REG_IF_OFF]   @ 
<br/>
   bx lr</td> </tr></table><span class="postbody">
<br/>
Also, waiting for the next VBLANK interrupt with the BIOS function makes the screen scroll pretty slowly. Here's a <a class="postlink" href="http://www.mirari.fr/RHp6" target="_blank">screenshot</a>. It's slightly faster than in the screenshot, but still pretty slow.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177703 - sverx - Tue Dec 04, 2012 5:46 pm</h4>
    <div class="postbody"><span class="postbody">I don't get why it should be slower, using the SWI function. You get one scroll each frame, no more, so how that could depend on how you manage the Vblank?
<br/>
BTW the SWI is the way to go for that. It saves lots of power.<br/>_________________<br/><a class="postlink" href="http://bit.ly/yiQrz9" target="_blank">libXM7</a>|<a class="postlink" href="http://bit.ly/yJwcOo" target="_blank">NDS programming tutorial (Italiano)</a>|<a class="postlink" href="http://disjointedstudio.blogspot.com/" target="_blank">Waimanu DS / GBA</a>|<a class="postlink" href="http://adshomebrewersdiary.blogspot.com" target="_blank">A DS Homebrewer's Diary</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177705 - chickendude - Tue Dec 04, 2012 7:15 pm</h4>
    <div class="postbody"><span class="postbody">I don't get it either, though i'm not exactly sure how the hardware scrolling works. I thought it would be more or less instantaneous, but it seems to take up quite a bit of time. I dunno if it's got something to do with my interrupt routine taking up too much time. Using the SWI function you don't even need an interrupt routine anymore, do you? I was using it to wait until the next VBLANK interrupt where my interrupt routine would handle it.
<br/>
<br/>
And if anyone's interested, this is my latest source and a screenshot:
<br/>
<a class="postlink" href="http://www.mirari.fr/zzRG" target="_blank">Source directory</a>
<br/>
<a class="postlink" href="http://www.mirari.fr/8sPM" target="_blank">Screenshot</a>
<br/>
<br/>
I've added another background layer (a sort of "sky") which scrolls more slowly than the "ground" layer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177706 - Dwedit - Tue Dec 04, 2012 7:22 pm</h4>
    <div class="postbody"><span class="postbody">NO$GBA says:
<br/>
* You're doing busy waiting to wait for vblank (100% CPU usage)
<br/>
* You are doing some invalid memory reads (address FFFFFFFB, FFFFFFFF, 00000001)  (it's inside the function "interrupt" by the way)<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177707 - chickendude - Tue Dec 04, 2012 7:34 pm</h4>
    <div class="postbody"><span class="postbody">Thanks. I think i've found where that's happening. How did you find that out so quickly? :D
<br/>
<br/>
EDIT: And i don't think i'm doing any actual waiting for VBLANK, i've just got a delay loop (which of course is just a huge waste of energy). I found HALTCNT in gbatek as well as a SWI halt function which'd probably be a better choice instead of what i'm doing now.
<br/>
<br/>
Annnd... now i think i've got the invalid reads fixed :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177723 - Miked0801 - Mon Dec 17, 2012 6:36 pm</h4>
    <div class="postbody"><span class="postbody">For fun and profit, you can also update the scroll register during the HBlank period as well.  Lots of fun possibilities when you start doing that ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177726 - chickendude - Thu Dec 20, 2012 8:45 pm</h4>
    <div class="postbody"><span class="postbody">Isn't that what i'm doing? Aren't REG_BG2X/Y the scroll registers? What sorts of things do you mean? :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177727 - elhobbs - Thu Dec 20, 2012 9:08 pm</h4>
    <div class="postbody"><span class="postbody">Hblank - horizontal blank, rather than vblank - vertical blank. using hblank you could have a different scroll position for each scan line.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177729 - sverx - Fri Dec 21, 2012 10:15 am</h4>
    <div class="postbody"><span class="postbody">You can do wave effects for instance :)<br/>_________________<br/><a class="postlink" href="http://bit.ly/yiQrz9" target="_blank">libXM7</a>|<a class="postlink" href="http://bit.ly/yJwcOo" target="_blank">NDS programming tutorial (Italiano)</a>|<a class="postlink" href="http://disjointedstudio.blogspot.com/" target="_blank">Waimanu DS / GBA</a>|<a class="postlink" href="http://adshomebrewersdiary.blogspot.com" target="_blank">A DS Homebrewer's Diary</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177730 - Miked0801 - Sat Dec 22, 2012 6:47 pm</h4>
    <div class="postbody"><span class="postbody">Check out The Legend of Spyro:Eternal Night's fire temple levels for some fun HBlank effects that we were able to accomplish. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177732 - sverx - Thu Dec 27, 2012 10:25 am</h4>
    <div class="postbody"><span class="postbody">You mean the background as seen in <a class="postlink" href="http://www.youtube.com/watch?v=siNPNWEVDNM" target="_blank">this video</a>? Were you using HBlank and palette effets? Very cool! :D<br/>_________________<br/><a class="postlink" href="http://bit.ly/yiQrz9" target="_blank">libXM7</a>|<a class="postlink" href="http://bit.ly/yJwcOo" target="_blank">NDS programming tutorial (Italiano)</a>|<a class="postlink" href="http://disjointedstudio.blogspot.com/" target="_blank">Waimanu DS / GBA</a>|<a class="postlink" href="http://adshomebrewersdiary.blogspot.com" target="_blank">A DS Homebrewer's Diary</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177733 - Miked0801 - Thu Dec 27, 2012 6:07 pm</h4>
    <div class="postbody"><span class="postbody">Yep - the waves were BG scaling and the colors were palette cycling.  And then getting those big sprites to animate at full speed and such :)
<br/>
<br/>
That was a fun time.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177734 - headspin - Thu Dec 27, 2012 9:46 pm</h4>
    <div class="postbody"><span class="postbody">Fun times indeed. Here are some examples of these two effects I wrote for Warhawk (which has a whole bunch more there too).
<br/>
<br/>
<a class="postlink" href="http://code.google.com/p/warhawk-ds/source/browse/trunk/WarhawkDS/arm9/source/fxColorCycle.s?r=684" target="_blank">fxColorCycle.s</a>
<br/>
<a class="postlink" href="http://code.google.com/p/warhawk-ds/source/browse/trunk/WarhawkDS/arm9/source/fxSine.s?r=684" target="_blank">fxSine.s</a><br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
