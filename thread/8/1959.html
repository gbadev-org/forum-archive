<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>question about LDR instruction ... ... ... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>ASM > question about LDR instruction ... ... ...</h2>
<div id="posts">
<div class="post">
    <h4>#10128 - wasiliy - Wed Aug 27, 2003 6:50 pm</h4>
    <div class="postbody"><span class="postbody">hi,
<br/>
when i write :
<br/>
ldr r1,=0x0404
<br/>
<br/>
the assembler seems to store the value 0x0404 somewhere in memory and on runtime the CPU loads the value from memory to the register.
<br/>
my question is: can i load the value directly and not from memory?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10129 - torne - Wed Aug 27, 2003 6:56 pm</h4>
    <div class="postbody"><span class="postbody">You can't *load* a value directly, as loading implies 'from memory'. You can use mov to put a constant into a register, however, you can only use constants that are an 8-bit constant shifted left by an even number of bits. 0x0404 cannot be represented in this form, so there is no way to put it into a register except by loading it from memory.
<br/>
<br/>
GAS will automatically detect if the number in an ldr instruction using = is of a suitable form (try doing ldr r1,=0x7 or something) and use a mov instruction instead of a memory load. Your best bet is just to use ldr with = all the time, and let the assembler work it out.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10136 - wasiliy - Wed Aug 27, 2003 7:31 pm</h4>
    <div class="postbody"><span class="postbody">hmm this sucks ...
<br/>
i try to copy my code from 0x08000000 to 0x03000000 and when i do it, all ldr instructions become useless because they use adresses which start with 0x03000000 but the values are stored at 0x08000000 =(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10138 - FluBBa - Wed Aug 27, 2003 7:47 pm</h4>
    <div class="postbody"><span class="postbody">Isn't the LDR instruction PC relative?<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10139 - DekuTree64 - Wed Aug 27, 2003 8:08 pm</h4>
    <div class="postbody"><span class="postbody">ldr r, =constant does a pc-relative load, so it shouldn't matter wether pc is in 0x3000000 or 0x8000000, the pool is the same distance from the pc either way. Try putting a .pool just after your ASM function so you know exactly where it will store all the things you're loading with ldr, and copy the size of your function plus some extra for the pool. The constants should be 4 bytes each, so you should be able to count the number of different things you loaded throughout your function, multiply that by 4 and add it to the size of the function, but I usually copy a little extra just to be sure.
<br/>
You can also do it more specifically by doing something like 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.global funcName
<br/>
@yada yada, do stuff
<br/>
ldr r0, value   @r0 should now be 0x2345
<br/>
bx lr
<br/>
value:
<br/>
.word 0x2345
<br/>
</td> </tr></table><span class="postbody">
<br/>
And then you know that right after you return, there's a 4 byte value that you need to copy. That should compile to an ldr r0, [pc] (pc points to 2 instructions ahead, and there's that bx lr, and then the constant, so just load from pc), so as you can see, it doesn't matter what pc is, it just knows that the value it's looking for is 8 bytes ahead.
<br/>
Be sure to .align those constants if you're using THUMB though, but then you might have 2 unused bytes, so be sure to copy a little extra incase of that. Generally it's only worth using IWRAM for ARM code though, so it should be 4-byte aligned already.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10153 - wasiliy - Thu Aug 28, 2003 11:40 am</h4>
    <div class="postbody"><span class="postbody">thank you very much for you help guys!!! my fire runs really fast now on emu and on hardware since it is in iwram.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
