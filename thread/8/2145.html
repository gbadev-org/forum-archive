<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Working with the stack - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>ASM > Working with the stack</h2>
<div id="posts">
<div class="post">
    <h4>#11129 - Lupin - Fri Sep 26, 2003 7:45 pm</h4>
    <div class="postbody"><span class="postbody">I want to write an function which uses more then just 11 registers (I think that's the amount of registers I could use freely, right?), so I have to use the stack. I know I could use....
<br/>
<br/>
stmfd   sp!,{r10-r12,r3}
<br/>
...to store r10-r12 + r3 onto the stack...
<br/>
....and....
<br/>
<br/>
ldmfd   sp!,{r10-r12,r3}
<br/>
...to load r10-r12 + r3 from my stack
<br/>
<br/>
But the problem is, the ldm instruction would of course overwrite my current values of r10-r12,r3, but I need to save these values on another position of the stack.
<br/>
<br/>
Could someone please explain me how I could do all this? An stm/ldm example using offsets would be cool, so that I could free like 8 bytes for 1 data set and access these 8 bytes directly and have another data set which is like 16 bytes big and which I could access directly too.
<br/>
<br/>
This stack thing is pretty confusing...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11136 - DekuTree64 - Sat Sep 27, 2003 3:12 am</h4>
    <div class="postbody"><span class="postbody">To store 2 sets and then load the first one, you'd do something like
<br/>
stmfd sp!, {r3, r10-r12}
<br/>
@do stuff
<br/>
stmfd sp!, {r3, r10-r12}
<br/>
add r0, sp, #16
<br/>
ldmia r0, {r3, r10-r12} @or ldmfd, different syntax for the same opcode
<br/>
<br/>
One more thing, the order you specify the regs for stm/ldm doesn't matter, they're always stored in the order of their numbers, with the higher numbers at higher addresses, wether you're using increment or decrement, so after this, [sp] will hold the value in r3, [sp + 4] will be r10, etc., so it actually goes decrement sp, store r12, dec sp, store r11, and so on. Stmia would go store r3, inc sp, store r10, etc. 
<br/>
Then ldmfd does load r3, inc sp, load r10, inc sp...
<br/>
<br/>
Does that clear things up a little?<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
