<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Directional Fire - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Directional Fire</h2>
<div id="posts">
<div class="post">
    <h4>#167280 - headspin - Sat Mar 07, 2009 6:32 pm</h4>
    <div class="postbody"><span class="postbody">Were looking at implementing directional fire into a game a friend and I are working on in asm. We have the following C code to work from.
<br/>
<br/>
To calculate the the angle from the alien to the ship
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"># Alien
<br/>
x1 = 128
<br/>
y1 = 128
<br/>
<br/>
# Ship
<br/>
x2 = 132
<br/>
y2 = 132
<br/>
<br/>
deltax = x2 - x1
<br/>
deltay = y2 - y1
<br/>
<br/>
angle_rad = atan2(deltay,deltax)</td> </tr></table><span class="postbody">
<br/>
<br/>
And then to move the bullet towards the ship from the alien
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"># alien starting point
<br/>
x0 = 1.0
<br/>
y0 = 1.5
<br/>
<br/>
# theta is the angle (in radians) of the direction in which to move
<br/>
theta = pi/6
<br/>
<br/>
# r is the distance to move
<br/>
r = 2.0
<br/>
<br/>
deltax = r * cos(theta)
<br/>
deltay = r * sin(theta)
<br/>
<br/>
# new point
<br/>
x1 = x0 + deltax
<br/>
y1 = y0 + deltay</td> </tr></table><span class="postbody">
<br/>
<br/>
I've found an implementation of atan2 in asm on these boards which we can use. But is there a way to do the calculation without atan2? Also avoiding the divide would be nice. So basically any suggestions for an algorithm that would be faster in arm asm.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167281 - Miked0801 - Sat Mar 07, 2009 6:42 pm</h4>
    <div class="postbody"><span class="postbody">atan and atan2 can be implemented as a table lookup.  There are also a number of algorithms that approximate the function quickly.
<br/>
<br/>
Also, where's the divide?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167284 - headspin - Sat Mar 07, 2009 7:13 pm</h4>
    <div class="postbody"><span class="postbody">A lookup table, good idea. The thing is it's not like sin and cos where it takes one parameter to calculate so how big would the table need to be if X is 0-256 and Y is 0-192? Seems like it would be a rather large table.
<br/>
<br/>
Does anyone have a table we could use. I can write a program to generate one quite easily if I knew how it should be structured so it's easy to look up.
<br/>
<br/>
Sorry I realised the divide (pi/6) is not required but just part of the example. The theta is the same as angle_rad as calculated in the first code snippet.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167291 - Ruben - Sun Mar 08, 2009 8:48 am</h4>
    <div class="postbody"><span class="postbody">Actually, you don't need a massive table for sin/cos; you just have a quarter of a sine, and then do the reflexes manually. Eg..
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//In a separate file calculated in GCC (not for ARM)
<br/>
<br/>
#define PI 3.1415926535897932384626433832795
<br/>
<br/>
#include &lt;math.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
int main(void) {
<br/>
    FILE *myFile = fopen("sin.s", "wt"); //Omit the T in a Linux environment
<br/>
    fprintf(myFile, ".section .rodata\n.align 2\n.global _SinTable\n\n_SinTable:\n");
<br/>
<br/>
    for(int i = 0; i &lt; (512/4) ; i++) { //512 / 4 to get only a quarter (rescaling sine to a 0-511 range)
<br/>
        unsigned int myVal = (unsigned int)(sin((float)i*2*PI / 512) * (1&lt;&lt;14) + 0.5);
<br/>
        if(i&amp;7) fprintf(myFile, ", 0x%04X", myVal);
<br/>
        else fprintf(myFile, "\n.hword 0x%04X", myVal);
<br/>
    }
<br/>
    fclose(myFile);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Then you make your own sin/cos functions like this...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">s32 Sine(s32 Theta) {
<br/>
    extern s16 _SinTable[512/4];
<br/>
    
<br/>
    s32 Mult = 1, Offset = (512/4)-1;
<br/>
    Theta &amp;= 512-1; //Clamp it in range
<br/>
    
<br/>
    //Calculate reflexes
<br/>
    if(Theta &gt; (512/2)) Mult = -Mult;
<br/>
    if((Theta&amp;255) &gt; (512/4)) Offset = 255;
<br/>
    
<br/>
    //Clamp theta in the range of the length of the LUT
<br/>
    Theta &amp;= (512/4)-1;
<br/>
    
<br/>
    //Return
<br/>
    return (s32)(_SinTable[Offset-Theta] * Mult);
<br/>
}</td> </tr></table><span class="postbody">Just please don't use that code directly.. I'm not sure if it's correct.. I only just woke up and I have a headache so don't trust everything I say. &gt;.&gt;"
<br/>
<br/>
Oh and about atan2..
<br/>
You can either use your own implementations or use the BIOS call.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167313 - headspin - Sun Mar 08, 2009 8:38 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Ruben but I already have a sin and cos table. I'm interested in how to generate one for atan2.
<br/>
<br/>
P.S I don't think there is an atan2 BIOS function for the NDS only for the GBA.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167318 - Cearn - Sun Mar 08, 2009 11:34 pm</h4>
    <div class="postbody"><span class="postbody">Unless you need the angle for something else (like rotating a turret to a certain direction) you probably don't need the arctan. Just get the deltas and normalize that vector to the desired speed.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// NOTE: assuming 12bit fixed point here.
<br/>
dx= x2-x1;
<br/>
dy= y2-y1;
<br/>
norm= divf32(speed, sqrtf32(dx*dx+dy*dy)&gt;&gt;6);
<br/>
<br/>
vx = dx*norm&gt;&gt;12;
<br/>
vy= dy*norm&gt;&gt;12;
<br/>
</td> </tr></table><span class="postbody">If you include the set-up and safeties, the NDS hardware division costs about 80 cycles. Unless you do several thousand of them per frame, I'm not sure if you should be that considered about it.
<br/>
<br/>
If you really do need an arctan, consider looking <a class="postlink" href="http://www.coranac.com/documents/arctangent/" target="_blank">here</a>. It can be done in roughly 100 cycles on the NDS even without trying very hard.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167388 - Flash - Tue Mar 10, 2009 7:15 pm</h4>
    <div class="postbody"><span class="postbody">Thanks to all for their help on this :)
<br/>
<br/>
We did get there in the end, though I had to keep all in toe with the rest of the sprite code (which is straight integer).
<br/>
<br/>
The workaround was to use the idea from cearn to create fixed point delays on the x/y axis and +/- speeds. This has worked a treat. it is perfectly accurate to the t!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">         @ ok, now to work out where to shoot???
<br/>
         @ r4/r5 = player X/Y
<br/>
         @ r6/r7 = Alien X/Y
<br/>
         @ r12 = shot speed
<br/>
         mov r10,r12                  @ Store the X/Y speeds
<br/>
         mov r11,r12                  @ we will need r12 later
<br/>
         
<br/>
         cmp r5,r7
<br/>
         rsble r11,r11,#0
<br/>
         suble r9,r7,r5
<br/>
         subgt r9,r5,r7         
<br/>
            cmp r4,r6
<br/>
            rsble r10,r10,#0
<br/>
            suble r8,r6,r4
<br/>
            subgt r8,r4,r6
<br/>
            cmp r8,r9
<br/>
            bmi directOddQuad
<br/>
               push {r0-r2}
<br/>
               mov r0,r8               @ divide this number
<br/>
               add r9,r12               @ we also need to divide by the SPEED
<br/>
               mov r1,r9               @ by this number
<br/>
                  bl divf32            @ r0=result 20.12   
<br/>
               mov r9,r0               @ move the whole to r9
<br/>
               mov r8,#0   
<br/>
               pop {r0-r2}
<br/>
            b directDone
<br/>
            directOddQuad:
<br/>
               push {r0-r2}
<br/>
               mov r0,r9               @ divide this number
<br/>
               add r8,r12               @ we also need to divide by the SPEED
<br/>
               mov r1,r8               @ by this number
<br/>
                  bl divf32            @ r0=result 20.12   
<br/>
               mov r8,r0               @ move the whole to r8
<br/>
               mov r9,#0   
<br/>
               pop {r0-r2}
<br/>
            b directDone         </td> </tr></table><span class="postbody">
<br/>
<br/>
So, the result is that r10,r11 hold the signed x/y speed and r8,r9 hold a 20.12 fixed point delay on the update of x/y.
<br/>
<br/>
It is not perfect, but it is quick and works a dream with the existing sprite code, so... I am very happy :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
