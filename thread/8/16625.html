<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Getting started the flat way... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Getting started the flat way...</h2>
<div id="posts">
<div class="post">
    <h4>#168371 - kohlrak - Sat Apr 25, 2009 10:50 pm</h4>
    <div class="postbody"><span class="postbody">Me and my one friend were working on an x86 kernel, and i've personally found that the hardware documentation and computability issues with it are just annoying.  I thought it'd be nice to try to work with a system with more standardized and better documented hardware (and i don't mean more documentation, i mean being able to look at examples or maybe a page [instead of 100+] just to use one piece of hardware).
<br/>
<br/>
Fortunately for me, my favorite assembler has an ARM version. Not so fortunately for me, nothing here is intended for an assembler with the kind of syntax that i wish to be using.  I'm not familiar with using gnu assembler (i hate it, quite frankly, because it's syntax is rather weird and it uses a linker).
<br/>
<br/>
So, can anyone do me a favor and come up with a flatter example of hello world or something for the ds? For those of you that don't quite understand what i'm asking, a nice equivalent in x86 asm would be the following:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
org 0x7c00 ;This is where the PXE loader puts us
<br/>
;zero all segment registers except CS, since no one knows what the BIOS fills them with
<br/>
   xor   ax,ax
<br/>
   mov   ds,ax
<br/>
   mov   es,ax
<br/>
   mov   fs,ax
<br/>
   mov   gs,ax
<br/>
   mov   ss,ax
<br/>
<br/>
   ;Setup text mode
<br/>
   mov ah, 0xF
<br/>
   int 0x10 ;Get the screen page
<br/>
   mov si, hello
<br/>
   mov ah, 0xE ;teletype output
<br/>
<br/>
   ;Print the string a letter at a time
<br/>
@@:   ;anonymous label
<br/>
   lodsb
<br/>
   or al, al
<br/>
   jz @f ;next anonymous label
<br/>
   int 0x10
<br/>
   jmp @b ;back a label
<br/>
<br/>
@@:
<br/>
   hlt
<br/>
   jmp @b ;halt loop
<br/>
<br/>
hello db "Hello, world!", 0
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168372 - Dwedit - Sat Apr 25, 2009 11:20 pm</h4>
    <div class="postbody"><span class="postbody">Hello world is a little tricky, since the GBA does not have a built in font, nor built in text drawing code.
<br/>
For a hello world program you would need to do something like this: (psuedocode, not actual equate names)
<br/>
Bring your own font and palette.
<br/>
<br/>
memset(vram,0,vramsize)
<br/>
memcpy(vram+font_location,font_data,fontsize)
<br/>
memcpy(palette,palette_data,palettesize)
<br/>
reg_dispcnt=mode_0 | bg1_enable
<br/>
reg_bg0cnt=(font_location/16384)*4  + (map_location/2048)*256
<br/>
<br/>
drawtext(const char* text, x, y, color) {
<br/>
addme=(color&lt;&lt;12)+FIRST_CHAR
<br/>
u16 *map_addr = vram+map_location
<br/>
u16 *text_addr = map_addr + x + y*32
<br/>
while (*text!=0) {
<br/>
*text_addr=*text+addme
<br/>
text_addr++
<br/>
text++
<br/>
}
<br/>
}
<br/>
drawtext("Hello World",0,0,0)
<br/>
<br/>
<br/>
An easier example ASM would be one which turns the screen blue.
<br/>
It would just need to do this:
<br/>
reg_dispcnt=0
<br/>
palette[0]=0x7C00<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168373 - headspin - Sun Apr 26, 2009 12:42 am</h4>
    <div class="postbody"><span class="postbody">Asm version of hello world <a class="postlink" href="http://members.iinet.net.au/~freeaxs/nds/helloworld.zip" target="_blank">here</a>. There are a couple more examples at the RetroBytes Portal website.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168374 - Dwedit - Sun Apr 26, 2009 12:49 am</h4>
    <div class="postbody"><span class="postbody">Also known as Hello World - Special battery killer edition.  No vblank waits seen in the ARM7 code here.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168375 - headspin - Sun Apr 26, 2009 1:08 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Also known as Hello World - Special battery killer edition.  No vblank waits seen in the ARM7 code here.</td> </tr></table><span class="postbody">
<br/>
<br/>
Okay updated :)<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168376 - kohlrak - Sun Apr 26, 2009 4:28 am</h4>
    <div class="postbody"><span class="postbody">alright, thank you. If i ever manage to get this working with fasmarm, i'll make an example... however, should most of the ram already be 0ed? Oh well, once i get it working with my assembler (due ot time restrictions it could take a while) i'll have everything posted here. I've heard complaints about the trouble of learning arm asm because of having to spend so much time learning just the assembler, so maybe this'll help a bit (this one has lots of features but you don't have to understand any of them to start out).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168382 - Dwedit - Sun Apr 26, 2009 2:49 pm</h4>
    <div class="postbody"><span class="postbody">Anyway, my recommendation is to use C for as much as you can for the non-performance critical code, then use sweet sweet ASM code placed in fast memory for the fast stuff.  Compilers are somewhat good at generating code, but if you need a function to run 4 times faster, that's what ASM is for.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168385 - kusma - Sun Apr 26, 2009 5:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Compilers are somewhat good at generating code, but if you need a function to run 4 times faster, that's what ASM is for.</td> </tr></table><span class="postbody">
<br/>
Actually, no. ASM optimizations can usually only buy you around 20-30% performance. Unless ofcourse, you're really bad at writing fast C code. And in such cases, going ASM isn't really the best first step ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168387 - Dwedit - Sun Apr 26, 2009 7:23 pm</h4>
    <div class="postbody"><span class="postbody">Okay, 4 times faster if you're moving from Thumb code in slow memory to ARM code in fast memory.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168395 - Miked0801 - Mon Apr 27, 2009 5:05 am</h4>
    <div class="postbody"><span class="postbody">Depends on what the C code is doing and how many times it's called.  I've seen many cases where asm hand code doubles to triples performance of a section of code.  That's not counting moving code to fast RAM.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168396 - kusma - Mon Apr 27, 2009 9:04 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Okay, 4 times faster if you're moving from Thumb code in slow memory to ARM code in fast memory.</td> </tr></table><span class="postbody">
<br/>
Yeah, but that has pretty much nothing to do with ASM, -marm and IWRAM_CODE ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168397 - kusma - Mon Apr 27, 2009 9:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Depends on what the C code is doing and how many times it's called.  I've seen many cases where asm hand code doubles to triples performance of a section of code.  That's not counting moving code to fast RAM.</td> </tr></table><span class="postbody">
<br/>
In my experience, this is usually only the case for poorly written C-code. There are some extremely rare cases where you can get something like this, but those are so rare that they aren't worth discussing on a general basis, IMO.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168398 - kohlrak - Mon Apr 27, 2009 10:38 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Actually, no. ASM optimizations can usually only buy you around 20-30% performance. Unless ofcourse, you're really bad at writing fast C code. And in such cases, going ASM isn't really the best first step ;)</td> </tr></table><span class="postbody">
<br/>
<br/>
I've written two hello world programs on linux, both using assembly. One used headers i created from scratch, the other made an object file for a linker. That very simple difference resulted in the GNU linker building a binary 10 times the size of the perfectly fine one i made (and i didn't even have it optimized at that point). I used the stipper tool, but it didn't take much off. However, since this is arm and it's simpler, i would assume they can make a better compiler.
<br/>
<br/>
EIther way, i find HLLs like C too tedious to work with (constantly have to make sure your types are converted [even though the computer never actually converts them] properly, or the compiler won't compile). The best example is with sockets... I remember doing winsocks in C++, and just trying to access the IP address in the one structure and never, ever, wanting to ever do it in C++ ever again.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168399 - kusma - Mon Apr 27, 2009 11:00 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">I've written two hello world programs on linux, both using assembly. One used headers i created from scratch, the other made an object file for a linker. That very simple difference resulted in the GNU linker building a binary 10 times the size of the perfectly fine one i made (and i didn't even have it optimized at that point). I used the stipper tool, but it didn't take much off.</td> </tr></table><span class="postbody">
<br/>
Did you notice how I was talking about performance and not size? ;)
<br/>
<br/>
Yes, when it comes to code-size, hand-optimizing is often more effective than compilers, since this is not a field that brings as much (perceived?) value to a compiler as performance is.
<br/>
<br/>
But do keep in mind that your measurements doesn't mean that linked code is 10 times as big as directly assembled code - it just means that the linker uses more space up-front. Also, since GBA / NDS doesn't run ELF-files you won't get the same overhead. Playing around with the linker-settings can also often save you quite some space. Nevertheless, as long as you link in the CRT, you'll bring in the startup-sequence, and that costs some bytes (at the gain of a working runtime environment).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168401 - Miked0801 - Mon Apr 27, 2009 5:40 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
In my experience, this is usually only the case for poorly written C-code
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And this is a most wonderful topic of discussion in and of itself.  What is poorly written code, normal code, and fast code :)
<br/>
<br/>
I've found that when writing 'fast' C code, it becomes so compiler/platform specific that it might as well be assembler anyways for its very stringent code alignment/funky accesses/etc..  Case in point:
<br/>
<br/>
Poor performance, yet easliy read code: (PS, non compiled, written on the fly code, user beware)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// assume src and dest are 4-byte aligned
<br/>
void fastcopy(u8 *src, u8 *dest, u32 size)
<br/>
{
<br/>
    for (int i=0; i&lt;size; i++)
<br/>
    {
<br/>
        dest[i] = src[i];
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
// better code (by speed, not size)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// assume src and dest are 4-byte aligned
<br/>
void fastcopy(u32 *src, u32 *dest, u32 size)
<br/>
{
<br/>
    for (int i=0; i&lt;size/4; i++)
<br/>
    {
<br/>
        *dest++ = *src++;
<br/>
    }
<br/>
     
<br/>
    int bytesRemaining = size &amp; 0x03;
<br/>
    if(bytesRemaining)
<br/>
    {
<br/>
        u8 *byteDest = (u8 *)dest;
<br/>
        u8 *byteSrc = (u8 *)src;
<br/>
        for (int i=0; i&lt;bytesRemaining; i++)
<br/>
        {
<br/>
            *byteDest++ = *byteSrc++;
<br/>
        }
<br/>
    }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And then we get into the realm of platform specific optimizations - where DS code will probably be different from GBA code and both will be different from any other platform.  Where assembler will probably be easier to read/understand than C code; where the compiler basically is getting in the way of your code.  Don't get me wrong.  This type of stuff should be in WAY less than 1% of any application and only where the time spent over the YEARS of you having to maintain it outway its immediate usefulness.
<br/>
<br/>
(and yes, we can get another 50-200% of performance over the better code, depending on how much the compiler sucks.)
<br/>
<br/>
For instance, in DS land, cache is king. Huge loop unrolls kill.  On GBA, what cache? :)  Unroll until you run out of RAM/ROM.  Yet unrolled code is ugly to read. and harder to maintain in C land without even uglier macros (or inlines).
<br/>
<br/>
Now, we can write a better version with jump tables to unrolls, or perhaps self modifying code on the loop lookups, etc.  Both of these will get us a speed boost by eliminating the need to track the loop, but both need to be aligned well on DS or caching kills.  And self-modifying probably kills the DS anyways.
<br/>
<br/>
But you get the point.  How far do you go in optimizations before you are better off with asm?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168403 - kusma - Mon Apr 27, 2009 6:55 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">But you get the point.  How far do you go in optimizations before you are better off with asm?</td> </tr></table><span class="postbody">
<br/>
I'll see your copy-loop, and raise you a memcpy - or CpuFastCopy(). There, not compiler specific, yet optimized. A copy-loop isn't a good example here anyway, since the algorithmic complexity is so much lower than usual program logic.
<br/>
<br/>
Writing assembly is easy. Writing GOOD assembly is very tedious, mostly due to register allocation and scheduling (do you remember what ARM9-instruction sequences cause interlocks on top of your head? The compiler does...). You can often write C-code that is almost equivalent to ASM without having to deal with register allocation and scheduling. And unless you spend hours reading instruction timings and allocating register life-time, your compiler will still usually beat you by a good margin.
<br/>
<br/>
As a clever man once said "Your compiler can write better code in microseconds than you can do in hours". Sure, those extra 20-30% might be worth it in your most timing critical loop, I never denied that. It might be just the little push you need to go from 30 to 60 FPS. But believing that code automatically become significantly faster by writing it in assembly is plain stupid.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168404 - kusma - Mon Apr 27, 2009 6:56 pm</h4>
    <div class="postbody"><span class="postbody">admins: perhaps this sub-thread should be split from the original topic?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168406 - elwing - Mon Apr 27, 2009 8:01 pm</h4>
    <div class="postbody"><span class="postbody">hum, what about "...the root of all evil" and other good advices? writing a game is complex enough, reuse the maximum you can from the lib you have... eg: use TTE console from tonclib rather that trying to set up your own... and work on your game logic rather that reinventing the wheel or spending 95% of your time on code running less than 5% of the program lifetime... once everything is done, perform some profiling, do the high level optimisation and if your skilled enough the low level assembly optimisation of the critical method (like memcopy method, trough in my opinion you should reuse assembly too when it's already good...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168425 - Miked0801 - Tue Apr 28, 2009 11:10 pm</h4>
    <div class="postbody"><span class="postbody">kusma, you give our compiler too much credit.  99.9% of the time, it does an acceptable job and sometimes it does even a good job.  But it rarely does a great job and that is where a little tweaking can go a long ways in VERY specific and carefully choosen places.
<br/>
<br/>
Yes, I chose a copy loop because it was something I could easily expand upon and code decently on the fly without thinking about it.  And yet, the 'optimized' CpuFastCopy() that we get is not as fast as it could be.  Copys tend to be a top 10 cycle eater when profiling so it is a valid discussion point.
<br/>
<br/>
And have you ever looked at memcpy?  The one I seen used a byte copy loop , bleh.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168426 - kusma - Tue Apr 28, 2009 11:47 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">kusma, you give our compiler too much credit.</td> </tr></table><span class="postbody">
<br/>
And you're giving it too little credit.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">99.9% of the time, it does an acceptable job and sometimes it does even a good job.</td> </tr></table><span class="postbody">
<br/>
Absolutely not. In my experience, 95% of the time it does an awesome job (at no effort), and 2% of the time it does a poor job - usually because the code doesn't allow it to optimize further.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">But it rarely does a great job and that is where a little tweaking can go a long ways in VERY specific and carefully choosen places.</td> </tr></table><span class="postbody">
<br/>
You and I must be from different planets. Either you are much much smarter than me, or you're writing bad C core and/or have been using bad compilers. Or you're exaggerating to make a point.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Yes, I chose a copy loop because it was something I could easily expand upon</td> </tr></table><span class="postbody">
<br/>
Which is exactly why I think it's a bad example - it isn't expanded to a practical level of complexity.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">and code decently on the fly without thinking about it.  And yet, the 'optimized' CpuFastCopy() that we get is not as fast as it could be.
<br/>
</td> </tr></table><span class="postbody">
<br/>
No, but it is fast enough for all practical purposes. Optimizing further is too much effort for the gain.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Copys tend to be a top 10 cycle eater when profiling so it is a valid discussion point.</td> </tr></table><span class="postbody">
<br/>
But there's always an optimized copy around somewhere, unless you're designing your own CPU or something.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">And have you ever looked at memcpy?  The one I seen used a byte copy loop , bleh.</td> </tr></table><span class="postbody">
<br/>
I've looked at multiple, yes. Some were byte-copies, so we swapped it, and some were fast. But these things is something PROFILING should tell you, not random rewriting in assembly.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168428 - kohlrak - Wed Apr 29, 2009 1:55 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Yes, when it comes to code-size, hand-optimizing is often more effective than compilers, since this is not a field that brings as much (perceived?) value to a compiler as performance is.</td> </tr></table><span class="postbody">
<br/>
<br/>
When memory is the bottleneck, size optimization usually is speed optimization. Though that all depends on the cache.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">But do keep in mind that your measurements doesn't mean that linked code is 10 times as big as directly assembled code - it just means that the linker uses more space up-front. Also, since GBA / NDS doesn't run ELF-files you won't get the same overhead. Playing around with the linker-settings can also often save you quite some space. Nevertheless, as long as you link in the CRT, you'll bring in the startup-sequence, and that costs some bytes (at the gain of a working runtime environment).</td> </tr></table><span class="postbody">
<br/>
<br/>
Dynamically linking, though, is typically sufficient. Typically a user doesn't mind so much about startup/load time as he or she may mind the download time... Although one may feel the time marginal, the more libraries used, the greater the effect.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">But you get the point. How far do you go in optimizations before you are better off with asm?</td> </tr></table><span class="postbody">
<br/>
<br/>
Let's not forget that some algorithems are much easier in assembly than C.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Writing assembly is easy. Writing GOOD assembly is very tedious, mostly due to register allocation and scheduling (do you remember what ARM9-instruction sequences cause interlocks on top of your head? The compiler does...). You can often write C-code that is almost equivalent to ASM without having to deal with register allocation and scheduling. And unless you spend hours reading instruction timings and allocating register life-time, your compiler will still usually beat you by a good margin. </td> </tr></table><span class="postbody">
<br/>
<br/>
Let's not forget that compilers also prefer stack over specific memory location handling... Some may see this good, but it can be cumbersome when you have to do an sp+offset when doing some fancy math (extra uops).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">As a clever man once said "Your compiler can write better code in microseconds than you can do in hours". Sure, those extra 20-30% might be worth it in your most timing critical loop, I never denied that. It might be just the little push you need to go from 30 to 60 FPS. But believing that code automatically become significantly faster by writing it in assembly is plain stupid.</td> </tr></table><span class="postbody">
<br/>
<br/>
No one ever claimed that. Though really, writing good assembly code is easy after experience. There's different degrees of optimization. There's no-optimzation, there's rediculous optimization, and then there's the stuff in between. Even a beginner can remember simple optimization tricks that compilers don't, such as left shifting by 1 to multiply by 2. But nobody, not even the compiler, counts cycles, which is what some enthusiasts could do.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">hum, what about "...the root of all evil" and other good advices? writing a game is complex enough, reuse the maximum you can from the lib you have... eg: use TTE console from tonclib rather that trying to set up your own... and work on your game logic rather that reinventing the wheel or spending 95% of your time on code running less than 5% of the program lifetime... once everything is done, perform some profiling, do the high level optimisation and if your skilled enough the low level assembly optimisation of the critical method (like memcopy method, trough in my opinion you should reuse assembly too when it's already good...)</td> </tr></table><span class="postbody">
<br/>
<br/>
The biggest mis-conception about assembly is that assemblers don't have "include." 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">You and I must be from different planets. Either you are much much smarter than me, or you're writing bad C core and/or have been using bad compilers. Or you're exaggerating to make a point.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I agree with him, i find it does a very bad job half the time, and i don't mean just size as well.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Which is exactly why I think it's a bad example - it isn't expanded to a practical level of complexity.</td> </tr></table><span class="postbody">
<br/>
<br/>
How about a searching algorithem? I've found people to prefer sorting or a linear search simply because pointers are too tedious in HLLs, whereas a nice bucket and chains algorithem can handle an unsorted search pretty effectively if one has a half decent hashing algorithem.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">But there's always an optimized copy around somewhere, unless you're designing your own CPU or something.</td> </tr></table><span class="postbody">
<br/>
<br/>
Is there for the GBA? How about the DS?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I've looked at multiple, yes. Some were byte-copies, so we swapped it, and some were fast. But these things is something PROFILING should tell you, not random rewriting in assembly.</td> </tr></table><span class="postbody">
<br/>
<br/>
I've seen a very nifty one on the x86...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
;Assumes rdi and rsi are already pointing where they belong. If not, simple lea...
<br/>
mov ecx, [arr_sz]
<br/>
shr ecx, 3
<br/>
rep movsq</td> </tr></table><span class="postbody">
<br/>
<br/>
Probably not the fastest example (huge uops i hear), but it's something i came up with off the top of my head. Optimized for a 64bit processor, assuming that the thing being copied isn't over 4 gigs.
<br/>
<br/>
EDIT: Come to think of it, on a linux computer, the code could probably be simplified to...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">shr ecx, 3
<br/>
rep movsq
<br/>
ret</td> </tr></table><span class="postbody">
<br/>
<br/>
because of the calling convention...
<br/>
<br/>
Edit2:
<br/>
<br/>
That's only seven bytes... While calling a function would actually be 6 bytes... At that point, it would be faster and more efficient to make that an inline function (since the 7 byte function call would be 13 bytes due to the streaming effect, whereas it would be only 1 extra byte per calling, which is really pointless since the ret is actually 1 byte, therefore inline would cost as much as calling in code size).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168436 - kusma - Wed Apr 29, 2009 10:34 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">When memory is the bottleneck, size optimization usually is speed optimization. Though that all depends on the cache.</td> </tr></table><span class="postbody">
<br/>
When INSTRUCTION memory is the bottle-neck, yes. The NDS has a separate I-cache, and the GBA doesn't have a cache at all. Total performance in this context is often a trade-off between cache-misses and unrolling. Unrolling can both reduce branch-overhead, and give better scheduling.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">Dynamically linking, though, is typically sufficient. Typically a user doesn't mind so much about startup/load time as he or she may mind the download time... Although one may feel the time marginal, the more libraries used, the greater the effect.</td> </tr></table><span class="postbody">
<br/>
I can't say I understand your point here. The GBA/NDS doesn't "really" use dynamic linkage, although there exist some hack to try to implement it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">Let's not forget that compilers also prefer stack over specific memory location handling... Some may see this good, but it can be cumbersome when you have to do an sp+offset when doing some fancy math (extra uops).</td> </tr></table><span class="postbody">
<br/>
The compiler uses the stack if you tell it to. In general the stack is better than fixed memory location due to reentrancy, but if you want your variable at a fixed location, sure, use global variables or static local variables.
<br/>
<br/>
Also, ARM CPUs are RISC and don't break down things to uops.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">No one ever claimed that. Though really, writing good assembly code is easy after experience. There's different degrees of optimization. There's no-optimzation, there's rediculous optimization, and then there's the stuff in between.
<br/>
</td> </tr></table><span class="postbody">
<br/>
No one said it in those words, but it sure as hell was implied ;)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">Even a beginner can remember simple optimization tricks that compilers don't, such as left shifting by 1 to multiply by 2.</td> </tr></table><span class="postbody">
<br/>
Ehh... Compilers does these tricks:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">$ echo "unsigned int div2(unsigned int a) { return a / 2; }" &gt; test.c &amp;&amp; arm-eabi-c++ -O2 -S test.c &amp;&amp; cat test.s
<br/>
        .cpu arm7tdmi
<br/>
        .fpu softvfp
<br/>
        .eabi_attribute 20, 1
<br/>
        .eabi_attribute 21, 1
<br/>
        .eabi_attribute 23, 3
<br/>
        .eabi_attribute 24, 1
<br/>
        .eabi_attribute 25, 1
<br/>
        .eabi_attribute 26, 1
<br/>
        .eabi_attribute 30, 2
<br/>
        .eabi_attribute 18, 4
<br/>
        .file   "test.c"
<br/>
        .text
<br/>
        .align  2
<br/>
        .global _Z4div2j
<br/>
        .type   _Z4div2j, %function
<br/>
_Z4div2j:
<br/>
        .fnstart
<br/>
.LFB2:
<br/>
        @ Function supports interworking.
<br/>
        @ args = 0, pretend = 0, frame = 0
<br/>
        @ frame_needed = 0, uses_anonymous_args = 0
<br/>
        @ link register save eliminated.
<br/>
        mov     r0, r0, lsr #1
<br/>
        bx      lr
<br/>
.LFE2:
<br/>
        .fnend
<br/>
        .size   _Z4div2j, .-_Z4div2j
<br/>
        .ident  "GCC: (devkitARM release 25) 4.3.3"</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm using the division by two optimization instead of multiplication by two, since multiplications by two is just as fast with an add (given that it can't be paired on an existing instruction in ARM mode), so it's less obvious what to pick.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">But nobody, not even the compiler, counts cycles, which is what some enthusiasts could do.</td> </tr></table><span class="postbody">
<br/>
Where do you take your arguments from? Compilers DO count cycles; I've written a couple, I should know...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">The biggest mis-conception about assembly is that assemblers don't have "include."</td> </tr></table><span class="postbody">
<br/>
But if you include assembly-code, it's not optimized to the context (no inlining + optimizations, macros is your best hope...), so it ends up being suboptimal. Not that that's always important, it's just something your compiler would have done for you more or less at no effort.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I agree with him, i find it does a very bad job half the time, and i don't mean just size as well.</td> </tr></table><span class="postbody">
<br/>
You DON'T seem to agree with him. Miked0801 said that it did an acceptable job 99.9% of the time, not a very bad job half of the time as you claim. If Miked0801 and I are from different planets, the two of US are from different galaxies. I'm guessing you're blindly trusting some rumors you heard from your asm-friends, or you're just picking random numbers out of the air.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">How about a searching algorithem? I've found people to prefer sorting or a linear search simply because pointers are too tedious in HLLs, whereas a nice bucket and chains algorithem can handle an unsorted search pretty effectively if one has a half decent hashing algorithem.</td> </tr></table><span class="postbody">
<br/>
Algorithms and data-structures are a very important aspect of performance not matter what language you're programming in. You're claiming that these are often more tedious to write in HLLs than assembly, I'd say the opposite.
<br/>
<br/>
If you think pointers are tedious in HLLs, it sounds to me like you (or the people you're referring to) aren't experienced in HLLs. Are you sure these experiences are the right ones to base generalizations about a language on in that case?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kohlrak wrote:</b></span></td> </tr> <tr> <td class="quote">Is there for the GBA? How about the DS?</td> </tr></table><span class="postbody">
<br/>
Yes. They are in the BIOS (although the one in the NDS BIOS has a pretty serious performance bug). ARM memcopies has been beaten to death already.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168471 - Miked0801 - Wed Apr 29, 2009 7:45 pm</h4>
    <div class="postbody"><span class="postbody">Our compiler is famous for crap like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
for(int i=10; i&gt;0; i--)
<br/>
{
<br/>
    foo--;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
becomes:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
    mov r0, 10
<br/>
    
<br/>
loop
<br/>
    sub  foo,1
<br/>
    sub  r0,1
<br/>
    cmp r0,0
<br/>
    bne loop
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
and obviously, foo-- is oversimplified and could be changed to a subtract once, but assume there is a little more going on.
<br/>
<br/>
ffs, use subs already in my tight loop.  Changing the loop to a while loop gives different code, worst optimized.  Changing it to a do/while loop changes it to different code, sometimes better, sometimes worse.  This kind of output doesn't matter except in very special places, and in those places, I am forced to resort to asm.  
<br/>
<br/>
You do know that I am not a big fan of Asm, right kusma?  Given a choice, I'll use C++ containers and meta algorithms every time to solve a problem.  Asm optimization, while fun, is tedious to maintain.  Why?  Because as soon as I write it, I am stuck supporting it for the next 10+ years.
<br/>
<br/>
Anyways, my other favorite:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int doSimpleMath(const int x, const int y)
<br/>
{
<br/>
    return x+y;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
usually becomes something like:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
    push r4,r5
<br/>
    add r0,r0,r1
<br/>
    pop   r4,r5
<br/>
    bx    lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Why must you push/pop unused registers all over the place?  Yes, inlining usually fixes this, but there are functions that are called too often to inline and I get sick of the stupid, useless stack crap.  Adding funky pragmas sometimes fixes this, depending on the compiler (leaf and such), but grrr.
<br/>
<br/>
There are plenty of other head scratching things my compiler does.  Metrowerks makes a substandard c/c++ compiler.  And I'm stuck using it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#168475 - kohlrak - Thu Apr 30, 2009 2:23 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">When INSTRUCTION memory is the bottle-neck, yes. The NDS has a separate I-cache, and the GBA doesn't have a cache at all. Total performance in this context is often a trade-off between cache-misses and unrolling. Unrolling can both reduce branch-overhead, and give better scheduling.</td> </tr></table><span class="postbody">
<br/>
<br/>
That's the nice thing about ARMs... They have seperate memory for instructions and data... Remember, my knowledge and points will most likely apply to x86 since i have no experience with arm, yet.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I can't say I understand your point here. The GBA/NDS doesn't "really" use dynamic linkage, although there exist some hack to try to implement it.</td> </tr></table><span class="postbody">
<br/>
<br/>
Sorry, x86 reference...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">The compiler uses the stack if you tell it to. In general the stack is better than fixed memory location due to reentrancy, but if you want your variable at a fixed location, sure, use global variables or static local variables.</td> </tr></table><span class="postbody">
<br/>
<br/>
How often does one need to do this, though? If you're only ever going to use one instance of a function at a time (which is typical unless threading [even rarely there] or recursive), re-entry is unimportant.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Also, ARM CPUs are RISC and don't break down things to uops. </td> </tr></table><span class="postbody">
<br/>
<br/>
Sorry, another x86 referance since i'm talking about C vs ASM in general, not specific to the arm CPUs.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">No one said it in those words, but it sure as hell was implied ;)</td> </tr></table><span class="postbody">
<br/>
<br/>
Perhaps to you, but any experienced assembly programmer wouldn't make such an assumption.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Ehh... Compilers does these tricks:</td> </tr></table><span class="postbody">
<br/>
<br/>
Not quite sure i can follow that code, so i cannot comment on it (GNU syntax is difficult for me to read).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I'm using the division by two optimization instead of multiplication by two, since multiplications by two is just as fast with an add (given that it can't be paired on an existing instruction in ARM mode), so it's less obvious what to pick. </td> </tr></table><span class="postbody">
<br/>
<br/>
If bit shift's available, that's typically a good choice. Usually much faster than an add or subtract, since it's a little more native to the processor's numbering system.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Where do you take your arguments from? Compilers DO count cycles; I've written a couple, I should know... </td> </tr></table><span class="postbody">
<br/>
<br/>
I would find that very rare, especially since cycle counting can vary between revisions, or more often from newer versions (like arm9 over arm7, but i don't have any examples to point out since i don't have experience with arm).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">But if you include assembly-code, it's not optimized to the context (no inlining + optimizations, macros is your best hope...), so it ends up being suboptimal. Not that that's always important, it's just something your compiler would have done for you more or less at no effort. </td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">macro cjmp x, y, [cond, loc]{
<br/>
   cmp x, y
<br/>
   j#cond loc }
<br/>
<br/>
cjump eax, ebx, a, loc1, b, loc2</td> </tr></table><span class="postbody">
<br/>
<br/>
Not the most practical example, but it assembles to what you'll see below:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   cmp eax, ebx
<br/>
   ja loc1
<br/>
   jb loc2</td> </tr></table><span class="postbody">
<br/>
<br/>
Could that be optimal enough? If you're like me, you'd keep macro that you find very useful, which is essentially what a compiler is for... It does common things for you. The difference is that it saves you the trouble of having to invent those things yourself. However, in the long run, who gains?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">You DON'T seem to agree with him. Miked0801 said that it did an acceptable job 99.9% of the time, not a very bad job half of the time as you claim. If Miked0801 and I are from different planets, the two of US are from different galaxies. I'm guessing you're blindly trusting some rumors you heard from your asm-friends, or you're just picking random numbers out of the air.</td> </tr></table><span class="postbody">
<br/>
<br/>
Or, perhaps, i'm using experience. However, lemme point out the word "acceptable" in that it's different from the word "good." Some people prefer using buses over cars because, for their situation, they find the wait time acceptable, since most of their work would be done on a laptop or such and time isn't of the essance for them.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Algorithms and data-structures are a very important aspect of performance not matter what language you're programming in. You're claiming that these are often more tedious to write in HLLs than assembly, I'd say the opposite. </td> </tr></table><span class="postbody">
<br/>
<br/>
Well then we disagree. Typcasting is a real pain as well, and that will occure often...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">If you think pointers are tedious in HLLs, it sounds to me like you (or the people you're referring to) aren't experienced in HLLs. Are you sure these experiences are the right ones to base generalizations about a language on in that case? </td> </tr></table><span class="postbody">
<br/>
<br/>
pointer, *pointer, &amp;pointer... That's HLL...
<br/>
<br/>
pointer, [pointer]... That's assembly... 
<br/>
<br/>
There's a reason why many programming courses avoid things like pointers and the mystical "goto."
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Yes. They are in the BIOS (although the one in the NDS BIOS has a pretty serious performance bug). ARM memcopies has been beaten to death already.</td> </tr></table><span class="postbody">
<br/>
<br/>
Well then for the GBA, use the one in the bios. In which case there's no need to use an HLL just to use it. ASM can use it too... Then we can spend time on other fancy algorithems that need optimized.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Adding funky pragmas sometimes fixes this, depending on the compiler (leaf and such), but grrr. </td> </tr></table><span class="postbody">
<br/>
<br/>
That takes alot of time (more than it would take to program) just to learn a compiler... I thought that was one of the rants against asm (not here though, which shows that people here are too smart to buy into the stupidity)... Then again, i'd personally turn around and throw the same argument at just about every assembler that i've ever used (but fortunately there are assemblers out there that are very quick to learn).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">There are plenty of other head scratching things my compiler does. Metrowerks makes a substandard c/c++ compiler. And I'm stuck using it.</td> </tr></table><span class="postbody">
<br/>
<br/>
Remember, getting a product out there faster and lest costly is more important than user satisfaction. Since ram is so cheap these days, people will not only have abundant amounts, but, if necessary, they will buy it to use our product, since it's so easy to upgrade, therefore only a minor invconvenience.[/clinche]</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
