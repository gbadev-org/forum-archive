<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Rotate/Scale sprite code to asm - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Rotate/Scale sprite code to asm</h2>
<div id="posts">
<div class="post">
    <h4>#166085 - headspin - Mon Jan 26, 2009 10:42 am</h4>
    <div class="postbody"><span class="postbody">I am trying to convert the following code from <a class="postlink" href="http://dev-scene.com/NDS/Tutorials/Captain_Apathy/Tiling#Movement_and_Rotation" target="_blank">this website</a>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">s16 s = -SIN[angle &amp; 0x1FF] &gt;&gt; 4;
<br/>
s16 c = COS[angle &amp; 0x1FF] &gt;&gt; 4;
<br/>
<br/>
spriteRotation[index].hdx = c;
<br/>
spriteRotation[index].hdy = -s;
<br/>
spriteRotation[index].vdx = s;
<br/>
spriteRotation[index].vdy = c;</td> </tr></table><span class="postbody">
<br/>
<br/>
And here is my current "translation" to arm asm.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldr r0, =SIN_bin            @ Load the address of our SIN table
<br/>
ldr r1, =COS_bin            @ Load the address of our COS table
<br/>
ldr r2, =angle               @ Load the address of angle
<br/>
ldrh r3, [r2]               @ Load r3 with the value of angle
<br/>
add r3, #1                  @ Add one to angle
<br/>
cmp r3, #512               @ Compare our angle to 512
<br/>
movpl r3, #0               @ If the angle is greater than 512 then set it to zero
<br/>
strh r3, [r2]               @ Write it back to angle
<br/>
ldr r4, =0x1FF               @ Load our mask to r4
<br/>
and r3, r4                  @ And our mask with our angle
<br/>
lsl r3, #1                  @ Multiply by 2? (16 bit SIN data?)
<br/>
add r0, r3                  @ Add our offset to our SIN table
<br/>
add r1, r3                  @ Add our offset to our COS table
<br/>
ldrsh r2, [r0]               @ Now read the SIN table
<br/>
ldrsh r3, [r1]               @ Now read the COS table
<br/>
asr r2, #4                  @ Right shift the SIN value 4 bits
<br/>
mov r6, r2                  @ Make a copy of our SIN value (-SIN[angle &amp; 0x1FF] &gt;&gt; 4)
<br/>
rsb r2, r2, #0               @ Reverse subtract to make it negative (r2=#0 - r2)
<br/>
asr r3, #4                  @ Right shift the COS value 4 bits  (c = COS[angle &amp; 0x1FF] &gt;&gt; 4)
<br/>
ldr r4, =OBJ_ROTATION_HDX(0)   @ This is the HDX address of the sprite
<br/>
ldr r5, =OBJ_ROTATION_HDY(0)   @ This is the HDY address of the sprite
<br/>
strh r3, [r4]               @ Write our COS value to HDX (hdx = c)
<br/>
strh r6, [r5]               @ Write our SIN value to HDY (hdy = -s)
<br/>
ldr r4, =OBJ_ROTATION_VDX(0)   @ This is the VDX address of the sprite
<br/>
ldr r5, =OBJ_ROTATION_VDY(0)   @ This is the VDY address of the sprite
<br/>
strh r2, [r4]               @ Write our SIN value to VDX (vdx = s)
<br/>
strh r3, [r5]               @ Write our COS value to VDY (vdy = c)</td> </tr></table><span class="postbody">
<br/>
<br/>
I am using the same SIN.bin and COS.bin from the old libnds (located in libnds\source\arm9) I ran a bin2s and included them in my project. I have no idea if the values are half word in size or not but thats what I've assumed in the code.
<br/>
<br/>
I also am also not sure how to make a value negative as in the C example, again I'm guessing it's setting the MSB.
<br/>
<br/>
All I'm getting is the sprite turns into the shape of a line and is really slowly moving. Obviously there is a bug in the code somewhere. Can you see it?<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"><br/><br/>Last edited by headspin on Mon Jan 26, 2009 12:59 pm; edited 4 times in total</span></div>    
</div>
<div class="post">
    <h4>#166089 - FluBBa - Mon Jan 26, 2009 11:36 am</h4>
    <div class="postbody"><span class="postbody">I guess the reason why you would use asm is becuase you want to optimise the code... adding extra code when converting to asm kind of defeats the purpose, doesn't it?
<br/>
Skip the "cmp #512" as it's even wrong, you'd need a movpl instead of movgt.
<br/>
use rsb (reverse subtract) to negate a number like this, "rsb r2,r2,#0", which means r2=#0 - r2.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166090 - headspin - Mon Jan 26, 2009 12:18 pm</h4>
    <div class="postbody"><span class="postbody">Thanks FluBBa. Actually it's not for optimizing but just for the challenge. I'm sure a C compiler can create better code than I can at the moment. But I'm doing this to learn arm and for fun. I can always optimize it a bit later when I learn more of the instruction set.
<br/>
<br/>
I've updated my first post with your code changes and now the sprite starts to rotate correctly but when it goes past the 90 degree position it disappears. Any clue why?<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166091 - Cearn - Mon Jan 26, 2009 12:40 pm</h4>
    <div class="postbody"><span class="postbody">A basic rotation function would look like this. It's untested, but the principles are there. I wouldn't be surprised if the compiler comes up with pretty much the same thing.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ void objRotate(int mtxIndex, int angle)
<br/>
    .align
<br/>
    .thumb_func
<br/>
    .global objRotate
<br/>
objRotate:
<br/>
    @ Get correct matrix offset and set-up lookup
<br/>
    ldr     r2, =oamBuffer
<br/>
    mov     r2, r2, #5
<br/>
    add     r0, r2                  @ r0= &amp;oamBuffer[4*mtxIndex]
<br/>
    ldr     r2, =SIN_bin
<br/>
    
<br/>
    @ Set cross-diagonals to sines.
<br/>
    lsl     r3, r1, #(32-9)         @ - r3= (angle%512)*2
<br/>
    lsr     r3, r3, #(32-8)         @ /
<br/>
    ldrsh   r3, [r2, r3]            @ NOTE: signed load
<br/>
    asr     r3, r3, #4              @ NOTE: asr, not lsr
<br/>
    
<br/>
    strh    r3, [r2, #22]           @ mtx.pc =  sin(a)
<br/>
    neg     r3, r3
<br/>
    strh    r3, [r2, #14]           @ mtx.pb = -sin(a)
<br/>
    
<br/>
    @ Set diagonals to cosines.
<br/>
    add     r3, r1, #0x80           @ \_
<br/>
    lsl     r3, r3, #(32-9)         @ - r3= ((angle+512/4)%512)*2
<br/>
    lsr     r3, r3, #(32-8)         @ /
<br/>
    ldrsh   r3, [r2, r3]
<br/>
    asr     r3, r3, #4
<br/>
    
<br/>
    strh    r3, [r2, #6]            @ mtx.pa= cos(a)
<br/>
    strh    r3, [r2, #30]           @ mtx.pd= cos(a)
<br/>
</td> </tr></table><span class="postbody">
<br/>
Note a couple of things. 
<br/>
First, signed vs unsigned shifts and loads. Since these are really signed data, you need the signed versions. Unsigned can make things go wonky when you start shifting. This is possibly why things disappear after 90 degrees.  
<br/>
<br/>
Second, where possible use indexed addressing modes. This can save you a lot of address loads. The affine matrices are interlaced with the normal object attributes at a distance of 32 bytes. The matrix elements start at 6 and then offsets of 8.
<br/>
<br/>
You can also get the cosine via the sine lut via cos(a) = sin(a+½π). 
<br/>
<br/>
If you're learning ARM asm, create some functions in C and compile with -save-temps. This will give you the assembly for the C code. Though the compiler at times uses more registers than necessary or adds superfluous mov/cmp instructions, it does know a few tricks that you may not have thought of.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166092 - headspin - Mon Jan 26, 2009 1:00 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Cearn ldrsh did the trick :)
<br/>
<br/>
I also appreciate your other tips especially viewing the compiled C assembly.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
