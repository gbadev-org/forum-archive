<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Streaming music from audio file in EFS - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Streaming music from audio file in EFS</h2>
<div id="posts">
<div class="post">
    <h4>#167526 - headspin - Tue Mar 17, 2009 1:58 pm</h4>
    <div class="postbody"><span class="postbody">I'm trying to stream some music for a game using the EFS to break the 4 MB memory limit of the DS. So far I have got the basic streaming working but every time the buffer is refilled there is an annoying click sound. Is there are bug in the code or perhaps streaming from the ROM is not fast enough in the timer? Any suggestions would be appreciated.
<br/>
<br/>
Code from main.s
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   ldr r0, =strInGame            @ Read the path to the file
<br/>
   bl playAudio               @ Play the sound
<br/>
<br/>
mainLoop:
<br/>
<br/>
   bl swiWaitForVBlank
<br/>
   b mainLoop
<br/>
<br/>
strInGame:
<br/>
   .asciz "/InGame.raw"</td> </tr></table><span class="postbody">
<br/>
<br/>
Here is the audioStream.s
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   #define BUFFER_SIZE      4096
<br/>
   #define AUDIO_FREQ      22050
<br/>
<br/>
   .arm
<br/>
   .align
<br/>
   .text
<br/>
   .global initAudioStream
<br/>
   .global playAudio
<br/>
   .global audioStreamTimer1
<br/>
   
<br/>
initAudioStream:
<br/>
<br/>
   stmfd sp!, {r0-r1, lr}
<br/>
   
<br/>
   ldr r0, =TIMER0_DATA
<br/>
   ldr r1, =SOUND_FREQ(AUDIO_FREQ) * 2
<br/>
   strh r1, [r0]
<br/>
   
<br/>
   ldr r0, =TIMER0_CR
<br/>
   ldr r1, =(TIMER_ENABLE | TIMER_DIV_1)
<br/>
   strh r1, [r0]
<br/>
   
<br/>
   ldr r0, =TIMER1_DATA
<br/>
   ldr r1, =(0x10000 - (BUFFER_SIZE / 2));
<br/>
   strh r1, [r0]
<br/>
<br/>
   ldr r0, =TIMER1_CR
<br/>
   ldr r1, =(TIMER_ENABLE | TIMER_IRQ_REQ | TIMER_CASCADE)
<br/>
   strh r1, [r0]
<br/>
   
<br/>
   ldmfd sp!, {r0-r1, pc}                        @ Return
<br/>
   
<br/>
   @ ---------------------------------------------
<br/>
   
<br/>
playAudio:
<br/>
<br/>
   stmfd sp!, {r0-r2, lr}
<br/>
<br/>
   @ r0 = string pointer to music
<br/>
   
<br/>
   mov r1, r0                                 @ Move string pointer
<br/>
   ldr r0, =fileName                           @ Read address of fileName
<br/>
   ldr r2, =256                              @ Size == 256
<br/>
   bl memcpy                                 @ Copy filename to fileName
<br/>
      
<br/>
   ldr r0, =fileName
<br/>
   ldr r1, =(BUFFER_SIZE / 2)
<br/>
   ldr r2, =fileSize                           @ Read fileSize address
<br/>
   
<br/>
   bl readFileSize
<br/>
   
<br/>
   str r0, [r2]                              @ Write the filesize to it
<br/>
   
<br/>
   ldr r0, =fileName
<br/>
   ldr r1, =buffer
<br/>
   ldr r2, =bufferPos
<br/>
   ldr r2, [r2]
<br/>
   ldr r3, =(BUFFER_SIZE / 2)                     @ Read the buffer size
<br/>
   
<br/>
   bl readFileStream                           @ Read the next buffer of audio file
<br/>
   bl playBuffer
<br/>
   
<br/>
   ldmfd sp!, {r0-r2, pc}                        @ restore registers and return
<br/>
<br/>
   @ ---------------------------------------------
<br/>
<br/>
playBuffer:
<br/>
   stmfd sp!, {r0-r1, lr}
<br/>
<br/>
   ldr r0, =IPC_SOUND_LEN(0)                     @ Get the IPC sound length address
<br/>
   ldr r1, =BUFFER_SIZE                        @ buffer size
<br/>
   str r1, [r0]                              @ Write the buffer size
<br/>
   
<br/>
   ldr r0, =IPC_SOUND_DATA(0)                     @ Get the IPC sound data address
<br/>
   ldr r1, =buffer                              @ Get the sample address
<br/>
   str r1, [r0]                              @ Write the value
<br/>
   
<br/>
   ldmfd sp!, {r0-r1, pc}                        @ restore registers and return
<br/>
   
<br/>
   @ ---------------------------------------------
<br/>
   
<br/>
audioStreamTimer1:
<br/>
<br/>
   stmfd sp!, {r0-r6, lr}
<br/>
   
<br/>
   ldr r0, =fileName
<br/>
   ldr r1, =buffer
<br/>
   ldr r2, =bufferPos
<br/>
   ldr r2, [r2]
<br/>
   ldr r3, =(BUFFER_SIZE / 2)                  @ Read the buffer size
<br/>
   
<br/>
   ldr r4, =backBuffer
<br/>
   ldr r5, [r4]
<br/>
   cmp r5, #0
<br/>
   moveq r5, #1
<br/>
   addeq r1, r3
<br/>
   movne r5, #0
<br/>
   str r5, [r4]
<br/>
   
<br/>
   bl readFileStream                           @ Read the next buffer of audio file
<br/>
<br/>
   bl DC_FlushAll                           @ Flush the cache
<br/>
   
<br/>
   ldr r0, =bufferPos                           @ Read the bufferPos address
<br/>
   ldr r1, [r0]                              @ Read the bufferPos value
<br/>
   ldr r2, =fileSize                           @ Read the file size address
<br/>
   ldr r2, [r2]                              @ Read the fileSize value
<br/>
   ldr r3, =(BUFFER_SIZE / 2)                     @ Read the buffer size
<br/>
   add r1, r3                                 @ Add buffer size to bufferPos
<br/>
   str r1, [r0]                              @ Write value back to bufferPos
<br/>
   
<br/>
   
<br/>
   ldmfd sp!, {r0-r6, pc}                        @ Return
<br/>
   
<br/>
   @ ---------------------------------------------
<br/>
<br/>
   .data
<br/>
   .align
<br/>
   
<br/>
backBuffer:
<br/>
   .word 0
<br/>
   
<br/>
bufferPos:
<br/>
   .word 0
<br/>
   
<br/>
fileSize:
<br/>
   .word 0
<br/>
   
<br/>
   .section .bss
<br/>
   
<br/>
fileName:
<br/>
   .space 256
<br/>
   
<br/>
buffer:
<br/>
   .space BUFFER_SIZE
<br/>
   
<br/>
   .pool
<br/>
   .end</td> </tr></table><span class="postbody">
<br/>
<br/>
and the readFile.c routines for reading from the EFS
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">FILE *pFileStream = NULL;
<br/>
   
<br/>
int readFileStream(char *fileName, unsigned char *pBuffer, int pos, int size)
<br/>
{ 
<br/>
   size_t result;
<br/>
   
<br/>
   if(pFileStream == NULL)
<br/>
      pFileStream = fopen(fileName, "rb");
<br/>
   
<br/>
   if (pFileStream == NULL)
<br/>
      return 0;
<br/>
   
<br/>
   result = fseek(pFileStream, pos, SEEK_SET);
<br/>
   
<br/>
   if(result != 0)
<br/>
   {
<br/>
      fclose(pFileStream);
<br/>
      return 0;
<br/>
   }
<br/>
<br/>
   result = fread(pBuffer, 1, size, pFileStream);
<br/>
   
<br/>
   if(result != size)
<br/>
   {
<br/>
      fclose(pFileStream);
<br/>
      return 0;
<br/>
   }
<br/>
<br/>
   return 1;
<br/>
}
<br/>
<br/>
int readFileSize(char *fileName)
<br/>
{
<br/>
   struct stat fileStat;
<br/>
   size_t result;
<br/>
   
<br/>
   result = stat(fileName, &amp;fileStat);
<br/>
   
<br/>
   if(result != 0)
<br/>
      return 0;
<br/>
      
<br/>
   return fileStat.st_size;
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"><br/><br/>Last edited by headspin on Fri Mar 20, 2009 4:03 pm; edited 10 times in total</span></div>    
</div>
<div class="post">
    <h4>#167529 - elhobbs - Tue Mar 17, 2009 2:19 pm</h4>
    <div class="postbody"><span class="postbody">16k does sound a little big to be reading all at once. also, it looks like you are restarting a new sound each chunk - it hard for me to tell as I am not exactly an asm expert. I think most of the streaming audio examples tend to use a circular buffer with the sound playing as a loop. then the update function loads the next section of the audio file to the correct position in the circular buffer - making sure not touch near where the current audio is playing.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167530 - headspin - Tue Mar 17, 2009 3:01 pm</h4>
    <div class="postbody"><span class="postbody">I think your right elhobbs but I can't find an example that reads directly from EFS or doesn't use FIFO. I have made the buffer 2048 and now only play the sound with a loop instead of triggering play every time the timer is called.
<br/>
<br/>
So I guess I will have to implement a ring buffer and keep it filled just in front of the play cursor. Perhaps someone could shed some more light or give an example of implementation?<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167531 - elhobbs - Tue Mar 17, 2009 3:36 pm</h4>
    <div class="postbody"><span class="postbody">as_lib, maxmod - either one of these should provide the needed info. I do not think it matters if they use efs or fifo (though I think as_lib can be built to use efs) - you just need to look at the parts involving filling the buffers at the right time and in the right place.
<br/>
<br/>
I think the typical approach is to create a buffer and split it into two sections. one section is currently playing and the other section needs to be loaded. I believe some care needs to be taken to make sure everyting is cache aligned (4 byte /32bit aligned).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167532 - headspin - Tue Mar 17, 2009 4:37 pm</h4>
    <div class="postbody"><span class="postbody">Thanks elhobbs you've been a great help. Splitting the buffer into two sections has improved the quality alot. Infact at times it's perfect but I'm guessing the play cursor eventually gets to a point where its right between the buffer swap and starts causing the clicking again and eventually is goes out of sync and sounds right again.
<br/>
<br/>
I've updated my first post with the code changes I've made. Any ideas on how to compensate for this syncing issue?<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167533 - elhobbs - Tue Mar 17, 2009 5:14 pm</h4>
    <div class="postbody"><span class="postbody">maybe set the timer to a higher frequency then load a little after the sound goes to the next buffer, but well before it switches to the next buffer. so, when your update function is called calculate the position were the sound is currently playing and compare it to the next load position and the already loaded position. if the current position is &gt; next load position and next load position &gt; loaded position then read more data and update the loaded position</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167551 - headspin - Wed Mar 18, 2009 4:41 am</h4>
    <div class="postbody"><span class="postbody">Changing to a frequency of 32000 seems to have fixed the sync issues. But it does add a meg and a bit to the file size for the music. I would prefer to go with 22050. There must be a value close to that frequency that will work without going out of sync. I would love to know if it's possible.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167556 - elhobbs - Wed Mar 18, 2009 1:42 pm</h4>
    <div class="postbody"><span class="postbody">I was not suggesting that the frequency for the sound be changed. I was suggesting that the timer be changed to a higher frequency. so, that it is called maybe 4 times while playing each half of the buffer. on the 1,3,4 calls do nothing. on the 2 call load more data.
<br/>
<br/>
in any case I think the issue may be with your code for setting up TIMER0_DATA</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   ldr r1, =(TIMER_FREQ(AUDIO_FREQ) &amp; 0xFFFE) 
<br/>
</td> </tr></table><span class="postbody"> this code is modifying the value calulated by TIMER_FREQ. Why not just use</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   ldr r1, =TIMER_FREQ(AUDIO_FREQ) 
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167592 - headspin - Thu Mar 19, 2009 2:15 pm</h4>
    <div class="postbody"><span class="postbody">It doesn't make a difference using "&amp; 0xFFFE" or not I just saw it in another example. I have removed it from the current code anyway.
<br/>
<br/>
I understood what you meant but the problem is it's getting out of sync with the timer. Changing to use a frequency of 32000 solves the sync issue. It works fine now. I'm sure I could use 22050 if I could figure out why exactly it's getting out of sync when using that frequency.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167593 - elhobbs - Thu Mar 19, 2009 3:13 pm</h4>
    <div class="postbody"><span class="postbody">you tried removing "&amp; 0xFFFE" for the 22050 frequency file and it made no difference? this is effectively removing precision from your frequency calculation. it has a larger effect on 22050 then it does on 32000. So I would expect that 32000 would still have the issue but to a lesser degree.
<br/>
<br/>
my suggestion is to separate the frequency of the audio file from the update of the buffers. so if the update function is called 8 times while the current buffer is playing then you just need to load the data during one of those calls. if it drifts a little bit it will not be a problem - so it might update on the 3rd call instead of the 2nd. so in the update function read TIMER0_DATA and see how many samples have played since the last time you loaded data. if some threshold has past and the next buffer still needs to be filled then read more data.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167618 - headspin - Fri Mar 20, 2009 4:03 pm</h4>
    <div class="postbody"><span class="postbody">I found the answer to my problem thanks to DekuTree
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Also, using the TIMER_FREQ macro can cause out-of-sync, because CPU timers run at twice the frequency of sound timers. Try using SOUND_FREQ(AUDIO_FREQ) * 2 to guarantee that it matches exactly.</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167622 - elhobbs - Fri Mar 20, 2009 6:17 pm</h4>
    <div class="postbody"><span class="postbody">excellent! that is a much simpler solution than I thought would be required.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
