<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Sign-extend instruction? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Sign-extend instruction?</h2>
<div id="posts">
<div class="post">
    <h4>#54855 - paladine - Fri Sep 23, 2005 4:19 am</h4>
    <div class="postbody"><span class="postbody">I have found a THUMB reference that indicates SXTB can be used to sign extend a byte into a word.  This is perfect since I want to take a signed byte and convert to an integer.  GCC doesn't like it.  Is this supported on the GBA's processor?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54856 - tepples - Fri Sep 23, 2005 4:24 am</h4>
    <div class="postbody"><span class="postbody">SXTB might be a macroinstruction for a left shift followed by a right shift. I seem to remember that MIPS assemblers support lots of macros out of the box; ARM's own tools might do the same.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54857 - paladine - Fri Sep 23, 2005 4:29 am</h4>
    <div class="postbody"><span class="postbody">My mind is currently blank as I'm about to go to sleep.  How could I accomplish this same task using shifts?  The pseudocode works as expected but I'd like to avoid the branch condition if possible.  I'm sure it can be done using standard shifting/or'ing.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline static i32 SpriteGetY(LPSPRITE pSprite)
<br/>
{
<br/>
  if (pSprite-&gt;attrib[0] &amp; 0x80)
<br/>
    return (0xFFFFFF00 | pSprite-&gt;attrib[0]);
<br/>
<br/>
  return (pSprite-&gt;attrib[0] &amp; 0xFF);
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'd like to extend bit 8 through bits 9-32 to form the integer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54858 - tepples - Fri Sep 23, 2005 4:41 am</h4>
    <div class="postbody"><span class="postbody">To sign-extend an 8-bit value, in C (assuming 32-bit ints):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static inline signed int extend_s8_s32(signed int x)
<br/>
{
<br/>
  return (x &lt;&lt; 24) &gt;&gt; 24;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Or in asm:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  lsl r0, r0, 24
<br/>
  asr r0, r0, 24
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
If you want to extend a 9-bit value (copy bits 8 onto bits 9 through 31), it's similar. In C:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static inline signed int extend_s8_s32(signed int x)
<br/>
{
<br/>
  return (x &lt;&lt; 23) &gt;&gt; 23;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Or in asm:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  lsl r0, r0, 23
<br/>
  asr r0, r0, 23
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-weight: bold">Besides...</span>
<br/>
Don't sprite y values on the GBA or Nintendo DS go from -64 to 191? This kind of wrapping can be done with the following expression:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">y_component = ((attribute_0 + 64) &amp; 0xff) - 64;</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54860 - paladine - Fri Sep 23, 2005 4:51 am</h4>
    <div class="postbody"><span class="postbody">I guess the 'magic' occurs in the right shift.  I'm more of a software guy so it didn't occur to me that when the right shift occurs it uses the MSB to fill in the data.  Thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54883 - Cearn - Fri Sep 23, 2005 8:20 am</h4>
    <div class="postbody"><span class="postbody">With the <span style="font-weight: bold">arithmetic</span> right-shift (asr) the magic happens. With the logical right-shift (lsr), it's always zero-extension. They're basically the signed and unsigned right shifts. Don't confuse the two, or there will be trouble.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54886 - FluBBa - Fri Sep 23, 2005 8:29 am</h4>
    <div class="postbody"><span class="postbody">I'm not sure about Thumb but in Arm you have ldrsb &amp; ldrsh to signextend the value on register load, though it is quite restrictive in it's addressing modes.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#54913 - paladine - Fri Sep 23, 2005 3:58 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Cearn, you are correct.  I looked at the generated assembly from GCC and noticed that the C code (x &lt;&lt; 24) &gt;&gt; 24 generated a lsl followed by an asr.  GCC is smart enough to use asr,lsr based on the sign of the argument.  In my case I was using a signed integer so it worked as expected.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
