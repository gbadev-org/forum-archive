<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Syncing IPC/FIFO - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Syncing IPC/FIFO</h2>
<div id="posts">
<div class="post">
    <h4>#166047 - Tyler24 - Sun Jan 18, 2009 9:09 pm</h4>
    <div class="postbody"><span class="postbody">I'm trying to avoid using libnds because I feel it's a little bloated for my tastes. I'm coding in assembly instead of C, and in order to write to the screen (at least in MODE_FB0) I realized that the processors have to be synced via IPC and FIFO has to be enabled and ready to go.
<br/>
<br/>
I've been trying to look at fifocommon.h, specifically fifoInit()... but nothing is commented. And I have no idea how to sync make the processors sync via the hardware IPC. I have the IPC sync register address and everything from GBAtek, but there's no documentation about how to actually go about syncing processors anywhere.
<br/>
<br/>
The sync code I have now works (in C), taken straight from the libnds source code. I have no idea what it's doing, unfortunately, and would like to understand:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">      REG_IPC_SYNC = 0;
<br/>
      while(counted &lt; 3)
<br/>
      {
<br/>
         their_value = REG_IPC_SYNC&amp;0x000F;
<br/>
         if( ((my_value + 1)&amp;0x000F ) == their_value ) counted++;
<br/>
         my_value=(their_value+1)&amp;0x000F;
<br/>
         REG_IPC_SYNC = my_value&lt;&lt;8;
<br/>
      }
<br/>
      REG_IPC_SYNC = 14 &lt;&lt;8;</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks in advance!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166048 - Maxxie - Sun Jan 18, 2009 9:40 pm</h4>
    <div class="postbody"><span class="postbody">It's doing a 4-time challenge and response (with a simple increase by one response) to make sure the other side is in this very same game.
<br/>
<br/>
This is done, because you can not tell simply by the registers content at which state it is because it's value is unknown before initialisation and you don't know whether or not the initialization on the other side has been done yet.
<br/>
<br/>
The challenge and response game however has to be played on both cpus or it won't pass (Or in very very unlikely circumstances) 
<br/>
However, i am missing a reset-on-failed challenge.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166051 - Tyler24 - Sun Jan 18, 2009 10:08 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Maxxie wrote:</b></span></td> </tr> <tr> <td class="quote">It's doing a 4-time challenge and response (with a simple increase by one response) to make sure the other side is in this very same game.
<br/>
<br/>
This is done, because you can not tell simply by the registers content at which state it is because it's value is unknown before initialisation and you don't know whether or not the initialization on the other side has been done yet.
<br/>
<br/>
The challenge and response game however has to be played on both cpus or it won't pass (Or in very very unlikely circumstances) 
<br/>
However, i am missing a reset-on-failed challenge.</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks for the reply. I can get some vague idea of a challenge and response going on. If this is your code, it initially had error checking and whatnot, but I deleted all of it to figure out which parts I really needed for my example.
<br/>
<br/>
The ARM9 code simply selects VRAM_A, MODEFB_0 and draws a square. No IPC/FIFO initialization code here. For some reason, however, the IPC/FIFO has to be initialized on the ARM7 side, or all I get is black screens, even on real hardware. I'm scratching my head as to why it only needs to be done on the ARM7 side of things, but it does.
<br/>
<br/>
Do you have any documentation on this, or is it all based off lots of trial-and-error? This is the C code that works as of now (it's all from the ndslib source though):
<br/>
<br/>
ARM7:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
---------------------------------------------------------------------------------*/
<br/>
#include &lt;stdint.h&gt;
<br/>
<br/>
#define IPC_FIFO_ENABLE (1 &lt;&lt; 15)
<br/>
#define IPC_FIFO_SEND_CLEAR (1 &lt;&lt; 3)
<br/>
#define REG_IPC_SYNC *(volatile uint16_t*) 0x04000180
<br/>
#define REG_IPC_FIFO_CR *(volatile uint16_t*) 0x4000184
<br/>
#define IPC_SYNC_IRQ_ENABLE (1 &lt;&lt; 14)
<br/>
<br/>
//---------------------------------------------------------------------------------
<br/>
int main() {
<br/>
//---------------------------------------------------------------------------------
<br/>
<br/>
   // initialize fifo and sync to other cpu
<br/>
   REG_IPC_FIFO_CR = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR;
<br/>
   {
<br/>
      int counted = 0;
<br/>
      int my_value = 0, their_value;
<br/>
      REG_IPC_SYNC = 0;
<br/>
      while(counted &lt; 3)
<br/>
      {
<br/>
         // sync
<br/>
         their_value = REG_IPC_SYNC&amp;0x000F;
<br/>
         if( ((my_value + 1)&amp;0x000F ) == their_value ) counted++;
<br/>
         my_value=(their_value+1)&amp;0x000F;
<br/>
         REG_IPC_SYNC = my_value&lt;&lt;8;
<br/>
      }
<br/>
      REG_IPC_SYNC = 14 &lt;&lt;8;
<br/>
   }
<br/>
<br/>
   // Stick it in an infinite loop
<br/>
   while (1);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
ARM9:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;stdint.h&gt;
<br/>
<br/>
typedef int16_t int16;
<br/>
typedef uint16_t uint16;
<br/>
typedef volatile uint32_t vu32;
<br/>
#define REG_DISPCNT  *(vu32*) 0x04000000
<br/>
#define VRAM_A_CR  *(vu32*) 0x04000240
<br/>
#define VRAM_ENABLE (1 &lt;&lt; 7)
<br/>
#define VRAM_A_LCD  0
<br/>
#define VRAM_A  ((uint16_t*) 0x6800000)
<br/>
#define RGB15(r,g,b) ((r) | ((g)&lt;&lt;5) | ((b)&lt;&lt;10) )
<br/>
<br/>
static int shape_width = 50;
<br/>
static int shape_height = 50;
<br/>
<br/>
void draw_shape(int x, int y, uint16* buffer, uint16 color)
<br/>
{
<br/>
   int i, j;
<br/>
<br/>
  buffer += y * 256 + x;
<br/>
  for(i = 0; i &lt; shape_height; ++i) {
<br/>
    uint16* line = buffer + (256 * i);
<br/>
    for(j = 0; j &lt; shape_width; ++j) {
<br/>
      *line++ = color;
<br/>
    }
<br/>
  }
<br/>
}
<br/>
<br/>
int main(void)
<br/>
{
<br/>
  //videoSetMode(MODE_FB0);
<br/>
  REG_DISPCNT = 0x00020000;
<br/>
  //vramSetBankA(VRAM_A_LCD);
<br/>
  VRAM_A_CR = VRAM_ENABLE | VRAM_A_LCD;
<br/>
<br/>
  draw_shape(5, 5, VRAM_A, RGB15(31, 0, 0));
<br/>
<br/>
<br/>
  while(1);
<br/>
  return 0;
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166052 - Maxxie - Sun Jan 18, 2009 10:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Tyler24 wrote:</b></span></td> </tr> <tr> <td class="quote">If this is your code, it initially had error checking and whatnot, but I deleted all of it to figure out which parts I really needed for my example.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
No it is not mine.
<br/>
If you got it, reinsert the error checking to prevent lock-ups.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The ARM9 code simply selects VRAM_A, MODEFB_0 and draws a square. No IPC/FIFO initialization code here. </td> </tr></table><span class="postbody">
<br/>
<br/>
There is but not in main:
<br/>
The first thing to be called before executing main() is the crt0. The file containing the code (arm assembler) is calling initSystem (see <a href="http://devkitpro.svn.sourceforge.net/viewvc/devkitpro/trunk/libnds/source/arm9/initSystem.c?revision=2967&amp;view=markup" target="_blank">http://devkitpro.svn.sourceforge.net/viewvc/devkitpro/trunk/libnds/source/arm9/initSystem.c?revision=2967&amp;view=markup</a>) Which calls the fifoInit  (see <a href="http://devkitpro.svn.sourceforge.net/viewvc/devkitpro/trunk/libnds/source/common/fifosystem.c?revision=2801&amp;view=markup" target="_blank">http://devkitpro.svn.sourceforge.net/viewvc/devkitpro/trunk/libnds/source/common/fifosystem.c?revision=2801&amp;view=markup</a>) . That's where it's done.
<br/>
<br/>
The arm9 will never reach main() if the crt0 does not pass the initSystem call.<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166053 - Tyler24 - Sun Jan 18, 2009 10:33 pm</h4>
    <div class="postbody"><span class="postbody">Ahh, didn't even think to peek at the crt0 code. I see it now, thanks.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   push   {r0}
<br/>
   ldr   r3, =initSystem
<br/>
   blx   r3         @ system initialisation</td> </tr></table><span class="postbody">
<br/>
<br/>
This is going to take a lot more work than I had hoped for to get some communication going. I'm still confused as to how to link the processors together via the IPC... as in, what needs to be "set" on both ends. I can see the challenge and response going on that you mentioned, but what is set/done as a result of it? What is preventing me from drawing on the screen if that challenge/response code doesn't execute in the ARM7 C code I provided? EDIT: Ahh, is the timeout on the other side of things preventing me from getting anywhere? I made my own template folder, which uses its own makefile, and links itself from all of my own code and such. When I run it in iDeaS, I can open the debugger and the ARM9/7 code is exactly where I specified, and when I run it, all of the resulting changes are expressed in memory. I tried specifying VRAM_A/MODE_FB0 and copied some memory to VRAMA. The debugger shows that there indeed was memory written to VRAMA, but nothing shows up on the screen. Now I'm beginning to wonder if it's for some other reason...?
<br/>
<br/>
This is all the information on the IPC Sync Register:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">4000180h - NDS9/NDS7 - IPCSYNC - IPC Synchronize Register (R/W)
<br/>
  Bit   Dir  Expl.
<br/>
  0-3   R    Data input from IPCSYNC Bit8-11 of remote CPU (00h..0Fh)
<br/>
  4-7   -    Not used
<br/>
  8-11  R/W  Data output to IPCSYNC Bit0-3 of remote CPU   (00h..0Fh)
<br/>
  12    -    Not used
<br/>
  13    W    Send IRQ to remote CPU      (0=None, 1=Send IRQ)
<br/>
  14    R/W  Enable IRQ from remote CPU  (0=Disable, 1=Enable)
<br/>
  15-31 -    Not used
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166054 - Tyler24 - Sun Jan 18, 2009 11:31 pm</h4>
    <div class="postbody"><span class="postbody">Sorry for the double post, but I found my problem! Solution for those who care:
<br/>
<br/>
I realized that I wasn't getting anything with the C code because as Maxxie helpfully pointed out, the ARM9 code was calling fifoInit as well as the ARM7 code, even though I hadn't explicitly called it (it was done in initSystem() in ds_arm9_crt0.s). When I got rid of the fifoInit() code from the ARM7 (or fiddled with it so much that I ended up destroying it) I created the lockup. Blank screens. One of the processors was stuck in the timeout loop.
<br/>
<br/>
Stupid me, on the other hard, was going along too fast and missed a 0 in my own assembler code. My ROM was getting assembled properly, but I wasn't writing to the display register, and thus nothing ever happened. Haha. Stupid me.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166082 - headspin - Mon Jan 26, 2009 9:24 am</h4>
    <div class="postbody"><span class="postbody">I am writing a project for the DS in pure asm (without libnds) and I am using IPC (0x027FF000) for music and have not found it necessary to use a method to sync the two CPU's.
<br/>
<br/>
I read from <a class="postlink" href="http://www.fampennings.nl/maarten/nds/index.htm" target="_blank">this website</a> that the IPC memory is the first mirror of main memory and is uncached. It also states that "<span style="font-style: italic">Both the ARM7 and the ARM9 can access this [the main] memory at any time. Any bus conflicts are delegated to the processor which has priority (the ARM7 by default but changeable via a control register) causing the other processor to wait until the first has finished its operation."</span>
<br/>
<br/>
So I just simply write to the IPC area from the ARM9 and ARM7 reads it. I have not had any problems and seems to work okay on hardware. If it's uncached I also assume I don't need to flush.<br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166088 - DekuTree64 - Mon Jan 26, 2009 11:10 am</h4>
    <div class="postbody"><span class="postbody">IPC FIFO is different from shared memory. <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=13430&amp;start=18" target="_blank">Here</a> is a simpler FIFO transfer system I wrote a long time ago, that might help you understand it a bit better (I'm also puzzled by the massive amount of code in the libnds one).
<br/>
<br/>
Mine has some annoying shared memory counter things, but I think they ended up being kind of pointless aside from giving the ability to wait for the other CPU to process a command, so you could remove them (and the IPCFifoCheckMessageDone and IPCFifoWaitMessage functions).
<br/>
<br/>
It doesn't look like I messed with REG_IPC_SYNC at all. Actually I'm not entirely sure what that register was invented for. I don't think it adds any abilities that you can't do using the FIFO.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166093 - Maxxie - Mon Jan 26, 2009 2:38 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
It doesn't look like I messed with REG_IPC_SYNC at all. Actually I'm not entirely sure what that register was invented for. I don't think it adds any abilities that you can't do using the FIFO.</td> </tr></table><span class="postbody">
<br/>
<br/>
Its much more ease. You can do a lot of things wrong when syncing via fifo including i.e. forgetting that the other side might clear your sync requests aways when initializing itself.
<br/>
<br/>
Surely you can do everything a second way, but that's not really the point. We could remove the mul opcodes, as we can add allready and rebuild the mul that way ;)<br/>_________________<br/><a class="postlink" href="http://nintendods.desperate-programmers.com/doku.php?id=wireless_io_map" target="_blank">Trying  to bring more detail into understanding the wireless hardware</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
