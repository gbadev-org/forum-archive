<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Reading DMA status registers - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Reading DMA status registers</h2>
<div id="posts">
<div class="post">
    <h4>#178216 - Bregalad - Wed Aug 27, 2014 10:41 pm</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
<br/>
I have a problem. I want to try to know if HBlank DMA is active by reading the DMA status register (in this case, DMA3CNT or 0x40000DE) and see bit 15, and I initiate a memory transfer only if this is not the case. However this doesn't seem to work.
<br/>
<br/>
Actually it seems that just the read instruction screws things up, even if I only read and write nothing. This is really strange. The documentation says we can read the status register, but it does not mention what the read returns, nor if there is any side-effect.
<br/>
<br/>
VBA emulates it correctly (i.e. the weird behaviour is the same as real hardware) so at least this behaviour is <span style="font-style: italic">known</span>.
<br/>
<br/>
I tried both 16-bit and 32-bit reads, without success (16-bit reads sounds a better idea to avoid reading the illegal 0x40000DC).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#178219 - Bregalad - Fri Aug 29, 2014 5:52 pm</h4>
    <div class="postbody"><span class="postbody">I have another question in regard to DMA :
<br/>
<br/>
What happens if a Vblank (or any other) IRQ fires during a DMA transfer ? Will the CPU :
<br/>
1) continue to be halted until the DMA is finished, then serve the IRQ
<br/>
<br/>
2) Serve the IRQ right away, and continue the DMA once the CPU returns in USER mode</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#178221 - DekuTree64 - Sat Aug 30, 2014 7:55 am</h4>
    <div class="postbody"><span class="postbody">DMA always takes precedence over CPU, so interrupts will not be serviced until the DMA finishes.
<br/>
<br/>
And by checking that HBlank DMA is active, I assume you just mean enabled, and not currently transferring? Because if it is currently transferring, then the CPU is paused so you'd never see it :-s
<br/>
<br/>
I thought it was ok to read DMA3CNT and check bit 15, but maybe not. I suppose you could just make a global variable to keep track of whether you have an HBlank DMA set up. But now I am kind of curious whether reading DMA control registers has side effects...<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#178222 - Bregalad - Sat Aug 30, 2014 4:38 pm</h4>
    <div class="postbody"><span class="postbody">Oh thank you, this is very helpful.
<br/>
<br/>
Reading DMA definitely has a side effect, it might restart the transfer(s) if one is currently pending or something like that. All I can say is that apparently the side effect, although undocumented, is somehow correctly emulated on Visual Boy Advance.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
