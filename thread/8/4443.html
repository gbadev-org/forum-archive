<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GBA C Programming with inline ARM ASM - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > GBA C Programming with inline ARM ASM</h2>
<div id="posts">
<div class="post">
    <h4>#29611 - ozahid - Mon Nov 22, 2004 4:16 pm</h4>
    <div class="postbody"><span class="postbody">I am still fairly new here, however I have learned that the prefered way of programming something for the GBA is to do so mostly in C. At the same time including inline Assembly seems to be a good idea in "time critical" areas of the program. This last statement is what confuses me and hopefully comeone can clarify it for me.
<br/>
<br/>
Lets say that I want to program Tetris Clone Advance. Should I:
<br/>
1. first start off my programming the entire thing in C, and then reprogram what I can in ARM
<br/>
2. program only "time critical" areas in ASM -- and I don't know what this means. I am guessing it refers to areas of code that need to be computed as fast and efficiently as possible
<br/>
<br/>
Thanks<br/>_________________<br/><a href="http://people.umass.edu/ozahid" target="_blank">http://people.umass.edu/ozahid</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29612 - isildur - Mon Nov 22, 2004 4:22 pm</h4>
    <div class="postbody"><span class="postbody">Usually, the thing to do is to program everything in C or C++ (if C/C++ is your language of choice) and then, if needed, convert time critical routines to assembly.  You might never need to use assembly. This really depends on what you are trying to do.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29615 - poslundc - Mon Nov 22, 2004 5:55 pm</h4>
    <div class="postbody"><span class="postbody">"Time-critical" implies that there is a limited amount of time within which to get a certain job done, and that either the limit is significant enough or the algorithm is complicated enough that it is unlikely you would have enough time to complete the routine without doing some optimizations.
<br/>
<br/>
On the GBA, time-critical routines are often interrupt service routines (ISRs) that must execute in a very brief period of time, such as those that generate special effects on every individual scanline, handle multiplayer communications, or mix sound into the sound buffers.
<br/>
<br/>
On the larger, more general scale a time-critical routine is often a very small portion of the code that the processor spends almost all of time in. The 80/20 rule is known as the Pareto Principle, which roughly states that 80% of the problem is due to 20% of the source (or, applied to programming that 80% of the computer's time is spent in 20% of your code). This is the code you want to find and ultimately optimize (perhaps into ASM, although not necessarily).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30773 - identitycrisisuk - Sat Dec 04, 2004 3:41 pm</h4>
    <div class="postbody"><span class="postbody">Thinking about this, although it is often said that you might not need to use assembly, how often is this the case? How about in these two scenarios, would well written C code be good enough?
<br/>
<br/>
1 - My current project, a platformer with not many special effects being used, at the moment the only thing I want to do with interrupts is create a wavy screen by changing BG offsets each HBlank and maybe some sound later.
<br/>
<br/>
2 - An idea I had to do a Rhythm action game like frequency. This would use mode 7 techniques to have a 3d plane that would travel towards you, obviously sound and probably keypress interrupts for accurate timings.<br/>_________________<br/></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">CanIKickIt(YES_YOU_CAN);</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30777 - poslundc - Sat Dec 04, 2004 4:49 pm</h4>
    <div class="postbody"><span class="postbody"><span style="font-style: italic">Heavily optimized</span> (as opposed to well-written) C code might be good enough to achieve the effect you desire. (Heck, you can do Mode 7 without interrupts entirely if it's your only raster effect by using DMA0.)
<br/>
<br/>
The problem is that the process of heavily optimizing C code generally means predicting what its assembly equivalent will wind up being, at which point you may as well just be writing assembly.
<br/>
<br/>
Another problem is that things aren't always stackable... for example, I might be able to write an interrupt-driven sound mixer/music player in plain C and get it working, but if in my game I have an HBlank effect that needs to steal cycles from it then having a tightly-optimized assembly version may be more useful.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30779 - identitycrisisuk - Sat Dec 04, 2004 5:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">Heck, you can do Mode 7 without interrupts entirely if it's your only raster effect by using DMA0.</td> </tr></table><span class="postbody">
<br/>
<br/>
Interesting, I might have to try and find some examples of that as I assume I could also use it for a rippling background effect?<br/>_________________<br/></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">CanIKickIt(YES_YOU_CAN);</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30785 - MumblyJoe - Sat Dec 04, 2004 5:55 pm</h4>
    <div class="postbody"><span class="postbody">Personally, I have found that diving into ASM for the GBA has done nothing but waste my time. I know that it is essential to do sometimes, and I think I have a strong grasp on assembly in general, but I have projects where I have used floats and division (not BIOS or shifts) everywhere with the intention of optimising it later and have never had to.
<br/>
<br/>
In general my golden rule is work in C/C++ and if something has issues it can usually be traced back to a design problem rather than a shitty compiler.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30790 - identitycrisisuk - Sat Dec 04, 2004 6:30 pm</h4>
    <div class="postbody"><span class="postbody">Yup, very much so. The only time I've managed to slow down the hardware so far was when I had two scrolling backgrounds that updated the entire screen rather than me being arsed to learn how to just update strips at the edges.<br/>_________________<br/></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">CanIKickIt(YES_YOU_CAN);</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#30810 - tepples - Sun Dec 05, 2004 1:46 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">The problem is that the process of heavily optimizing C code generally means predicting what its assembly equivalent will wind up being, at which point you may as well just be writing assembly.</td> </tr></table><span class="postbody">
<br/>
However, the C is still easier to read, and it lets one release bit-equivalent mixers and rasterizers in the GBA version and in a hypothetical downloadable demo of a PC port of a GBA game.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Another problem is that things aren't always stackable... for example, I might be able to write an interrupt-driven sound mixer/music player in plain C and get it working, but if in my game I have an HBlank effect that needs to steal cycles from it then having a tightly-optimized assembly version may be more useful.</td> </tr></table><span class="postbody">
<br/>
TOD M3 runs a C based mixer (albeit mono) and HDMA-based mode 7 at the same time. The trick is to do as much as you can in DMA.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31181 - Miked0801 - Wed Dec 08, 2004 7:12 pm</h4>
    <div class="postbody"><span class="postbody">I'll chime in here a bit.
<br/>
<br/>
The only places in all our games where we use assembly are:
<br/>
<br/>
1. Decompression routines (#2 speed hit in our games, everything in our game is compressed heavily so these routines take a ton of our time - this is what profiling is for.)
<br/>
2. crt0 as it is called a ton
<br/>
3. Mixers in sound libraries (#1 speed hit in our games)
<br/>
4. Our sprite Y Sort routine (Shell Sort - was #3, but converted to assembly made it go ~x20 faster and half the size.)
<br/>
5. Before we switched to edge fill scrolling, our scroll routines.
<br/>
<br/>
And for fun:
<br/>
4. Our division routine, though if we ran low on IWRAM, this would be the first to revert back to BIOS calls.  Needed in Mode7/3D games, otherwise it's kind fluff.
<br/>
<br/>
What's not in assembly that is suprising?
<br/>
1. Our HBlank(VCount)/VBlank interrupts as the compiler handles these small routines fine on its own with special care in coding.
<br/>
2. Our Serial communications code, because it's so big and complicated, it's hard to justify that much space for it - especially when a bunch of it's time is hardware dependant.
<br/>
3. Our base actor handler - which probably should be in assembly (#3 speed hit for most games) :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31208 - Lupin - Wed Dec 08, 2004 9:53 pm</h4>
    <div class="postbody"><span class="postbody">Why do you use shell sort? Isn't it a bit slow? Why not a O(n log n) implementation? Ok i guess it won't matter much with just a few sprites...<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31221 - tepples - Thu Dec 09, 2004 12:14 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lupin wrote:</b></span></td> </tr> <tr> <td class="quote">Why do you use shell sort? Isn't it a bit slow? Why not a O(n log n) implementation? Ok i guess it won't matter much with just a few sprites...</td> </tr></table><span class="postbody">
<br/>
Right, and at small array sizes, the constant term dominates. Some have reported that the constant term is bigger with heapsort or merge sort than with Shell sort. (Quicksort uses extra RAM, and practical implementations actually fall back to an insertion sort such as a Shell sort for small sub-ranges.) In addition, Shell sort is about O(n log n) on nearly sorted data, and Y-positions of sprites that were sorted in the previous frame are likely to be nearly sorted in this frame.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31328 - Miked0801 - Fri Dec 10, 2004 3:24 am</h4>
    <div class="postbody"><span class="postbody">Couldn't have said it better myself :)
<br/>
<br/>
The overhead for shell sort is so small that it beats other sorts for the datasets we use it on.  Heck, Bubble sort is (almost) fine for small, nearly sorted data sets.  We usually sort between 10 and 70 objects per gameloop so our routine gets in and out and done plenty quick.
<br/>
<br/>
Bubble Sort - hehe, N=60 of 1800 or so was our original version and was butt slow.
<br/>
<br/>
Insert Sort - very simple, but for higher Ns, N^2/8 adds up quick (60 would be 450ish)
<br/>
<br/>
Quick Sort == big stack space or silly complexity on versions that kill tail recursion.  For our data sets, it's overkill and since its in and out of memory so much, it wouldn't be an ideal GBA sort anyways as our data is mostly in EWRAM.)
<br/>
<br/>
Heap Sort - Nice on all datasets, but a whole lot of setup and exit code on the implementations I've seen.  
<br/>
<br/>
For N around 60, n log n and n ^ 1.25 come pretty close anyways (107 to 167), but overhead kills the heap sort advantage.  My shell sort is around 200 bytes and compares against y pos, sprite priority, secondary priority, and a unique number (the last needed as my sort isn't stable which causes sprites to flicker back and forth if they are exactly the same in comparison values)
<br/>
<br/>
Again, I could use a N sort like bucket or radix, but come on!  Complexity and RAM overhead makes this as silly as bogo sort :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
