<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>foolish question from an asm knobbit - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>ASM > foolish question from an asm knobbit</h2>
<div id="posts">
<div class="post">
    <h4>#163703 - moonlightcheese - Thu Oct 09, 2008 1:35 pm</h4>
    <div class="postbody"><span class="postbody">i'm 'porting' a program from a fake assembly language to arm assembly for a project and i just want to make sure i'm not screwing up.  the .align at the top aligns everything to words right?  so if i type some code like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r3, #0x5C
<br/>
mov r2, #10
<br/>
str r2, [r3]
<br/>
mov r2, #6
<br/>
str r2, [r3, #1]</td> </tr></table><span class="postbody">
<br/>
<br/>
this should place the value 10 in address 0x5C and the value 6 in address 0x5D as 32 bit words right?  sorry for the stupid question... just making sure i'm doing things right.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163704 - eKid - Thu Oct 09, 2008 2:28 pm</h4>
    <div class="postbody"><span class="postbody">The .align directive aligns the code to the word boundary.
<br/>
<br/>
What that code will do is write 10 to the word at 0x5C and write 6 to <span style="text-decoration: underline">0x5C</span> too!
<br/>
<br/>
ARM can't write 32-bit values to misaligned addresses so the lower two bits of the address are ignored when using str.
<br/>
<br/>
The final result will be '6' in the byte at 0x5C and 0 in the next 3 bytes, or 6 in the word at 0x5C.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163705 - moonlightcheese - Thu Oct 09, 2008 2:54 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>eKid wrote:</b></span></td> </tr> <tr> <td class="quote">The .align directive aligns the code to the word boundary.
<br/>
<br/>
What that code will do is write 10 to the word at 0x5C and write 6 to <span style="text-decoration: underline">0x5C</span> too!
<br/>
<br/>
ARM can't write 32-bit values to misaligned addresses so the lower two bits of the address are ignored when using str.
<br/>
<br/>
The final result will be '6' in the byte at 0x5C and 0 in the next 3 bytes, or 6 in the word at 0x5C.</td> </tr></table><span class="postbody">
<br/>
ok.
<br/>
<br/>
i thought that the instr (str r2, [r3, #1]) would increment the address stored in r3 and store r2 into that address, no?  should i add the number of bytes instead?  essentially you're telling me to do this, right?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r3, #0x5C
<br/>
mov r2, #10
<br/>
str r2, [r3]
<br/>
mov r2, #6
<br/>
str r2, [r3, #4]</td> </tr></table><span class="postbody">
<br/>
so that the value 10 stores to 0x5C, and the value 6 stores to (0x60?) right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163706 - Cearn - Thu Oct 09, 2008 3:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote">i thought that the instr (str r2, [r3, #1]) would increment the address stored in r3 and store r2 into that address, no?  should i add the number of bytes instead? 
<br/>
</td> </tr></table><span class="postbody">
<br/>
Unlike in C, the offset is always measured in bytes, so `str, [r3, #1]' would try to store r2 in 0x5D (and do it incorrectly for the reason eKid mentioned). So yes, use #4 in this case. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r3, #0x5C
<br/>
mov r2, #10
<br/>
str r2, [r3]
<br/>
mov r2, #6
<br/>
str r2, [r3, #4]</td> </tr></table><span class="postbody">
<br/>
so that the value 10 stores to 0x5C, and the value 6 stores to (0x60?) right?</span></td> </tr></table><span class="postbody">
<br/>
Yes. 
<br/>
<br/>
You can also make use of ARM block-transfers LDM and STM if you want to load/store multiple words of data. These tend to be a little faster.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov     r0, #0x5C
<br/>
mov     r2, #10
<br/>
mov     r3, #6
<br/>
stmia   r0, {r2-r3}     @ Store r2 in 0x5C and r3 in 0x60.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Note that you shouldn't be able to access addresses as low as 0x5C. on GBA or NDS, but I'm assuming this was just an example.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163708 - moonlightcheese - Thu Oct 09, 2008 4:08 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote">i thought that the instr (str r2, [r3, #1]) would increment the address stored in r3 and store r2 into that address, no?  should i add the number of bytes instead? 
<br/>
</td> </tr></table><span class="postbody">
<br/>
Unlike in C, the offset is always measured in bytes, so `str, [r3, #1]' would try to store r2 in 0x5D (and do it incorrectly for the reason eKid mentioned). So yes, use #4 in this case. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r3, #0x5C
<br/>
mov r2, #10
<br/>
str r2, [r3]
<br/>
mov r2, #6
<br/>
str r2, [r3, #4]</td> </tr></table><span class="postbody">
<br/>
so that the value 10 stores to 0x5C, and the value 6 stores to (0x60?) right?</span></td> </tr></table><span class="postbody">
<br/>
Yes. 
<br/>
<br/>
You can also make use of ARM block-transfers LDM and STM if you want to load/store multiple words of data. These tend to be a little faster.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov     r0, #0x5C
<br/>
mov     r2, #10
<br/>
mov     r3, #6
<br/>
stmia   r0, {r2-r3}     @ Store r2 in 0x5C and r3 in 0x60.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Note that you shouldn't be able to access addresses as low as 0x5C. on GBA or NDS, but I'm assuming this was just an example.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
cool thanks!
<br/>
<br/>
so instead of storing to memory i'm storing to the stack, which should be perfectly legal, afaik.  so the code i'll be using goes something like this to start (this is just to store the data for the program to be used later).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r2, #10
<br/>
str r2, [r13]  @store to top of stack
<br/>
mov r2, #6
<br/>
str r2, [r13, #-4] @store next word onto stack, moving down SP
<br/>
@9 more data moves in this fashion</td> </tr></table><span class="postbody">
<br/>
also, is there a better way to store the data in the program, like using a .data section or something?  i don't know how to do that and couldn't find any specifics in my ARM resources.
<br/>
<br/>
also also, how can i accept user or file input?  is there an easy way?
<br/>
<br/>
my idea was to write this app as inline assembly, accepting file input into an array and then somehow (this is the part that eludes me) storing the array to the top of the stack (or passing a pointer to the array maybe?) and then running the inline assembly instructions to execute the program using the values placed on the stack by the C code.  can i do this?
<br/>
<br/>
sorry for being such a noob :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163710 - eKid - Thu Oct 09, 2008 5:04 pm</h4>
    <div class="postbody"><span class="postbody">When the 'push' instruction is used, it decrements before the store, so writing to [r13] will overwrite critical data, only underneath r13 is safe.
<br/>
<br/>
Also, if you have some interrupts enabled, then storing underneath r13 is risky. If the interrupt handler switches back to the user/system stack (this is common to achieve more stack space during interrupts), then that data will get corrupted. To be safe you can decrement r13 beforehand to reserve the space.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163714 - Cearn - Thu Oct 09, 2008 5:48 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote">So instead of storing to memory i'm storing to the stack, which should be perfectly legal, afaik.  so the code i'll be using goes something like this to start (this is just to store the data for the program to be used later).
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov r2, #10
<br/>
str r2, [r13]  @store to top of stack
<br/>
mov r2, #6
<br/>
str r2, [r13, #-4] @store next word onto stack, moving down SP
<br/>
@9 more data moves in this fashion</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
Yeah keeping things on the stack should work fine. Stackwork is usually done with stmfd and ldmfd, though (or push and pop in Thumb mode).
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov     r2, #10
<br/>
mov     r3, #6
<br/>
stmfd   sp!, {r2-r3}    @ Push r2 and r3 on stack. The `!' means sp 
<br/>
                        @ is updated to sp-8. 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote">also, is there a better way to store the data in the program, like using a .data section or something?  i don't know how to do that and couldn't find any specifics in my ARM resources.
<br/>
</td> </tr></table><span class="postbody">
<br/>
You can put things in .data (initialized data), .bss (uninitialized data) and .section .rodata (const data). You can find a few things relating to the GNU assembler in <a class="postlink" href="http://www.coranac.com/tonc/text/asm.htm#sec-gas" target="_blank">tonc:asm</a>, and of course <a class="postlink" href="http://sourceware.org/binutils/docs/as/index.html" target="_blank">the manual</a>.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote">also also, how can i accept user or file input?  is there an easy way?
<br/>
<br/>
my idea was to write this app as inline assembly, accepting file input into an array and then somehow (this is the part that eludes me) storing the array to the top of the stack (or passing a pointer to the array maybe?) and then running the inline assembly instructions to execute the program using the values placed on the stack by the C code.  can i do this?
<br/>
<br/>
sorry for being such a noob :(</td> </tr></table><span class="postbody">
<br/>
Eeew, inline asssembly :P. 
<br/>
IMHO, it's best to use a proper assembly file for your asm code. Inline assembly has a fairly obscure syntax and may not play well with the surrounding C code (not to mention the instruction set the C file is compiled under; inline ARM asm in Thumb compilation unit is probably a bad idea). You don't have to do anything extra to deal with assembly files if you're working with the standard devkitPro template makefiles: just give it an .s extension and the makefile will take care of the rest.
<br/>
<br/>
Instead of keeping the data on the top of the stack, you could simply malloc an area and use the pointer it gives you.
<br/>
<br/>
As for file input, it's probably best to use libfat for something like that. You can still call functions from assembly. The thing is, though, if you're calling file operations, why would use assembly for it? Assembly is most properly used for speeding up time-critical code (well, that and for the lulz of course), but any gains you think you might get from hand-coded assembly will be nullified by the file access.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163717 - moonlightcheese - Thu Oct 09, 2008 6:12 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote">Yeah keeping things on the stack should work fine. Stackwork is usually done with stmfd and ldmfd, though (or push and pop in Thumb mode).
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov     r2, #10
<br/>
mov     r3, #6
<br/>
stmfd   sp!, {r2-r3}    @ Push r2 and r3 on stack. The `!' means sp 
<br/>
                        @ is updated to sp-8. 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote">also, is there a better way to store the data in the program, like using a .data section or something?  i don't know how to do that and couldn't find any specifics in my ARM resources.
<br/>
</td> </tr></table><span class="postbody">
<br/>
You can put things in .data (initialized data), .bss (uninitialized data) and .section .rodata (const data). You can find a few things relating to the GNU assembler in <a class="postlink" href="http://www.coranac.com/tonc/text/asm.htm#sec-gas" target="_blank">tonc:asm</a>, and of course <a class="postlink" href="http://sourceware.org/binutils/docs/as/index.html" target="_blank">the manual</a>.</span></td> </tr></table><span class="postbody">
<br/>
ok cool, i'll have to look up how to use the .data section and how to use that data in the .text
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>moonlightcheese wrote:</b></span></td> </tr> <tr> <td class="quote">also also, how can i accept user or file input?  is there an easy way?
<br/>
<br/>
my idea was to write this app as inline assembly, accepting file input into an array and then somehow (this is the part that eludes me) storing the array to the top of the stack (or passing a pointer to the array maybe?) and then running the inline assembly instructions to execute the program using the values placed on the stack by the C code.  can i do this?
<br/>
<br/>
sorry for being such a noob :(</td> </tr></table><span class="postbody">
<br/>
Eeew, inline asssembly :P. 
<br/>
IMHO, it's best to use a proper assembly file for your asm code. Inline assembly has a fairly obscure syntax and may not play well with the surrounding C code (not to mention the instruction set the C file is compiled under; inline ARM asm in Thumb compilation unit is probably a bad idea). You don't have to do anything extra to deal with assembly files if you're working with the standard devkitPro template makefiles: just give it an .s extension and the makefile will take care of the rest.
<br/>
<br/>
Instead of keeping the data on the top of the stack, you could simply malloc an area and use the pointer it gives you.
<br/>
<br/>
As for file input, it's probably best to use libfat for something like that. You can still call functions from assembly. The thing is, though, if you're calling file operations, why would use assembly for it? Assembly is most properly used for speeding up time-critical code (well, that and for the lulz of course), but any gains you think you might get from hand-coded assembly will be nullified by the file access.</span></td> </tr></table><span class="postbody">
<br/>
well there are two reasons i'd like to use inline assembly.  one, this is a project and the first part is due monday so i'd like to have as much done as possible and i have a better idea (i think) of how to get things working in this manner and second, this project is basically an operating system.  we were supposed to kind of 'emulate' a machine and OS in java but i asked if i could do this instead.  the learning curve has proved most difficult but i'm getting more out of coding for the gba in terms of real world experience on the low level.
<br/>
<br/>
the idea behind this project is to build an OS to run his program (the code snippets in this thread are from his program) and run a number of instances of that program with his input files (which is why i need input and output).
<br/>
<br/>
so... it would be even better if i could do things properly and implement true context switching (saving the registers to the stack, saving the next instr to LR, calling the program as a subroutine, then switching back the PC from LR and returning the registers to their states, re-initiating the OS).  i think this would be too difficult, no?  i have the weekend to finish this first part...
<br/>
<br/>
i definitely appreciate the responses!  this brings me much closer to my end goal, which would be an OS for the gba complete with CLI.  :D
<br/>
<br/>
i have a lot of work to do...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164043 - strat - Sun Oct 19, 2008 8:08 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">The thing is, though, if you're calling file operations, why would use assembly for it? Assembly is most properly used for speeding up time-critical code (well, that and for the lulz of course)</td> </tr></table><span class="postbody">
<br/>
<br/>
Or when it just feels natural.  I'd like to store the level data for my game as a 3d array, but since that's a lot of trouble in C, it makes more sense to wrap all the pointer arithmetic in a neat little asm function.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164092 - Miked0801 - Mon Oct 20, 2008 4:44 pm</h4>
    <div class="postbody"><span class="postbody">How are 3D arrays a pain in c?
<br/>
<br/>
foo[1][2][3];
<br/>
<br/>
What's the issue?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164096 - Cearn - Mon Oct 20, 2008 6:09 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">How are 3D arrays a pain in c?
<br/>
<br/>
foo[1][2][3];
<br/>
<br/>
What's the issue?</td> </tr></table><span class="postbody">I kinda agree with this. However, if you're passing it onto functions and the sizes aren't known in advance you can't really do that. Still, you could just use single pointers like bar[z*zPitch + y*yPitch+x], which is what it would look like in assembly anyway.
<br/>
<br/>
That said, there are a few times when doing it in C really is ugly. In a fast non-DMA copy routine you may have t do it-masks on pointer and  switch between byte, halfword and word types for the pointers. That just looks awful in C.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164102 - Miked0801 - Mon Oct 20, 2008 8:01 pm</h4>
    <div class="postbody"><span class="postbody">If you are doing as you suggest, you are already abusing the arrays and deserve what you get :)
<br/>
<br/>
Anytime you get to the point where you are trying to pass around entire multi-dim array access, as pointer or otherwise, you need to ask yourself if there's a better way to represent your data.  Personally, the only time my arrays get to 3 dimensions is when I'm creating 2-permutation lookup tables.  At that point, the going from 2 dim to 3 is just a convience for not having to create a structure and defining data that way.  And these tables tend to get factored into smaller, more precise tables over time.
<br/>
<br/>
And I'm missing why you'd have to play the byte masking game.  If something is a 1/2/4 bytes in base size, pointer arithmetic will take care of the various multiplies you may need to do to get around in the structure.  Oh, and if you are talking about passing a byte array to a u32 expecting function such as the DMA copy, again you are asking for it.  :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164235 - strat - Fri Oct 24, 2008 2:12 am</h4>
    <div class="postbody"><span class="postbody">Cearn pretty much nailed it.  Also, it had more to do with the nature of C syntax than anything.  There'd be all those brackets and comments telling what level it is.  And trying to do the same thing in C that worked in assembly (storing the levels in their own arrays and having an array of pointers to each level) got to be a mess.
<br/>
<br/>
This way I get to store each level in a neat .ascii array with its own variable name, a pointer table of the level names, and a look-up function that almost looks like a 3D array:  MetaTileEntry(row,col,num)
<br/>
<br/>
Plus it was a good excuse to use assembly in a game that will probably never need it.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
