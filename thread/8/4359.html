<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>CLZ (count leading zeros) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > CLZ (count leading zeros)</h2>
<div id="posts">
<div class="post">
    <h4>#28848 - pyros - Sun Nov 07, 2004 5:02 pm</h4>
    <div class="postbody"><span class="postbody">According to the ARM instruction reference sheet, ARM5+ support the CLZ instruction. However I cannot get this to work (using combinations of goldroad, armasm, visualboy advance and mappy). Apparently no$gba does support it.
<br/>
<br/>
My questions are:
<br/>
<br/>
does the GBA support CLZ?
<br/>
<br/>
which assemblers support CLZ?
<br/>
<br/>
which emulators are known  to support CLZ?
<br/>
<br/>
Thankyou :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28850 - ecurtz - Sun Nov 07, 2004 5:49 pm</h4>
    <div class="postbody"><span class="postbody">Not supported on the gba.
<br/>
<br/>
The ARM7 in the gba is actually a generation "3" chip. I think you need an ARM9, which actually is generation "5" to support CLZ.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28896 - tepples - Mon Nov 08, 2004 4:23 pm</h4>
    <div class="postbody"><span class="postbody">Get a GP32 emulator or wait for 2006 when Nintendo DS emulators begin to show up.
<br/>
<br/>
What were you planning to use the 'CLZ' instruction for? Perhaps we could suggest a better algorithm to do what you ultimately wanted your program to do.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28904 - keldon - Mon Nov 08, 2004 4:49 pm</h4>
    <div class="postbody"><span class="postbody">CLZ and CTZ are sexy opcodes that would divide the time of a lot of algorithms, such as range checking etc. On the x86 we can (if I remember correctly) count zeros from a specific position; but if not it's still a sexy opcode.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28906 - pyros - Mon Nov 08, 2004 5:12 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">What were you planning to use the 'CLZ' instruction for? Perhaps we could suggest a better algorithm to do what you ultimately wanted your program to do.</td> </tr></table><span class="postbody">
<br/>
<br/>
Better algorithms already have been suggested :)
<br/>
<br/>
I was going to use it for writing my own fast divide function. Not a particularly necessary thing to do given several very fast ones have already been suggested to me. Just an interesting thing to do :)
<br/>
<br/>
Anyway, i 'would have' CLZed the numerator and denominator, then left-shifted the denominator along by the difference. Thus the algorithm 'would have' only required one loop, with only 0-32 iterations plus a few more instructions. Without CLZ, another loop is required to left-shift the denominator.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29043 - bakery2k - Wed Nov 10, 2004 6:42 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">CLZ and CTZ are sexy opcodes that would divide the time of a lot of algorithms...</td> </tr></table><span class="postbody">
<br/>
<br/>
There is no CTZ instruction. However, there is a cool way of counting trailing zeros (in 5 instructions if I remember correctly), if CLZ is available.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29045 - poslundc - Wed Nov 10, 2004 6:52 pm</h4>
    <div class="postbody"><span class="postbody">... It isn't, though. :P
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29078 - tepples - Thu Nov 11, 2004 1:00 am</h4>
    <div class="postbody"><span class="postbody">I can think of a way, using conditional execution, to count leading zeroes in about a dozen ARM cycles without CLZ.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34558 - metis - Fri Jan 21, 2005 12:35 pm</h4>
    <div class="postbody"><span class="postbody">From the book "Hacker's Delight":
<br/>
<a class="postlink" href="http://www.hackersdelight.org/HDcode/nlz.cc" target="_blank">Counting leading zeros</a>
<br/>
<a class="postlink" href="http://www.hackersdelight.org/HDcode/ntz.cc" target="_blank">Counting trailing zeros</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34566 - Arjan - Fri Jan 21, 2005 6:29 pm</h4>
    <div class="postbody"><span class="postbody">This is the version I made a couple of years ago. It's similar to nlz2 from Hacker's Delight.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
      movs   r1,r0,lsr #16
<br/>
                                                   
<br/>
      moveq   r1,r0      @if r1 is zero, there are at least 16 leading zero's
<br/>
      moveq   r0,#16          @and we'll have to search in lowest 16bits of input
<br/>
      movne   r0,#0       @otherwise, no leading zero's found yet
<br/>
<br/>
      @divide reg in 2 parts of 8 bits
<br/>
      movs   r2,r1,lsr #8
<br/>
<br/>
      addeq   r0,r0,#8   @if r2 is zero, we've found another 8 leading zero's
<br/>
      moveq   r2,r1      @search in lowest 8 bits
<br/>
<br/>
      @devide reg in 2 parts of 4 bits
<br/>
      movs   r1,r2,lsr #4
<br/>
<br/>
      addeq   r0,r0,#4   @if r1 is zero, we've found another 4 leading zero's
<br/>
      moveq   r1,r2      @search in lowest 4 bits
<br/>
<br/>
      @devide reg in 2 parts of 2 bits
<br/>
      movs   r2,r1,lsr #2
<br/>
<br/>
      addeq   r0,r0,#2   @if r2 is zero, we've found another 2 leading zero's
<br/>
      moveq   r2,r1      @and we'll search in lowest 2 bits
<br/>
      
<br/>
      @devide reg in 2 parts of 1 bits
<br/>
      subs   r2,r2,#1
<br/>
<br/>
      addeq   r0,r0,#1    @if r2 is zero, we've found another leading zero
<br/>
      movmi   r0,#32          @if r2 was zero before substracting, there are 32 leading zero's
<br/>
</td> </tr></table><span class="postbody">[/code]<br/>_________________<br/>dus.... <a href="http://www.bombaman.net" target="_blank">http://www.bombaman.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34573 - Miked0801 - Fri Jan 21, 2005 8:31 pm</h4>
    <div class="postbody"><span class="postbody">BSearch of leading 0's :)  Same idea we use.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34596 - FluBBa - Sat Jan 22, 2005 1:50 am</h4>
    <div class="postbody"><span class="postbody">Arjan: can this be put at <a class="postlink" href="http://www.geocities.com/v_d_d/gba/" target="_blank">http://www.geocities.com/v_d_d/gba/</a>?
<br/>
Full credits is ofcourse given.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34627 - Arjan - Sat Jan 22, 2005 10:04 pm</h4>
    <div class="postbody"><span class="postbody">FluBBa: I have no problems with that.<br/>_________________<br/>dus.... <a href="http://www.bombaman.net" target="_blank">http://www.bombaman.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34811 - isildur - Wed Jan 26, 2005 5:28 pm</h4>
    <div class="postbody"><span class="postbody">Thanks!
<br/>
<br/>
CLZ was added to the
<br/>
<a class="postlink" href="http://www.geocities.com/v_d_d/gba" target="_blank">GBA ARM Code Repository</a>.
<br/>
<br/>
We look forward for more contributions!</span><span class="gensmall"><br/><br/>Last edited by isildur on Wed Nov 16, 2005 5:03 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#60984 - kusma - Wed Nov 16, 2005 2:47 pm</h4>
    <div class="postbody"><span class="postbody">two iterations of binary search + a 256-entry lut ain't too bad either.
<br/>
should be possible in around 10 cycles.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61000 - Miked0801 - Wed Nov 16, 2005 5:47 pm</h4>
    <div class="postbody"><span class="postbody">Behold as threads arise from the dead ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65422 - keldon - Tue Jan 03, 2006 2:48 am</h4>
    <div class="postbody"><span class="postbody">I think I have found a way to speed up CLZ and CTZ. If you do a simple search to find which 8bytes the MSB and LSB is within then you can use a 256 entry look table.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ IN:
<br/>
@   r0 = num
<br/>
@ USE:
<br/>
@   r1 = Trailing Zeros
<br/>
@   r2 = num
<br/>
CTZ:
<br/>
   movs r2, r0, lsr #16
<br/>
<br/>
   moveq r2, r0
<br/>
   moveq r1, #16
<br/>
   movne r1, #0
<br/>
<br/>
   movs r0, r2, lsr #8
<br/>
<br/>
   addeq r1, r1, #8
<br/>
   moveq r0, r2</td> </tr></table><span class="postbody">
<br/>
You could start with that; and after use r0 as an index to an array where arr[n] = log(n). You then add the result in that array to r1 as the array only stores the amount of trailing for one byte and r1 stores how much zeroes trail before.
<br/>
<br/>
All that is missing from this code is using r0 to index the array; but I do not know any arm assembler.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65423 - kusma - Tue Jan 03, 2006 3:07 am</h4>
    <div class="postbody"><span class="postbody">keldon: that was exactly what i suggested three posts ago ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65424 - keldon - Tue Jan 03, 2006 3:11 am</h4>
    <div class="postbody"><span class="postbody">Oh yes. I did not notice that post. So how many cycles does it end up being after the memory accesses?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#65425 - kusma - Tue Jan 03, 2006 3:15 am</h4>
    <div class="postbody"><span class="postbody">i've never tested [edit: i use a c-version myself], i don't consider this kind of code a candidate for assembly, as the compiler usually generate damn good results, and as i can choose to have it inline, the compiler can do optimizations with the code around. but i assume that 10 cycles is about right.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#71886 - nmain - Wed Feb 15, 2006 2:48 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ecurtz wrote:</b></span></td> </tr> <tr> <td class="quote">Not supported on the gba.
<br/>
<br/>
The ARM7 in the gba is actually a generation "3" chip. I think you need an ARM9, which actually is generation "5" to support CLZ.</td> </tr></table><span class="postbody">
<br/>
<br/>
I believe the ARM7TDMI is a v4T... a v3 doesn't have BX?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
