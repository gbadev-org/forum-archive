<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Access data from structs? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Access data from structs?</h2>
<div id="posts">
<div class="post">
    <h4>#27519 - ProblemBaby - Thu Oct 14, 2004 6:01 pm</h4>
    <div class="postbody"><span class="postbody">Is it possible in asm to access data that is putted in a C struct.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
LDR r0, =GlobalStruct
<br/>
LDR r1, [r0, GlobalStruct.Var]
<br/>
</td> </tr></table><span class="postbody">
<br/>
or something
<br/>
it isnt fun to search the exact address for each variable
<br/>
and especially not if Ive to add one at the top or make a buffer bigger.
<br/>
<br/>
Plz help!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27520 - poslundc - Thu Oct 14, 2004 6:15 pm</h4>
    <div class="postbody"><span class="postbody">There is no built in or really simple method if your structs keep changing a lot. <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=2218" target="_blank">This topic</a> links to a more sophisticated and somewhat complicated method of sharing structs between C and ASM; it's what I use for all of my projects that require it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27528 - ProblemBaby - Thu Oct 14, 2004 7:45 pm</h4>
    <div class="postbody"><span class="postbody">I didnt exactly understand but I think its stupid that it just doesnt exist a built in function like offsettof(ASTRUCT, Var).
<br/>
And then put it in the code</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27530 - sgeos - Thu Oct 14, 2004 7:57 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ProblemBaby wrote:</b></span></td> </tr> <tr> <td class="quote">I didnt exactly understand but I think its stupid that it just doesnt exist a built in function like offsettof(ASTRUCT, Var).
<br/>
And then put it in the code</td> </tr></table><span class="postbody">
<br/>
Why not write a macro that does exactly that?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27531 - sajiimori - Thu Oct 14, 2004 8:12 pm</h4>
    <div class="postbody"><span class="postbody">In C it is trivial:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define STRUCT_OFFSET(type, elem) ((u32)&amp;((type*)0)-&gt;elem)</td> </tr></table><span class="postbody">An assembler OTOH has no way of knowing that information.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27533 - poslundc - Thu Oct 14, 2004 8:39 pm</h4>
    <div class="postbody"><span class="postbody">The general strategy in the article I referenced is to write a C program that generates another header file with these offsets precalculated. This header file is then #included in your ASM project, and you write your makefile so that if any of the struct-containing header files change then the program runs and recreates the ASM header file.
<br/>
<br/>
It is a complicated solution, and it requires GCC both for the ARM and for your native computer, and GCC for your computer's architecture must generate structs the same way that the ARM-targetted GCC does (which should be the case on most computers; it's like that in Mac OS anyway). But until they come out with a version of GAS that features better C compatibility, it's the best way I'm aware of.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27539 - keldon - Fri Oct 15, 2004 12:42 am</h4>
    <div class="postbody"><span class="postbody">A macro should be able to do that (providing your assembler has the correct features, which it may not).
<br/>
<br/>
EDIT: It can be done easily in the assembler I use, but it is unlikely it can be done in any other. Sometimes I do forget.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27541 - sajiimori - Fri Oct 15, 2004 1:37 am</h4>
    <div class="postbody"><span class="postbody">How do you do it in your assembler, out of curiosity?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27549 - keldon - Fri Oct 15, 2004 11:35 am</h4>
    <div class="postbody"><span class="postbody">The macro is <span style="font-weight: bold">[enum | {#1 #x} | #+1]</span>
<br/>
<br/>
<span style="font-weight: bold">#</span>means for parameter number, so #1 is parameter 1
<br/>
<br/>
<span style="font-weight: bold">#+1</span> means loop from first to last parameter, adding 1 to all parameter numbers, so #1 really means #2
<br/>
<br/>
<span style="font-weight: bold">#x</span> is the loop number, which comes into effect when you have more than one parameter
<br/>
<br/>
<span style="font-weight: bold">{}</span> is converted to <span style="font-weight: bold">[]</span> when it is unfolded, this is because variables and constants use square brackets also.
<br/>
---
<br/>
So <span style="font-weight: bold">enum startState endState keyState</span> unfolds as:
<br/>
<span style="font-weight: bold">[startState 1] ; Loop 1 (#x = 1, #1 points to param 1)
<br/>
[endState 2] ; Loop 2 (#x = 2, #1 points to param 2)
<br/>
[keyState 3] ; Loop 3 (#x = 3, #1 points to param 3)</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27553 - poslundc - Fri Oct 15, 2004 1:50 pm</h4>
    <div class="postbody"><span class="postbody">Maybe I'm missing something obvious but I don't see how that works to make C structs compatible with assembly code.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27560 - keldon - Fri Oct 15, 2004 3:29 pm</h4>
    <div class="postbody"><span class="postbody">oops, completely forgot I was doing structs and not enums
<br/>
<br/>
well first I'd make some defines
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">[u16 2 ; u16 is 2 bytes
<br/>
u32 4] ; u32 is 4 bytes</td> </tr></table><span class="postbody">
<br/>
There are more complex features to the macros set. <span style="font-weight: bold">&amp;1</span> means compile time variable 1
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">[Struct | { &amp;1=0 | &amp;2=#1 | #1: StructVariables #2&gt;L | } ]
<br/>
[StructVariables | &amp;2.#2 &amp;1 | &amp;1=&amp;1+#1 | #+2]</td> </tr></table><span class="postbody">
<br/>
<br/>
So <span style="font-weight: bold">Struct myStruct u16 Egg, u32 Stone, u16 Fire</span> unfolds as
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">[myStruct:
<br/>
myStruct.Egg 0
<br/>
myStruct.Stone 2
<br/>
myStruct.Fire 6]</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27561 - jma - Fri Oct 15, 2004 3:36 pm</h4>
    <div class="postbody"><span class="postbody">Perhaps this was covered in the article that <span style="font-weight: bold">poslundc</span> posted. However, the main reason this is a difficult task is because the C spec doesn't specify that members of a struct must be offset in order -- nor that alignment issues are handled properly. For example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct my_struct {
<br/>
  char b;
<br/>
  u32 i;
<br/>
} my_struct;</td> </tr></table><span class="postbody">
<br/>
<br/>
How many bytes does <span style="font-weight: bold">my_struct</span> occupy? It isn't know without a <span style="font-weight: bold">sizeof </span>operation. It could be 5 or 8. If <span style="font-style: italic">b</span> is first (which is what most compilers would do -- it's easier) then it could very well be 8 if the compiler word aligns <span style="font-style: italic">i</span>. But there is nothing in the spec preventing the compiler from putting <span style="font-style: italic">i</span> first (because it is already word aligned) followed by <span style="font-style: italic">b</span> -- making the structure only 5 bytes in size.
<br/>
<br/>
To get around this, typically compilers allow for specific <span style="font-weight: bold">#pragma</span> statements that allow you to specify (for example) <span style="font-weight: bold">pack</span> to force the compiler to not pad out structures, show the padding, etc.  This is all very compiler and platform specific, which is what makes it difficult to do.
<br/>
<br/>
This is why many times you'll see structures that are defined that have dumby data in them to pad out memory alignment issues:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct my_struct {
<br/>
  char b;
<br/>
  char pad[3];
<br/>
  u32 i;
<br/>
} my_struct;</td> </tr></table><span class="postbody">
<br/>
<br/>
I should re-iterate, though, that <span style="font-style: italic">most</span> compilers will compile structure offsets in-order (eg, <span style="font-style: italic">b</span> first, then <span style="font-style: italic">pad</span>, finally <span style="font-style: italic">i</span>). For your specific situation (the GBA and GNU) you might be very aware of what is happening under-the-hood and take advantage of it. But many, very-optimizing compilers will reorganize your structure for you.
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#27562 - poslundc - Fri Oct 15, 2004 3:49 pm</h4>
    <div class="postbody"><span class="postbody">This is part of why keldon's solution is no good for me... after all, GAS provides a .struct directive; that isn't the problem. The two problems are:
<br/>
<br/>
1. How GCC constructs/optimizes the struct
<br/>
<br/>
2. Keeping your ASM structs consistent with changes to your C structs
<br/>
<br/>
The technique that sajimori shows earlier in this thread works to solve the first problem (there is also an offsetof macro that does the same thing; I forget where it's defined but it's in that article I linked to).
<br/>
<br/>
The second problem is more compelling, because you can declare your structs using whatever directives your assembler provides for you, but it means you then have to keep track of your structures in two places, which is a real pain.
<br/>
<br/>
<br/>
My solution (which I also briefly explained further up) is to write an auxillary program in C <span style="font-style: italic">for my computer</span> (as opposed to for the GBA) that #includes my various header files that have structs in them. This program's function is to output a header file ("asmheaders.h") with a bunch of #defines in it that have all of the necessary offsets and sizes of the structures I'm interested in for my ASM routines.
<br/>
<br/>
Then my makefile has a dependency that lists those header files and checks them whenever it builds, and runs the auxillary program and rebuilds the ASM files if the header files have changed.
<br/>
<br/>
It's a bit of a pain to set up and adding new structs means changing the source of the auxillary program (adding new header files to it means changing the makefile as well), but it's a very smooth system once everything is set up and working properly.
<br/>
<br/>
The only caveat to this system is that GCC targetted for your computer has to generate its structs using the same rules that it does when targetted for the ARM. Which thankfully it does, at least on the Mac and probably on the PC as well.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
