<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Working with 64 bit numbers - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Working with 64 bit numbers</h2>
<div id="posts">
<div class="post">
    <h4>#10652 - Lupin - Thu Sep 11, 2003 5:14 pm</h4>
    <div class="postbody"><span class="postbody">How could I work with 64 bit numbers? I don't understand how they work, why do I need an orr after multiplication for example? Some explanation about the system would be great :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10657 - sajiimori - Thu Sep 11, 2003 5:59 pm</h4>
    <div class="postbody"><span class="postbody">Since the ARM7 is 32 bit, 64 bit values have to be simulated.  A simple way of doing that would be to stick two 32 bit values together.  Perhaps you'd make a structure such as this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef struct
<br/>
{
<br/>
   u32 hi;
<br/>
   u32 lo;
<br/>
} int64;
<br/>
</td> </tr></table><span class="postbody">
<br/>
Then, since you couldn't use the stock C operators (+ - * / etc) on int64's, you would probably want to implement those operations yourself.
<br/>
<br/>
But what if you implemented addition this way:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int64 add64(int64 left, int64 right)
<br/>
{
<br/>
   int64 tmp;
<br/>
   tmp.lo = left.lo + right.lo;
<br/>
   tmp.hi = left.hi + right.hi;
<br/>
   return tmp;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
That is clearly not correct.  The addition of the low parts could have easily overflowed, requiring a carry to the high part (just like doing math by hand).
<br/>
<br/>
You could figure out the correct math for each operator on your own (good if you want to know how the math works), or find some code and copy it.
<br/>
<br/>
Some more info on the underlying mechanisms of binary math:
<br/>
<a href="http://computer.howstuffworks.com/boolean.htm" target="_blank">http://computer.howstuffworks.com/boolean.htm</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10659 - tepples - Thu Sep 11, 2003 6:03 pm</h4>
    <div class="postbody"><span class="postbody">GNU C has a built-in 64-bit integer type: <span style="font-weight: bold">long long</span>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10661 - DekuTree64 - Thu Sep 11, 2003 6:45 pm</h4>
    <div class="postbody"><span class="postbody">Generally you only need 64-bit numbers for multiplication/division with 16-bit fixed point. The orr is to combine part of the lower 32 bits with part of the upper 32. So say you multiply 0x20000 by 0x30000 (2 &lt;&lt; 16 * 3 &lt;&lt; 16), you get 0x600000000, which overflows 32 bits. What you want is 6 &lt;&lt; 16, so you want to shift the whole 64-bit number to the right 16 bits, but since you have to do it one reg at a time, you shift the lower 16 bits off of the first register (in this example those 8 0's after the 6 would be the lower register, and the 6 is the upper reg), and then shift the uppwer register LEFT 16, so it fills the empty 16 bits from the top of the lower reg, and orr them together. Since GBA's BIOS div is only 32 bit, I usually just shift the denominator right 8 spaces, divide, and shift the result left 8. Basically an 8-bit fp division. I know you can do a 32x32=64-bit multiply by splitting it up in to a bunch of 16x16=32 ones and shift/add them together, so you might be able to split up a divide to get full precision too. Not sure.
<br/>
And adding is dead easy, just adds the lower halves, and adc the uppers.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10665 - torne - Thu Sep 11, 2003 8:06 pm</h4>
    <div class="postbody"><span class="postbody">If you want a full 64x64=64 multiply, it's just cross-multiplication. GCC generates the code given below with r0=op1 low, r1=op1 high, r2=op2 low, r3=op2 high, r4=result low, r5=result high:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">umull r4, r5, r0, r2
<br/>
mla r5, r0, r3, r5
<br/>
mla r5, r1, r2, r5</td> </tr></table><span class="postbody">
<br/>
<br/>
This works for signed or unsigned arithmetic and no shifts are needed as you can just stick the high results directly into the top word of the output. You can't do division by a similar method as far as I know; division is pretty crappy and unpleasant at the best of times let alone when you're operating above your word size.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10671 - sajiimori - Fri Sep 12, 2003 12:33 am</h4>
    <div class="postbody"><span class="postbody">Yeah, I probably should have mentioned that GCC will automatically generate 64 bit math for you, but it sounded like Lupin wanted to do the stuff by hand. ;-)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10681 - torne - Fri Sep 12, 2003 11:01 am</h4>
    <div class="postbody"><span class="postbody">That's why I gave the asm code. =)
<br/>
<br/>
gcc -S is very helpful (though I had to use -O to get it to generate mla instructions instead of a seperate mul and add).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10687 - Lupin - Fri Sep 12, 2003 4:54 pm</h4>
    <div class="postbody"><span class="postbody">hm, i'm still confused... so, how does the code for an 32x32=32 multiply look like? I know, you'll say that has nothing to do with 64 bit numbers, but the problem is that when i multiply my both 32bit numbers the result won't fit in 32bit, but I want 32 bit output -&gt; so I have to shift down 32 bits in order to get an 32 bit output.
<br/>
<br/>
I'm feeling like I'm asking an dumb question now :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10688 - torne - Fri Sep 12, 2003 5:01 pm</h4>
    <div class="postbody"><span class="postbody">A 32x32=32 multiply is just mul r0, r1, r2. If the resulting number is more than 32 bits it will overflow, yes, but that's unavoidable; if you want a 32-bit output, you simply can't multiply two numbers whose product is more than 2^32. The alternative is to use a 32x32=64 multiply: the umull or smull instructions.
<br/>
<br/>
I may have misunderstood your question..</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10689 - Lupin - Fri Sep 12, 2003 6:30 pm</h4>
    <div class="postbody"><span class="postbody">I want to do 32x32=64&gt;&gt;32 this is because for my reciprocal table (hmm, this is like my 100th try to create an good working reciprocal lut...lol :()</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10690 - torne - Fri Sep 12, 2003 6:35 pm</h4>
    <div class="postbody"><span class="postbody">Ah. That's just a 32x32=64 multiply, followed by a shift. The multiply is done by umull or smull (unsigned and signed respectively), then just shift it normally.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10696 - DekuTree64 - Fri Sep 12, 2003 9:01 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, just think of it as regular decimal multiplication on paper. If you multiply a number with 2 digits after the decimal point by a number with 3 digits after the point, you get a number with 5 digits after the point. Same with fixed-point math, so if you use a 32 bit RCP table, and 16 bit numbers, then you multiply and get 48 fractional bits. You want to get back to 16, so shift 32 of those off. But since shifting by 32, you'd just shift off the entire low reg, and then orr on the hi reg without shifting at all, it's easier to just use a 
<br/>
umull r2, r0, r1, r0
<br/>
Assuming you put that in a function so r0 and r1 are the args, r2 is free, and r0 is the return. 
<br/>
<br/>
But actually a 32 bit RCP table will make dividing by 1 a problem, since 1 &lt;&lt; 32 doesn't fit in a register. You could probably get away with just setting it to 0xffffffff instead though.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10698 - Lupin - Fri Sep 12, 2003 11:37 pm</h4>
    <div class="postbody"><span class="postbody">hm, how could I shift the whole 64 bit number right by lets say 16 bits?
<br/>
<br/>
Thx for all your answers!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10700 - col - Sat Sep 13, 2003 12:13 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lupin wrote:</b></span></td> </tr> <tr> <td class="quote">hm, how could I shift the whole 64 bit number right by lets say 16 bits?
<br/>
<br/>
Thx for all your answers!</td> </tr></table><span class="postbody">
<br/>
<br/>
warning - untested code follows :)
<br/>
<br/>
r0 is input low
<br/>
r1 is input high
<br/>
<br/>
mov r2, r1, lsl#16    
<br/>
add r0, r2, r0, lsr#16
<br/>
mov r1, r1, asr#16
<br/>
<br/>
r0 is output low
<br/>
r1 is output high
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10725 - Roidy - Sat Sep 13, 2003 1:02 pm</h4>
    <div class="postbody"><span class="postbody">I`m trying to use the 64 bit type long long but am having problems with the following calculations:-
<br/>
<br/>
c=((65536*65536)+(65536*65536))
<br/>
print c/65536.0   =  0.0      WRONG!!!
<br/>
<br/>
c=4294967296+4294967296
<br/>
print c/65536.0   =  131072.0    CORRECT
<br/>
<br/>
Both of these equations should give the same result all i`ve done in the second equation is worked the multiplication out in advance. All of these values should fit into 64bits.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10727 - Burton Radons - Sat Sep 13, 2003 2:23 pm</h4>
    <div class="postbody"><span class="postbody">The difference is that 65536 is interpreted as an int, while 4294967296, because it doesn't fit in an int, is interpreted as a long long.  So the first multiplication is between int with an int result, while the second is between long long with a long long result.  You can cause a 64-bit operation by casting one of the values to long long or appending LL to the number, as with "65536LL".</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10732 - Roidy - Sat Sep 13, 2003 3:41 pm</h4>
    <div class="postbody"><span class="postbody">Ok now I see, thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10838 - funkeejeffou - Wed Sep 17, 2003 7:07 pm</h4>
    <div class="postbody"><span class="postbody">By the way, the max value for an unsigned :
<br/>
- 16unsigned bit int is :65535
<br/>
- 32unsigned bit int is : 4294967295
<br/>
<br/>
I don't understand how your second test can work cause I tryed it in ASM, and loading a value superior to (2^32 - 1) in a register puts in it all zeros. So the second result should be zero...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10843 - torne - Wed Sep 17, 2003 8:32 pm</h4>
    <div class="postbody"><span class="postbody">GCC automatically detects that 2^32 is too large to fit, and uses 64-bit arithmatic.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
