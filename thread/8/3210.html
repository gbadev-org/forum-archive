<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Interrupt routine question - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Interrupt routine question</h2>
<div id="posts">
<div class="post">
    <h4>#19026 - poslundc - Sat Apr 10, 2004 1:16 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gbawiz wrote:</b></span></td> </tr> <tr> <td class="quote">Hello all, 
<br/>
 I have a question with regards to ISR interrupt routines. 
<br/>
 In my app, I am using two timers, each with the ability to call the interrupt routine. 
<br/>
 timer 1 deals with the general game timers such as the animation frame rate, counting, etc.. and the other deals with the audio. 
<br/>
<br/>
 The question I have is: what happens when the ISR is currently servcing the interrupt from timer 1 and then timer 2 generates and interrupt? 
<br/>
<br/>
 Is timer2 ignored? 
<br/>
 or does the CPU wait till it finishes timer1 servicing then move onto 2 
<br/>
 or does the interrupt for timer 1 get interrupted by timer 2 with timer 2 being serviced? 
<br/>
<br/>
 Thanks 
<br/>
 GbaWIZ</td> </tr></table><span class="postbody">
<br/>
<br/>
This depends on your interrupt handler.
<br/>
<br/>
If you use the one that comes with DKA, you can select in crt0.S whether you want to enable multiple interrupt support or not.
<br/>
<br/>
If you write your own ISR, by default a new interrupt can be triggered while your current interrupt is still running, so you should code your ISR to be able to handle it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19030 - gbawiz - Sat Apr 10, 2004 1:41 pm</h4>
    <div class="postbody"><span class="postbody">Thanks,
<br/>
Well, im using my own ISR routine.
<br/>
Basically what im attempting is to include an audio mixer engine which I created (nothing exciting), which makes use of the timer which indicates that the 2k mixing buffer needs refilling by counting the samples played.
<br/>
The ISR performs the refilling.
<br/>
So what you are saying is that each of the routines within the ISR can interrupt each other?
<br/>
The app starts ok, a bit slower than usual, but then itseems to stall after a while. The stalling point is never the same when the app is run.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19031 - poslundc - Sat Apr 10, 2004 1:45 pm</h4>
    <div class="postbody"><span class="postbody">Make sure you are properly setting the correct interrupt-acknowledge bits  when you complete your ISR. This is the kind of thing that can start making a system behave oddly when you support multiple interrupts.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19032 - gbawiz - Sat Apr 10, 2004 1:51 pm</h4>
    <div class="postbody"><span class="postbody">I think this might have something to do with it:
<br/>
<br/>
------ within my ISR----------------
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if(REG_IF==INT_TIMER1){
<br/>
    REG_IF=(REG_IF|INT_TIMER1); 
<br/>
    //do stuff related to timer 1
<br/>
}
<br/>
<br/>
if(REG_IF==INT_TIMER2){
<br/>
    REG_IF=(REG_IF|INT_TIMER2);
<br/>
    //do stuff related to timer 2
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19064 - tepples - Sat Apr 10, 2004 9:08 pm</h4>
    <div class="postbody"><span class="postbody">And what if REG_IF has more than one bit set at once?
<br/>
<br/>
The right way is to read the interrupts once as a bitfield and then test each bit:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void isr(void)
<br/>
{
<br/>
  int interrupts = REG_IF;
<br/>
<br/>
  if(interrupts &amp; INT_TIMER1)
<br/>
  {
<br/>
    /* whatever */
<br/>
  }
<br/>
  if(interrupts &amp; INT_TIMER2)
<br/>
  {
<br/>
    /* whatever */
<br/>
  }
<br/>
<br/>
  BIOS_IF |= interrupts;  /* important: |= (or equals) not = */
<br/>
  REG_IF = interrupts;  /* important: |= (or equals) not = */
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19066 - poslundc - Sat Apr 10, 2004 9:10 pm</h4>
    <div class="postbody"><span class="postbody">Why are you OR-ing with REG_IF before assigning the new value to it? You only need to acknowledge the current interrupt being serviced.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19068 - tepples - Sat Apr 10, 2004 9:16 pm</h4>
    <div class="postbody"><span class="postbody">If two interrupts happen at once (two bits set in REG_IF), and I've serviced them both, then I need to acknowledge them both.
<br/>
<br/>
If you refer to the line that modifies BIOS_IF, that's necessary to get BIOS IntrWait() to work. IntrWait() checks *(volatile unsigned short int)0x03fffff8 (which may or may not be called BIOS_IF in your GBA header file) to see which interrupts happened. If IntrWait() does not work, then the program wastes current by spinning rather than halting.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19075 - poslundc - Sat Apr 10, 2004 10:39 pm</h4>
    <div class="postbody"><span class="postbody">Sorry tepples, my post was in response to gbawiz's post, not yours. For some reason yours didn't show up between his and mine, even after I posted it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19142 - gbawiz - Sun Apr 11, 2004 11:27 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Tepples for the useful info, it seems to have worked as the app is no longer stalling and sound seems to be playing as required (although the app seems to have slowed down).
<br/>
<br/>
One thing about the interrupt triggers,
<br/>
timers 1 and 2  can cause interrupts and they are serviced in this order.
<br/>
What happens if timer2 causes interrupt while processing interrupt 1?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Poslundc:
<br/>
If you write your own ISR, by default a new interrupt can be triggered while your current interrupt is still running, so you should code your ISR to be able to handle it. 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
my interrupts cannot be interrupted otherwize this causes major problems.
<br/>
Do I have to disable other possible interrupts while processing the current one?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19143 - poslundc - Sun Apr 11, 2004 11:41 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gbawiz wrote:</b></span></td> </tr> <tr> <td class="quote">my interrupts cannot be interrupted otherwize this causes major problems.
<br/>
Do I have to disable other possible interrupts while processing the current one?</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, you do, if it'll cause a problem like you say.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19145 - Gopher - Sun Apr 11, 2004 11:58 pm</h4>
    <div class="postbody"><span class="postbody">Random question, when you disable interrupts, do their flags still get set in REG_IF?<br/>_________________<br/>"Only two things are infinite: the universe, and human stupidity. The first is debatable." -Albert Einstein</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19149 - torne - Mon Apr 12, 2004 2:18 am</h4>
    <div class="postbody"><span class="postbody">It depends where you disable them. If you disable them in the CPU's status register, then yes, they are recorded; they just don't interrupt your program. If you disable them in the source place (e.g. disable VBLANK interrupts in the REG_DISPCNT) then no, they won't happen at all. If you disable them in REG_IE, I don't actually know. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19151 - poslundc - Mon Apr 12, 2004 3:13 am</h4>
    <div class="postbody"><span class="postbody">Someone once claimed that REG_IE acts as a mask, so that interrupts enabled in their control registers won't trigger, but will essentially queue up until their mask bit is set (or I suppose until interrupts are disabled). This would provide an effective method for temporarily disabling interrupts (eg. in time-critical code such as an HBlank ISR) without "missing" interrupts (eg. if you have a sound-mixer running).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19157 - torne - Mon Apr 12, 2004 1:32 pm</h4>
    <div class="postbody"><span class="postbody">You can already do that just by disabling the I bit in the CPU status register; no interrupts will fire, but all will be collected normally, and will deliver when you set the I bit back on. The only reason you'd need to use REG_IE is if you wanted to turn off some and not others (and I still don't know if that works; perhaps someone should try it *grin*).</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
