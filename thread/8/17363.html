<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>"reverse" memcpy32() - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > "reverse" memcpy32()</h2>
<div id="posts">
<div class="post">
    <h4>#174987 - Kensai - Fri Aug 13, 2010 8:27 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I'm looking for a "reverse" version of memcpy32(), which could be used to flip an image horizontally.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174988 - Dwedit - Fri Aug 13, 2010 9:14 pm</h4>
    <div class="postbody"><span class="postbody">That wouldn't flip an image though, since pixels are 16-bit, not 32-bit.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174989 - Kensai - Fri Aug 13, 2010 9:23 pm</h4>
    <div class="postbody"><span class="postbody">Yes, the function would have to flip the 4 bytes (I need it for mode 4).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174990 - Dwedit - Fri Aug 13, 2010 9:55 pm</h4>
    <div class="postbody"><span class="postbody">Just use DMA, with Source and Destination address going in reverse directions.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174991 - Kensai - Fri Aug 13, 2010 11:13 pm</h4>
    <div class="postbody"><span class="postbody">Thank you for the advice. But how do I flip the bytes? You can't set "Chunk Size" to 8 bit. The only option is DMA_16 and it only flips the halfwords:
<br/>
<br/>
[1][2][3][4] -&gt; [3][4][1][2]
<br/>
<br/>
What I need is: 
<br/>
<br/>
[1][2][3][4] -&gt; [4][3][2][1]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174992 - Dwedit - Sat Aug 14, 2010 1:13 am</h4>
    <div class="postbody"><span class="postbody">Sorry, forgot that was an 8-bit mode, thought you were using 16 bit pixels...
<br/>
<br/>
Off the top of my head, untested, check it for bugs...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void copybackwards(u16 *src, u16* dest, int size) //size is in halfwords
<br/>
{
<br/>
   src += size-1;
<br/>
   while (size &gt; 0)
<br/>
   {
<br/>
      int a = *src--;
<br/>
      a = (a &gt;&gt; 8) | ((a &amp; 0xFF)&lt;&lt;8);
<br/>
      *dest++ = a;
<br/>
      size--;
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
post edited, forgot a left shift<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174998 - Kensai - Sat Aug 14, 2010 5:59 pm</h4>
    <div class="postbody"><span class="postbody">Thank you. Do you think the code can be made faster using ASM?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#174999 - Dwedit - Sat Aug 14, 2010 9:13 pm</h4>
    <div class="postbody"><span class="postbody">There's the 32-bit algorithm to swap bytes within a word:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
M1 = 00FF00FF
<br/>
M2 = 0000FFFF
<br/>
<br/>
A = src[xxxx]
<br/>
<br/>
B = M1 &amp; (A &gt;&gt; 8) //00FF00FF
<br/>
C = A &amp; M1
<br/>
A = B | (C &lt;&lt; 8)
<br/>
B = M2 &amp; (A &gt;&gt; 16) //0000FFFF
<br/>
C = (A &amp; M2)
<br/>
A = B | (C &lt;&lt; 16)
<br/>
<br/>
dest[xxxx] = A
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And the 16 bit algorithm:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
A = src[xxxx]
<br/>
B = (A &lt;&lt; 8)
<br/>
A = (A &gt;&gt; 8) | B
<br/>
dest[xxxx] = A
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Let's assume source is the cartridge and dest is VRAM, and this is a GBA.
<br/>
<br/>
32 bit takes 20 cycles to copy and swap 4 bytes. (4 more when you make it loop)
<br/>
16 bit takes 11 cycles to copy and swap 2 bytes. (4 more when you make it loop)
<br/>
<br/>
Note, I never did get the hang of timing ARM instructions correctly, with the waitstates and all that, might be mistakes in the timing.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175009 - Ruben - Sun Aug 15, 2010 12:37 pm</h4>
    <div class="postbody"><span class="postbody">Building on Dwedit's post...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ Reverse memcpy.
<br/>
@ Stores 16-bits
<br/>
@ not very optimized, but
<br/>
@ gets the job done AFAIK.
<br/>
@ Cost is roughly 3 + 8x
<br/>
@ where x is the number of
<br/>
@ bytes to be copied.
<br/>
@ ---
<br/>
@ r0: dst
<br/>
@ r1: src
<br/>
@ r2: cnt [in bytes]
<br/>
<br/>
memcpyr16:
<br/>
    subs   r2, #2             @  1 ( 1)
<br/>
    ldrcsh r3, [r1, r2]       @ ~6 ( 7)
<br/>
    movcs  ip, r3, lsr #8     @  1 ( 8)
<br/>
    orrcs  r3, ip, r3, lsl #8 @  1 ( 9)
<br/>
    strcsh r3, [r0], #2       @ ~4 (13)
<br/>
    bne    memcpyr16          @  3 (16)
<br/>
    bx     lr                 @  3 (19)</td> </tr></table><span class="postbody">
<br/>
<br/>
EDIT: Fixed formatting and added timing + typo</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175020 - Miked0801 - Mon Aug 16, 2010 9:37 pm</h4>
    <div class="postbody"><span class="postbody">Any chance this image is a sprite and you could use the X-Flip bit?  Or perhaps a tile based BG in which you could also use the same bit?  If it's a 3D layer or something that allows scaling, you could negative X scale to get this effect as well.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175027 - Cearn - Wed Aug 18, 2010 8:36 pm</h4>
    <div class="postbody"><span class="postbody">32bit-based version using some ROR &lt;3.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*!
<br/>
    @function void memrcpy32(const void *src, void *dst, uint size);
<br/>
    Byte-reverse copies \a size/4 words from \a src to \a dst.
<br/>
    @param  src     Source pointer.
<br/>
    @param  dst     Destination pointer. Points to the START of the buffer.
<br/>
    @param  size    number of bytes to copy.
<br/>
    @note   Kinda expects word-alignment for everything (for now).
<br/>
*/
<br/>
    .section .iwram, "ax", %progbits
<br/>
    .arm
<br/>
    .align
<br/>
    .global memrcpy32
<br/>
memrcpy32:
<br/>
    bics    r2, r2, #3              @ word-align size,
<br/>
    bxeq    lr                      @ and perhaps quick escape.
<br/>
    stmfd   sp!, {r4}
<br/>
    
<br/>
    add     r1, r1, r2              @ point dst to its (not it's) tail.
<br/>
    ldr     ip,=0x00FF00FF
<br/>
.LrcpyLoop:
<br/>
        ldmia   r0!, {r3}               @ r3: abcd  ; r3= *src++;
<br/>
        and     r4, ip, r3, ror #16     @ r4: 0d0b
<br/>
        and     r3, ip, r3, ror #24     @ r3: 0c0a
<br/>
        orr     r3, r3, r4, lsl #8      @ r3: dcba
<br/>
        stmdb   r1!, {r3}               @           ; *--dst= r3;
<br/>
        subs    r2, r2, #4
<br/>
        bne     .LrcpyLoop
<br/>
<br/>
    ldmfd   sp!, {r4}
<br/>
    bx      lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
Of course, this only works if everything is word aligned. If not, you'll have to account for the misalignments, as well as deal with the head and tail ending in the middle of a word.
<br/>
<br/>
If possible, use sprites for image flipping.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175030 - Ruben - Thu Aug 19, 2010 9:10 am</h4>
    <div class="postbody"><span class="postbody">Can't you avoid the "add r1, r1, r2" by instead chaging the loop to...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.LrcpyLoop:
<br/>
        subs    r2, r2, #4
<br/>
        ldrcs   r3, [r0, r2]            @ r3: abcd ; r3= src[end--]
<br/>
        andcs   r4, ip, r3, ror #16     @ r4: 0d0b
<br/>
        andcs   r3, ip, r3, ror #24     @ r3: 0c0a
<br/>
        orrcs   r3, r3, r4, lsl #8      @ r3: dcba
<br/>
        stmcsia r1!, {r3}               @          ; *dst++ = r3;
<br/>
        bhi    .LrcpyLoop</td> </tr></table><span class="postbody">Or does that screw up the sequential access timing?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
