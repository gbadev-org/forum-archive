<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>What to look for in well optimized ARM code - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>ASM > What to look for in well optimized ARM code</h2>
<div id="posts">
<div class="post">
    <h4>#17323 - Miked0801 - Sat Mar 06, 2004 10:05 am</h4>
    <div class="postbody"><span class="postbody">While writing that pixel plotter, I was remembering all the things that help me to determine if my code is doing all that it can.  Here are a few of the guidelines that kept popping up in my head.  Keep in mind that these are for use after your algorithm is deemed good (which the below may not be as I'm still coding this blind).  My first attempt didn't work so it doesn't matter how fast it was :P
<br/>
I'll repost the code here to make it easy for reference:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
PlotPixel: 
<br/>
   add   r3,r1,r1,#lsl 8      @ Get x240 by 256 - 16 
<br/>
   sub   r3,r3,r1,#lsr 4      @ ... 
<br/>
   movs  r0,r0,#0,#lsr 1      @ x/2 + address and use carry for low/high 
<br/>
   add   r3,r3,r0             @ Add x to address 
<br/>
   rsc   r0,r0,#1             @ Use reverse subtract carry to reverse the carry for address read.  
<br/>
   ldrb  r0,[r3,r0]           @ Read the byte (r0 is 0 or 1 for offset) 
<br/>
   orrcs r0,r0,r2,#lsl 8      @ if Carry, move color value high 
<br/>
   orrcc r0,r2,r0,#lsl 8      @ if not, color low, video value high 
<br/>
   strh  r0,[r3]              @ store the result with base address only. 
<br/>
    
<br/>
   bx    r14                  @ return 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
1. How many instructions are using the built in shifter?  
<br/>
In the above, only 2 non load instructions are without shifting which tells me there are working hard.
<br/>
<br/>
2. How many branches are in the code?
<br/>
In good ARM, you don't need to branch hardly at all.  In the above, the 2 orr use conditional compiling to save time.
<br/>
<br/>
3. Are you using the mov instruction?
<br/>
Mov is a very lazy opcode.  All the other arithmetic opcodes have mov's functionality built in.  That's one reason I believe the above has at least 1 more cycle to be had in the removal of the mov.  It's only saving grace is that it is shifting and setting a flag at the same time.
<br/>
<br/>
4. Are you minimizing Memory accesses?
<br/>
The above reads once and writes once.  Hard to be that :)
<br/>
<br/>
5. Are you using 8-bit constants or shiftable 8-bit constants?
<br/>
If not, you need an expensive load or funky shifting to get your values.  The above only uses 0 and 1.
<br/>
<br/>
6. Please tell me you are avoiding globals?
<br/>
Globals cost thrice - once for loading the address, once for loading the value, and 4 bytes of ROM for address storage you need to avoid.
<br/>
<br/>
7. Are you commenting your code so that you'll be able to read it tomorrow?
<br/>
The above is barely commented enough.  The section on the byte address stuff isn't very clear.
<br/>
<br/>
8. Are you avoiding pushes/pops?
<br/>
While it's nice to use all the ARM registers, it takes time to push/pop when calling from C code.  If you can, use only the safe registers.  The above only uses r0-r3 (with r1 and r2 never changed)
<br/>
<br/>
Others who are experienced with ARM optimization, please chime in!  I'm interested in comparing notes and seeing how many things I'm missing.
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17330 - poslundc - Sat Mar 06, 2004 2:28 pm</h4>
    <div class="postbody"><span class="postbody">Optimizations aside, just glancing at your code there are a couple of things I don't understand... either errors or things that are different on the Nintendo assembler from GAS, I guess...
<br/>
<br/>
1. Prefixing the barrel-shift operation with a number-sign, and then not prefixing your constants. I don't think this works in GAS.
<br/>
<br/>
2. movs r0, r0, #0, #lsr 1 - this would definitely come up as having too many operands in GAS.
<br/>
<br/>
Anyway, as far as optimizations go, you've covered most of the bases... I'd also mention unrolling loops wherever it's practical to do so, using the block-load/store instructions wherever possible, and effective use of the flag-set option to reduce the need for the comparison commands.
<br/>
<br/>
I also like to see code that uses "logical" condition mnemonics (since many of them overlap in functionality) that match the documentation/comments. eg. if I am comparing two variables against each other, I like to use gt/ge/lt/le, as if I were using the equivalent C comparison operators.
<br/>
<br/>
I also like to see comments that describe the purpose of the code instead of just repeating what the code does. For example, from your code "Add x to address" is far more descriptive than "Add r0 to r3". At the same time documenting register use is often useful, so I might have commented it "r3 &lt;- address + x". Consistent notation in comments is also important.
<br/>
<br/>
That's all I've got at the moment.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17377 - DekuTree64 - Sun Mar 07, 2004 1:39 am</h4>
    <div class="postbody"><span class="postbody">For what it's worth, here's one in 9 instructions. Didn't test it on hardware, so I can't say for sure wether VRAM cares about the lower bit for storing, but it works fine in VBA.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">PlotPixel:
<br/>
   tst   r0, #1               @check odd/even pixel
<br/>
   rsb   r1, r1, r1, LSL #4
<br/>
   add   r1, r0, r1, LSL #4   @r1=x+(y*16-y)*16, or x+y*240
<br/>
   eor   r1, r1, #1            @if setting odd, load even, else load odd
<br/>
   ldrb   r0, [r3, r1]
<br/>
   orreq   r0, r2, r0, LSL #8   @if even, put old in top
<br/>
   orrne   r0, r0, r2, LSL #8   @if odd, put new in top
<br/>
   strh   r0, [r3, r1]         @store, lower bit doesn't matter
<br/>
   bx      lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
As for optimization notes, one of my favorites, which is good for sound mixers, is using a single multiply to do 2 values, either by putting one sample in the bottom and another in the top 16 bits, and multiplying by volume, or for stereo, left volume in bottom and right volume in top, and multiplying a single sample by that. 
<br/>
Also, carefully ordering your globals in a struct so you can ldmia bunches of related ones at a time is a nice trick.
<br/>
<br/>
Another one I came up with for an S-buffer 3D engine I was scheming on a while back is using unrolled loops to render pixels to registers and stmia them, and when you need to break and load a new span, bl to the span loader so you can just bx lr back to where you were in the loop. Basically a regular function call, but with both functions knowing what the other is doing. That's another nice one, if you have a normal function that gets called a lot from a specific function, but is a little big to inline, you can just write a specific version for that caller so it knows exactly which regs are available and such.
<br/>
And a nifty one to get around storing both a texture's size and bitmask for looping in each span is storing the size as its power of two, like 3 for an 8x8, 6 for 64x64, etc.. Then to generate the texture mask, all you have to do is set a register to 1 and do like rsb reg, 1, 1&lt;&lt;sizeShift
<br/>
<br/>
Can't think of many general optimizations aside from the ones already mentioned, but there's plenty of task-specific tricks out there.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17397 - Miked0801 - Sun Mar 07, 2004 9:24 am</h4>
    <div class="postbody"><span class="postbody">My experience and my ARM documentation say that writing an odd address with strh[] is undefined.  Unless you are sure this works on hardware, I'd be very wary of that.  That's what I'm having so much trouble with: put low bit in flags, reverse it, and clear it before strh.  Losts of stuff to do before that last store.  Still, this way is much more efficient than anding off a ldrh call :)
<br/>
<br/>
One more thing for the optimization list:
<br/>
<br/>
9. Like mov; cmp, tst, cmn, and any other test only opcodes are also very lazy.  Though not quite as bad as mov, they can almost always be replaced by arithmetic routines setting flags while playing with data.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17403 - torne - Sun Mar 07, 2004 1:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">My experience and my ARM documentation say that writing an odd address with strh[] is undefined.  Unless you are sure this works on hardware, I'd be very wary of that.</td> </tr></table><span class="postbody">
<br/>
<br/>
It says undefined in the ARM ARM, but it's actually defined by the memory controller. The GBA's mem controller ignores the appropriate low bits on word and halfword writes (as it's the simplest thing you can do), so it will work perfectly. =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17418 - DekuTree64 - Sun Mar 07, 2004 6:29 pm</h4>
    <div class="postbody"><span class="postbody">Tested it on HW and it works fine. 
<br/>
Although I glanced past Flubba's post in the other thread earlier that day and got the idea for the rsb, but I didn't get a chance to read his whole function, and it turned out to do almost exactly the same thing. Guess that means it really is about as good as it gets. Still, the explicit tst seems like it could be squeezed into an arithmetic instruction somewhere.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17424 - Miked0801 - Sun Mar 07, 2004 8:52 pm</h4>
    <div class="postbody"><span class="postbody">Agreed with some more use of unique indexing.  I'll let the sit in the back of my head today and see if we can't get another cycle out of it (I think we can.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17485 - FluBBa - Tue Mar 09, 2004 11:11 am</h4>
    <div class="postbody"><span class="postbody">Using the barrel shifter adds one internal cycle when used on normal logical ops (add, mov, orr etc) but I don't think it matters when used together with mem access (ldr &amp; str).
<br/>
I'm not sure how the writeback works though.
<br/>
Can you make a speed test on the two different implemntations?<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17494 - poslundc - Tue Mar 09, 2004 4:18 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>FluBBa wrote:</b></span></td> </tr> <tr> <td class="quote">Using the barrel shifter adds one internal cycle when used on normal logical ops (add, mov, orr etc)</td> </tr></table><span class="postbody">
<br/>
<br/>
Only if you are shifting by a register (ie. variable) amount. If you are shifting by a constant, it does not add any additional cycles.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18480 - ecurtz - Sat Mar 27, 2004 9:30 am</h4>
    <div class="postbody"><span class="postbody">WARNING: I haven't written a line of production ARM ASM in my life. (In fact I just started reading this thread for inspiration on learning.)
<br/>
<br/>
r3 is the base for the buffer (or I'm hopelessly confused) - would that normally be initialized from an immediate value or from a memory copy? If it's from memory can we set initialize it to (base | 0x0001) and do this modified version of Deku's code?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">PlotPixel:
<br/>
   tst   r0, #1            @check odd/even pixel
<br/>
   rsb   r1, r1, r1, LSL #4   @r1=y*15
<br/>
   eor   r3, r3, r1            @r3=r3^x, (base + (x^1))
<br/>
   ldrb   r0, [r3, r1, LSL #4]      @load from r3 + r1*16, (r3 + (y*240))
<br/>
   orreq   r0, r2, r0, LSL #8   @if even, put old in top
<br/>
   orrne   r0, r0, r2, LSL #8   @if odd, put new in top
<br/>
   strh   r0, [r3, r1,  LSL #4]   @store, lower bit doesn't matter
<br/>
   bx      lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
&lt;&lt;EDIT: As you all probably know this doesn't work because I didn't realize that strh uses a different addressing mode. I'm leaving it up in case the eor idea inspires somebody, but I'll go back to the nice, safe C board now...&gt;&gt;&gt;
<br/>
<br/>
- eli</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
