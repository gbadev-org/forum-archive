<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>The "peter-t" FDIVS problem, and ASM ArcTan2 quest - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > The "peter-t" FDIVS problem, and ASM ArcTan2 quest</h2>
<div id="posts">
<div class="post">
    <h4>#24234 - DiscoStew - Fri Jul 30, 2004 7:22 am</h4>
    <div class="postbody"><span class="postbody">WOW!
<br/>
This will be my first post in the assembly thread, and I hope to come back here many times as I will have an assembly class in college this coming semester. 
<br/>
<br/>
Anyways, I've used the "Peter-Teichmann" unsigned divide algorithm in my projects, and it has worked really well for me. However, I did this through inline assembly.
<br/>
<br/>
Now I am trying to stray from using inline assembly as much as possible with using external pure asembly code and linking that into my c code. I does work, but now I am trying to add the signed divide function, and it isn't working. In VBA, it brings up "Unsupported ARM mode 00." I used the exact code that was supplied, which I'll show here with my own name for the function...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@Asm_SDivide(s32 dividend, s32 divisor)
<br/>
Asm_SDivide:
<br/>
      ands r3,r1,#0x80000000
<br/>
      rsbmi r1,r1,#0
<br/>
      eor r3,r3,r0,asr#1
<br/>
      cmp r0,#0
<br/>
      rsbmi r0,r0,#0
<br/>
      mov r12,r14
<br/>
      bl Asm_Divide  
<br/>
      tst r3,#0x80000000
<br/>
      rsbne r0,r0,#0
<br/>
      tst r3,#0x40000000
<br/>
      rsbne r1,r1,#0
<br/>
      movs pc,r12</td> </tr></table><span class="postbody">
<br/>
Now, being that this function uses the unsigned divide, I'm not sure which function has the error. The code is just like on his website, except for main label names and hexidecimal numbers (#0x80000000, not #&amp;800000000). Can anyone help me? thx
<br/>
<br/>
PS: Be aware that I practically know no assembly except for a few things here and there, enough to where I got FDIV working as inline assembly through copy, paste, and minor editing.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"><br/><br/>Last edited by DiscoStew on Fri Jul 30, 2004 9:03 pm; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#24237 - FluBBa - Fri Jul 30, 2004 9:02 am</h4>
    <div class="postbody"><span class="postbody">It would be nice to also see the "Asm_Divide" routine, if you happen to use r3 and/or r12 in that one.
<br/>
Is your function called from Thumb mode? if so you should probably use "bx r12" instead of "mov<span style="font-weight: bold">s</span> 12" when exiting.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24238 - wintermute - Fri Jul 30, 2004 9:04 am</h4>
    <div class="postbody"><span class="postbody">If you're calling the function from thumb code then you need an interworking variant of the return. Instead of "mov pc.lr" you need "bx lr" which returns the processor to the mode it was in when the call was made</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24251 - DiscoStew - Fri Jul 30, 2004 5:25 pm</h4>
    <div class="postbody"><span class="postbody">Yes, I was calling it from Thumb. I made the change to "bx lr", and the error window didn't appear. However, I wasn't getting any return value from the function. Then I thought that before branching into the AsmDivide function, I stored whatever data that was in r14 into r12 (return address? I'm still learning), so before "bx lr", I added "mov r14,r12" to move the stored data rom r12 back into r14, and now it is working. Even though it does work now, is that how I should have done it?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24253 - poslundc - Fri Jul 30, 2004 5:55 pm</h4>
    <div class="postbody"><span class="postbody">LR is short for Link Register, and is a synonym for r14 (which is the link register).
<br/>
<br/>
So yes, you need to restore the value of r14 if it has changed since the beginning of your subroutine.
<br/>
<br/>
In fact, if you plan on calling your routine from C, you need to preserve all of the registers except r0-r3 and r12.
<br/>
<br/>
Other registers you generally shouldn't ever touch are r13 (SP - stack pointer) and r15 (PC - program counter).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24260 - DiscoStew - Fri Jul 30, 2004 9:00 pm</h4>
    <div class="postbody"><span class="postbody">NOTE: the "quest" in "ArcTan2 quest" was meant to be "question"
<br/>
<br/>
Thanks for the info, but now I have another assembly problem that maybe someone could help me with. I found this ArcTan2 ASM function somewhere (most likely here in the forums due to a Divide BIOS call), but it doesn't work, or at least I don't know how to use it properly. Here it is...</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@Asm_ArcTan2(s32 y, s32 x)
<br/>
Asm_ArcTan2:
<br/>
      mov     r3, r1   @backup
<br/>
      cmp     r0, #0
<br/>
      blt     _xlt0
<br/>
      movs    r2,r1
<br/>
      rsbmi   r2,r2,#0  @abs(y/r1)
<br/>
      add     r1, r0, r2
<br/>
      mov     r1, r1, lsr #8
<br/>
      cmp     r1, #0
<br/>
      beq     _error
<br/>
      sub     r0, r0, r2
<br/>
      swi     0x60000
<br/>
      mov     r2, #1280
<br/>
      sub     r0,r2,r0
<br/>
      b       _xnlt0
<br/>
   _xlt0:
<br/>
      movs    r2,r1
<br/>
      rsbmi   r2,r2,#0  @abs(y/r1)
<br/>
      sub     r1, r2, r0
<br/>
      mov     r1, r1, lsr #8
<br/>
      cmp     r1, #0
<br/>
      beq     _error
<br/>
      add     r0, r0, r2
<br/>
      swi     0x60000    
<br/>
      mov     r2, #1792
<br/>
      sub     r0,r2,r0
<br/>
   _xnlt0:
<br/>
      movs    r3, r3
<br/>
      rsbmi   r0,r0,#0  @invert if y&lt;0
<br/>
      bx      lr
<br/>
   _error:
<br/>
      mov     r0,#0     @DIV BY 0 ERROR - what to do here?
<br/>
      bx      lr</td> </tr></table><span class="postbody">
<br/>
Does anyone know where this came from, or how it should work? Does it return Radians or Degrees? Are the parameters FIXED 24:8 or something else?
<br/>
I'd use the BIOS ArcTan2 function, except that must also use the Divide BIOS call, but since I'm using Peter-Teichmann's divide function, I planned to incorporate that into an ArcTan2 function, preferably this one. Any help would be appreciated. If this does work, is there a possibility that it could be edited so that instead of returning 0-359 degrees, it would return 0-511 degrees (512 degrees equaling 2π)? It would help to keep angles within limits by ANDing 0x01FF (511) to it. It is very simple with sin and cos because those are LUTs, but this isn't. thx for any help givin.
<br/>
<br/>
EDIT: I did find it here. Lupin posted it <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=3064" target="_blank">here</a>. Does it really work Lupin? If so, how do you use it, as I am not very knowedgeable in ASM at the moment to see how it works. Could it be easily converted to a range of 0-511 degrees?<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24262 - ecurtz - Sat Jul 31, 2004 12:48 am</h4>
    <div class="postbody"><span class="postbody">There is a much better atan2 function using cordic rotators posted in the forums here. You should implement that in assembly instead of trying to do one with divide (unless you need extreme precision.) My raycaster only uses 512 distinct angles for its tables and I was able to reduce the algorithm to 14 iterations and keep enough precision for my stuff. As a bonus you get the distance function nearly for free if you want it.
<br/>
<br/>
&lt;edit&gt; I'm not actually POSITIVE that the cordic rotator is faster, but it seems really likely - no divides. I'll post my "optimized" C version when I get home if anybody wants to compare it to BIOS or do an ASM version. &lt;/edit&gt;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24274 - DiscoStew - Sat Jul 31, 2004 8:36 am</h4>
    <div class="postbody"><span class="postbody">I searched the forums for cordic rotators, and I only found <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=656&amp;highlight=cordic" target="_blank">this</a> with a post by AnthC on cordic rotators. I went and copied that code into a Windows project to see if it worked, and the resulting number was some number far up in value. I even did a Google search and came up with this <a class="postlink" href="http://www.whisqu.se/per/docs/math11.htm" target="_blank">website</a> which looks like it could give me a result in Polar Coordinates (Distance and Theta), but the theta from Arctan2 at point (10,10) brought up 188743680. Am I doing something wrong? Either look at it on the website, or I can post it here.
<br/>
<br/>
If it wouldn't be too much trouble, I'd like to see your method. Both the 512 angles and free Distance is exactly what my program could really use, the 512 angles so that a simple "&amp;= 511" keeps the angles within limits, and my program get the Distance from the origin to point (X,Y) right after a call to the ArcTan2. I am currently using the BIOS call ArcTan2 to get an angle, but if your function is faster, I'd switch over in a second.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24282 - ecurtz - Sat Jul 31, 2004 3:30 pm</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://www.andraka.com/cordic.htm" target="_blank">Here</a> is the page with the paper I read. Not necessary unless you care how it works, but it does have implementations of other functions. I guess I lied about having the GBA version on this machine, but hopefully this Java/pseudo-code with comments should be good enough. Otherwise let me know and I'll get the GBA version up ASAP.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
/* this is what you set to determine your output range */
<br/>
/* currently is just 1 &lt;&lt; 26 for scaled radians, but could be */
<br/>
/* something like (256/PI) &lt;&lt; 16 to get a 16:16 fixed "angle" */
<br/>
/* with 512 "degrees" in a circle */
<br/>
static int atan2Scale = (1 &lt;&lt; 26);
<br/>
<br/>
static int atan2Table[];
<br/>
static {
<br/>
   /* adjust the size based on accuracy required */
<br/>
   /* only using _8_ steps in current test, not 18 */
<br/>
   /* this should be calculated on the computer and stored with tables */
<br/>
   atan2Table = new int[18];
<br/>
<br/>
   for (int i=0; i &lt; 18; i++) 
<br/>
   { 
<br/>
      double tmp = Math.pow(2.0,(double)-i); 
<br/>
      tmp = Math.atan(tmp); 
<br/>
      atan2Table[i] = (int)(tmp * (double)atan2Scale); 
<br/>
   } 
<br/>
}
<br/>
<br/>
static int atan2(int y,int x) 
<br/>
{ 
<br/>
   int tmp = 0;
<br/>
   int ang = 0; 
<br/>
   int shift = 0;
<br/>
<br/>
   /* 'normalise' for accuracy */ 
<br/>
   if (x &lt; 0) { 
<br/>
      x = -x; y = -y; 
<br/>
      ang = (int)(Math.PI * atan2Scale);  // obviously a pre-computed constant
<br/>
   } 
<br/>
<br/>
   tmp = x; 
<br/>
<br/>
   if ( y &lt; 0) { 
<br/>
      tmp |= -y; 
<br/>
   } 
<br/>
   else {
<br/>
      tmp|=y; 
<br/>
      ang=-ang;
<br/>
   }
<br/>
<br/>
   /* better to use a constant shift if you know your range */
<br/>
   while((tmp &amp; 0xFE000000) == 0) {
<br/>
      tmp &lt;&lt;= 1; shift++;
<br/>
   } 
<br/>
   x &lt;&lt;= shift;
<br/>
   y &lt;&lt;= shift;
<br/>
<br/>
   /* 8 steps seems ok for 512 separate "angles" */
<br/>
   for (int i = 0; i &lt; 8; i++) { 
<br/>
   if (y &lt; 0) { 
<br/>
      ang -= atan2Table[i]; 
<br/>
      tmp = x - (y&gt;&gt;i); 
<br/>
      y += (x&gt;&gt;i); 
<br/>
   } 
<br/>
   else { 
<br/>
      ang += atan2Table[i]; 
<br/>
      tmp = x + (y&gt;&gt;i); 
<br/>
      y -= (x&gt;&gt;i); 
<br/>
   }
<br/>
   x=tmp; 
<br/>
   } 
<br/>
<br/>
   /* distance is just x after the conversion, in whatever format x was in */
<br/>
   int distance = x &gt;&gt; shift;
<br/>
   
<br/>
   /* angle can be negative, so adjust if needed */
<br/>
   if (ang &lt; 0) {
<br/>
      ang += (int)(2.0 * Math.PI * atan2Scale); // obviously a pre-computed constant
<br/>
   }
<br/>
   
<br/>
   /* remember this is scaled by whatever you are using in your table */
<br/>
   return ang;
<br/>
}    
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Hope that helps, now I'm curious about how it compares.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24310 - DiscoStew - Sun Aug 01, 2004 6:45 am</h4>
    <div class="postbody"><span class="postbody">Well, I tried your ArcTan function in a Win32 console project just so that I could get it working. I must say that it is pretty good, but it doesn't seem to be very accurate, extremely bad with distance. I've set the atan2Scale equal to (256 / PI) &lt;&lt; 16 so that I could get 2PI = 512. When using point (0, -10), I got 377 which was surprisingly close, but when I tried (0, 10), I got 134, which was 6 degrees off. Increasing the steps helped, but only a little. Distance, however, was way off, at least in my tests. At point (0, 10), I got a result of 164, and point (-1000, 80) gave me 2720, not 1003. Ouch! Have you been getting the same results? Even when working with radians and 2PI = 360 has the same kind of estimation. I'd like to see the GBA version if it isn't too much trouble. thx<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24327 - ecurtz - Sun Aug 01, 2004 5:14 pm</h4>
    <div class="postbody"><span class="postbody">I'm out of town visiting my parents, I'll post the code Moday evening. I admit I haven't tested the distance calculation, but I'm surprised it is so bad.
<br/>
<br/>
Try using (int)((1.0 / PI)*(1&lt;&lt;26)) for you table scaling and atan2(y,x)&gt;&gt;18 to get your angles. I'm not seeing anything off by more than one "degree"(512) with these values. Maybe there is something wrong with my testing methodology, I haven't used this in an actual game. Is it possible your table was getting calculated with integer math before the final conversion?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24354 - DiscoStew - Mon Aug 02, 2004 3:44 am</h4>
    <div class="postbody"><span class="postbody">Yes, that change to atan2Scale seemed to do it. Now I can only see about a 1.5 degree max error, but increasing the step even by 1 or 2 fixes it to be more accurate. Thanks a lot. Now, with this change, I'm beginning to see a pattern with what the Distance should be, and what the Distance becomes from the function, as shown here...
<br/>
<br/>
Point (1, 0) ; Actual Distance = 1 ; Function Distance = 1
<br/>
Point (10, 0) ; Actual Distance = 10 ; Function Distance = 16
<br/>
Point (100, 0) ; Actual Distance = 100 ; Function Distance = 164
<br/>
Point (1000, 0) ; Actual Distance = 1000 ; Function Distance = 1646
<br/>
<br/>
From what I can see (and calculated), dividing the Function Distance by 1.646702791 (or multiply by 0.6072529195657680112885888735598) should give an approximate Distance. However, at points that are very close to the origin, like (1,0), will result in 0.
<br/>
In terms of the GBA, an approximation would be something like this...
<br/>
<br/>
ActualDistance = (FuncDistance * 2487) &gt;&gt; 12;
<br/>
<br/>
Unless someone can fix the distance problem, I guess I'll be doing this this way. I'm go and convert this to the GBA so that I can compare it to the BIOS function. I don't know ASM, so I can't convert it to that.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24380 - DiscoStew - Mon Aug 02, 2004 4:56 pm</h4>
    <div class="postbody"><span class="postbody">Well, I have just done my comparison with the BIOS ArcTan2 and Cordic Rotators. Now I can't really say which one is the better because it all depends on what a programmer needs, just an ArcTan2 function, or a function that calculates the ArcTan and Distance at the same time.
<br/>
For the Cordic Rotator test, the function is in C, and placed in IWRAM as ARM code, with its scale and table in IWRAM also, with PI = 256 deg, not 180 deg. For the BIOS test, a call to swi 0x0a0000, plus a simple formula to get an approximate angle between 0 and 360 (result = ((BIOS_Result * 727) &gt;&gt; 17);). I had tried to incorporate this simple formula into assembly, but it kept saying that there were bad arguments for the instruction 'mul', so this is running under THUMB right now. Also with the BIOS ArcTan is Distance calculated with an IWRAM ASM Sqrt function (by KevinW).
<br/>
<br/>
For calculating the test, I used the emulator VBA (of course), and used a counter which increments thoughout post and pre VBlank stages, so a test within 223 scanlines for each. Calculations resulting in angles divisible by PI/2 don't count because a pre-check could be done before actual processing. Results were written to an unused area in IWRAM, then retrieved through Memory viewer. The result is how many times the function was called, so higher means better.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Point from Origin | CordicRot | BIOS | BIOS w/ Distance
<br/>
(1, 1)            |    843    | 949  | 743
<br/>
(-76, 330)        |    973    | 976  | 763
<br/>
(345, -10432)     |    928    | 1007 | 779
<br/>
(-6346, -95324)   |    928    | 999  | 773</td> </tr></table><span class="postbody">
<br/>
<br/>
As you can see, the BIOS ArcTan2 call is faster in practically all cases than the Cordic Rotators function, but when combined with an ASM Distance function to equal what the Cordic Rotators function can do, Cordic goes all the way. However, remember that the Cordic function was written in C. I could see the function go way faster if it were coded in ASM.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24381 - ecurtz - Mon Aug 02, 2004 5:12 pm</h4>
    <div class="postbody"><span class="postbody">Great, thanks for doing that testing. Of course I don't know if VBA is cycle accurate, does anyone know if I could do this with the shareware version of no$gba? (still waiting for Martin to get PayPal going, though.)
<br/>
<br/>
How many iterations were you using in the rotator?
<br/>
<br/>
I'm going to try to do an assembly implementation this week as a learning exercise. I'm post my progress here as I'm going if anybody wants to kibitz. Given how close the C version is to the BIOS I'd be VERY surprised if we can't beat it in all cases with a little head scratching. I need to learn ARM assembly at some point anyway so I can hang out here with the cool kids...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24401 - DiscoStew - Tue Aug 03, 2004 2:36 am</h4>
    <div class="postbody"><span class="postbody">VBA is not cycle accurate, so I would say that the results would be lower. I'd go and try it with the free version of no$gba, but that would require something like setting the screen to display the count, but I was only trying something quick and easy to check it faster. Later, I might try that.
<br/>
<br/>
Iterations? You mean steps? I'm using 8 like you had. Any number below that would result in a lot less accuracy.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ecurtz wrote:</b></span></td> </tr> <tr> <td class="quote">I need to learn ARM assembly at some point anyway so I can hang out here with the cool kids</td> </tr></table><span class="postbody">
<br/>
Me too. =) Starting Aug 16.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24406 - torne - Tue Aug 03, 2004 3:04 am</h4>
    <div class="postbody"><span class="postbody">Really should finish my static timing analyser at some point; it got spun off from the work I was doing on high-level assembly and never finished. For a cacheless system like the GBA it should be able to give you cycle-accurate timings without having to emulate anything at all, but right now it's too primitive to use on any real code examples.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24552 - ecurtz - Thu Aug 05, 2004 4:47 pm</h4>
    <div class="postbody"><span class="postbody">Well, I'm still working on the assembly, but here are a couple (should have been obvious) improvements for the C version I figured out while working on it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   while((tmp &amp; 0xFE000000) == 0) { 
<br/>
      tmp &lt;&lt;= 1; shift++; 
<br/>
   }</td> </tr></table><span class="postbody">
<br/>
should be replaced with something like
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if (tmp &lt; 0x01000000)
<br/>
   shift += 3;
<br/>
if (tmp &lt; 0x00200000)
<br/>
   shift += 3;
<br/>
if (tmp &lt; 0x00040000)
<br/>
   shift += 3;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
and the final angle should be
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
(ang + (1&lt;&lt;16)) &gt;&gt; 18;
<br/>
</td> </tr></table><span class="postbody">
<br/>
rather than just
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
ang &gt;&gt; 18;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Of course this was just typed in, but the ideas are correct, even if there are typos.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24557 - DiscoStew - Thu Aug 05, 2004 7:28 pm</h4>
    <div class="postbody"><span class="postbody">I went to take your optimizations into the test that I did earlier, but I then remembered that I began using that project for something else, so I went and recoded the test just as it was before these new optimizations. For some reason, I am getting different results that from earlier, and yet the actual angle and distance are correct (except for the last test, in which only the distance was not correct, it has been changed). Here is the redone test from earlier with the different results...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Test done in a 223 scanline period (more means better)
<br/>
Point from Origin | CordicRot | BIOS | BIOS w/ Distance 
<br/>
(1, 1)            |    1199   | 1010 | 810 
<br/>
(-76, 330)        |    1299   | 1031 | 802 
<br/>
(345, -10432)     |    1307   | 1026 | 788 
<br/>
(-6346, -35324)   |    1345   | 983  | 772   &lt;-Y was changed</td> </tr></table><span class="postbody">If you are wondering about the test, I am too, as now the Cordic Rotator function now is faster, even though it is the exact same code used earlier. Even the BIOS function became faster, though now it isn't faster that CordicRot. Was my computer doing something else while these tests were running?
<br/>
Now you must be waiting for the new test involving the changes. Right now I just want to say...
<br/>
<br/>
"ECURTZ!!!!! YOUR A GENIUS!!!!!!"
<br/>
<br/>
Why, well here is the results...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Test done in a 223 scanline period (more means better)
<br/>
Point from Origin | CordicRot
<br/>
(1, 1)            |    1733
<br/>
(-76, 330)        |    1671
<br/>
(345, -10432)     |    1545
<br/>
(-6346, -35324)   |    1545   &lt;-Y was changed</td> </tr></table><span class="postbody">
<br/>
<br/>
The outcome is incredible, and yet it is still in C, running as ARM code in IWRAM. Now I'd really like to see it ASM, how about you?
<br/>
<br/>
EDIT:
<br/>
<br/>
I think I know the reason why in my redone test the CordicRot function became faster. The atantable was converted into a LUT without needing to create it in real-time, and all computation that were meant to be pre-computated were changed to to their actual values. Plus I converted the function a little so now you can choose whether to return the Distance or the ArcTan, and if you also need the other, the values are stored in their own personal variable, which I used to make inline functions for both. The BIOS function, however, is a mystery to me as to why it is somewhat faster than before. I'll post the new function if you'd like. Remember, I was still using VBA, so it isn't cycle-accurate.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24598 - ecurtz - Sat Aug 07, 2004 6:11 am</h4>
    <div class="postbody"><span class="postbody">Hardly a genius, more of a "... great coders steal" situation, but thanks.
<br/>
<br/>
Now here's the payoff - I'm posting my first attempt at an assembly version into a new thread. Hopefully some of the experts will look it over and suggest any fixes. It is a little larger than I'd like, but it should be pretty fast.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
