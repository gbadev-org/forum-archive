<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Functions with more than four parameters - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Functions with more than four parameters</h2>
<div id="posts">
<div class="post">
    <h4>#12447 - poslundc - Fri Nov 14, 2003 5:53 am</h4>
    <div class="postbody"><span class="postbody">According to the Arm-Thumb Procedure Call Standard, if you have a variable number or more than four arguments in your function, every argument after the fourth will be stored in reverse order on the stack.
<br/>
<br/>
My question is: should my function move the stack pointer as it unloads the arguments off of the stack, or should I leave it where it was when the function began (in which case the procedure-calling routine presumably cleans up the parameters it set up for me)?
<br/>
<br/>
My gut says it's the former (it's a stack, after all), but if I'm wrong I will be generating a world of errors.
<br/>
<br/>
Thanks,
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12452 - torne - Fri Nov 14, 2003 3:23 pm</h4>
    <div class="postbody"><span class="postbody">Don't move the stack pointer. Read the local variables like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldr r5, [SP]
<br/>
ldr r6, [SP, #4]
<br/>
ldr r7, [SP, #8]</td> </tr></table><span class="postbody">
<br/>
and so on. The stack pointer points directly at the fifth argument and subsequent arguments are 4/8/12/16..etc bytes above the stack pointer.
<br/>
<br/>
Thumb has a special mode for writing SP-relative loads, so don't worry about Thumb not being able to use the required addressing mode.[/code]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12462 - poslundc - Sat Nov 15, 2003 2:42 am</h4>
    <div class="postbody"><span class="postbody">This presents me with a bit of a conundrum.
<br/>
<br/>
In my case, where I am attempting to write my own bastardized version of sprintf, I won't know the number of parameters I am receiving until I am done processing the string.
<br/>
<br/>
If the stack pointer isn't pointing to the top of the stack, but instead pointing to the beginning of my parameters, then I can't possibly know where the stack actually begins. Which means I can't get to the stack until I'm done loading in my parameters.
<br/>
<br/>
The thing is, I can't even do that, since all of my scratch registers are occupied with the first four parameters passed to my function. How can I save the remaining registers to the stack when I don't know where the stack begins?
<br/>
<br/>
It seems to me there must be a simple solution to this I cannot see; otherwise it would be impossible to write variadic functions.
<br/>
<br/>
Thanks,
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12463 - tepples - Sat Nov 15, 2003 3:05 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">If the stack pointer isn't pointing to the top of the stack, but instead pointing to the beginning of my parameters, then I can't possibly know where the stack actually begins. Which means I can't get to the stack until I'm done loading in my parameters.
<br/>
<br/>
The thing is, I can't even do that, since all of my scratch registers are occupied with the first four parameters passed to my function. How can I save the remaining registers to the stack when I don't know where the stack begins?
<br/>
</td> </tr></table><span class="postbody">
<br/>
Try implementing vsprintf(), and then set up a C wrapper that calls it. Then disassemble the C wrapper to see how the pros handle it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">It seems to me there must be a simple solution to this I cannot see; otherwise it would be impossible to write variadic functions.</td> </tr></table><span class="postbody">
<br/>
Try writing a variadic function, compiling it to assembly language, and reading it (gcc -mthumb -O -S foo.c -o foo.s; notepad foo.s).<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12467 - poslundc - Sat Nov 15, 2003 6:21 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Try writing a variadic function, compiling it to assembly language, and reading it (gcc -mthumb -O -S foo.c -o foo.s; notepad foo.s).</td> </tr></table><span class="postbody">
<br/>
<br/>
That's my backup plan... but if someone already knows and can save me the trouble, my makefile is a bitch to get working on a single ASM file (part of running multiple versions of gcc on the same computer). :)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12470 - torne - Sat Nov 15, 2003 10:56 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">This presents me with a bit of a conundrum.
<br/>
<br/>
In my case, where I am attempting to write my own bastardized version of sprintf, I won't know the number of parameters I am receiving until I am done processing the string.</td> </tr></table><span class="postbody">
<br/>
<br/>
That's no problem; you can use a loop. =)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">If the stack pointer isn't pointing to the top of the stack, but instead pointing to the beginning of my parameters, then I can't possibly know where the stack actually begins. Which means I can't get to the stack until I'm done loading in my parameters.</td> </tr></table><span class="postbody">
<br/>
<br/>
The stack pointer is pointing to the top of the stack. The GBA uses a full-descending stack - it grows downwards and the stack pointer always points to the last used entry, not the first empty one. Here's what the GBA stack looks like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  ^    +------------------------------+
<br/>
  |    | Caller's stuff on stack      | &lt;- some high address
<br/>
  |    +------------------------------+
<br/>
Caller | Your nth argument            | &lt;- SP-(4*(n-5))
<br/>
pushes +------------------------------+
<br/>
 and   | Your n-1th argument          | &lt;- SP-(4*(n-6))
<br/>
 pops  +------------------------------+
<br/>
these  | etc...                       |
<br/>
  |    +------------------------------+
<br/>
  |    | Your 5th argument            | &lt;- SP
<br/>
  v    +------------------------------+
<br/>
  ^    | First value you push         |
<br/>
  |    +------------------------------+
<br/>
You do | Second value you push        |
<br/>
these  +------------------------------+
<br/>
  |    | etc...                       | &lt;- new SP after you're done pushing
<br/>
  v    +------------------------------+
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">The thing is, I can't even do that, since all of my scratch registers are occupied with the first four parameters passed to my function. How can I save the remaining registers to the stack when I don't know where the stack begins?</td> </tr></table><span class="postbody">
<br/>
<br/>
You can. You can still get to your arguments after you push further things to the stack.
<br/>
<br/>
Say you push three registers:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">push {r4,r5,r6}</td> </tr></table><span class="postbody">
<br/>
This does SP = SP - 12 (4 bytes per register).
<br/>
So, now you can get your fifth argument from SP+12, and your sixth argument from SP+16, and so on. =)
<br/>
<br/>
You just need to keep track of how many registers you push (in your head, not in code) and use that as the offset to find your parameters.
<br/>
<br/>
If you're implementing a variadic function, you might want to do something like this (using partial unrolling to deal with the first few params):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ Code for a variadic function with 2 fixed arguments that
<br/>
@ implements a not-really-sprintf: it copies the string
<br/>
@ pointed to by r1 to the location r0, replacing each %
<br/>
@ in the string with the char pointed to by the next variadic argument.
<br/>
@ I've not assembled this so expect small errors, but the arg handling
<br/>
@ should be sound. It's partially unrolled to handle the first two variadic
<br/>
@ args easily but I don't pretend it's optimised =)
<br/>
notsprintf:
<br/>
        push {r4,r5}    @ Save r4, r5 so we can change them
<br/>
        @ First loop: copy chars until we hit a null or a %, and
<br/>
        @ if it's a %, substitute char.
<br/>
l1:     ldrb r4, [r0]   @ Load char
<br/>
        add r0, #1      @ increment source pointer
<br/>
        cmp r4, #0      @ check if null
<br/>
        beq end         @ exit if null
<br/>
        cmp r4, #'%     @ check if %
<br/>
        bne s1          @ skip ahead if not
<br/>
        ldrb r4, [r2]   @ load char pointed to by first varg instead
<br/>
s1:     strb r4, [r1]   @ store char
<br/>
        add r1, #1      @ increment target pointer
<br/>
        bne l1          @ Go back if we didn't do a substitution
<br/>
        
<br/>
        @ Second loop: do the same but use next register for substitution
<br/>
l2:     ldrb r4, [r0]   @ Load char
<br/>
        add r0, #1      @ increment source pointer
<br/>
        cmp r4, #0      @ check if null
<br/>
        beq end         @ exit if null
<br/>
        cmp r4, #'%     @ check if %
<br/>
        bne s2          @ skip ahead if not
<br/>
        ldrb r4, [r3]   @ load char pointed to by second varg instead
<br/>
s2:     strb r4, [r1]   @ store char
<br/>
        add r1, #1      @ increment target pointer
<br/>
        bne l2          @ Go back if we didn't do a substitution
<br/>
        
<br/>
        @ Third to nth loop: do the same but read subs from stack
<br/>
        mov r5, sp      @ Stick SP value into r5
<br/>
        add r5, #8      @ add 8 so it points to third varg (skipping our pushes)
<br/>
loop:   ldrb r4, [r0]   @ Load char
<br/>
        add r0, #1      @ Increment source pointer
<br/>
        cmp r4, #0      @ check if null
<br/>
        beq end         @ exit if null
<br/>
        cmp r4, #'%     @ check if %
<br/>
        bne skip        @ skip ahead if not
<br/>
        ldrb r4, [r5]   @ Load pointer in nth varg
<br/>
        ldrb r4, [r4]   @ Pointer deref
<br/>
        add r5, #4      @ increment vararg
<br/>
skip:   strb r4, [r1]   @ store char
<br/>
        add r1, #1      @ increment target pointer
<br/>
        b loop          @ Loop
<br/>
<br/>
        @ Cleanup and return
<br/>
end:    strb r4, [r1]   @ Append null to target
<br/>
        pop {r4,r5}     @ pop stored vals (we didn't change SP so this is fine)
<br/>
        bx lr           @ Return</td> </tr></table><span class="postbody">
<br/>
<br/>
Hope that makes sense. Once you have the stack layout clear in your head it's pretty easy =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12473 - poslundc - Sat Nov 15, 2003 4:03 pm</h4>
    <div class="postbody"><span class="postbody">OKAY, now I see. :)
<br/>
<br/>
It's the stupid stack terminology/behaviour that has me confused. From what you were telling me, I thought that the additional arguments were pushed onto the stack but that the stack pointer wasn't moved with them, which would create the problems I was describing.
<br/>
<br/>
I take it, then, that the calling routine takes responsibility for popping off the extra parameters once your routine is finished? This is what I was initially unsure about.
<br/>
<br/>
Thanks for the indepth explanation and sample code, by the way. I think all I really needed was a smack in the face and the message "the stack grows downward".
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12523 - torne - Sun Nov 16, 2003 8:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">I take it, then, that the calling routine takes responsibility for popping off the extra parameters once your routine is finished? This is what I was initially unsure about.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#12561 - poslundc - Mon Nov 17, 2003 10:28 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for your help, guys, especially torne. I've finished the function and tested it pretty thoroughly. I'll post it on gbadev as soon as I figure out how.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
