<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Burst Boot & GAS - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Burst Boot & GAS</h2>
<div id="posts">
<div class="post">
    <h4>#29438 - Joe_Sextus - Sat Nov 20, 2004 1:19 am</h4>
    <div class="postbody"><span class="postbody">I was wondering if any one has implemented Burst Boot in GNU's syntax. I am not very familar with the ARM assembler and when I translated the Burst  Boot code for A22i to GAS syntax the program never (as for as I can tell) receives any SIO IRQs. I am using DevKitArm_r8.
<br/>
<br/>
Here's my Code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  .ARM
<br/>
  .ALIGN
<br/>
  .GLOBAL main
<br/>
<br/>
msg_boot:  .ascii "BOOT"
<br/>
msg_okay:  .ascii "OKAY"
<br/>
msg_brst:  .ascii "BRST"
<br/>
<br/>
irq_handler:
<br/>
  mov  r8, #0x03E0
<br/>
  strh r8, [r5]
<br/>
  
<br/>
  mov  r1, #0x4000000             @&gt; Base of address of all I/O Registers
<br/>
  
<br/>
  ldr  r0, [r1, #0x200]           @\ Read REG_IE &amp; REG_IF 
<br/>
  and  r0, r0, r0, lsr #16        @] check for handled IRQs
<br/>
  add  r3, r1, #0x200             @] and place back in REG_IF
<br/>
  strh r0, [r3, #2]               @/ 
<br/>
  
<br/>
  ldrh r3, [r1, #-8]              @\ 
<br/>
  orr  r3, r3, r0                 @] Mirror REG_IF at REG_IRQ_MIRROR (0x3007FF8)
<br/>
  strh r3, [r1, #-8]              @/ 
<br/>
  
<br/>
  and   r3, r0, #0x80             @\ 
<br/>
  cmp   r3, #0x80                 @] Check for the Burst Boot (SIO) IRQ
<br/>
  
<br/>
  mov r11, r11
<br/>
  moveq  r8, #0x001F
<br/>
  streqh r8, [r5]
<br/>
  ldreq r2, [r1 , #0x120]         @] 
<br/>
  ldreq r3, msg_brst              @] if "BRST" received jump to the 
<br/>
  cmpeq r2, r3                    @] Burst Boot Handler
<br/>
  mov r11, r11
<br/>
  
<br/>
  beq   burst_boot                @/ 
<br/>
  
<br/>
  @Insert Additional IRQ Handler Code Hear
<br/>
  
<br/>
  bx   lr                         @&gt; return
<br/>
  
<br/>
burst_boot:   @requires icoming r1=0x4000000
<br/>
<br/>
  @Disable DMA Transfers
<br/>
  ldr   r4, msg_okay              @\ Receive transfer length in bytes
<br/>
  bl    sio_transfer              @] and reply "OKAY"
<br/>
  mov   r2, r0                    @/ 
<br/>
  
<br/>
  mov   r3, #0x3000000            @\ 
<br/>
  mov   r4, #0                    @] Download Burst Loader to
<br/>
 burstLoop:                       @] 0x3000000 and up
<br/>
  bl    sio_transfer              @] 
<br/>
  stmia r3!, {r0}                 @] 
<br/>
  add   r4, r4, r0                @] 
<br/>
  subs  r2, r2, #4                @] 
<br/>
  bhi   burstLoop                 @/ 
<br/>
  
<br/>
  bl    sio_transfer              @&gt; Send the CRC value back to the master
<br/>
  
<br/>
  mov   r14, #0x3000000
<br/>
  bx    lr
<br/>
  
<br/>
  @b     0x3000000                 @&gt; start the loader
<br/>
  
<br/>
sio_transfer:
<br/>
  str   r4, [r1, #0x120]          @siodata32 ;-set reply/send data
<br/>
  
<br/>
  ldr   r0, [r1, #0x128]          @\
<br/>
  orr   r0, r0, #0x80             @] activate slave transfer
<br/>
  str   r0, [r1,#0x128]           @/
<br/>
  
<br/>
 sio_wait:                        @\
<br/>
  ldr   r0, [r1, #0x28]           @] wait until transfer completed
<br/>
  tst   r0, #0x80                 @]
<br/>
  bne   sio_wait                  @/
<br/>
  
<br/>
  ldr   r0, [r1, #0x120]          @&gt; get received data
<br/>
  bx   lr                         @&gt; return
<br/>
  
<br/>
download_rom_to_ram:
<br/>
  bx   lr                         @&gt; return
<br/>
  
<br/>
init_interrupts:
<br/>
  mov  r4, #0x4000000             @&gt; Base of address of all I/O Registers
<br/>
  
<br/>
  ldr  r0, =irq_handler           @\ Place the address of irq_handler in
<br/>
  str  r0, [r4, #-4]              @/ REG_IRG_HANDLER (0x3007FFFC)
<br/>
  
<br/>
  mov  r0, #0x0008                @\ Enable the VBlank IRQ in REG_DISPCNT
<br/>
  strh r0, [r4, #0x4]             @/ 
<br/>
  
<br/>
  mrs  r0, cpsr                   @\ 
<br/>
  bic  r0, r0, #0x80              @] Enable CPU Interrupts (clear i-flag)
<br/>
  msr  cpsr, r0                   @/ 
<br/>
  
<br/>
  mov  r0, #0                     @\ 
<br/>
  str  r0, [r4, #0x120]           @] Init SIO Normal mode, External Clock
<br/>
  ldr  r0, =0x5080                @] 32-bit, Enable IRQ, transfer Started
<br/>
  str  r0, [r4, #0x128]           @/ 
<br/>
  
<br/>
  ldr  r0, msg_boot               @\ output "BOOT" to the link
<br/>
  str  r0, [r4, #0x120]           @/ 
<br/>
  
<br/>
  mov  r0, #1                     @\ Master interrupt enable (REG_IME)
<br/>
  str  r0, [r4, #0x208]           @/ 
<br/>
  
<br/>
  mov  r0, #0x81                  @\ Enable VBlank and SIO (Burst Boot)
<br/>
  str  r0, [r4, #0x200]           @/ IRQs
<br/>
  
<br/>
  bx   lr                         @&gt; return
<br/>
<br/>
main:
<br/>
  mov r0, #0xFE                   @\ Clear all RAM Registers
<br/>
  swi 0x10000                     @/ except Multiboot Register
<br/>
  
<br/>
  bl init_interrupts              @&gt; install irq_handler
<br/>
  
<br/>
  mov  r4, #0x4000000             @\ Enable video by clearing
<br/>
  strh r4, [r4]                   @] the forced blank bit of
<br/>
                                  @/ REG_DISPCNT
<br/>
  
<br/>
  mov r5, #0x5000000
<br/>
  mov r8, #0x7C00
<br/>
  
<br/>
  mainLoop:
<br/>
    swi 0x50000                   @&gt; WaitForVIRQ
<br/>
         
<br/>
    strh r8, [r5]                 @&gt;
<br/>
      
<br/>
    b mainLoop
<br/>
  .ALIGN
<br/>
  .POOL
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
In my code the screen starts out blue, then when irq_handler is called by bios it changes the screen color to green. Now when a SIO IRQ is received the screen should turn red, but this never happens.
<br/>
<br/>
If I boot this up in an emulator and check the memory locations on REG_IE the value is 0x81 (VBlank and SIO) and 0x4000120 = BOOT like it does in the original.
<br/>
<br/>
Any help would be appreciated.
<br/>
<br/>
-Joe</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31170 - Joe_Sextus - Wed Dec 08, 2004 4:56 pm</h4>
    <div class="postbody"><span class="postbody">I have found my errors and am posting the fixed so everyone else can use it.
<br/>
In init_interrupts the line
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">str  r0, [r4, #0x120]           @] Init SIO Normal mode, External Clock</td> </tr></table><span class="postbody">
<br/>
should read
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">str  r0, [r4, #0x134]           @] Init SIO Normal mode, External Clock</td> </tr></table><span class="postbody">
<br/>
and in sio_transfer the line
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldr   r0, [r1, #0x28]           @] wait until transfer completed</td> </tr></table><span class="postbody">
<br/>
should read
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldr   r0, [r1, #0x128]           @] wait until transfer completed</td> </tr></table><span class="postbody">
<br/>
<br/>
And here is the complete fixed code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  .ARM 
<br/>
  .ALIGN 
<br/>
  .GLOBAL main 
<br/>
<br/>
msg_boot:  .ascii "BOOT" 
<br/>
msg_okay:  .ascii "OKAY" 
<br/>
msg_brst:  .ascii "BRST" 
<br/>
<br/>
irq_handler: 
<br/>
  mov  r8, #0x03E0 
<br/>
  strh r8, [r5] 
<br/>
  
<br/>
  mov  r1, #0x4000000             @&gt; Base of address of all I/O Registers 
<br/>
  
<br/>
  ldr  r0, [r1, #0x200]           @\ Read REG_IE &amp; REG_IF 
<br/>
  and  r0, r0, r0, lsr #16        @] check for handled IRQs 
<br/>
  add  r3, r1, #0x200             @] and place back in REG_IF 
<br/>
  strh r0, [r3, #2]               @/ 
<br/>
  
<br/>
  ldrh r3, [r1, #-8]              @\ 
<br/>
  orr  r3, r3, r0                 @] Mirror REG_IF at REG_IRQ_MIRROR (0x3007FF8) 
<br/>
  strh r3, [r1, #-8]              @/ 
<br/>
  
<br/>
  and   r3, r0, #0x80             @\ 
<br/>
  cmp   r3, #0x80                 @] Check for the Burst Boot (SIO) IRQ 
<br/>
  
<br/>
  mov r11, r11 
<br/>
  moveq  r8, #0x001F 
<br/>
  streqh r8, [r5] 
<br/>
  ldreq r2, [r1 , #0x120]         @] 
<br/>
  ldreq r3, msg_brst              @] if "BRST" received jump to the 
<br/>
  cmpeq r2, r3                    @] Burst Boot Handler 
<br/>
  mov r11, r11 
<br/>
  
<br/>
  beq   burst_boot                @/ 
<br/>
  
<br/>
  @Insert Additional IRQ Handler Code Hear 
<br/>
  
<br/>
  bx   lr                         @&gt; return 
<br/>
  
<br/>
burst_boot:   @requires icoming r1=0x4000000 
<br/>
<br/>
  @Disable DMA Transfers 
<br/>
  ldr   r4, msg_okay              @\ Receive transfer length in bytes 
<br/>
  bl    sio_transfer              @] and reply "OKAY" 
<br/>
  mov   r2, r0                    @/ 
<br/>
  
<br/>
  mov   r3, #0x3000000            @\ 
<br/>
  mov   r4, #0                    @] Download Burst Loader to 
<br/>
 burstLoop:                       @] 0x3000000 and up 
<br/>
  bl    sio_transfer              @] 
<br/>
  stmia r3!, {r0}                 @] 
<br/>
  add   r4, r4, r0                @] 
<br/>
  subs  r2, r2, #4                @] 
<br/>
  bhi   burstLoop                 @/ 
<br/>
  
<br/>
  bl    sio_transfer              @&gt; Send the CRC value back to the master 
<br/>
  
<br/>
  mov   r14, #0x3000000           @\ start the loader 
<br/>
  bx    lr                        @/
<br/>
  
<br/>
sio_transfer: 
<br/>
  str   r4, [r1, #0x120]          @siodata32 ;-set reply/send data 
<br/>
  
<br/>
  ldr   r0, [r1, #0x128]          @\ 
<br/>
  orr   r0, r0, #0x80             @] activate slave transfer 
<br/>
  str   r0, [r1,#0x128]           @/ 
<br/>
  
<br/>
 sio_wait:                        @\ 
<br/>
  ldr   r0, [r1, #0x128]          @] wait until transfer completed 
<br/>
  tst   r0, #0x80                 @] 
<br/>
  bne   sio_wait                  @/ 
<br/>
  
<br/>
  ldr   r0, [r1, #0x120]          @&gt; get received data 
<br/>
  bx   lr                         @&gt; return 
<br/>
  
<br/>
download_rom_to_ram: 
<br/>
  bx   lr                         @&gt; return 
<br/>
  
<br/>
init_interrupts: 
<br/>
  mov  r4, #0x4000000             @&gt; Base of address of all I/O Registers 
<br/>
  
<br/>
  ldr  r0, =irq_handler           @\ Place the address of irq_handler in 
<br/>
  str  r0, [r4, #-4]              @/ REG_IRG_HANDLER (0x3007FFFC) 
<br/>
  
<br/>
  mov  r0, #0x0008                @\ Enable the VBlank IRQ in REG_DISPCNT 
<br/>
  strh r0, [r4, #0x4]             @/ 
<br/>
  
<br/>
  mrs  r0, cpsr                   @\ 
<br/>
  bic  r0, r0, #0x80              @] Enable CPU Interrupts (clear i-flag) 
<br/>
  msr  cpsr, r0                   @/ 
<br/>
  
<br/>
  mov  r0, #0                     @\ 
<br/>
  str  r0, [r4, #0x134]           @] Init SIO Normal mode, External Clock 
<br/>
  ldr  r0, =0x5080                @] 32-bit, Enable IRQ, transfer Started 
<br/>
  str  r0, [r4, #0x128]           @/ 
<br/>
  
<br/>
  ldr  r0, msg_boot               @\ output "BOOT" to the link 
<br/>
  str  r0, [r4, #0x120]           @/ 
<br/>
  
<br/>
  mov  r0, #1                     @\ Master interrupt enable (REG_IME) 
<br/>
  str  r0, [r4, #0x208]           @/ 
<br/>
  
<br/>
  mov  r0, #0x81                  @\ Enable VBlank and SIO (Burst Boot) 
<br/>
  str  r0, [r4, #0x200]           @/ IRQs 
<br/>
  
<br/>
  bx   lr                         @&gt; return 
<br/>
<br/>
main: 
<br/>
  mov r0, #0xFE                   @\ Clear all RAM Registers 
<br/>
  swi 0x10000                     @/ except Multiboot Register 
<br/>
  
<br/>
  bl init_interrupts              @&gt; install irq_handler 
<br/>
  
<br/>
  mov  r4, #0x4000000             @\ Enable video by clearing 
<br/>
  strh r4, [r4]                   @] the forced blank bit of 
<br/>
                                  @/ REG_DISPCNT 
<br/>
  
<br/>
  mov r5, #0x5000000 
<br/>
  mov r8, #0x7C00 
<br/>
  
<br/>
  mainLoop: 
<br/>
    swi 0x50000                   @&gt; WaitForVIRQ 
<br/>
          
<br/>
    strh r8, [r5]                 @&gt; 
<br/>
      
<br/>
    b mainLoop 
<br/>
  .ALIGN 
<br/>
  .POOL 
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31171 - keldon - Wed Dec 08, 2004 5:00 pm</h4>
    <div class="postbody"><span class="postbody">It would help to have defines (or your assemblers equivalent) instead of using the address number everytime you make an access to hardware.
<br/>
<br/>
Basically we're all error prone. And if you use a define that you type wrong; your code will not compile. But if you make an error with an address it will still compile. So it is best to go with defines.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31192 - Joe_Sextus - Wed Dec 08, 2004 7:54 pm</h4>
    <div class="postbody"><span class="postbody">I was just try to get it to work with gas, so that i understood what it was doing. I plan to translate it to C/C++ eventually.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
