<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>My asm is worse than a compiler but where is "C" f - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > My asm is worse than a compiler but where is "C" f</h2>
<div id="posts">
<div class="post">
    <h4>#177103 - blessingta@hotmail.co.uk - Sun Dec 11, 2011 12:56 pm</h4>
    <div class="postbody"><span class="postbody">Hi
<br/>
<br/>
My asm code optimisation is bound to be worse than the compiler. But if "C"'s optimisations where to be criticised where do they lie in? Plus is there any documentation on the topic.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177104 - Dwedit - Sun Dec 11, 2011 5:28 pm</h4>
    <div class="postbody"><span class="postbody">You might want to clarify your post a bit, it's hard to read.
<br/>
<br/>
Most of the lack of optimization in C comes from following the ARM Procedure Call Standard (APCS) too rigidly.  Register use by function calls is limited.  Functions must taken in 4 arguments in r0,r1,r2,r3, and must return one 32-bit value into r0, otherwise it needs to use the stack to store results of a function call.  (It's also possible to cheat and get two 32-bit values returned in r0 and r1).
<br/>
Some restrictions of the APCS don't even have any positive effect on the GBA or NDS, like forcing the stack pointer to be aligned to an 8-byte boundary.
<br/>
Inlining functions lets the compiler do a better job of calling them, because it allows the compiler to decide if it has enough registers available to not need the stack.
<br/>
<br/>
When you write your own functions in ASM, you can determine how the registers are used.  You can decide which registers are input, output, should be unchanged, and which should be trashed.
<br/>
<br/>
The compiler also misses some specific optimizations:
<br/>
* Division is slow when dividing by a variable (change this to the reciprocal to speed up the program, so it can use the multiply instruction instead of calling a slow division function), dividing by a constant is okay, and dividing by a constant power of 2 becomes a shift.
<br/>
* It can't re-order registers for LDMIA/STMIA.
<br/>
* Long Multiplication is REALLY bad in THUMB mode, use ARM mode instead.
<br/>
* Short functions that do nothing except call another function with a specific argument are not changed to a mov \ branch instruction.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177105 - blessingta@hotmail.co.uk - Sun Dec 11, 2011 8:51 pm</h4>
    <div class="postbody"><span class="postbody">I just meant to ask about the areas in which "C" implements assembly code less efficiently. I'm trying to discuss this in my report</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#177112 - Miked0801 - Mon Dec 12, 2011 7:51 pm</h4>
    <div class="postbody"><span class="postbody">I've found that C does a good job overall - good enough that you rarely have to worry about it.  Where it does worse though is:
<br/>
* Quite often is pushes and pops vars it doesn't need to.
<br/>
* C doesn't usually have direct access to certain opcodes like 'clz', though intrinsics per vendor address this.
<br/>
* C doesn't have a rotate left/right command without intrinsics.
<br/>
* C has no concept nor any way at getting to the CPU flags such as zero and carry.  There are a few distinct cases where you can use these flags for small scale optimization.
<br/>
* C will generally have more frame/stack overhead than straight assembler.  Asm code can make assumptions about register use and jumps that the compiler cannot.  This actually is one of the larger areas of gain to be had by hand-coding stuff.  Also makes it harder to debug and maintain so beware.
<br/>
* C code doesn't necessarily copy large structures in an efficient manner.  You have to be very careful to get optimal performance when copying one structure to another.  memcpy() is not usually the most optimal way of copying data and the compiler will rarely use all registers available to it for copying with the block copy commands.  That said, if the compiler isn't using those registers, it's worth taking a very close look at the CPU's documentation to make sure that the compiler writers didn't do it on purpose. 
<br/>
<br/>
Programmers who write compilers are very, very bright individuals.  You want to be really sure your "optimization" is better than their code.  I've been burned a few times by writing assembler that I thought was better, only to find out the compiler outperformed me because it understood the architecture better than I.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
