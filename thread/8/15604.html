<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Any room for optimization? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>ASM > Any room for optimization?</h2>
<div id="posts">
<div class="post">
    <h4>#157777 - Ruben - Thu May 29, 2008 2:39 am</h4>
    <div class="postbody"><span class="postbody">Hey guys. I recently finished a stereo mixer which I should be about to release but it takes a bit long to mix down each channel. I was wondering if there's any room for improvement?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.section .iwram, "ax", %progbits
<br/>
.align
<br/>
.global S3MTmp
<br/>
<br/>
S3MTmp:
<br/>
        .space 304*2*16/8
<br/>
<br/>
.size S3MTmp, .-S3MTmp
<br/>
.align
<br/>
<br/>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
<br/>
<br/>
.section .iwram, "ax", %progbits
<br/>
.align
<br/>
.arm
<br/>
<br/>
.global        S3MMixdown
<br/>
.extern S3MBuffer
<br/>
.extern S3MVrs
<br/>
<br/>
S3MMixdown:
<br/>
.LStart:
<br/>
        stmfd      sp!, {r4-r11, r14}               @ save used registers
<br/>
<br/>
.LPreClearLoop:
<br/>
        ldr        r1, =S3MTmp                      @ r1 = S3MBuffer
<br/>
        mov        r2, r0                           @ r2 = samples to mix
<br/>
        mov        r3, #0x00                        @ r3 = 0
<br/>
        mov        r4, #0x00                        @ r4 = 0
<br/>
        mov        r5, #0x00                        @ r5 = 0
<br/>
        mov        r6, #0x00                        @ r6 = 0
<br/>
<br/>
.LClearLoop:
<br/>
        stmia      r1!, {r3-r6}                     @ store 4 samples
<br/>
        subs       r2, r2, #0x04                    @ subtract those 4 samples
<br/>
        bhi        .LClearLoop                      @ if positive, then keep clearing
<br/>
<br/>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
<br/>
<br/>
.LPreChannelLoop:
<br/>
        mov        r1, #0x20                        @ r1 = channel count (32)
<br/>
        ldr        r2, =S3MVrs                      @ \
<br/>
        add        r2, r2, #0x28                    @  r2 = pointer to channels
<br/>
<br/>
.LChannelLoop:
<br/>
        ldr        r3, [r2]                         @ r3 = cnt
<br/>
        tst        r3, #0x01                        @ \
<br/>
        beq        .LChannelLoopEnd                 @  if(not active) dont do this channel
<br/>
<br/>
.LPreSampleLoop:
<br/>
        mov        r4, r0                           @ r4 = samples to mix
<br/>
        ldmib      r2, {r5-r8}                      @ r5 = source
<br/>
                                                    @ r6 = position
<br/>
                                                    @ r7 = increment
<br/>
                                                    @ r8 = length
<br/>
        ldr        r9, =S3MTmp                      @ r9 = S3MTmp
<br/>
        ldr        r11, =S3MVrs                     @ \
<br/>
        ldrb       r12, [r11, #0x15]                @  r10 = master volume
<br/>
        
<br/>
        mov        r10, r3, asr #0x02
<br/>
        and        r10, r10, #0x7F
<br/>
        mul        r10, r12, r10                    @ r10 = channel vol (left) * master vol
<br/>
        mov        r10, r10, asr #0x04              @ r10 = final volume
<br/>
        
<br/>
        mov        r11, r3, asr #0x09
<br/>
        and        r11, r11, #0x7F
<br/>
        mul        r11, r12, r11                    @ r11 = channel vol (right) * master vol
<br/>
        mov        r11, r11, asr #0x04              @ r11 = final volume
<br/>
<br/>
.LSampleLoop:
<br/>
@ do left channel
<br/>
        add        r12, r5, r6, lsr #0x0C           @ r12 = position in ROM
<br/>
        ldrsb      r12, [r12]                       @ r12 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r14, r5, r6, lsr #0x0C           @ r14 = position in ROM
<br/>
        ldrsb      r14, [r14]                       @ r14 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r12, r12, r14, lsl #0x10         @ r12 = 2 samples
<br/>
        
<br/>
        ldr        r14, [r9]                        @ r14 = mixed data
<br/>
        mla        r14, r10, r12, r14               @ r14 = final data
<br/>
        str        r14, [r9], #0x04                 @ store mixed data and increment
<br/>
<br/>
@ do right channel
<br/>
        ldr        r14, [r9]                        @ r14 = mixed data
<br/>
        mla        r14, r11, r12, r14               @ r11 = final data
<br/>
        str        r14, [r9], #0x04                 @ store mixed data and increment
<br/>
        
<br/>
        cmp        r6, r8                           @ \
<br/>
        bge        .LSampleNoData                   @  if(pos &gt;= length) do some stuff
<br/>
<br/>
.LSampleLoopEnd:
<br/>
        subs       r4, r4, #0x02                    @ \
<br/>
        bhi        .LSampleLoop                     @  if(--samples left) keep looping
<br/>
<br/>
.LChannelLoopEnd:
<br/>
        str        r3, [r2], #0x08                  @ store cnt
<br/>
        str        r6, [r2], #0x10                  @ store pos; channel++
<br/>
        subs       r1, r1, #0x01                    @ \
<br/>
        bne        .LChannelLoop                    @  if(--channels left != 0) loop again
<br/>
        b          .LPreDownsampleLoop              @ skip the end of sample handler
<br/>
<br/>
.LSampleNoData:
<br/>
        tst        r3, #0x02                        @ test for loop flag
<br/>
        ldrne      r6, [r2, #0x14]                  @ if(looping) get loop begin position
<br/>
        bne        .LSampleLoopEnd                  @  keep looping
<br/>
        
<br/>
        bic        r3, r3, #0x01                    @ clear the active flag
<br/>
        b          .LChannelLoopEnd                 @ stop looping
<br/>
<br/>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
<br/>
<br/>
.LPreDownsampleLoop:
<br/>
        ldr        r1, =S3MTmp                      @ r1 = S3MTmp
<br/>
        ldr        r2, =S3MVrs                      @ r2 = S3MVrs
<br/>
        ldr        r3, [r2, #0x04]!                 @ r3 = left buffer location
<br/>
        add        r4, r3, #0x260                   @ r4 = right buffer location
<br/>
        add        r5, r3, r0                       @ r4 = buffer location + samples mixed
<br/>
        str        r5, [r2]                         @ store this location
<br/>
<br/>
.LDownsampleLoop:
<br/>
        ldrsh      r5, [r1], #0x02                  @ get mixed samples (left)
<br/>
        movs       r5, r5, asr #0x07
<br/>
        cmnmi      r5, #0x80
<br/>
        mvnlt      r5, #0x7F
<br/>
        cmppl      r5, #0x7F
<br/>
        movgt      r5, #0x7F
<br/>
        strb       r5, [r3], #0x01                  @ store
<br/>
        ldrsh      r5, [r1], #0x02                  @ get mixed samples (left)
<br/>
        movs       r5, r5, asr #0x07
<br/>
        cmnmi      r5, #0x80
<br/>
        mvnlt      r5, #0x7F
<br/>
        cmppl      r5, #0x7F
<br/>
        movgt      r5, #0x7F
<br/>
        strb       r5, [r3], #0x01                  @ store
<br/>
        
<br/>
        ldrsh      r5, [r1], #0x02                  @ get mixed samples (right)
<br/>
        movs       r5, r5, asr #0x07
<br/>
        cmnmi      r5, #0x80
<br/>
        mvnlt      r5, #0x7F
<br/>
        cmppl      r5, #0x7F
<br/>
        movgt      r5, #0x7F
<br/>
        strb       r5, [r4], #0x01                  @ store
<br/>
        ldrsh      r5, [r1], #0x02                  @ get mixed samples (right)
<br/>
        movs       r5, r5, asr #0x07
<br/>
        cmnmi      r5, #0x80
<br/>
        mvnlt      r5, #0x7F
<br/>
        cmppl      r5, #0x7F
<br/>
        movgt      r5, #0x7F
<br/>
        strb       r5, [r4], #0x01                  @ store
<br/>
        
<br/>
        subs       r0, r0, #0x02
<br/>
        bcs        .LDownsampleLoop
<br/>
<br/>
.LEnd:
<br/>
        ldmfd      sp!, {r4-r11, r14}               @ restore used registers
<br/>
        bx         lr                               @ return</td> </tr></table><span class="postbody">
<br/>
<br/>
These are the structs
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct tChn {
<br/>
 u32 cs; //channel status (bit0: on. bit1: loop. bit2-8: vol left. bit9-F: vol right)
<br/>
 s8* wp; //wave pointer
<br/>
 u32 cp; //channel position (20.12 fixed point)
<br/>
 u32 ci; //channel increment (20.12 fixed point)
<br/>
 u32 cl; //channel length (20.12 fixed point)
<br/>
 u32 lb; //loop begin (20.12 fixed point)
<br/>
} tChn;
<br/>
<br/>
typedef struct tSndArea {
<br/>
//mixer stuff
<br/>
 s8       *bb; //base buffer (+0)
<br/>
 s8       *mb; //mix buffer (current) (+4)
<br/>
 
<br/>
 u32       fr; //mix frequency (+8)
<br/>
 u32       st; //samples til tick (20.12FP) (+C)
<br/>
 u32       sp; //samples per tick (20.12FP) (+10)
<br/>
 
<br/>
 u8        ab; //active buffer (+14)
<br/>
 u8        mv; //master volume (default 15) (+15.. COINCIDENCE?! lol)
<br/>
 u16       sc; //sound control (+16)
<br/>
 
<br/>
//player stuff
<br/>
 tS3M     *pm; //pointer to module (+18)
<br/>
 u8       *nb; //next byte (+1C)
<br/>
 
<br/>
 u8        mp; //module speed (+20)
<br/>
 u8        mt; //module tempo (+21)
<br/>
 u8        mc; //mixer count/tick/tap (+22)
<br/>
 
<br/>
 u8        cr; //current row (+23)
<br/>
 u8        co; //current order (+24)
<br/>
 u8        oc; //order count (+25)
<br/>
 
<br/>
 tChn  pc[32]; //player channels (+26)
<br/>
 
<br/>
 u8        pd; //pattern delays left
<br/>
 
<br/>
 u32       ef;     //effect flags
<br/>
 u8        ep[32]; //effect paramaters
<br/>
} tSndArea;</td> </tr></table><span class="postbody">
<br/>
<br/>
The mono code for the mixer is really fast but after I added those 3 instructions for the right channel, it's slowed down quite a lot. Thanks a lot guys.[/code]
<br/>
<br/>
EDIT: Fixed up the misaligned text</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157786 - DekuTree64 - Thu May 29, 2008 5:31 am</h4>
    <div class="postbody"><span class="postbody">Loads, multiplies, and stores are some of the slowest instructions, so I'm not surprised that those 3 would add a lot.
<br/>
<br/>
I'm a bit rusty on mixer optimization and I haven't thorougly examined the code, but here are a few things I noticed:
<br/>
<br/>
One "free" speed boost you can have here is to swap the middle 2 registers on the multiplies. The cycles taken depends on the number of "significant" bytes in the SECOND multiplying register. Since you have 2 samples packed together, that register should go first, and the volume second, because the volume should be all zeroes in the upper 3 bytes.
<br/>
<br/>
That said, I'd recommend packing the left and right volumes together, rather than 2 samples. Saves at least the one add per 2 samples, and probably will save some registers too. But in that case, you would want to multiply with the volume register first, followed by the one byte sample.
<br/>
<br/>
Since you're not using a whole lot of registers even as it is, how about unrolling that loop 4 or 8 times and ldm/stm'ing the temp buffer values?
<br/>
<br/>
Also, make sure the temp buffer is in IWRAM. Even if it is pretty big, it's only needed during the mixer function, so it can go on the stack. Of course, if that's the only thing in your game that uses a lot of stack space, then it's just as bad as giving it a permanent chunk. But if a few other speed-critical sections can get some use out of a big stack, then there's no guilt in using it to speed up the mixer.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157787 - eKid - Thu May 29, 2008 5:36 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ do left channel
<br/>
        add        r12, r5, r6, lsr #0x0C           @ r12 = position in ROM
<br/>
        ldrsb      r12, [r12]                       @ r12 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r14, r5, r6, lsr #0x0C           @ r14 = position in ROM
<br/>
        ldrsb      r14, [r14]                       @ r14 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r12, r12, r14, lsl #0x10         @ r12 = 2 samples 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
You can add a shifted register to the LDRSB address, instead of using an add before the load.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ do left channel
<br/>
        ldrsb      r12, [r5, r6, lsr#0x0C]          @ r12 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        ldrsb      r14, [r5, r6, lsr#0x0C]     @ r14 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r12, r12, r14, lsl #0x10         @ r12 = 2 samples 
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157788 - Ruben - Thu May 29, 2008 5:42 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>eKid wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ do left channel
<br/>
        add        r12, r5, r6, lsr #0x0C           @ r12 = position in ROM
<br/>
        ldrsb      r12, [r12]                       @ r12 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r14, r5, r6, lsr #0x0C           @ r14 = position in ROM
<br/>
        ldrsb      r14, [r14]                       @ r14 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r12, r12, r14, lsl #0x10         @ r12 = 2 samples 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
You can add a shifted register to the LDRSB address, instead of using an add before the load.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ do left channel
<br/>
        ldrsb      r12, [r5, r6, lsr#0x0C]          @ r12 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        ldrsb      r14, [r5, r6, lsr#0x0C]     @ r14 = sample
<br/>
        add        r6, r6, r7                       @ pos += inc
<br/>
        add        r12, r12, r14, lsl #0x10         @ r12 = 2 samples 
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">Nope, already tried that many times before. 'ldrb r0, [r1, r2, lsr #0x02]' is OK but 'ldrsb' doesn't work for it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157789 - eKid - Thu May 29, 2008 5:45 am</h4>
    <div class="postbody"><span class="postbody">oh.. oops :P
<br/>
My mixer takes unsigned samples... so I can use that trick. (aren't the samples in S3M unsigned?)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157790 - Ruben - Thu May 29, 2008 5:49 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>eKid wrote:</b></span></td> </tr> <tr> <td class="quote">oh.. oops :P
<br/>
My mixer takes unsigned samples... so I can use that trick. (aren't the samples in S3M unsigned?)</td> </tr></table><span class="postbody">Yeah, they are but I XORed them with 128 'cause I couldn't get unsigned samples working right &gt;.&lt;" And besides, most games use signed samples so I thought I'd join in :D Lol.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157791 - Ruben - Thu May 29, 2008 6:01 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">That said, I'd recommend packing the left and right volumes together, rather than 2 samples. Saves at least the one add per 2 samples, and probably will save some registers too. But in that case, you would want to multiply with the volume register first, followed by the one byte sample.</td> </tr></table><span class="postbody"> So, basically, load a sample into (i.e.) r0, multiply that sample by left vol into r1, multiply the sample by right vol into r2, add them together with a 'lsl #0x10' and store? If so, how? It confused me the second I tried it 'cause I'm using all the registers.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Since you're not using a whole lot of registers even as it is, how about unrolling that loop 4 or 8 times and ldm/stm'ing the temp buffer values?</td> </tr></table><span class="postbody">Umm... I suppose you mean that I don't use too many registers within the sample loop which means that I would need to stack one or two, right? 'Cause I'm using r0-r14 (except r13) atm...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Also, make sure the temp buffer is in IWRAM. Even if it is pretty big, it's only needed during the mixer function, so it can go on the stack. Of course, if that's the only thing in your game that uses a lot of stack space, then it's just as bad as giving it a permanent chunk. But if a few other speed-critical sections can get some use out of a big stack, then there's no guilt in using it to speed up the mixer.</td> </tr></table><span class="postbody">... Huh??????</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157792 - DekuTree64 - Thu May 29, 2008 6:26 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ruben wrote:</b></span></td> </tr> <tr> <td class="quote">So, basically, load a sample into (i.e.) r0, multiply that sample by left vol into r1, multiply the sample by right vol into r2, add them together with a 'lsl #0x10' and store?</td> </tr></table><span class="postbody">
<br/>
Not quite. Before going into the sample loop, load the left and right volumes, and add them together with lsl #0x10. Then inside the sample loop, a single mla multiplies one sample with both volumes, and adds to the result. Very similar to what you're doing, just multiplying 1 sample by 2 volumes, rather than 2 samples by 1 volume. You will end up with interleaved left/right samples, but that can be sorted out in the downsampling step.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ruben wrote:</b></span></td> </tr> <tr> <td class="quote">Umm... I suppose you mean that I don't use too many registers within the sample loop which means that I would need to stack one or two, right?</td> </tr></table><span class="postbody">
<br/>
Yeah. The sample loop gets a whole lot of repetitions, so if stacking a few registers can save a few cycles per sample, do it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ruben wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">blah blah blah ... temp buffer ... IWRAM ... blah</td> </tr></table><span class="postbody">... Huh??????</span></td> </tr></table><span class="postbody">
<br/>
I'm talking about your global "S3MTmp", which seems to be the buffer that you're storing the intermediate mixed samples in before downsampling at the end. Since you have to load and store to it for every sample for every channel, putting it in fast memory saves a whole lot of cycles.
<br/>
<br/>
...but I just noticed that it's declared right there at the top, in IWRAM, so you can just leave it as is.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157793 - Ruben - Thu May 29, 2008 7:00 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Not quite. Before going into the sample loop, load the left and right volumes, and add them together with lsl #0x10. Then inside the sample loop, a single mla multiplies one sample with both...</td> </tr></table><span class="postbody">
<br/>
Tried that and it actually slowed down the code... :S Maybe because it takes double the iterations?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Yeah. The sample loop gets a whole lot of repetitions, so if stacking a few registers can save a few cycles per sample, do it.</td> </tr></table><span class="postbody">
<br/>
Theoretically, I'm supposed to be saving around 1 or 2 cycles per sample but the CPU usage (according to no$gba) is still the same as when I used str twice. Right now I'm using double samples rather than left and right at the same time and I'm stacking r0 and r1 and using then as temps (r0: sample, r1: left sample, r12: right sample) then stmia'ing them to the temp buffer but it has the same speed. Should I still stack or should I revert back to what it was?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157794 - kusma - Thu May 29, 2008 10:19 am</h4>
    <div class="postbody"><span class="postbody">Oh, there's so many things! Unsigned mixing is definately faster, but it's a bit more complex since you need to track the DC offsets per frame rendered. Also, in my modplayer, I moved the looping-logic outside of the raw mixer. You can have a look at how that's done <a class="postlink" href="http://pimpmobile.svn.sourceforge.net/viewvc/pimpmobile/trunk/src/pimp_mixer.c?view=markup" target="_blank">here</a>. So, once you've done both of those optimizations, unrolling is your next friend, since the loads and stores from your temp-buffer become much faster, and you don't get that expensive branch for every sample.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157795 - Cearn - Thu May 29, 2008 11:15 am</h4>
    <div class="postbody"><span class="postbody">Just a few small things:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">        mov        r10, r3, asr #0x02
<br/>
        and        r10, r10, #0x7F
<br/>
        mul        r10, r12, r10                @ r10 = channel vol (left) * master vol
<br/>
        mov        r10, r10, asr #0x04          @ r10 = final volume
<br/>
       
<br/>
        mov        r11, r3, asr #0x09
<br/>
        and        r11, r11, #0x7F
<br/>
        mul        r11, r12, r11                @ r11 = channel vol (right) * master vol
<br/>
        mov        r11, r11, asr #0x04          @ r11 = final volume
<br/>
</td> </tr></table><span class="postbody">
<br/>
Preload the 0x7F and use a shifted AND:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">        mov        r14, 0x7F
<br/>
<br/>
        and        r10, r14, r3, asr #2
<br/>
        mul        r10, r12, r10                @ r10 = channel vol (left) * master vol
<br/>
        mov        r10, r10, asr #0x04          @ r10 = final volume
<br/>
       
<br/>
        and        r11, r14, r3, asr #9
<br/>
        mul        r11, r12, r11                @ r11 = channel vol (right) * master vol
<br/>
        mov        r11, r11, asr #0x04          @ r11 = final volume
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">        ldr        r14, [r9]                    @ r14 = mixed data
<br/>
        mla        r14, r10, r12, r14           @ r14 = final data
<br/>
        str        r14, [r9], #0x04             @ store mixed data and increment
<br/>
<br/>
@ do right channel
<br/>
        ldr        r14, [r9]                    @ r14 = mixed data
<br/>
        mla        r14, r11, r12, r14           @ r11 = final data
<br/>
        str        r14, [r9], #0x04             @ store mixed data and increment
<br/>
</td> </tr></table><span class="postbody">
<br/>
You can combine the left/right loads and stores. Assuming r10 is free:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">        ldmia      r9, {r10, r14}                    @ Load left/right data
<br/>
        mla        r10, r10, r12, r10               @ r14 = final data
<br/>
        mla        r14, r11, r12, r14               @ r11 = final data
<br/>
        stmia      r9!, {r10, 14}                   @ store mixed data and increment
<br/>
</td> </tr></table><span class="postbody">
<br/>
About singed vs unsigned: the problem is probably the center-point. Signed data centers around 0, but in unsigned samples the zero-line is at 128. When you then add samples, the center-line shifts as well. For example, an empty unsigned sample will contain 128s. Adding two of them gives 256, which defin<span style="font-weight: bold"><span style="font-size: 15px; line-height: normal"><span style="color: red">i</span></span></span>tely ([/spelling police]) does not count as empty.
<br/>
<br/>
The true range is always [-<span style="font-style: italic">M</span>/2, +<span style="font-style: italic">M</span>/2), i.e. a signed sample (<span style="font-style: italic">s</span>). For unsigned samples (<span style="font-style: italic">u</span>), the bar is raised by <span style="font-style: italic">M</span>/2, so you have <span style="font-style: italic">s</span> = <span style="font-style: italic">u</span>-<span style="font-style: italic">M</span>/2. This should still be true after the summation.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Signed :  S = ∑(0 to n) s[i]
<br/>
vs
<br/>
Unsigned: U - M/2 =  ∑(0 to n) (u[i]-M/2)
<br/>
                U = ( ∑ u[i] ) - (n-1)*M/2
<br/>
</td> </tr></table><span class="postbody">
<br/>
In other words, you have to subtract (n-1)*M/2 from the final sum over all unsigned samples.
<br/>
<br/>
Of course, since I hardly know anything about sound programming, I could be entirely wrong here :P
<br/>
<br/>
<span style="font-weight: bold">EDIT : forgot about volume.</span>
<br/>
Things are slightly different when the samples have different volumes. This scales the center-point as well:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">U - M/2 = ∑(0 to n) V[i]*(u[i]-M/2)
<br/>
      U = ∑ V[i]*u[i] - (∑V[i])*M/2 + M/2
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
But yeah, unsigned should make things faster. The adds for the ldrsb can be combined into a single ldrb. It's also useful in the downsample loop, since clamping between 0 and a power of two can be done in two instructions rather than four.
<br/>
<br/>
Also:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ruben wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> u8        cr; //current row (+23)
<br/>
 u8        co; //current order (+24)
<br/>
 u8        oc; //order count (+25)
<br/>
 
<br/>
 tChn  pc[32]; //player channels (+26)
<br/>
<br/>
 u8        pd; //pattern delays left
<br/>
 u32       ef;     //effect flags</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
Watch your member packing (and I'm talking about struct members here &gt;_&gt;). tChn requires 32bit alignment, so it's actually at 0x28.  There is a 2-byte gap between oc and pc, as well as a 3-byte gap between pd and ef. Consider moving pd into the gap between oc and pc for a slightly smaller struct.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157796 - Ruben - Thu May 29, 2008 12:47 pm</h4>
    <div class="postbody"><span class="postbody">Wow! That was so much better than what I had expected! Thanks a MILLION guys!
<br/>
<br/>
What I ended up doing was following... uh... kusma's (?) advice on calling different functions for different things along with Cearn's ldmia/stmia suggestion. I'm not going to move onto unsigned samples 'cause I never understood how to properly mix them together so I may as well as stick to signed mode.
<br/>
<br/>
Now to figure out why the right speaker clicks... ROFL!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159170 - Ruben - Thu Jun 26, 2008 1:52 pm</h4>
    <div class="postbody"><span class="postbody">OK... umm... I went all out and thought of a faster method... this one:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.equ SND_BUFFERLEN, 304
<br/>
.equ SND_ACCBITS, 12
<br/>
<br/>
.section .iwram, "ax", %progbits
<br/>
.align
<br/>
SndTmp:
<br/>
 .space SND_BUFFERLEN*2*16/8
<br/>
.size SndTmp, .-SndTmp
<br/>
<br/>
.section .iwram, "ax", %progbits
<br/>
.global SndMix
<br/>
.extern sa__
<br/>
.align
<br/>
.arm
<br/>
<br/>
@ r0: samples to mix
<br/>
SndMix:
<br/>
<br/>
r14 is a pointer to the channels, r12 is the number of channels left (16 now), and r0 is the samples to mix
<br/>
...
<br/>
<br/>
.L1:
<br/>
   ldrb      r11, [r14]         @ \
<br/>
   tst      r11, #0x01         @  make sure channel is active
<br/>
   beq      .L5            @ /
<br/>
   
<br/>
   stmfd      sp!, {r0,r12,r14}
<br/>
   
<br/>
   ldrb      r1, [r14, #0x02]      @ \
<br/>
   ldrb      r2, [r14, #0x03]      @  r1: l/r volumes
<br/>
   add      r1, r1, r2, lsl #0x10      @ /
<br/>
   ldmib      r14, {r2-r4}         @ r2 = sample pointer
<br/>
                     @ r3 = position
<br/>
                     @ r4 = increment
<br/>
   add      r2, r2, #0x10
<br/>
   ldr      r5, [r2, #-0x04]      @ r5 = length
<br/>
   
<br/>
   ldr      r6, =SndTmp         @ r6 = pointer to temp buffer
<br/>
   add      r7, r2, r3, lsr #SND_ACCBITS
<br/>
   add      r14, r4, lsr #SND_ACCBITS
<br/>
   
<br/>
   mla      r8, r4, r0, r3
<br/>
   cmp      r5, r8, lsr #(SND_ACCBITS-2)
<br/>
   blt      .L2
<br/>
<br/>
.Lfast:
<br/>
   ldmia       r6, {r8-r11}         @ \
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r8, r12, r1, r8         @  |
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r9, r12, r1, r9         @  do 4 samples
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r10, r12, r1, r10      @  |
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r11, r12, r1, r11      @ /
<br/>
   stmia       r6!, {r8-r11}         @ store mixed samples
<br/>
   subs      r0, r0, #0x04
<br/>
   bhi      .Lfast
<br/>
   
<br/>
   mov      r7, r0, lsl #0x02      @ \
<br/>
   mla      r3, r4, r7, r3         @  save new position
<br/>
   b      .L4
<br/>
<br/>
.L2:
<br/>
   ldr       r8, [r6]         @ get mixed samples
<br/>
   ldrsb      r12, [r7], r14         @  get the sample
<br/>
   mla      r8, r12, r1, r8         @ get final value
<br/>
   str       r8, [r6], #0x04         @ store mixed samples
<br/>
   
<br/>
   add      r3, r3, r4
<br/>
   cmp      r5, r3, lsr #SND_ACCBITS
<br/>
   ble      .L6
<br/>
<br/>
.L3:
<br/>
   subs      r0, r0, #0x01
<br/>
   bhi      .L2
<br/>
<br/>
.L4:
<br/>
   ldmfd      sp!, {r0,r12,r14}
<br/>
   str      r3, [r14, #0x08]      @ store position
<br/>
<br/>
.L5:
<br/>
   add      r14, r14, #0x20         @ go to the next channel
<br/>
   subs      r12, r12, #0x01         @ channels left--
<br/>
   bne      .L1
<br/>
   b      .L7            @ if == 0, skip the EOF handler
<br/>
<br/>
.L6:
<br/>
   ldrh      r8, [r2, #-0x0E]      @ get sample stat
<br/>
   tst      r8, #0x4000         @ check if it's looping
<br/>
   ldrne      r3, [r2, #-0x08]      @  get loop point
<br/>
   movne      r3, r3, lsl #SND_ACCBITS   @  put it in FP format
<br/>
   bne      .L3            @  keep looping
<br/>
   
<br/>
   ldr      r7, [sp, #-0x04]
<br/>
   bic      r8, r8, #0x01         @ otherwise stop channel
<br/>
   strh      r8, [r7]         @ store channel control
<br/>
   b      .L4            @  stop looping
<br/>
...
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I thought that by incrementing by a set value using "ldrsb r0, [r1], r2", it would speed it up but it seems to be reading... ... ... garbage to say the least. Any ideas why?
<br/>
<br/>
I also changed the channel structure around like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct channel {
<br/>
 u8      sf;   //status flags               (+00)
<br/>
 s8      pa;   //panning               (+01)
<br/>
 u8      lv;   //left  vol   (0-&gt;64)            (+02)
<br/>
 u8      rv;   //right vol   (0-&gt;64)            (+03)
<br/>
 voice*      wp;   //voice pointer               (+04)
<br/>
 u32      po;   //position               (+08)
<br/>
 u32      in;   //increment               (+0C)
<br/>
 u8      wl;   //waits left               (+10)
<br/>
 u8      pr;   //program               (+11)
<br/>
 u8      vo;   //volume               (+12)
<br/>
 u8      co;   //chn. origin               (+13)
<br/>
 u8*      nb;   //next byte               (+14)
<br/>
 u32      ja;   //jump address               (+18)
<br/>
 u8      at;   //attack envelope            (+1C)
<br/>
 u8      de;   //decay envelope            (+1D)
<br/>
 u8      su;   //sustain envelope            (+1E)
<br/>
 u8      re;   //release envelope            (+1F)
<br/>
} channel;</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159171 - eKid - Thu Jun 26, 2008 2:07 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.Lfast:
<br/>
   ldmia       r6, {r8-r11}         @ \
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r8, r12, r1, r8         @  |
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r9, r12, r1, r9         @  do 4 samples
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r10, r12, r1, r10      @  |
<br/>
   ldrsb      r12, [r7], r14         @  |
<br/>
   mla      r11, r12, r1, r11      @ /
<br/>
   stmia       r6!, {r8-r11}         @ store mixed samples
<br/>
   subs      r0, r0, #0x04
<br/>
   bhi      .Lfast 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I can't really understand how this works? Isn't r7 a fixed point number?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159172 - Ruben - Thu Jun 26, 2008 2:11 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>eKid wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
...
<br/>
I can't really understand how this works? Isn't r7 a fixed point number?</td> </tr></table><span class="postbody">
<br/>
<br/>
r7 = sound wave position + (position &gt;&gt; accuracy)
<br/>
r14 = increment &gt;&gt; accuracy
<br/>
<br/>
:P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159173 - Ruben - Thu Jun 26, 2008 2:19 pm</h4>
    <div class="postbody"><span class="postbody">Oh, I just found a small bug... "add r14, r4, lsr #SND_ACCBITS" should be "mov r14, r4, lsr #SND_ACCBITS". But it's still buggy...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159174 - eKid - Thu Jun 26, 2008 2:23 pm</h4>
    <div class="postbody"><span class="postbody">Wouldn't shifting out all the accuracy bits cause a bunch of noise/failure? :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159176 - Ruben - Thu Jun 26, 2008 2:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>eKid wrote:</b></span></td> </tr> <tr> <td class="quote">Wouldn't shifting out all the accuracy bits cause a bunch of noise/failure? :)</td> </tr></table><span class="postbody">
<br/>
Noise? Failure? o.O *confused*</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159179 - Cearn - Thu Jun 26, 2008 3:51 pm</h4>
    <div class="postbody"><span class="postbody">What eKid means is that if you shift down before adding, the additions won't be in fixed point anymore and you stand to lose a lot of precision that way.
<br/>
<br/>
It's similar to this situation:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">float a= 0.5;
<br/>
int b= int(a+a+a+a);   // b = 0.5+0.5+0.5+0.5 = 2
<br/>
<br/>
int a= 0.5;            // cast to int removes sub-integer accuracy
<br/>
int b = a+a+a+a;       // b = 0+0+0+0 = 0
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Also, 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    ldrb    r11, [r14]
<br/>
    ldrb    r1, [r14, #0x02]
<br/>
    ldrb    r2, [r14, #0x03]
<br/>
    add     r1, r1, r2, lsl #0x10
<br/>
</td> </tr></table><span class="postbody">
<br/>
works a little faster like this: (10 cycles vs 6)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    ldr     r11, [r14]              // R L x x
<br/>
    mov     r1, r11, lsr #16        // 0 0 R L
<br/>
    orr     r1, r1, r1, lsl #8      // 0 R x L
<br/>
    bic     r1, r1, #0xFF00         // 0 R 0 L
<br/>
</td> </tr></table><span class="postbody">
<br/>
And if you want to be really 1337, you can simply start with the optimal arrangement in the struct. That said, I doubt this is really the place where you can gain that much speed. You'll probably gain more from switching to unsigned data.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#159213 - Ruben - Fri Jun 27, 2008 5:00 am</h4>
    <div class="postbody"><span class="postbody">Nice... that is some serious thinking you can do! :P Anyway... is there anyway to contact you outside of the forum for code optimization? (I don't want to disclose the source just yet! :P) I'm pretty sure there's more room for optimization in the actual "sound.c" file so yeah.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
