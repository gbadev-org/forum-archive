<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>strcat() is assembly - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>ASM > strcat() is assembly</h2>
<div id="posts">
<div class="post">
    <h4>#44627 - ymalik - Fri Jun 03, 2005 7:40 pm</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
I am new to ARM 32 assembly.  For practice, I am implementing many common functions in assembly.  I am trying to implement strcat().  Here is the code.  When I call the functions, the screen just blanks out:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   .thumb
<br/>
   .thumb_func
<br/>
   .align
<br/>
   .global strcat2
<br/>
   .type   strcat2,function
<br/>
<br/>
/*
<br/>
 * r0: first string
<br/>
   r1: string to append to first string
<br/>
   r2: where to store two appended strings
<br/>
<br/>
   C-code:
<br/>
   strcat2(const char *one, const char *two, const char *result)
<br/>
   {
<br/>
      char *temp_one, *temp_two, *temp_result;
<br/>
<br/>
      temp_one = one;
<br/>
      temp_two = two;
<br/>
      temp_result = result;
<br/>
<br/>
      while(*temp_one)
<br/>
      {
<br/>
         *temp_result = *temp_one;
<br/>
         temp_one++;
<br/>
         temp_result++;
<br/>
      }
<br/>
      
<br/>
      while(*temp_two)
<br/>
      {
<br/>
         *temp_result = *temp_two;
<br/>
         temp_result++;
<br/>
         temp_two++;
<br/>
      }
<br/>
      
<br/>
      *temp_result = 0;
<br/>
   }
<br/>
 */
<br/>
strcat2:
<br/>
   push {r0-r3}   @ r3 used to store character for comparison
<br/>
                  @ r0-r2 store addresses of constant pointers, but they
<br/>
                  @ will changed within the function, so push them as well
<br/>
loop1:
<br/>
   ldr r3, [r0]
<br/>
   cmp r3, #0
<br/>
   beq loop2
<br/>
   str r3, [r2]
<br/>
   add r0, r0, #1
<br/>
   add r2, r2, #1
<br/>
   b loop1
<br/>
   
<br/>
loop2:
<br/>
   ldr r3, [r1]
<br/>
   cmp r3, #0
<br/>
   beq done
<br/>
   str r3, [r2]
<br/>
   add r1, r1, #1
<br/>
   add r2, r2, #1
<br/>
   b loop2
<br/>
   
<br/>
done:
<br/>
   str r3, [r2]
<br/>
   pop {r0-r3}
<br/>
   mov pc, r14
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And the prototype:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void strcat2(const char *, const char *, const char *);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks,
<br/>
Yasir</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44629 - DekuTree64 - Fri Jun 03, 2005 7:55 pm</h4>
    <div class="postbody"><span class="postbody">You should be using ldrsb/strb instead of ldr/str. ldr loads 4 bytes, so you'll most likely miss your single-byte null terminator.
<br/>
<br/>
You could use ldrb instead of ldrsb, since all the normal ascii characters are below 128, but just for exactness to the original C code, the chars are signed.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44633 - strager - Fri Jun 03, 2005 8:07 pm</h4>
    <div class="postbody"><span class="postbody">Your declaration is incorrect: remove the last 'const'.  Also, you need to use LDRB or LDRSB, like Deku stated in his post.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44634 - ymalik - Fri Jun 03, 2005 8:08 pm</h4>
    <div class="postbody"><span class="postbody">Thank you.  I will try that soon.  Question though:  I followed the tutorial at <a href="http://www.ee.ic.ac.uk/pcheung/teaching/ee2_computing/Lecture_7.pdf," target="_blank">http://www.ee.ic.ac.uk/pcheung/teaching/ee2_computing/Lecture_7.pdf,</a> and they use stmda r13!, {r0-r3} to push onto the stack.  However, the assembler did not accept that, and I had to use push.  Does stmda not work under GCC?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44636 - ymalik - Fri Jun 03, 2005 8:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>strager wrote:</b></span></td> </tr> <tr> <td class="quote">Your declaration is incorrect: remove the last 'const'.</td> </tr></table><span class="postbody">
<br/>
I don't understand.  The pointer is not changing; just the value the pointer is pointing at is changing.  Is this correct?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44637 - strager - Fri Jun 03, 2005 8:11 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Thank you.  I will try that soon.  Question though:  I followed the tutorial at <a href="http://www.ee.ic.ac.uk/pcheung/teaching/ee2_computing/Lecture_7.pdf," target="_blank">http://www.ee.ic.ac.uk/pcheung/teaching/ee2_computing/Lecture_7.pdf,</a> and they use stmda r13!, {r0-r3} to push onto the stack.  However, the assembler did not accept that, and I had to use push.  Does stmda not work under GCC?</td> </tr></table><span class="postbody">
<br/>
<br/>
That is an ARM statement.  You must replace .thumb with .arm, and have the option -mthumb-interwork in your commandline (you should already).  Clear enough?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44640 - sajiimori - Fri Jun 03, 2005 8:29 pm</h4>
    <div class="postbody"><span class="postbody">Put the const before the * to say that the data the pointer points to is const.  Put the const after the * to say that the pointer itself is const.  The latter form is rarely used.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44647 - DekuTree64 - Fri Jun 03, 2005 9:53 pm</h4>
    <div class="postbody"><span class="postbody">You don't even need to push/pop r0-r3, because the calling function expects them to be trashed.
<br/>
<br/>
Another little optimization is that you can increment the pointers right in the load/store instructions:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ldrsb   r3, [r0], #1   @ Load signed byte, then increment r0
<br/>
strb    r3, [r2], #1   @ Store byte (signed or unsigned), inc r2</td> </tr></table><span class="postbody"><br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44648 - strager - Fri Jun 03, 2005 10:10 pm</h4>
    <div class="postbody"><span class="postbody">Hmm. I thought that shifted the register instead.  *goes to optimize some more code*</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44664 - ymalik - Sat Jun 04, 2005 12:25 am</h4>
    <div class="postbody"><span class="postbody">I have some more questions about what you guys said, but let me get this over with first.  Here is the new code.  It still does not work:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
strcat2:
<br/>
   push {r0-r3}   @ r3 used to store character for comparison
<br/>
                  @ r0-r2 store addresses of constant pointers, but they
<br/>
                  @ will changed within the function, so push them as well
<br/>
loop1:
<br/>
   ldrb r3, [r0]
<br/>
   cmp r3, #0
<br/>
   beq loop2
<br/>
   strb r3, [r2]
<br/>
   add r0, r0, #1
<br/>
   add r2, r2, #1
<br/>
   b loop1
<br/>
   
<br/>
loop2:
<br/>
   ldrb r3, [r1]
<br/>
   cmp r3, #0
<br/>
   beq done
<br/>
   strb r3, [r2]
<br/>
   add r1, r1, #1
<br/>
   add r2, r2, #1
<br/>
   b loop2
<br/>
   
<br/>
done:
<br/>
   strb r3, [r2]
<br/>
   pop {r0-r3}
<br/>
   mov pc, r14
<br/>
</td> </tr></table><span class="postbody">
<br/>
Doing ldrsb gives me the following assembler error:
<br/>
Error: syntax: ldrs[b] Rd, [Rb, Ro] -- `ldrsb r3,[r0]'</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44675 - strager - Sat Jun 04, 2005 1:25 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Doing ldrsb gives me the following assembler error:
<br/>
Error: syntax: ldrs[b] Rd, [Rb, Ro] -- `ldrsb r3,[r0]'</td> </tr></table><span class="postbody">
<br/>
<br/>
Try using "ldrsb r3, [r0, #0]".  That might solve the little problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44678 - ymalik - Sat Jun 04, 2005 2:15 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>strager wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Doing ldrsb gives me the following assembler error:
<br/>
Error: syntax: ldrs[b] Rd, [Rb, Ro] -- `ldrsb r3,[r0]'</td> </tr></table><span class="postbody">
<br/>
<br/>
Try using "ldrsb r3, [r0, #0]".  That might solve the little problem.</span></td> </tr></table><span class="postbody">
<br/>
That doesn't work either.  I think the assembler is giving us an hint: it expects a register to be the third parameter to ldrsb</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44679 - strager - Sat Jun 04, 2005 2:19 am</h4>
    <div class="postbody"><span class="postbody">Try an ldrb instead and see if that works.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44701 - ymalik - Sat Jun 04, 2005 1:23 pm</h4>
    <div class="postbody"><span class="postbody">Actually, all I had to do was replace mov pc, r14 with bx lr.  I don't understand why mov pc, r14 did not work.  Doesn't r14 contain the return address?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44708 - strager - Sat Jun 04, 2005 2:29 pm</h4>
    <div class="postbody"><span class="postbody">Ah: You can only access registers r0-r7 with most assembler statements (to save space).  mov is one of those statements.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44727 - poslundc - Sat Jun 04, 2005 5:56 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Actually, all I had to do was replace mov pc, r14 with bx lr.  I don't understand why mov pc, r14 did not work.  Doesn't r14 contain the return address?</td> </tr></table><span class="postbody">
<br/>
<br/>
BX allows you to exchange instruction sets between ARM and Thumb depending on bit zero of the return address. This is the necessary instruction to use when returning from globally-accessible functions if you are interworking ARM and Thumb code.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>strager wrote:</b></span></td> </tr> <tr> <td class="quote">Ah: You can only access registers r0-r7 with most assembler statements (to save space). mov is one of those statements.</td> </tr></table><span class="postbody">
<br/>
<br/>
The reduced register set only applies in Thumb mode, not ARM mode, and the MOV instruction can still access all registers.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44745 - ymalik - Sat Jun 04, 2005 10:43 pm</h4>
    <div class="postbody"><span class="postbody">I actually got the bx lr idea from your posprintf function.  We, or at least I, used your function heavily in our senior design project.  It is very nice.
<br/>
I have some questions:
<br/>
<br/>
1. How are parameters passed to a function?
<br/>
2. Dekutree63 said that I don't need the push and pop calls.  Since registers represent a global state on a machine, why was it that when I removed the push and pop calls, the strcat function still worked fine?  Since I am incrementing the pointers in the two loops, shouldn't the pointers return as pointing to different values without push and pop calls?
<br/>
3. What memory location does the stack begin?
<br/>
4. Since code is originally compiled into the ROM, how is that you can have some functions placed in IWRAM?  Is the function copied into IWRAM when executed?
<br/>
5. What is "interworking ARM and Thumb code?"
<br/>
<br/>
Thanks,
<br/>
Yasir</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44746 - Quirky - Sat Jun 04, 2005 11:01 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">1. How are parameters passed to a function?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The first 4 arguments are in registers r0-r3, the rest on the stack in the order that makes most sense... (in other words I don't remember without looking at an example of something that works!)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">2. Dekutree63 said that I don't need the push and pop calls.  Since registers represent a global state on a machine, why was it that when I removed the push and pop calls, the strcat function still worked fine?  Since I am incrementing the pointers in the two loops, shouldn't the pointers return as pointing to different values without push and pop calls?</td> </tr></table><span class="postbody">
<br/>
<br/>
GCC will save certain register (check the docs, but I think it's r4-r7?) when you call from one C function to some other function. You have to promise to keep the rest of the registers untouched. Or if you do touch them, you need to push them first and pop them after. Would that explain it? Perhaps you don't mess up more registers - or possibly worse, you use them, but then after returning the caller doesn't REUSE them. That's a tricky bug to spot.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">3. What memory location does the stack begin?</td> </tr></table><span class="postbody">
<br/>
<br/>
The end of IWRAM, or a few hundred bytes from the end IIRC. And it counts back down to the star tof IWRAM.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">4. Since code is originally compiled into the ROM, how is that you can have some functions placed in IWRAM?  Is the function copied into IWRAM when executed?</td> </tr></table><span class="postbody">
<br/>
<br/>
The code is compiled to a section. This section is usually .text, but you can specify .iwram section (or eram). crt0 copies your code and data to the correct place in IWRAM or EWRAM when the program starts, the linker and link script has made sure the addresses are all correct in the actual code (IYSWIM).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">5. What is "interworking ARM and Thumb code?"</td> </tr></table><span class="postbody">
<br/>
<br/>
Calling arm from thumb, or vice versa, and then returning to the arm or thumb routine. The processor needs to know if it should change modes. This is basically summed up by the "bx lr" op, (anything else required?) which if you only go arm-arm or thumb-thumb can be substituted by any pc altering operation (in arm you could do ldmia r0!,{r9-r12,pc} for example instead of ldmia and bx lr).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44747 - DekuTree64 - Sat Jun 04, 2005 11:39 pm</h4>
    <div class="postbody"><span class="postbody">The compiler will preserve r0-r3, r12 and lr (r14) before calling a function. The <a class="postlink" href="http://www.arm.com/miscPDFs/8031.pdf" target="_blank">APCS</a> (ARM Procedure Call Standard) says so.
<br/>
That also means that if you want to call a C function from your assembly code, you have to preserve those too (or just make sure your code doesn't expect them to be the same afterward), because the compiled C function expects you to follow the APCS like it does.
<br/>
<br/>
I'd recommend looking at the Crt0 to get a better feel for how everything starts up. Basically when you turn the system on, the CPU starts executing from address 0x8000000, in ARM mode. All the initialization of the stack pointer and memory is done manually through code, using lots of constants that are defined by the linker according to the linkscript.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44749 - ymalik - Sun Jun 05, 2005 12:10 am</h4>
    <div class="postbody"><span class="postbody">Much thanks for your clear responses.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">BX allows you to exchange instruction sets between ARM and Thumb depending on bit zero of the return address. This is the necessary instruction to use when returning from globally-accessible functions if you are interworking ARM and Thumb code.</td> </tr></table><span class="postbody">
<br/>
Since the last bit determines whether returning to ARM or Thumb code, ARM (or Thumb) functions have only even (or odd) return addresses, correct?  Why is this so?  Isn't ARM and Thumb code aligned on even addresses?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44790 - poslundc - Sun Jun 05, 2005 9:42 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Much thanks for your clear responses.
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">BX allows you to exchange instruction sets between ARM and Thumb depending on bit zero of the return address. This is the necessary instruction to use when returning from globally-accessible functions if you are interworking ARM and Thumb code.</td> </tr></table><span class="postbody">
<br/>
Since the last bit determines whether returning to ARM or Thumb code, ARM (or Thumb) functions have only even (or odd) return addresses, correct?  Why is this so?  Isn't ARM and Thumb code aligned on even addresses?</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, all code is aligned on even addresses. Thumb code is aligned on 2 bytes, and ARM code on 4 bytes. This means that the least-significant bit of the address doesn't serve any actual purpose, since you can't have code located at an odd-number address anyway. So instead it's made to serve a purpose: that extra bit of information is used to encode whether the code at the destination address should be run in ARM or Thumb mode.
<br/>
<br/>
So in an odd-number address, the least-significant bit is zeroed when determining the actual address to branch to, but its presence is used to determine that the code at the new memory location is Thumb code and not ARM code.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45055 - FluBBa - Tue Jun 07, 2005 11:12 am</h4>
    <div class="postbody"><span class="postbody">Can this be more like it?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
strcat2:
<br/>
                  @ r3 used to store character for comparison
<br/>
                  @ r0-r2 store addresses of constant pointers
<br/>
loop1:
<br/>
   ldrb r3, [r0],#1
<br/>
   cmp r3, #0
<br/>
   strneb r3, [r2],#1
<br/>
   bne loop1
<br/>
   
<br/>
loop2:
<br/>
   ldrb r3, [r1],#1
<br/>
   strb r3, [r2],#1
<br/>
   cmp r3, #0
<br/>
   bne loop2
<br/>
<br/>
   bx lr
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45061 - strager - Tue Jun 07, 2005 1:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>FluBBa wrote:</b></span></td> </tr> <tr> <td class="quote">Can this be more like it?</td> </tr></table><span class="postbody">
<br/>
From what I see, yes.  Good job, it is both shorter and readable. :-)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45318 - ymalik - Thu Jun 09, 2005 4:09 pm</h4>
    <div class="postbody"><span class="postbody">The above only works in ARM mode.  Is something similar possible in Thumb mode?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45324 - poslundc - Thu Jun 09, 2005 5:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">The above only works in ARM mode.  Is something similar possible in Thumb mode?</td> </tr></table><span class="postbody">
<br/>
<br/>
Have a look at <a class="postlink" href="http://www.danposluns.com/gbadev/posprintf/index.html" target="_blank">posprintf</a>, which, among other things, is a string parser/copier, and includes Thumb source when you download it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45338 - Miked0801 - Thu Jun 09, 2005 7:37 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The above only works in ARM mode. Is something similar possible in Thumb mode?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Just need to replace the 1 conditonal compile (strneb) statement with a cmp and branch and yes it it'll be thumb compliant.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45364 - ymalik - Fri Jun 10, 2005 12:13 am</h4>
    <div class="postbody"><span class="postbody">And you also can't have ldrb r3, [r0],#1.  But then the code degenerates to my old code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45371 - Miked0801 - Fri Jun 10, 2005 1:00 am</h4>
    <div class="postbody"><span class="postbody">You sure?  Oh wait, putting the immediate on the inside doesn't update the pointer does it.  Hmmm.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45494 - tepples - Sat Jun 11, 2005 5:48 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Just need to replace the 1 conditonal compile (strneb) statement with a cmp and branch and yes it it'll be thumb compliant.</td> </tr></table><span class="postbody">
<br/>
Shouldn't a Thumb assembler see 'strneb' and know to generate a 'beq' followed by 'strb'? MIPS assemblers like to break up complicated instructions using a predefined set of macros; in fact, the MIPS architecture specifies a register '$at' that's reserved for use by macros.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45679 - Miked0801 - Mon Jun 13, 2005 7:37 pm</h4>
    <div class="postbody"><span class="postbody">$at - now that brings back memories of programming for the PS1.  Lol.
<br/>
<br/>
And yes, a great assembler might do this.  I doubt our would though.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
