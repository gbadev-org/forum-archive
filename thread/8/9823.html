<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>need help getting TONCs intterrupt handler to work in vham - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > need help getting TONCs intterrupt handler to work in vham</h2>
<div id="posts">
<div class="post">
    <h4>#86606 - Ant6n - Thu Jun 08, 2006 6:31 am</h4>
    <div class="postbody"><span class="postbody">Hey,
<br/>
<br/>
I am disturbing the peace and quietness in these forums again to bring up a question of the past...
<br/>
I am trying to get a little library working (to be used in some class); I would like it to be standalone, so libga is not much of an option.
<br/>
For the time being I would like to use tonc's intterrupt handler,
<br/>
<a href="http://user.chem.tue.nl/jakvijn/tonc/interrupts.htm," target="_blank">http://user.chem.tue.nl/jakvijn/tonc/interrupts.htm,</a> because as I understand it can handle multiple interrupts, but they are not nested (i.e. they are run one after another).
<br/>
It doesnt seem to do anything. Right now I am using visual ham (as far as I know it shouldnt make much of a difference what compiler to use).
<br/>
<br/>
I have the handler, 'irqhandler.S'
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   .extern interrupttable
<br/>
<br/>
    .section .iwram,"ax",%progbits
<br/>
    .code   32
<br/>
    .align  2
<br/>
    .global interrupthandler
<br/>
interrupthandler:
<br/>
@ (1)
<br/>
    @ Single interrupts support
<br/>
    mov     r3, #0x04000000         @ REG_BASE
<br/>
    ldr     r2, [r3, #0x200]        @ Read REG_IE and REG_IF
<br/>
    and     r1, r2, r2, lsr #16     @ r1 =  REG_IE &amp; REG_IF
<br/>
@ (2)
<br/>
    ldrh    r2, [r3, #-8]           @\mix up with BIOS irq flags at 3007FF8h,
<br/>
    orr     r2, r2, r1              @ aka mirrored at 3FFFFF8h, this is required
<br/>
    strh    r2, [r3, #-8]           @/when using the (VBlank)IntrWait functions
<br/>
<br/>
@ (3)
<br/>
    add     r3, r3, #0x200
<br/>
    ldr     r2, =interrupttable
<br/>
@ V-Blank Interrupt
<br/>
    ands    r0, r1, #0x0001
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ H-Blank Interrupt
<br/>
    ands    r0, r1, #0x0002
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ V Counter Interrupt
<br/>
    ands    r0, r1, #0x0004
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ Timer 0 Interrupt
<br/>
    ands    r0, r1, #0x0008
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
    @ Timer 1 Interrupt
<br/>
    ands    r0, r1, #0x0010
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ Timer 2 Interrupt
<br/>
    ands    r0, r1, #0x0020
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ Timer 3 Interrupt
<br/>
    ands    r0, r1, #0x0040
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ Serial Communication  Interrupt
<br/>
    ands    r0, r1, #0x0080
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ DMA0 Interrupt
<br/>
    ands    r0, r1, #0x0100
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ DMA1 Interrupt
<br/>
    ands    r0, r1, #0x0200
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ DMA2 Interrupt
<br/>
    ands    r0, r1, #0x0400
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ DMA3 Interrupt
<br/>
    ands    r0, r1, #0x0800
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ Key Interrupt
<br/>
    ands    r0, r1, #0x1000
<br/>
    bne     .Ljump_intr
<br/>
    add     r2, r2, #4
<br/>
@ Cart Interrupt
<br/>
    ands    r0, r1, #0x2000
<br/>
    strneb  r0, [r3, #0x84-0x200] @ Stop  sound if cart removed (REG_SOUNDCNT_X)
<br/>
.Lloop:
<br/>
    bne     .Lloop                  @ Infinite  loop if cart removed
<br/>
@ (4)
<br/>
.Ljump_intr:
<br/>
    strh    r0, [r3, #2]            @ Acknowlegde int (will clear REG_IF)
<br/>
    ldr     r0, [r2]                @ Jump  to user IRQ process
<br/>
    bx      r0
<br/>
<br/>
<br/>
    .align  2
<br/>
    .pool
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
and the lib_interrupt.c
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "lib_interrupt.h"
<br/>
#include "lib_type.h"
<br/>
<br/>
<br/>
fnptr interrupttable[14];
<br/>
extern fnptr interrupthandler;
<br/>
extern fnptr hblank;
<br/>
<br/>
void irq_set(int flags, fnptr irq_handle, int priority)
<br/>
{
<br/>
   int i;
<br/>
   for(i = 0; i &lt; 14; i++)
<br/>
   {
<br/>
      if(flags &amp; BIT(i))
<br/>
         interrupttable[i] = irq_handle;
<br/>
   }
<br/>
   REG_IRQ_HANDLER = interrupthandler;
<br/>
   REG_IME  = 0;
<br/>
   REG_IE |= flags;
<br/>
   REG_IME = 1;
<br/>
}
<br/>
<br/>
void irq_disable(int flags)
<br/>
{
<br/>
   REG_IME = 0;
<br/>
   REG_IE &amp;= ~flags;
<br/>
   REG_IME = 1;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
and some main.c
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include "lib_math.h"
<br/>
#include "lib_time.h"
<br/>
#include "lib_register.h"
<br/>
#include "lib_interrupt.h"
<br/>
<br/>
fnptr* IntrTable;
<br/>
<br/>
<br/>
void WaitForVblank(void)
<br/>
{
<br/>
   while(!(REG_DISPSTAT &amp; 1));
<br/>
   while(REG_DISPSTAT &amp; 1);
<br/>
}
<br/>
<br/>
void hblank(void)
<br/>
{
<br/>
   *(vu16*)0x05000000 ^= 0x7FFF;
<br/>
}
<br/>
<br/>
<br/>
int main(void)
<br/>
{
<br/>
    unsigned char x,y;
<br/>
    REG_DISPCNT = (4 | 1024);
<br/>
   *(vu16*)0x05000000 = 31*32;
<br/>
    for(x = 0; x &lt; 240; x++)
<br/>
        for(y = 0; y &lt; 160; y++)
<br/>
            ((vu16*)0x06000000)[x+ y * 240] = 0;
<br/>
    //set up our interrupt
<br/>
   REG_DISPSTAT = 32 | (80 &lt;&lt; 8);
<br/>
   irq_set(4,hblank,0);
<br/>
    while(1)
<br/>
   {
<br/>
      WaitForVblank();
<br/>
      //*(vu16*)0x05000000 = 31*32;
<br/>
   }
<br/>
   return 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
this code should basicly invert the backdrop coloer in mode 4 every 80th scanline, so it should flash a lot. It doesnt. If I set the little 'hblank' function directly as the handler, then it does. I somehow suspect there might be a general problem here. As far as i know ham supports interworking, so I am kind of stuck... any ideas?
<br/>
<br/>
thank you
<br/>
Anton Dubrau</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86621 - Cearn - Thu Jun 08, 2006 9:22 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ant6n wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">fnptr interrupttable[14];
<br/>
extern fnptr interrupthandler;
<br/>
extern fnptr hblank;
<br/>
<br/>
void irq_set(int flags, fnptr irq_handle, int priority)
<br/>
{
<br/>
   int i;
<br/>
   for(i = 0; i &lt; 14; i++)
<br/>
   {
<br/>
      if(flags &amp; BIT(i))
<br/>
         interrupttable[i] = irq_handle;
<br/>
   }
<br/>
   REG_INTMAIN = interrupthandler;
<br/>
   REG_IME  = 0;
<br/>
   REG_IE |= flags;
<br/>
   REG_IME = 1;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">interrupthandler is not a function pointer, it is a function. The way it's set up now, interrupthandler is seen as a variable containing an address of a function, where in fact it's an instruction. Use the proper declaration, with attributes:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__attribute__((section(".iwram"), long_call)) void interrupthandler(void);
<br/>
</td> </tr></table><span class="postbody">
<br/>
Do the same for hblank(). 
<br/>
<br/>
As a side note, it may be better to use libgba's or pern's irq-handler; while this one can do multiple interrupts, it's not exactly safe. And, yes, the obligatory note on
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    unsigned char x,y; </td> </tr></table><span class="postbody">Ints please. Anything else just slows things down unnecessarily.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#86724 - Ant6n - Thu Jun 08, 2006 8:11 pm</h4>
    <div class="postbody"><span class="postbody">thank you; it works beautifully now. I also switched to perns handler.
<br/>
Btw, is there information (i.e. a tutorial) on the ominous __attribute__'s
<br/>
or things like the inline assembler (I still try to figure out whether 
<br/>
they can be dependent on whether the code around it is thumb or arm...) ?
<br/>
thx
<br/>
anton</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
