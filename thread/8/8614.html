<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Can this be optimized better? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Can this be optimized better?</h2>
<div id="posts">
<div class="post">
    <h4>#72268 - aaronphughes - Fri Feb 17, 2006 8:04 am</h4>
    <div class="postbody"><span class="postbody">I have the following code that calculates an IP checksum, as in the checksum found in an IP header. I have included the code. Can it be optimzed any better?
<br/>
<br/>
Thanks,
<br/>
AH
<br/>
<br/>
<br/>
b MainFunction
<br/>
<br/>
<br/>
UnitTest1:
<br/>
        @DCW    0x0100, 0xF203, 0xF4F5, 0xF6F7
<br/>
        @DCW    0x0000, 0x0000, 0x0000, 0x0000	;; ChkSum = 0x210E
<br/>
<br/>
UnitTest2:
<br/>
        @DCW    0x45C0, 0x0044, 0xad22, 0x0159
<br/>
        @DCW    0xAC14, 0x7143, 0xE000, 0x0005	;; ChkSum = 0x0E22
<br/>
<br/>
UnitTest3:
<br/>
        @DCW    0x45C0, 0x0044, 0xDC15, 0x0159
<br/>
        @DCW    0xAC14, 0x7142, 0xE000, 0x0005	;; ChkSum = 0xDF2F
<br/>
<br/>
MainFunction:
<br/>
<br/>
<br/>
<br/>
        ldr     R1,=UnitTest1		;; This is the ADDRESS of my UnitTest Data
<br/>
        ldr     R2,=8               ;; Size of the array of 16 bit words
<br/>
<br/>
        mov     R3,#0               ;; clear this guy out
<br/>
        ldr     R4,=0xFFFF          ;; MASK for lower 16 bits
<br/>
<br/>
lbl_AddTheData1:
<br/>
<br/>
        ldr     R5,[R1]+2!,			;; get value @ R1, put into R4, inc R1 by 2 - moves to next word
<br/>
        and     R5, R5, R4			;; only want lower 16 bits
<br/>
        add     R3, R3, R5			;; sum these values
<br/>
<br/>
        subs    R2, R2, 1			;; dec by 1
<br/>
        bne     lbl_AddTheData1		;; Repeat until we hit the end of the array
<br/>
<br/>
lbl_AdditionComplete:
<br/>
<br/>
        ;;mov     R2, R3, LSR #16		;; The upper 16-bits are the carries
<br/>
        ;;add     R3, R3, R2			;; Add the carries to the sum in R3
<br/>
		add     R3, R3, R3 LSR #16		;; The above two lines in one command
<br/>
<br/>
        EOR     R3, R3, R4			;; NOT R3
<br/>
        and     R3, R3, R4			;; Only want the lower 16-bits
<br/>
<br/>
EndOfProgram:
<br/>
<br/>
B EndOfProgram<br/>_________________<br/><a href="mailto:urpNO_SPAM_MAN@canerdian.ca">urpNO_SPAM_MAN@canerdian.ca</a>
<br/>
<a href="http://www.canerdian.ca" target="_blank">http://www.canerdian.ca</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#72277 - FluBBa - Fri Feb 17, 2006 9:18 am</h4>
    <div class="postbody"><span class="postbody">use LDRH for reading 16bit instead of 32bit.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#72821 - strager - Tue Feb 21, 2006 11:57 pm</h4>
    <div class="postbody"><span class="postbody">Here is what I have come up with.  I tried it with the first data set (on paper), and it yeilds the correct results.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
MainFunction:       ; Optimized for speed and size
<br/>
; User init.
<br/>
ldr r1, =UnitTest1  ; Load our sample data
<br/>
ldr r2, =8          ; The array size is 8
<br/>
<br/>
; Program init.
<br/>
mov r3, #0          ; Reset our sub counter
<br/>
mov r2, r2, lsl #2  ; Multiply the array size by two (get bytesize)
<br/>
<br/>
; Sum loop
<br/>
loop:
<br/>
subs r2, r2, #2     ; Go back two bytes
<br/>
ldrh r5, [r1, r2]   ; Load the data
<br/>
sub r3, r3, r5      ; Subtract ("add") our data
<br/>
bne loop            ; Loop if not the first byte
<br/>
<br/>
; r3 now contains the negative sum of the data
<br/>
<br/>
add r3, r3, r3, lsl #16 ; Add the upper and lower half-words, storing it in the upper half-word
<br/>
mov r3, r3, lsr #16     ; Shift the result back into place.
<br/>
</td> </tr></table><span class="postbody">
<br/>
My major itching was that your code used masks.  I didn't like this, so I used some fancy trickery to let the last two instructions do the masking for me.  Also, this bit of code assumes that you are optimizing for both speed and size; if you want more speed, you can use 32-bit reads instead.
<br/>
<br/>
Edit: Fixed some typos.</span><span class="gensmall"><br/><br/>Last edited by strager on Wed Feb 22, 2006 10:56 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#72959 - aaronphughes - Wed Feb 22, 2006 5:14 pm</h4>
    <div class="postbody"><span class="postbody">Hi and thanks for the suggestions. Strager, in your code, I cannot see where the actual data (in R5) is being used to generate the checksum? Also when I ran your code, using UnitTest3, I do not get the correct checksum. 
<br/>
<br/>
Based on some experimenting and FluBBa's suggestion, I have came up with the following code. 
<br/>
<br/>
<br/>
<br/>
MainFunction:
<br/>
<br/>
        ldr  R1,=UnitTest2     ;; 1st Argument, address of array of 16-bit values
<br/>
<br/>
        ldr  R2,=8                 ;; 2nd Argument, length of array 
<br/>
<br/>
        mov  R3,#0               ;; zero out - will hold the SUM of 16 bit array
<br/>
<br/>
        ldr  R4,=0xFFFF         ;; MASK for lower 16 bits - used frequently
<br/>
<br/>
<br/>
<br/>
lbl_SummingTheArray:
<br/>
<br/>
        ldrh R5,[R1]+2!        ;; load the 16-bit value @ R1, inc R1 pointer by 2
<br/>
<br/>
        add  R3, R3, R5        ;; sum these values
<br/>
<br/>
        subs R2, R2, 1         ;; dec by 1
<br/>
<br/>
        bne  lbl_SummingTheArray     ;; Repeat until the end of the array
<br/>
<br/>
FinalStepIsAddingTheCarriesAndInverting:
<br/>
<br/>
            ;;mov R2, R3, LSR #16    ;; The upper 16-bits are the carries 
<br/>
            ;;add R3, R3, R2         ;; Add the carries to the sum in R3 
<br/>
<br/>
        add  R3, R3, R3 LSR #16      ;; The above two lines in one command 
<br/>
<br/>
            ;;EOR R3, R3, R4         ;; NOT R3 
<br/>
            ;;and R3, R3, R4         ;; Only want the lower 16-bits 
<br/>
<br/>
										;; The above two lines can be done with BIC
<br/>
        BIC  R3, R4, R3              ;; NOT R3, then AND with R4, result in R3
<br/>
<br/>
<br/>
<br/>
EndOfProgram:
<br/>
B EndOfProgram</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#72977 - Cearn - Wed Feb 22, 2006 7:31 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>aaronphughes wrote:</b></span></td> </tr> <tr> <td class="quote">Hi and thanks for the suggestions. Strager, in your code, I cannot see where the actual data (in R5) is being used to generate the checksum? Also when I ran your code, using UnitTest3, I do not get the correct checksum.</td> </tr></table><span class="postbody">
<br/>
strager's procedure is sound, only the 'r2' in the sub before the loop-branch should have been an 'r5'. Change that and it's fixed. This would be my own version, in GNU asm:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ code tags are good for displaying code!
<br/>
<br/>
@ === u16 ipcrc(const void *data) CODE_IN_IWRAM; ======================
<br/>
@ NOTE! GNU asm syntax.
<br/>
@ reglist:  r0-r3: data pointer, value, counter and sum
<br/>
<br/>
   .section .iwram,"ax", %progbits
<br/>
   .align   2
<br/>
   .code   32
<br/>
   .global   ipcrc
<br/>
ipcrc:
<br/>
   mov   r2, #8
<br/>
   mov   r3, #0
<br/>
<br/>
   @ Summing data; using -x instead of +x already inverts the sum
<br/>
.Lcrc_loop:
<br/>
      ldrh   r1,[r0],#2
<br/>
      sub    r3, r3, r1
<br/>
      subs   r2, r2, #1
<br/>
      bne .Lcrc_loop
<br/>
<br/>
   @ add sum (lower halfword) to the carries (upper hw)
<br/>
   @ then shift sum+carries down and into the return register
<br/>
   add   r3, r3, r3, lsl #16
<br/>
   mov   r0, r3, lsr #16
<br/>
   bx lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>strager wrote:</b></span></td> </tr> <tr> <td class="quote">... if you want more speed, you can use 32-bit writes instead.</td> </tr></table><span class="postbody">
<br/>
You meant 'reads', right? Not sure that'd help, though: yes, the loads are quicker, but simply adding words will screw up the carries (at least that's what happened when I tested it) and masking to compensate defeats the purpose of loading words in the first place. 
<br/>
<br/>
Another optimization would be to unroll the loop, but that's cheating. :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#73223 - strager - Thu Feb 23, 2006 11:41 pm</h4>
    <div class="postbody"><span class="postbody">I've worked it out to be a little faster without loop unrolling.  This one reads two halfwords at a time, then adds those two together with the counter.  Then, it traps the overflow and adds it to the counter if necessary.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.arm
<br/>
.global   ipsum
<br/>
<br/>
; u16 ipsum(u16 *data); - Finds the IPSUM of data
<br/>
; Notes - If the halfword size is not even (x%2==1),
<br/>
; the function hangs.  No way to get around this unless
<br/>
; you want to waste an extra four bytes and a few cycles.
<br/>
; Current function cycles: 5 + size / 2 * (5 or 6)
<br/>
; Old function cycles:     5 + size * 4
<br/>
<br/>
ipsum:      ; Finds the sum of an IP address (?)
<br/>
mov r2, #8  ; Halfword size
<br/>
mov r3, #0  ; Counter
<br/>
<br/>
ipsum_loop:                 ; Main loop
<br/>
ldr r1, [r0], #4            ; Load 2 halfwords
<br/>
adds r1, r1, r1, lsl #16    ; Add them
<br/>
sub r3, r3, r1, lsr #16     ; Sub from counter
<br/>
subvs r3, r3, #0x00010000   ; Sub overflow
<br/>
subs r2, r2, #2             ; Sub size
<br/>
bne ipsum_loop              ; Loop if size &gt; 0
<br/>
<br/>
add r3, r3, r3, lsl #16 ; Add the two halfwords
<br/>
mov r0, r3, lsr #16     ; Shift back
<br/>
<br/>
bx lr   ; Return
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I tried working it out on paper, and I got the same results (with only four iterations).  Just be aware that the data must be 4-byte (perhaps 2-byte?) aligned, or the code may trip on itself.  It only takes up 8 more bytes of space, so if size isn't what you are optimizing for, this may as well be the best you can do without loop unrolling.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#73611 - FluBBa - Sun Feb 26, 2006 10:16 pm</h4>
    <div class="postbody"><span class="postbody">Should the extra sub be on carry set? Or am I missing something?<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#73620 - strager - Sun Feb 26, 2006 11:42 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>FluBBa wrote:</b></span></td> </tr> <tr> <td class="quote">Should the extra sub be on carry set? Or am I missing something?</td> </tr></table><span class="postbody">
<br/>
I'm not so sure of that.  I assumed that "carry" meant that some bits of the number were modified because the bits left one on both sides were both one.  E.g., 01 + 01 = 10, because both bit zeros are 1.  Overflow means that the operations caused the number to go past the 31'nd bit, I think.  Perhaps you were thinking of the logical operators, where when a bit is shifted off the register, the carry flag is set?
<br/>
<br/>
Maybe I am way off; I don't know, I haven't tried it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#74324 - FluBBa - Sat Mar 04, 2006 12:41 pm</h4>
    <div class="postbody"><span class="postbody">Overflow means that a number goes from it's max signed value over to it's lowest signed value (or the other way around as well).
<br/>
<br/>
like this: 0x7F800000+0x00821220=0x80021220
<br/>
Overflow will be set, the value goes from a positive to a negative by adding 2 positive values.
<br/>
I don't have any good site which explains it better byt I suppose Google could help you.
<br/>
<br/>
Carry is used when the value wraps from its max unsigned value.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
