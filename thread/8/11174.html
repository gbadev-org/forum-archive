<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>SWI - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > SWI</h2>
<div id="posts">
<div class="post">
    <h4>#102920 - Kirby - Mon Sep 18, 2006 12:11 am</h4>
    <div class="postbody"><span class="postbody">Hi. It's me again. I am writing a function that handles all BIOS functions, but I still need to know more. Here's what it looks like so far:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "gba.h"
<br/>
<br/>
#define THUMB_MODE 0
<br/>
<br/>
#define SWI_SoftReset 0x000000
<br/>
#define SWI_RegisterRamReset 0x010000
<br/>
<br/>
void swi(u16 func, u16 paras, u16 para1, u16 para2, u16 para3, u16 para4,u8 ret, u16 value);
<br/>
<br/>
void swi(u16 func, u16 paras, u16 para1, u16 para2, u16 para3, u16 para4,u8 ret, u16 value)
<br/>
{
<br/>
   if (paras &gt;= 1) {
<br/>
      *(volatile char *)0x03007FFA = para1;
<br/>
   }
<br/>
   if (THUMB_MODE == 1) {
<br/>
      func /= 0x10000;
<br/>
   }
<br/>
   asm volatile ("swi " &amp; func);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
func is one of the defines above, paras is the # of paramenters, para1-4 is obvious, ret is wheather or not there is a return value, and value should store the value.
<br/>
What addresses are there for the other 4 r's I need? And I also need to know how to get a return value, for something like 0x060000 Div. And one last question. Would it be easier to change it to a int instead of void, and have value be returned? Like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "gba.h"
<br/>
<br/>
#define THUMB_MODE 0
<br/>
<br/>
#define SWI_SoftReset 0x000000
<br/>
#define SWI_RegisterRamReset 0x010000
<br/>
<br/>
u16 swi(u16 func, u16 paras, u16 para1, u16 para2, u16 para3, u16 para4,u8 ret);
<br/>
<br/>
u16 swi(u16 func, u16 paras, u16 para1, u16 para2, u16 para3, u16 para4,u8 ret)
<br/>
{
<br/>
   if (paras &gt;= 1) {
<br/>
      *(volatile char *)0x03007FFA = para1;
<br/>
   }
<br/>
   if (THUMB_MODE == 1) {
<br/>
      func /= 0x10000;
<br/>
   }
<br/>
   asm volatile ("swi " &amp; func);
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>Knock-knock.
<br/>
Whose there?
<br/>
Kirby.
<br/>
Kirby-who?
<br/>
I told you! Kirby!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#102924 - Kirby - Mon Sep 18, 2006 12:30 am</h4>
    <div class="postbody"><span class="postbody">Actually, never mind about most of that, I've got it fixed, I just need to know what addresses r1, r2, and r3 are at.<br/>_________________<br/>Knock-knock.
<br/>
Whose there?
<br/>
Kirby.
<br/>
Kirby-who?
<br/>
I told you! Kirby!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#102925 - tepples - Mon Sep 18, 2006 1:14 am</h4>
    <div class="postbody"><span class="postbody">For most BIOS functions, the arguments and the return value should be 32-bit, not 16-bit.
<br/>
<br/>
And no, the arguments aren't going to be at the same address. They're stored on a stack, and the addresses will vary depending on whether you call it in main() or in a function.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#102929 - Kirby - Mon Sep 18, 2006 1:55 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">And no, the arguments aren't going to be at the same address. They're stored on a stack, and the addresses will vary depending on whether you call it in main() or in a function.</td> </tr></table><span class="postbody">
<br/>
How do I know where r0,r1,r2, and r3 are then?<br/>_________________<br/>Knock-knock.
<br/>
Whose there?
<br/>
Kirby.
<br/>
Kirby-who?
<br/>
I told you! Kirby!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#102932 - Kirby - Mon Sep 18, 2006 2:01 am</h4>
    <div class="postbody"><span class="postbody">How's this for so far?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "gba.h"
<br/>
<br/>
#define THUMB_MODE 0
<br/>
<br/>
#define SWI_SoftReset 0x000000
<br/>
#define SWI_RegisterRamReset 0x010000
<br/>
#define SWI_Halt 0x020000
<br/>
#define SWI_Stop 0x030000
<br/>
#define SWI_IntrWait 0x0400000
<br/>
#define SWI_VBlankIntrWait 0x050000
<br/>
#define SWI_Div 0x0600000
<br/>
#define SWI_DivArm 0x070000
<br/>
#define SWI_Sqrt 0x080000
<br/>
#define SWI_ArcTan 0x090000
<br/>
#define SWI_ArcTan2 0x0A0000
<br/>
#define SWI_CpuSet 0x0B0000
<br/>
#define SWI_CpuFastSet 0x0C0000
<br/>
#define SWI_GetBiosChecksum 0x0D0000 //Undocumented
<br/>
#define SWI_BgAffineSet 0x0E0000 //Don't use in swi(....)
<br/>
#define SWI_ObjAffineSet 0x0F0000 //Don't use in swu(....)
<br/>
#define SWI_BitUnPack 0x100000
<br/>
#define SWI_LZ77UnCompWram 0x110000
<br/>
#define SWI_LZ77UnCompVram 0x120000
<br/>
#define SWI_HuffUnComp 0x130000
<br/>
#define SWI_RLUnCompWram 0x140000
<br/>
#define SWI_RLUnCompVram 0x150000
<br/>
#define SWI_Diff8bitUnFilterWram 0x160000
<br/>
#define SWI_Diff8bitUnFilterVram 0x170000
<br/>
#define SWI_Diff16bitUnFilter 0x180000
<br/>
#define SWI_SoundBias 0x190000
<br/>
#define SWI_SoundDriverInit 0x1A0000
<br/>
#define SWI_SoundDriverMode 0x1B0000
<br/>
#define SWI_SoundDriverMain 0x1C0000
<br/>
#define SWI_SoundDriverVSync 0x1D0000
<br/>
#define SWI_SoundChannelClear 0x1E0000
<br/>
#define SWI_MidiKey2Freq 0x1F0000
<br/>
#define SWI_MultiBoot 0x250000
<br/>
#define SWI_HardReset 0x260000 //Undocumented
<br/>
#define SWI_CustomHalt 0x270000 //Undocumented
<br/>
#define SWI_SoundDriverVSyncOff 0x280000
<br/>
#define SWI_SoundDriverVSyncOn 0x290000
<br/>
#define SWI_GetJumpList 0x2A0000 //Undocumented
<br/>
<br/>
#define r0 (*((u16 volatile *) 0x3007FFA))
<br/>
<br/>
u16 blank;
<br/>
<br/>
typedef struct BgAfflineSrc
<br/>
{
<br/>
   s32 origCenterX;
<br/>
   s32 origCenterY;
<br/>
   s16 dispCenterX;
<br/>
   s16 dispCenterY;
<br/>
   s16 scalRatioXdir;
<br/>
   s16 scalRatioYdir;
<br/>
   u16 rotAngle;
<br/>
}BgAfflineSrc;
<br/>
<br/>
typedef struct BgAfflineDest
<br/>
{
<br/>
   s16 diffXsame;
<br/>
   s16 diffXnext;
<br/>
   s16 diffYsame;
<br/>
   s16 diffYnext;
<br/>
   s32 startX;
<br/>
   s32 startY;
<br/>
}BgAfflineDest;
<br/>
<br/>
typedef struct ObjAfflineSrc
<br/>
{
<br/>
   s16 scalRatioXdir;
<br/>
   s16 scalRatioYdir;
<br/>
   u16 rotAngle;
<br/>
}ObjAfflineSrc;
<br/>
<br/>
typedef struct ObjAfflineDest
<br/>
{
<br/>
   s16 diffXsame;
<br/>
   s16 diffXnext;
<br/>
   s16 diffYsame;
<br/>
   s16 diffYnext;
<br/>
}ObjAfflineDest;
<br/>
<br/>
void swi(u16 func, u16 paras, u32 para1, u32 para2, u32 para3, u32 para4,u16 ret, u32 *ret1, u32 *ret2, u32 *ret3);
<br/>
void BgAfflineSet(BgAfflineSrc *src, BgAfflineDest *dest, u16 num);
<br/>
void ObjAfflineSet(ObjAfflineSrc *src, ObjAfflineDest *dest, u16 num, u16 offset);
<br/>
<br/>
void swi(u16 func, u16 paras, u16 para1, u16 para2, u16 para3, u16 para4,u6 ret, u16 *ret1, u16 *ret2, u16 *ret3)
<br/>
{
<br/>
   //Get Input
<br/>
   if (paras &gt;= 1) {
<br/>
      r0 = para1;
<br/>
   }
<br/>
<br/>
   //Fix SWI Value
<br/>
   if (THUMB_MODE == 1) {
<br/>
      func /= 0x10000;
<br/>
   }
<br/>
<br/>
   //Run BIOS Function
<br/>
   asm volatile ("swi " &amp; func);
<br/>
<br/>
   //Return Output
<br/>
   if (ret &gt;= 1) {
<br/>
      ret1 = r0;
<br/>
   }
<br/>
}
<br/>
<br/>
void BgAfflineSet(BgAfflineSrc *src, BgAfflineDest *dest, u16 num)
<br/>
{
<br/>
   r0 = src;
<br/>
   r1 = dest;
<br/>
   r2 = num;
<br/>
   if (THUMB_MODE == 1) {
<br/>
      asm volatile ("swi 0x0E");
<br/>
   } else {
<br/>
      asm volatile ("swi 0x0E0000");
<br/>
   }
<br/>
}
<br/>
<br/>
void ObjAfflineSet(ObjAfflineSrc *src, ObjAfflineDest *dest, u16 num, u16 offset)[
<br/>
{
<br/>
   r0 = src;
<br/>
   r1 = dest;
<br/>
   r2 = num;
<br/>
   r3 = offset;
<br/>
   if (THUMB_MODE == 1) {
<br/>
      asm volatile ("swi 0x0F");
<br/>
   } else {
<br/>
      asm volatile ("swi 0x0F0000");
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>Knock-knock.
<br/>
Whose there?
<br/>
Kirby.
<br/>
Kirby-who?
<br/>
I told you! Kirby!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#102933 - tepples - Mon Sep 18, 2006 2:11 am</h4>
    <div class="postbody"><span class="postbody">If a function has only four arguments, they will already be in r0, r1, r2, and r3. If it has more, see the ARM Procedure Call Standard.
<br/>
<br/>
I'd suggest making a separate .s file with an SWI for each BIOS call. They would look like the following (untested):
<br/>
<br/>
swi.s (to be compiled using something like arm-eabi-gcc -mthumb -mthumb-interwork -c swi.s -o swi.o):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ void RegisterRamReset(unsigned int regions)
<br/>
@ Clears each memory or register region where the bit is set.
<br/>
<br/>
.THUMB
<br/>
.THUMB_FUNC
<br/>
.ALIGN
<br/>
.GLOBL  RegisterRamReset
<br/>
RegisterRamReset:
<br/>
  swi 0x01
<br/>
  bx lr
<br/>
<br/>
@ int Div(int num, int den)
<br/>
@ Divides two signed integers.  Division by 0 returns INT_MAX.
<br/>
<br/>
.THUMB
<br/>
.THUMB_FUNC
<br/>
.ALIGN
<br/>
.GLOBL  Div
<br/>
<br/>
Div:
<br/>
  cmp r1, #0
<br/>
  beq 0f
<br/>
  swi 0x06
<br/>
  bx lr
<br/>
0:
<br/>
  ldr r0, =0x7fffffff
<br/>
  bx lr
<br/>
<br/>
<br/>
@ void LZ77UnCompWRAM(const void *src, void *dst)
<br/>
@ Unpack GB LZSS format data.
<br/>
<br/>
.THUMB
<br/>
.THUMB_FUNC
<br/>
.ALIGN
<br/>
.GLOBL  LZ77UnCompWRAM
<br/>
LZ77UnCompWRAM:
<br/>
  swi 0x11
<br/>
  bx lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
swi.h (to be #included from C files):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#ifndef INCLUDE_SWI_H
<br/>
#define INCLUDE_SWI_H
<br/>
#ifdef __cplusplus
<br/>
extern "C" {
<br/>
#endif
<br/>
<br/>
void RegisterRamReset(unsigned int regions);
<br/>
int Div(int num, int den);
<br/>
LZ77UnCompWRAM(const void *src, void *dst);
<br/>
<br/>
#ifdef __cplusplus
<br/>
}
<br/>
#endif
<br/>
#endif
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#102958 - Kirby - Mon Sep 18, 2006 6:51 am</h4>
    <div class="postbody"><span class="postbody">Is there a way to retrieve to current address of r0, r1, r2, and r3 using ASM? That way I could have r0 be retrieved from ASM every VSync. Like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">extern volatile Getr0;
<br/>
extern volatile Getr1;
<br/>
extern volatile Getr2;
<br/>
extern volatile Getr3;
<br/>
<br/>
...
<br/>
<br/>
Getr0 = para1;
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>Knock-knock.
<br/>
Whose there?
<br/>
Kirby.
<br/>
Kirby-who?
<br/>
I told you! Kirby!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#102966 - Cearn - Mon Sep 18, 2006 8:39 am</h4>
    <div class="postbody"><span class="postbody">Both libgba and tonc's codebase provide a full list of bios calls, it's probably easier to just use those. More information on how to get them running can be found at <a class="postlink" href="http://www.coranac.com/tonc/text/swi.htm" target="_blank">tonc:swi</a>, and the AAPCS can be found <a class="postlink" href="http://www.arm.com/miscPDFs/8031.pdf" target="_blank">here</a>. It'll help you understand how function calling operates on ARM systems. The basic gist of it is that the first 4 arguments are put in r0-r3, the rest goes on the stack (pointed to by r13), and r0 holds the return value of the function.
<br/>
<br/>
Other points:
<br/>
<ul><li>The registers don't have addresses, they're CPU registers (not IO registers like REG_DISPCNT and such). If you're working in C, you shouldn't care about which registers are used where ... with the exception of bios calls I guess. If you do need to care, I'd suggest using actual assembly, where you have the necessary control over what's going on.
<br/>
</li><li>Use word (int or unsigned int) for basic datatypes unless you have a very good reason not to. 
<br/>
</li><li>The word is affine, not aff<span style="font-style: italic">l</span>ine :P
<br/>
</li><li>GCC already creates a macro called <span style="font-style: italic">__thumb__</span> for thumb compiled code, so you don't have to do that yourself. Again, see libgba or tonc for more.
<br/>
</li><li>You can't convert numbers to strings using '&amp;'. This is not VB.
<br/>
</li><li>ObjAffineSet does not necessarily take an ObjAffineDest as its second parameter. Technically it's a pointer to the <span style="font-style: italic">pa</span> element of the matrix, with <span style="font-style: italic">offset</span> being the offset between the elements. That way you can use it for backgrounds (offset=2) or objects (offset=8). Also, if you want <span style="font-style: italic">num</span> to work correctly you need to watch your <a class="postlink" href="http://www.coranac.com/tonc/text/bitmaps.htm#ssec-data-align" target="_blank">data alignment</a>. The struct needs to be word-aligned in order for ObjAffineSet to work with <span style="font-style: italic">num</span>&gt;1.</li></ul></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#103303 - ProblemBaby - Wed Sep 20, 2006 9:00 pm</h4>
    <div class="postbody"><span class="postbody">Doesnt SWI require a constant parameter?
<br/>
I think you should write this kind of functions in pure asm, that gives you much more control.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#103946 - hello world - Mon Sep 25, 2006 4:30 pm</h4>
    <div class="postbody"><span class="postbody">Correct me if I'm wrong but would Get/Set rX work like this: (The code is untested)
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Getr1:
<br/>
   @ Move r1 into r0 (return value)
<br/>
   mov r0, r1
<br/>
   bx lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Setr1
<br/>
    @ Move r0 into r1 (r0 = first parameter)
<br/>
    mov r1, r0
<br/>
    bx lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
And then you'd write
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
extern int Getr1 (int x);
<br/>
extern int Setr1 (int x);
<br/>
</td> </tr></table><span class="postbody">
<br/>
Or something like that.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#103952 - Cearn - Mon Sep 25, 2006 5:15 pm</h4>
    <div class="postbody"><span class="postbody">Yes, but there's no point in doing something like that because you have no control over what the registers will be in the C code surrounding those calls. Example of using functions like that:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void BgAfflineSet(BgAfflineSrc *src, BgAfflineDest *dest, u16 num)
<br/>
{
<br/>
   SetR0((u32)src);
<br/>
   SetR1((u32)dest);
<br/>
   SetR2((u32)num);
<br/>
   
<br/>
   swi_call(0x0E);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
The calls to SetR1 and SetR2 would also set r0 again because that's how parameter passing works. Reversing the calling order would work ... this time. But any code inbetween calls would just mess everything up again. It's just too unstable; if you want/need to know exact registers (which is a rare situation anyway), just use assembly for the whole thing.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
