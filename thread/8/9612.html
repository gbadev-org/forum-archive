<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Memory tricks? GBA fill rate - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Memory tricks? GBA fill rate</h2>
<div id="posts">
<div class="post">
    <h4>#83822 - devmelon - Thu May 18, 2006 8:40 pm</h4>
    <div class="postbody"><span class="postbody">Hi everyone. 
<br/>
<br/>
I'm trying to fill the back buffer as fast as possible, but my routine is ridiculously slow. It looks like 5-6 fps or so. Are there faster memory accessing ways or some other trick to make it faster? How the hell can people make cool looking fullscreen effects at reasonable framerates when I fail? :) I'm puzzled.
<br/>
<br/>
Are there tricks for making this routine go faster?
<br/>
<br/>
r1 = pixel offset from video buffer start
<br/>
r2 = pointer to vram back buffer
<br/>
r3 = page size in bytes
<br/>
r4 = pixel to be written
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">...
<br/>
...
<br/>
...
<br/>
.L1:
<br/>
   strh r4, [r2, r1]      @ Write pixel to video buffer
<br/>
   add r1, r1, #0x2       @ Point to next pixel
<br/>
   add r4, r4, #0x1       @ Change pixel color with something
<br/>
   cmp r1, r3             @ If we have not reached the
<br/>
   bne .L1                @    end of buffer, continue
<br/>
...
<br/>
...
<br/>
...</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83830 - kusma - Thu May 18, 2006 9:02 pm</h4>
    <div class="postbody"><span class="postbody">yes.
<br/>
use pointer-walking rather than indexing. that way you can use the post-increment adressing-mode. also unroll the loop like there was no tomorrow if the loop is time-critical. (usually around 8-16 unrolled iterations are enough). that way you don't get the penalty for the compare and branch for every pixel.
<br/>
<br/>
also, is the code running from iwram in arm-mode? if it's time-critical, then it really should. 5-6 fps sounds too slow even with the above optimizations...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83832 - devmelon - Thu May 18, 2006 9:13 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">yes.
<br/>
use pointer-walking rather than indexing. that way you can use the post-increment adressing-mode.</td> </tr></table><span class="postbody">
<br/>
I'm quite new to ARM assembler. I've been doing MIPS a little before this.. But is it like</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">strh r4, [r1]!</td> </tr></table><span class="postbody">or something like that?</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">also unroll the loop like there was no tomorrow if the loop is time-critical. (usually around 8-16 unrolled iterations are enough). that way you don't get the penalty for the compare and branch for every pixel.
<br/>
</td> </tr></table><span class="postbody">This "unrolling" simply means to repeat several memwrites after each other? Well, I can see how that makes sense.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">also, is the code running from iwram in arm-mode?</td> </tr></table><span class="postbody">Can you move instructions elsewhere? How? I just have plain ol' instructions lined up in a .s file. No magic.</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">if it's time-critical, then it really should. 5-6 fps sounds too slow even with the above optimizations...</td> </tr></table><span class="postbody">
<br/>
Yeah, it sounds quite slow... What fill-rate can one achieve with some tricks? Can I expect 24+ which is a reasonable rate for smooth animations?
<br/>
Thanks alot by the way! :) I'll get around and test some unrolling practices right away.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83836 - Quirky - Thu May 18, 2006 9:36 pm</h4>
    <div class="postbody"><span class="postbody">That's the idea. I filled triangles in a tile mode thingy with this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.rept  31
<br/>
  str   r0,[r1], #32   @ store the 8 pixels and move on a tile
<br/>
.endr
<br/>
</td> </tr></table><span class="postbody">
<br/>
and jump to a suitable place in that loop depending on line length. For regular bitmap modes it'd be ,#4.
<br/>
<br/>
Clear screen can be done even faster with the stmia instruction (push everything onto the stack, store the stack, set r1-14 to 0, stmia r0!,{r1-r14}, pop the lot)
<br/>
<br/>
But it's been a while since I coded in arm so I can't remember too much.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83841 - devmelon - Thu May 18, 2006 10:23 pm</h4>
    <div class="postbody"><span class="postbody">Ah, that's clever. I didn't know much about preprocessor directives (as I assume they are). Well, I came to the conclusion that I need more meat on my legs if I am about to stand a battle with assembling software for GBA. I'm currently plowing though the ARM7TDMI Data Sheet. 
<br/>
<br/>
Could someone direct me to further reading? Link(s) would be greatly apprechiated! :)
<br/>
<br/>
I am starting to grasp the difference between ARM/THUMB mode, and stuff like that. Also the CPSR and so. But I doubt this will go though preprocessor directives (?). It doesn't sound like it has anything to do with the processor model.
<br/>
<br/>
<span style="text-decoration: underline"><span style="font-weight: bold">EDIT:</span></span>
<br/>
Can someone tell me the difference of MOV vs MOVS, SUB vs SUBS ? I could not find information about it in this pdf.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83844 - DekuTree64 - Thu May 18, 2006 10:57 pm</h4>
    <div class="postbody"><span class="postbody">Faster still:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">stmfd sp!, {r4-r11, lr}
<br/>
<br/>
mov r0, #0
<br/>
mov r1, #0
<br/>
mov r2, #0
<br/>
mov r3, #0
<br/>
mov r4, #0
<br/>
mov r5, #0
<br/>
mov r6, #0
<br/>
mov r7, #0
<br/>
mov r8, #0
<br/>
mov r9, #0
<br/>
mov r10, #0
<br/>
mov r11, #0
<br/>
<br/>
@ Probably want to make this an argument, if 
<br/>
@ you want to pass in an EWRAM backbuffer
<br/>
mov r12, #0x6000000  @VRAM start
<br/>
@ Size of buffer, in bytes (this is assuming mode3)
<br/>
mov r14, #240 * 160 * 2
<br/>
<br/>
loop:
<br/>
stmia r12!, {r0-r11}    @ Store 48 bytes, and update r12
<br/>
stmia r12!, {r0-r11}
<br/>
stmia r12!, {r0-r11}
<br/>
stmia r12!, {r0-r11}
<br/>
stmia r12!, {r0-r11}
<br/>
stmia r12!, {r0-r11}
<br/>
stmia r12!, {r0-r11}
<br/>
stmia r12!, {r0-r11}
<br/>
@ Subtract 12 regs, 4 bytes each, repeated 8 times
<br/>
@ Be careful that the total size is a multiple of this amount
<br/>
subs r14, r14, #12 * 4 * 8
<br/>
bgt loop
<br/>
<br/>
ldmfd sp!, {r4-r11, lr}
<br/>
bx lr</td> </tr></table><span class="postbody">
<br/>
subs is subtract and set flags. Basically a sub and cmp in one.
<br/>
<br/>
Of course, the fastest of all is if your effect can redraw the entire screen so you don't have to clear it in the first place.
<br/>
<br/>
As for expected fill rate, with 240 * 160 pixels, and 280896 CPU cycles per 60Hz frame, that leaves you 7.315 cycles per pixel to run at 60Hz. Filling the way I did above should average slightly over 1 cycle per 16-bit pixel, leaving you with a bit over 6 cycles to do your effect. 
<br/>
<br/>
If you use a backbuffer in EWRAM, it will take significantly longer to fill, plus you'll have to copy the buffer to VRAM. By then you've probably used up your 7 cycles already, so you'll be 30Hz at most. 
<br/>
<br/>
I'd recommend either using mode4, or stretching the mode3 layer 2x horizontally so you get half resolution, but can double buffer by scrolling it left and right each frame.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83853 - devmelon - Thu May 18, 2006 11:55 pm</h4>
    <div class="postbody"><span class="postbody">So the -s postfix is just letting the CPSR register condition flags to be written? Cool. In fact, I just read that sorta, and popped back here. Still having a hard time understanding the usage for IRQs, but I'm sure it'll fill in when I read on.
<br/>
<br/>
Dang. 7 cycles per pixel isn't much bargain material. But then again, 25-30 fps is a reasonable frame rate for me and ~15 cycles are a little bit more than 7. I guess one must be extremely careful with overhead when coding for GBA, if you're attempting raw videobuffer writes. 
<br/>
<br/>
I usually write to the back buffer in VRAM (using double buffered modes 4 or 5). I can clearly see how update regions could benefit for complex drawing algorithms. 
<br/>
<br/>
If I understood this sheet correctly, branches flushes the instruction fetch pipeline, causing it to refill at some extra cycle costs? Branches are evil :(
<br/>
<br/>
Hmm.. There is no way that you could make games with a moderate complex graphics on the GBA. Not much left for the game logic if you waste cycles per pixel. But on the other hand, if you can spare one cycle per pixel, you get 38400 extra cycles for game logic, minus the overhead... 
<br/>
<br/>
BTW: WRAM (In-chip), is it free to use any way I like? Do I keep track of all data put there or how do I manage memory usage? <a class="postlink" href="http://www.work.de/nocash/gbatek.htm#memorymap" target="_blank">http://www.work.de/nocash/gbatek.htm#memorymap</a> If I use mode 5, can I use palette memory for general purposes (considering its still faster than some other memories)?
<br/>
<br/>
I have so many questions, but asking too many is likely to confuse you aswell as myself. Perhaps I shouldn't be concerned about all the magic optimizations yet, considering I have yet to learn the full language specification. 
<br/>
<br/>
You know what? :)
<br/>
I've grown fond of this! I love problems! :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83859 - kusma - Fri May 19, 2006 12:51 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>devmelon wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
If I understood this sheet correctly, branches flushes the instruction fetch pipeline, causing it to refill at some extra cycle costs? Branches are evil :(
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
yes. conditional instructions are usually better for small chunks of conditional code. and unrolling really helps a lot on arm7s.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>devmelon wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Hmm.. There is no way that you could make games with a moderate complex graphics on the GBA. Not much left for the game log'ic if you waste cycles per pixel. But on the other hand, if you can spare one cycle per pixel, you get 38400 extra cycles for game logic, minus the overhead... 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
well, keep in mind how your cycles scale. there's usually a LOT more pixels than triangles in a 3d scene, and even less game objects. i'm not saying it's easy to do complex 3d (or anything else for that matter), but it sure is possible to go beyond what we see in todays games. if it's something to invest money into, is a different question ;)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>devmelon wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
BTW: WRAM (In-chip), is it free to use any way I like? Do I keep track of all data put there or how do I manage memory usage? <a class="postlink" href="http://www.work.de/nocash/gbatek.htm#memorymap" target="_blank">http://www.work.de/nocash/gbatek.htm#memorymap</a> If I use mode 5, can I use palette memory for general purposes (considering its still faster than some other memories)?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
VRAM and IWRAM is in short stock, so you should really consider what to put there. in our "complex, high performace" 3d-stuff, we really just have the polyfillers and audio-mixers there, togeither with some small buffers and some coordinate-transform code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83893 - devmelon - Fri May 19, 2006 11:23 am</h4>
    <div class="postbody"><span class="postbody">I'm not looking into making 3d just yet. I was more thinking about blending and various effects. But then again, small objects doesn't require the whole screen to be redrawn. 
<br/>
<br/>
I'm thinking like particle effects. Sure, in palette mode, you could make easy addition of pixels given that some of the palette is sequential color variation order (0..1..2..---...31 for say grayscale color values). But more complex blending would require so many memory accesses. I'm assuming that loading several registers pararell (ldmfd) could speed up this process somewhat. But things like pixel[i] = (pixel[i] + src[i]) &gt;&gt; 1; would require alot of work if done in 15 bit mode. 
<br/>
<br/>
Masking out RGB values and changing them individually, then merging it back to one half word and rewrite would take more than 7 cycles. 
<br/>
<br/>
One instruction for loading src from memory, another three for expanding RGB into three registers, repeat this for dst, add these rgbs together and shift 1, then slam back into 15 bit format and write back.... It quickly builds up :/
<br/>
<br/>
How fast are sprite blending? (Or was it BG blending?) Can I use tricks with ordered sprites that I write my data into and use their blend modes to speed things up?
<br/>
<br/>
What framerate should I aim for? 60 Hz seems a bit more than I really need.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83895 - kusma - Fri May 19, 2006 11:35 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>devmelon wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Masking out RGB values and changing them individually, then merging it back to one half word and rewrite would take more than 7 cycles. 
<br/>
<br/>
One instruction for loading src from memory, another three for expanding RGB into three registers, repeat this for dst, add these rgbs together and shift 1, then slam back into 15 bit format and write back.... It quickly builds up :/
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
the trick here is to not actually do this seperately for every component, and to do multiple pixels in parallel. for additive blending, do something like two pixels at the time with a bit-layout like this (it's a simple matter of masking bits):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
register 1: 000000ggggg000000rrrrr00000bbbbb
<br/>
register 2: 0rrrrr00000bbbbb000000ggggg00000
<br/>
</td> </tr></table><span class="postbody">
<br/>
to prevent overflow into the other components when adding. then mask out overflow and or the pixels togeither. that way you split the cost of the masking over the two pixels, and you don't have to separate each component out for each pixel. there are also a lot of additional tricks on how to do fast 15 bit color manipulations.
<br/>
<br/>
edit:
<br/>
oh, and there's a quite neat trick to generate a saturation-mask based on overflow bits described by Mikael Kalms in some <a class="postlink" href="http://hugi.scene.org/" target="_blank">hugi</a> (try the special edition - the coders digest, if you're interressed in loads of old and mostly outdated coding docs  :P).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83911 - Cearn - Fri May 19, 2006 3:07 pm</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=6721" target="_blank">Here's something</a> :)
<br/>
<br/>
EDIT: argh, or maybe not. I thought I had to do it like that to make sure things didn't bleed into the rest of the fields, but apparently not. BRB.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#83915 - devmelon - Fri May 19, 2006 4:11 pm</h4>
    <div class="postbody"><span class="postbody">Ah, I see. So, if I'd like to add some brightness (+1) to all pixels (all channels), I'd add  0x00200401 to register 1, and  0x04010020 to register 2, mask the result with AND to prevent overflow, then ORR together the two registers and write it to buffer?
<br/>
<br/>
Still, it's alot of job to do per pixel :) On the other hand, we're working with 4 pixels at a time, so I see where you're going. That's pretty clever! 
<br/>
<br/>
Thanks alot all. I've gotton more information than I asked for and I am grateful. I'll take some time now to experiment with my new found powers and fool around a little. And maybe swig a beer ^^</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112526 - nornagon - Sun Dec 17, 2006 2:54 pm</h4>
    <div class="postbody"><span class="postbody">Here's a nice memset routine I found in tonclib:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
@ void memset32(void *dst, u32 val, u32 n)
<br/>
  .section .itcm,"ax", %progbits
<br/>
  .align 2
<br/>
  .code 32
<br/>
  .global memset32
<br/>
memset32:
<br/>
  and   r12, r2, #7
<br/>
  movs  r2, r2, lsr #3
<br/>
  beq  .Lres_set32
<br/>
  stmfd sp!, {r4-r10}
<br/>
  mov   r3, r1
<br/>
  mov   r4, r1
<br/>
  mov   r5, r1
<br/>
  mov   r6, r1
<br/>
  mov   r7, r1
<br/>
  mov   r8, r1
<br/>
  mov   r9, r1
<br/>
  mov   r10, r1
<br/>
.Lmain_set32:
<br/>
    stmia r0!, {r3-r10}
<br/>
    subs r2, r2, #1
<br/>
    bhi .Lmain_set32
<br/>
  ldmfd sp!, {r4-r10}
<br/>
.Lres_set32:
<br/>
    subs    r12, r12, #1
<br/>
    stmcsia r0!, {r1}
<br/>
    bcs     .Lres_set32
<br/>
  bx    lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
There are 16-bit versions as well as memcpy routines.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112530 - keldon - Sun Dec 17, 2006 4:28 pm</h4>
    <div class="postbody"><span class="postbody">I once created a memory transfer routine where you do a certain amount of copies without checking where you are in the loop.
<br/>
<br/>
So you have something like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void copy ( int *src, int *dst, int len ){
<br/>
   int i;
<br/>
   for ( i = 0; i &lt; len &amp; (~127); i += (4*16) ){
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
      *(dst++) = *(src++);
<br/>
   }
<br/>
   for ( ; i &lt; len; i += 4 ){
<br/>
      *(dst++) = *(src++);
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112540 - Ant6n - Sun Dec 17, 2006 7:51 pm</h4>
    <div class="postbody"><span class="postbody">i was thinking for 15 bgr one could keep the last bit in every color 0, i.e. use
<br/>
0bbbb0gggg0rrrr0. Then if you want to blend you could add two colors and shift the result right by one. if you want to blend again afterwards you just OR with 0111101111011110. one could even do 2 pixels at a time.
<br/>
<br/>
you wanted links, here is something to read: <a href="http://www.ee.ic.ac.uk/pcheung/teaching/ee2_computing/arm/Progtech.pdf" target="_blank">http://www.ee.ic.ac.uk/pcheung/teaching/ee2_computing/arm/Progtech.pdf</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112569 - Dwedit - Sun Dec 17, 2006 11:21 pm</h4>
    <div class="postbody"><span class="postbody">Keep in mind that intensity 0-15 is too dark to see on a regular GBA....<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#112583 - Ant6n - Mon Dec 18, 2006 5:56 am</h4>
    <div class="postbody"><span class="postbody">i meant to zero the least significant bit, not the most. so instead of 0,1,2,3,4,5...31 you'd have 0,2,4,..,30</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#128537 - Janekxx - Sat May 12, 2007 3:04 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
Can You explain me how exactly this works?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">len &amp; (~127)</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not sure, I was trying to find explaination on google but without success.
<br/>
<br/>
<br/>
Thank You.<br/>_________________<br/><a class="postlink" href="http://sony.int.pl" target="_blank">sony.int.pl</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#128546 - kusma - Sat May 12, 2007 4:05 pm</h4>
    <div class="postbody"><span class="postbody">It return len with the bottom 7 bits cleared. 127 in binary is 1111111, ~127 is the bitwise compliment, ie 11111111111111111111111110000000b. When you're and'ing a number with that mask, you're only keeping the higher bits of that number.
<br/>
<br/>
It's used to find how many "full" iterations can be done. Then fix-up for the remaining iterations can be done afterwards.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
