<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Division again... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>ASM > Division again...</h2>
<div id="posts">
<div class="post">
    <h4>#16389 - corranga - Sat Feb 14, 2004 1:53 pm</h4>
    <div class="postbody"><span class="postbody">I have searched the forums and read almost everything on division, but am at a bit of a loss.  I've been trying to get division working (preferably fixed point 20:12).  I need it to run FAST as I am attempting some 3D stuff on the gba.
<br/>
<br/>
I was trying to adapt the Division 32bit/32bit=32bit code from <a class="postlink" href="http://www.peter-teichmann.de/ahinte.html" target="_blank">http://www.peter-teichmann.de/ahinte.html</a> to work on the gba (I've not done any assembly at all really so I got a bit lost.
<br/>
<br/>
Using the official arm assembley reference and some other stuff I found 
<br/>
I presume ; (semicolon) is a comment, and for arm asm on the gba I need to change it to @ (at sign) and all the branchs have to have a : (colon) as does the function name ( ie  |FDIV| becomes FDIV:  )
<br/>
<br/>
Then I presumed the #&amp;80000000 was hexidecimal for the highest bit (signed bit?) and changed it to #0x80000000
<br/>
<br/>
When I compile using GCC I get the following error:
<br/>
<br/>
"path"/Temp/ccUqQO9X.o: In function `FDIV':
<br/>
"path"/Temp/ccUqQO9X.o(.text+0x2c): relocation truncated to fit: R_ARM_PC24 *UND*
<br/>
collect2: ld returned 1 exit status
<br/>
<br/>
What am I doing wrong?
<br/>
<br/>
Chris<br/>_________________<br/>If virtual reality is ever on a par with reality, I want to be Bomberman! :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16392 - DekuTree64 - Sat Feb 14, 2004 4:47 pm</h4>
    <div class="postbody"><span class="postbody">Hmm, well I tried converting it and it worked fine. Unfortunately it only does what the BIOS div does, so there's not much point in messing with it. The 64/32=32 is what you need, but it looks like it uses some kind of special assembler function to expand that bit of code that's there, but I don't know exactly what it does, so I can't try it.
<br/>
<br/>
Anyway, if you still want to get the other working, that error is usually due to trying to access something out of range (like ROM from IWRAM), or trying to branch to a missing label, which is likely the case. Check and make sure you got the : after all the non-commented label-looking lines.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16399 - poslundc - Sat Feb 14, 2004 10:26 pm</h4>
    <div class="postbody"><span class="postbody">It could quite possibly be a spelling error in one of your labels. That is the kind of thing that is likely to cause a linker error.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16797 - KevinW - Wed Feb 25, 2004 4:26 am</h4>
    <div class="postbody"><span class="postbody">Don't be fooled into taking verbatim that a routine is "fast" because it's called, someone says, or it's simply labeled "fast".
<br/>
<br/>
For instance the "fast" divide in BIOS ROM might be faster then the standard GCC library routine but I found the library divide in the ARM ADS to be much faster!
<br/>
<br/>
Plus what you do is put these algorithms in IWRAM to get the best performance.  If you setup your make in ADS to output special mapping/list files at the link stage, you can see what library(s) it's using for your math.  You can then force these files to load into IWRAM (as I do) by using a scatter file.  
<br/>
You should be able to do this as well with GCC, but I personaly have not tried it.  
<br/>
The complier must automatically generate some veneer code so it can make calls/jumps to IWRAM from ROM.  While this adds some extra cycles for the indirection, it?s a good thing after all since you?ll be able to call 32 routines from 16 bit ROM.
<br/>
Incidentally, ADS only includes library functions in the binary that are actually used.  So you don't have to wory so much about a libaray wasting space on the ADS.
<br/>
<br/>
Furthermore for my experience in this sort of thing is that you'd benefit greatly from breaking down your math and taking short cuts when feasible.
<br/>
If for example you are making a division with a constant (in fixed point or not) you could multiply by a reciprocal instead.
<br/>
Or use tables to a greater (eliminating an entire algorithm) or lesser (eliminating part of an algorithm) degree.  For instance, you have 160 vertical scan lines so it might be possible to eliminate a few expensive operations by using a divide array table of 160 entries..
<br/>
<br/>
If you are lucky you can reorder some calculations into prime powers of two and use simple shifts (for both divides and multiplies) instead.
<br/>
<br/>
Also what you might want to do is cascade the last two timers into a utility 64bit cycle timer.
<br/>
Then you can precisely time and compare various functions.   
<br/>
This alone will tell you what is ?fast? and what is not..
<br/>
<br/>
Please note that to add to the complexity to this is that some algorithms give better performance in some circumstances than others.  Like if your denominator is small some division functions might be faster then say a function that?s better designed for general perpose use.
<br/>
<br/>
Note: you CAN use software floating point emulation libraries for setup and test code!
<br/>
Yes they are prohibitedly slow for a working 3D graphics engine on the GBA,  but works great for testing, profiling and proving things.  Again you can use the same speedup by forcing the math emulation libraries in IWRAM (space permiting).
<br/>
<br/>
3D ?Software rendering? was a big subject a few years ago (back in the Doom, and Quake 1; days, etc).  Look these up on the web for some ideas.  Some of the tricks might apply to what you are doing.
<br/>
<br/>
Besure to check out the fast sqrt() routine I posted on the main <a href="http://www.gbadev.org" target="_blank">www.gbadev.org</a> page.  This type of algorithm is an order of magnatude faster then the BIOS routine.
<br/>
<br/>
P.S. No I don?t work for ARM Corp., as you might thing from my so many posts on ARM ADS :-P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16816 - Lupin - Wed Feb 25, 2004 3:30 pm</h4>
    <div class="postbody"><span class="postbody">ADS is great... but there is almost no documentation out for it. I think i will try to make my projects able to compile with both compilers.
<br/>
<br/>
Maybe you should try to clearify what type of division is actually the fastest, because i am also not sure about what division would be the best...
<br/>
<br/>
The problem for me is that i am too lazy to set up a profiler for the gba :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16819 - Lupin - Wed Feb 25, 2004 3:37 pm</h4>
    <div class="postbody"><span class="postbody">Kevin, i have a question about the ARM ADS debugger, how can i use swi commands with it? Everytime i call an SWI opcode it says that the opcode is unrecognized and stops debugging :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16821 - poslundc - Wed Feb 25, 2004 3:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lupin wrote:</b></span></td> </tr> <tr> <td class="quote">Maybe you should try to clearify what type of division is actually the fastest, because i am also not sure about what division would be the best...</td> </tr></table><span class="postbody">
<br/>
<br/>
The fastest division is by a power of two; then you can just shift. ;)
<br/>
<br/>
Seriously, though, the point is that it depends on your specific requirements. From fastest to slowest, the different techniques would be:
<br/>
<br/>
- Shifting (powers of 2 only)
<br/>
- Multiplication by constant reciprocal (division by constant only)
<br/>
- Reciprocal LUT (only works within the range of your LUT)
<br/>
- Custom, optimized divide function
<br/>
- BIOS divide function (SWI #6)
<br/>
- gcc division
<br/>
<br/>
Note that while I place gcc as the slowest, gcc with any optimizations turned on will do the first and second technique if it can. (Not sure about without the optimizations.)
<br/>
<br/>
You can easily search the forum to find a way to improve on the BIOS function for your own optimized divide routine, but I find that if you're doing a division that you can't use any of the first three techniques for then you may as well just use the BIOS call. If it ever really becomes a problem than you can optimize it later. :P
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16835 - Torlus - Wed Feb 25, 2004 6:39 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>corranga wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
When I compile using GCC I get the following error:
<br/>
<br/>
"path"/Temp/ccUqQO9X.o: In function `FDIV':
<br/>
"path"/Temp/ccUqQO9X.o(.text+0x2c): relocation truncated to fit: R_ARM_PC24 *UND*
<br/>
collect2: ld returned 1 exit status
<br/>
<br/>
What am I doing wrong?
<br/>
<br/>
Chris</td> </tr></table><span class="postbody">
<br/>
<br/>
Hmm looks like some kind of "well-known" linker issue. Get Jeff Frohwein's crtls from his site (www.devrs.com) and follow his intructions (you can also search gbadev.org's forum for more information).[/b]<br/>_________________<br/>GBA,GC,NGPC,GP32,FPGA,DS stuff at <a class="postlink" href="http://torlus.com/" target="_blank">http://torlus.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16836 - Miked0801 - Wed Feb 25, 2004 6:50 pm</h4>
    <div class="postbody"><span class="postbody">He also has a nice Arm Division routine on his site that - while 2x larger than the ARM one - it generally outperfoms it (it adds a binary search ot get the MSb of the larger term to cut down on division loop time.  On larger numbers, it's faster, on smaller, it's a touch slower.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#60757 - keldon - Mon Nov 14, 2005 2:19 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">LSB(a) {
<br/>
   // (if zero) |= n &lt;&lt;&lt; means ORR c regN in Arm ASM
<br/>
   m = a&amp;-a;
<br/>
   m &amp; 0xaaaaaaaa
<br/>
   (if zero) lsb|= 1;
<br/>
   m &amp; 0xcccccccc
<br/>
   (if zero) lsb|= 2;
<br/>
   m &amp; 0xf0f0f0f0
<br/>
   (if zero) lsb|= 4
<br/>
   m &amp; 0xff00ff00
<br/>
   (if zero) lsb|= 8
<br/>
   m &amp; 0xffff0000
<br/>
   (if zero) lsb|= 16
<br/>
   return lsb
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">MSB(a){
<br/>
   b = a&gt;&gt;1;
<br/>
   b |= b&gt;&gt;2;
<br/>
   b |= b&gt;&gt;4;
<br/>
   b |= b&gt;&gt;8;
<br/>
   b |= b&gt;&gt;16;
<br/>
   m=a &amp; !b;
<br/>
   return LSB(m);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
m = 1 &lt;&lt; MSB(a) so the conditional OR's will convert (1 &lt;&lt;MSB) to MSB
<br/>
<br/>
there doesn't seem to be an LSB command for the arm, am i right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#60861 - kusma - Tue Nov 15, 2005 2:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
- Reciprocal LUT (only works within the range of your LUT)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Just a quick note: if you count the leading zero-bits, then you can quite easily normalize the number, and use a lut for the entire range. you don't really need a big lut to get acceptable results for stuff like 3d-projections either.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#60872 - poslundc - Tue Nov 15, 2005 6:55 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
- Reciprocal LUT (only works within the range of your LUT)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Just a quick note: if you count the leading zero-bits, then you can quite easily normalize the number, and use a lut for the entire range. you don't really need a big lut to get acceptable results for stuff like 3d-projections either.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Interesting idea. So is it pretty much as follows:
<br/>
<br/>
- Count the leading zeros in your denominator
<br/>
- Obtain the difference between that value and the range of your table (say it has 256 entries, you'd subtract 8)
<br/>
- Downshift the denominator by that value, and look it up in your table to obtain the reciprocal
<br/>
- Upshift the reciprocal (presumably into a long-long)
<br/>
- Multiply
<br/>
<br/>
Presumably you'd have to throw in a test for negative denominators as well and negate your numerator if you encountered those values. And depending on the precision of your LUT's values and the size of your terms it might be necessary to save the upshift until after the multiply.
<br/>
<br/>
How does this work out in practice, and how does it stack up against other techniques, like interpolating between LUT values?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#60876 - keldon - Tue Nov 15, 2005 7:44 pm</h4>
    <div class="postbody"><span class="postbody">EDIT: Removed, see below</span><span class="gensmall"><br/><br/>Last edited by keldon on Wed Nov 16, 2005 11:06 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#60967 - keldon - Wed Nov 16, 2005 10:40 am</h4>
    <div class="postbody"><span class="postbody">i have optimised the MSB routine -- might have NZ(EQ) statements the wrong way around because i am used to using Z and NZ - it is supposed to AND if (AND R0) is NZ
<br/>
<br/>
also i don't know the right way to load the address of Data into R3, would you have to load the high 16, SHL 16, and then add the low 16? Also I am assuming that <span style="font-weight: bold">LDR R1, [R3+1]</span> will give me <span style="font-style: italic">Data+4</span>, otherwise all of those instructions need to be altered;
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">; r0 = num
<br/>
; ret: R2 = MSB(r0)
<br/>
;
<br/>
; R1: loaded data
<br/>
; R2: MSB
<br/>
; R3: Data ptr
<br/>
MSB:
<br/>
   XOR R2 R2
<br/>
   LDR R3 Data
<br/>
   LDR R1, [R3]
<br/>
   AND R1 R0 R1
<br/>
   AND EQ S R0 R0 R1
<br/>
   ADD EQ R2 16
<br/>
<br/>
   LDR R1, [R3+1]
<br/>
   AND R1 R0 R1
<br/>
   AND EQ S R0 R0 R1
<br/>
   ADD EQ R2 8
<br/>
<br/>
   LDR R1, [R3+2]
<br/>
   AND R1 R0 R1
<br/>
   AND EQ S R0 R0 R1
<br/>
   ADD EQ R2 4
<br/>
<br/>
   LDR R1, [R3+3]
<br/>
   AND R1 R0 R1
<br/>
   AND S EQ R0 R0 R1
<br/>
   ADD EQ R2 2
<br/>
<br/>
   LDR R1, [R3+4]
<br/>
   AND R1 R0 R1
<br/>
   AND EQ S R0 R0 R1
<br/>
   ADD EQ R2 1
<br/>
   ret
<br/>
Data:
<br/>
   DW 0xffff0000, 0xff00ff00, 0xf0f0f0f0, 0xcccccccc, 0xaaaaaaaa</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#60980 - FluBBa - Wed Nov 16, 2005 1:12 pm</h4>
    <div class="postbody"><span class="postbody">Wasn't this dissused <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=4359" target="_blank">here</a>?
<br/>
16 instructions without any memory accesses.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
