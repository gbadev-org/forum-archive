<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Vector Graphics on Gba? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Graphics > Vector Graphics on Gba?</h2>
<div id="posts">
<div class="post">
    <h4>#8371 - Sckuz - Wed Jul 09, 2003 9:31 am</h4>
    <div class="postbody"><span class="postbody">Ive started a project that uses vector graphics similar to early arcade games. So far, i have to basic graphics engine built, but its super slow. Im even compiling it using thumb. Ive tried everything i can think of. I think the reason its so slow is because im using Bresenham's Line Algorithm and plotting each pixel individually? Im not sure though. If anyone could give me some advice or point me to demo that uses vector graphics, i would really appreciate it. I know the GBA is capable of doing this.<br/>_________________<br/>"There is no right and wrong. There's only fun and boring." - The Plague</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8383 - Sweex - Wed Jul 09, 2003 2:04 pm</h4>
    <div class="postbody"><span class="postbody">You should be able to draw lines quite fast. Floats usually slowdown a lot. Are you using floats or doubles?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8389 - Cyberman - Wed Jul 09, 2003 4:01 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Sckuz wrote:</b></span></td> </tr> <tr> <td class="quote">Ive started a project that uses vector graphics similar to early arcade games. So far, i have to basic graphics engine built, but its super slow. Im even compiling it using thumb. Ive tried everything i can think of. I think the reason its so slow is because im using Bresenham's Line Algorithm and plotting each pixel individually? Im not sure though. If anyone could give me some advice or point me to demo that uses vector graphics, i would really appreciate it. I know the GBA is capable of doing this.</td> </tr></table><span class="postbody">
<br/>
<br/>
Bresenham's algo is very fast, obviously it's not the problem.
<br/>
<br/>
A few things to realize.
<br/>
<br/>
<ul>
<br/>
1:) Thumb mode is slower than ARM mode, depending on WHERE the code is located, if it's in ROM it's actually faster, if it's in IRAM it's slower than ARM.
<br/>
2:) floating point should be used sparingly at best.  This is because the GBA must emulate it.  Fixed point is better. 
<br/>
3:) DON'T I repeat DON'T use a divide unless you HAVE to.  Divide is not supported in GBA hardware AGAIN this must be emulated for both floating point and integers and both are fairly slow.  If you are dividing by a constant take it's recipricol and multiply by it JUST to be sure.
<br/>
4:) Try using fixed point for calculations and move your drawing routines from ROM to IRAM and use ARM instructions instead. Heck just moving it to IRAM will boost the performance but using ARM mode for the code will boost it even more.
<br/>
</ul>
<br/>
<br/>
My recomendation is to be sure you are only handing your line drawing function integers.
<br/>
If you are drawing in mode 3 treat the display as a linear array. In mode 4 don't do this. It's not an array of char.  Writting to it a char will give you a headache namely it won't work right. You should have a local variable to read the 16 bit aligned word you are operating on in the VRAM and perform masking and bit twiddling in your function. When you cross a 16 bit boundry write out your little scratch buffer.
<br/>
<br/>
If you go with using fixed point, be sure your objects won't cause an overun of your variables when scaled etc. :) 
<br/>
<br/>
Cyb</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8392 - DekuTree64 - Wed Jul 09, 2003 4:29 pm</h4>
    <div class="postbody"><span class="postbody">Hmm, I'm nto really sure what style you mean (I never played arcade games), but I'll guess you mean 3D drawn in wireframe mode? Well it should be perfectly possible, seeing as how GBA can (kinda) do polygonal 3D, which requires tracing all the edge lines anyway, and a lot more pixel drawing time. But Sweex is right, if you're using floats, that's your whole problem. Use fixed-point instead, or a fractional method, where like for a line with a slope of 2/3 (just take yEnd - yStart as the numerator (the 2 in this case) and xEnd - xStart as the denomenator (the 3 (we have a very short line)), and swap them if the numer is greater then the denom), then you plot a pixel, add 1 to x, add the numerator of your slope fraction to yError (that would be 2 for this example), and as soon as yError gets to be greater than or equal to the denominator of your slope fraction, you add 1 to the screen Y coord, and subtract the denominator from yError. That way, in this example, after the first 2 increments, you've added 2 to yError twice, so it's 4. Then you subtract 3 from it, so you have 1. On the next step, you add 2 to it again, so you have 3, and that means another pixel, so you add 1 to y, and subtract 3 again. So as you can see, you get 2 pixels, then 1 pixel, then 2, then 1. Which turns out to move precisely 2 pixels vertically for every 3 horizontal ones. And since the slope was 2/3, that's exactly how it should be.
<br/>
<br/>
I've heard of a more advanced line drawing technique though (I think it was called run-length slice), but I've never tried it myself. The basic theory was to use that pattern of alternating run lengths, which in the example was 2, 1, 2, 1, 2, 1... to speed up the line drawing process.
<br/>
So you figure out what those 2 lengths will be, and then make a fast loop to draw that many pixels in a straight line, then increment y (or x the runs are vertical), then draw the second length, inc y again, then do the first again, until your line is drawn. You can make a huge unrolled loop to draw the full length of the screen, and jump to the (end - runLength)th pixel in the loop so you don't have to do any checking if x is greater than the length at all. Would be fast if you got it working, especially if you have a pointer to the urrent pixel on the sreen, and in your pixel drawnig loop, you just increment it as you draw, and then add/subtract the screen width to/from it so you move down/up a pixel and you're ready for the next row without any multiplying the y coord by the width. 
<br/>
You have to special case the endpoints though, cause depending on the length of your line, you might end up starting with a run of say 10 pixels, and then ending with a run of 2. Then the end would look kinda funny, so you need to average those 2, so it would be 6 on each end. Actually now that I think about it that would happen with the fraction method I was talking about before too. I've never tried it either though, I just use fixed point. Much simpler.
<br/>
<br/>
EDIT: Cyberman posted while I was writing all that and pointed out something important: You can't have a direct pointer to a pixel in mode4, so the run-length slice would loose a lot of its advantage. But it would gain some in being able to write 2 pixels at a time in long runs, whereas the fixed point style draws one pixel at a time, so it's not worth the trouble of checking if you can draw the next pixel while you're doing the current one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8414 - Sckuz - Wed Jul 09, 2003 10:07 pm</h4>
    <div class="postbody"><span class="postbody">Hey, thanks for the help. I'll start rewriting some code using your suggestions and see if it helps. I have one question though. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
1:) Thumb mode is slower than ARM mode, depending on WHERE the code is located, if it's in ROM it's actually faster, if it's in IRAM it's slower than ARM. 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
How exactly do I store the code in the IRAM? Sorry if that's a stupid question. As I'm sure you can tell, I'm pretty new to Gba Development.<br/>_________________<br/>"There is no right and wrong. There's only fun and boring." - The Plague</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8426 - Sckuz - Thu Jul 10, 2003 4:46 am</h4>
    <div class="postbody"><span class="postbody">Also... Ive never had to work with fixed point before. I wont make you explain it to me, but if you could point me to any helpful references, I would appreciate it. Thanks!<br/>_________________<br/>"There is no right and wrong. There's only fun and boring." - The Plague</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8466 - Sckuz - Fri Jul 11, 2003 11:04 am</h4>
    <div class="postbody"><span class="postbody">Ok.. Scratch that last request. I found some useful resources on Fixed Points. Yeah.. taking those floats out at the least tripled my game's performance. I still would like to know how you load the code into IRAM.<br/>_________________<br/>"There is no right and wrong. There's only fun and boring." - The Plague</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8468 - Quirky - Fri Jul 11, 2003 12:54 pm</h4>
    <div class="postbody"><span class="postbody">Here's my interupt routine. It's compiled in arm and placed in iwram:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// inter.h
<br/>
#define CODE_IN_IWRAM __attribute__ ((section (".iwram"), long_call)) 
<br/>
CODE_IN_IWRAM void InterruptProcess(void);
<br/>
<br/>
// inter.arm.c
<br/>
#include "inter.h"
<br/>
CODE_IN_IWRAM void InterruptProcess(void) {
<br/>
  //blah
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The .c file has the extension ".arm.c" so that make knows to compiled it in arm mode. All my other ".c" files are -mthumbed (for rom).</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
