<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>bitmap palette data - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Graphics > bitmap palette data</h2>
<div id="posts">
<div class="post">
    <h4>#10682 - hnager - Fri Sep 12, 2003 12:06 pm</h4>
    <div class="postbody"><span class="postbody">I'm putting together a very simple image converter which reads a 16 color bitmap file and creates a header file formatted as needed to copy it to memory...I know that there are other tools out there but I'm looking at this as both a lesson in C/C++ aswell as a way to get exactly what I want out of the converted header file.
<br/>
<br/>
Where I'm stuck - is how to extract the bitmap palette? I have no problem opening the bitmap and extracting the height and width and bit depth, but I'm not sure how to get the palette...
<br/>
<br/>
thanks! Howard</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10683 - chrisrothery - Fri Sep 12, 2003 12:57 pm</h4>
    <div class="postbody"><span class="postbody">Quick google search yielded this
<br/>
<br/>
<a class="postlink" href="http://www.gameprogrammer.com/archive/html/msg03091.html" target="_blank">http://www.gameprogrammer.com/archive/html/msg03091.html</a>
<br/>
<br/>
seems to have a pretty low level expaination of the .bmp format, along with some example code.  It goes into RLE (run length encoding for compression), which I haven't used in my bmp's before.
<br/>
<br/>
I've done similar, but being at work, don't have the code to hand.  Piece of advice though, pay attention to padding of rows, I remember that messing me up in the past (bmp's pad each row to an even byte), so if your images come out sort of right but skewed on hardware, that's probably the problem.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10685 - Nessie - Fri Sep 12, 2003 3:55 pm</h4>
    <div class="postbody"><span class="postbody">You might also find something useful here..just a huge page dedicated to file formats for practically anything you want.
<br/>
<br/>
<a class="postlink" href="http://www.wotsit.org/" target="_blank">http://www.wotsit.org/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10741 - hnager - Sat Sep 13, 2003 7:41 pm</h4>
    <div class="postbody"><span class="postbody">hmmm, this is as far as I've gotten - I'm doing something wrong in the palette department...this isn't yet optimized/commented but it has the basics going. I'm only using this for 4 bit bitmaps. help!:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;fstream&gt;
<br/>
#include &lt;iostream&gt;
<br/>
#include &lt;windows.h&gt;
<br/>
<br/>
using namespace std;
<br/>
<br/>
typedef unsigned short uShort;
<br/>
<br/>
class Exception {
<br/>
public:
<br/>
   Exception(){};
<br/>
   Exception(char* e){
<br/>
      details = e;
<br/>
   }
<br/>
   void PrintError(){ cout &lt;&lt; details &lt;&lt; endl; }
<br/>
private:
<br/>
   char* details;
<br/>
};
<br/>
<br/>
class BMP1 {
<br/>
public:
<br/>
   //file header
<br/>
   unsigned short   bfType; //must be set to 'BM'
<br/>
   unsigned long   bfSize; //size in bytes
<br/>
   unsigned short   bfReserved1;
<br/>
   unsigned short   bfReserved2;
<br/>
   unsigned long   bfOffBits; //number of bits before bitmap
<br/>
};
<br/>
<br/>
<br/>
class BMP2 {
<br/>
public:
<br/>
   //bitmap header
<br/>
   unsigned long   biSize; //size of this header
<br/>
   unsigned long   biWidth; //the width in pixels
<br/>
   unsigned long   biHeight; //the height in pixels
<br/>
   unsigned short   biPlanes; //the number of planes
<br/>
   unsigned short   biBitCount; //the number of bits per pixel
<br/>
   unsigned long   biCompression; //the type of compression
<br/>
   unsigned long   biSizeImage; //size of image in bytes when compressed
<br/>
   unsigned long   biXPelsPerMeter; //the horizontal number of pix/meter
<br/>
   unsigned long   biYPelsPerMeter; //the vertical number of pix/meter
<br/>
   unsigned long   biClrUsed; //the number of colors that are used
<br/>
   unsigned long   biClrImportant; //the number of important colors
<br/>
};
<br/>
<br/>
<br/>
<br/>
void LoadBitmap (char* lpszFilename);
<br/>
<br/>
int main(int argc, char* argv[]){
<br/>
   char* bmpName;
<br/>
<br/>
   if (argc &gt; 1){
<br/>
      bmpName = argv[1];
<br/>
   } else {
<br/>
      std::cout &lt;&lt; "";
<br/>
   }
<br/>
   
<br/>
   try {
<br/>
      LoadBitmap(bmpName);
<br/>
   }
<br/>
   catch(Exception e)
<br/>
   {
<br/>
      e.PrintError();
<br/>
   }
<br/>
<br/>
   
<br/>
   return 0;
<br/>
}
<br/>
<br/>
<br/>
void LoadBitmap (char* filename){
<br/>
<br/>
   BMP1 BMPFILEHEADER;
<br/>
   BMP2 BMPINFOHEADER;
<br/>
<br/>
   fstream     kBitmap(filename, ios::binary | ios::in );
<br/>
   
<br/>
   if(!kBitmap){
<br/>
      throw Exception("Unable to open bitmap...");
<br/>
   }
<br/>
<br/>
   fstream     kHeader("test.h", ios::out );
<br/>
<br/>
   kBitmap.read((char *) &amp;BMPFILEHEADER, 14);
<br/>
<br/>
   if (0x4D42 != BMPFILEHEADER.bfType) {
<br/>
      throw Exception("Not a valid bitmap...");
<br/>
   }
<br/>
<br/>
   kBitmap.read((char *) &amp;BMPINFOHEADER, 40);
<br/>
<br/>
   if (BMPINFOHEADER.biCompression != BI_RGB){
<br/>
      throw Exception("Compression not supported...");
<br/>
   }
<br/>
   
<br/>
   
<br/>
<br/>
   kHeader &lt;&lt; "//Height: " &lt;&lt; BMPINFOHEADER.biHeight &lt;&lt; endl;
<br/>
   kHeader &lt;&lt; "//Width: " &lt;&lt; BMPINFOHEADER.biWidth &lt;&lt; endl;
<br/>
   kHeader &lt;&lt; "//BitCount: " &lt;&lt; BMPINFOHEADER.biBitCount &lt;&lt; endl;
<br/>
<br/>
   kHeader &lt;&lt; "const u8 palette[] = {" &lt;&lt; endl &lt;&lt; "\t";
<br/>
   
<br/>
   int r, g, b, counter = 0;
<br/>
   for( int i=0; i&lt;16*2; i++){
<br/>
      r = kBitmap.get() &gt;&gt; 3 &lt;&lt; 10;
<br/>
      g = kBitmap.get() &gt;&gt; 3 &lt;&lt; 5;
<br/>
      b = kBitmap.get() &gt;&gt; 3;
<br/>
<br/>
      kHeader &lt;&lt; "0x" &lt;&lt; hex &lt;&lt; (unsigned short)(r|g|b);
<br/>
      kHeader &lt;&lt; ", ";
<br/>
      kBitmap.get(); // skip a byte (RGBx)
<br/>
      if(!(++counter%8)) kHeader &lt;&lt; endl &lt;&lt; "\t";
<br/>
<br/>
   }
<br/>
<br/>
   kHeader &lt;&lt; endl &lt;&lt; "};" &lt;&lt; endl;
<br/>
   
<br/>
   
<br/>
   // Move to bitmap buffer
<br/>
   kBitmap.seekg (10, ios::beg);
<br/>
   kBitmap.read((char*)&amp;BMPFILEHEADER.bfOffBits,4);
<br/>
<br/>
   kBitmap.seekg (BMPFILEHEADER.bfOffBits, ios::beg);
<br/>
<br/>
   
<br/>
   int b1, b2;
<br/>
   counter = 0;
<br/>
<br/>
   kHeader &lt;&lt; "const u8 data[] = {" &lt;&lt; endl &lt;&lt; "\t";
<br/>
<br/>
   for(int i = (BMPINFOHEADER.biHeight*BMPINFOHEADER.biWidth)/2; i &gt; 0; i--){
<br/>
<br/>
      b1 = kBitmap.get();
<br/>
      //b2 = kBitmap.get();
<br/>
      kHeader &lt;&lt; "0x" &lt;&lt; hex &lt;&lt; b1;
<br/>
      kHeader &lt;&lt; ", ";
<br/>
      if(!(++counter%8)) kHeader &lt;&lt; endl &lt;&lt; "\t";
<br/>
   }
<br/>
<br/>
   kHeader &lt;&lt; endl &lt;&lt; "};" &lt;&lt; endl;
<br/>
<br/>
   kBitmap.close ();
<br/>
   kHeader.close ();
<br/>
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10762 - hnager - Sun Sep 14, 2003 11:44 pm</h4>
    <div class="postbody"><span class="postbody">Figured it out...now my only problem is that all black pixels are showing up as transparent...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10769 - tepples - Mon Sep 15, 2003 3:37 am</h4>
    <div class="postbody"><span class="postbody">In the GBA's indexed color modes (0, 1, 2, 4, and sprites), color 0 is always transparent.  If color 0 in your palette is black, rearrange your palette so that color 0 is not used in your image.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10770 - hnager - Mon Sep 15, 2003 3:41 am</h4>
    <div class="postbody"><span class="postbody">I suppose that would have to be done within the bitmap itself, before running it through my converter?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#10784 - tepples - Mon Sep 15, 2003 3:35 pm</h4>
    <div class="postbody"><span class="postbody">Yes.
<br/>
<br/>
To do this in GIMP, set the upper-left pixel of your bitmap to the color you want to use as transparent, then convert to indexed color, then change the upper-left pixel back.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
