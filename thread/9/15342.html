<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Anisotropic filtering in a software renderer - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Graphics > Anisotropic filtering in a software renderer</h2>
<div id="posts">
<div class="post">
    <h4>#153945 - simonjhall - Tue Apr 08, 2008 5:23 pm</h4>
    <div class="postbody"><span class="postbody">I'm writing a perpective-correct software renderer at the moment and I'm trying to render a lot of surfaces that are at a distance and at an angle to the camera. I'm in need of some filtering! Bilinear ain't hacking it, and I don't really think trilinear'll make too much difference.
<br/>
Any help?
<br/>
<br/>
So my regular pixel putting loop looks like this
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">while (width &gt; 0)
<br/>
{
<br/>
   float z = 1.0f / one over z;
<br/>
   float u = u overz * z;
<br/>
   float v = v overz * z;
<br/>
<br/>
   output pixel = texture[v][u]
<br/>
<br/>
   one over z += d one over z dx;
<br/>
   u over z += d u over z dx;
<br/>
   v over z += d v over z dx;
<br/>
   width--;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Bilinear would involve
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">float low u = floor(u);
<br/>
float low v = floor(v);
<br/>
float u ratio = u - low u;
<br/>
float v ratio = v - low v;
<br/>
float one minus u ratio = 1 - u ratio;
<br/>
float one minus v ratio = 1 - v ratio;
<br/>
<br/>
and then the final pixel would be,
<br/>
output pixel = (texture[v][u] * one minus u ratio + texture[v][u + 1] * u ratio) * one minus v ratio + (texture[v + 1][u] * one minus u ratio + texture[v + 1][u + 1] * u ratio) * v ratio;</td> </tr></table><span class="postbody">
<br/>
What do I do for anisotropic filtering? I can't seem to find a lot online about how to code this, like where do I put my samples? I know it's dependent on the angle of the surface that I'm trying to render.
<br/>
<br/>
Ta guys :-)
<br/>
<br/>
EDIT: not sure if I've put this in the right forum - is graphics appropriate?<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153948 - kusma - Tue Apr 08, 2008 5:37 pm</h4>
    <div class="postbody"><span class="postbody">For anisotropic filtering, you should basically find the view-direction in texture-space, and sample along the 2d-line that generates. It's pretty damn expensive to do in software, and I can't help feeling that it's somewhat not the right thing to do there. Perhaps the mipmap-variation where you store each possible combination of power-of-two reduction over both axes (or lazy evaluate it and cache the result to save memory) is better and gives good enough results? Also, keep in mind that anisitropic filtering is an improved bilinear, not a replacement.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153962 - simonjhall - Tue Apr 08, 2008 6:38 pm</h4>
    <div class="postbody"><span class="postbody">Ah, just the person I was hoping would reply!
<br/>
<br/>
I'm sort of getting the problem that's in <a href="http://en.wikipedia.org/wiki/Image:Anisotropic_compare.png" target="_blank">http://en.wikipedia.org/wiki/Image:Anisotropic_compare.png</a> just not quite that severe; that horizontal smearing effect.
<br/>
I'll definately try mip mapping again tomorrow (I had a dabble a few months back), and esp those non-uniform mip map levels to see what happens. I figured AF'd be pretty expensive, and it'd definately chew the memory system a bit. I was just going to try all the options to see which gives the best result then pick the one that gives the best quality/performance ratio.
<br/>
<br/>
So...if you were to code this, what would you do? Ta mate :-)
<br/>
<br/>
PS: what other options do I have to improve my texture mapped results other than mip maps/bilinear/trilinear/AF?<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153973 - kusma - Tue Apr 08, 2008 8:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">I'm sort of getting the problem that's in <a href="http://en.wikipedia.org/wiki/Image:Anisotropic_compare.png" target="_blank">http://en.wikipedia.org/wiki/Image:Anisotropic_compare.png</a> just not quite that severe; that horizontal smearing effect.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Well, that effect is basically due to mip-mapping; sampling more times along the axis that stretches the texels the most allows you to pick a higher resolution mipmap without getting aliasing. It does not apply without mipmapping.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I'll definately try mip mapping again tomorrow (I had a dabble a few months back), and esp those non-uniform mip map levels to see what happens.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I don't want to sound like a critique here, but do you know why your artifacts appear, or are you just randomly stabbing at the problem? Your explanation leads me to believe the second to be true, but please correct me if I'm wrong. If you're not mipmapping already, anisotropic filtering shouldn't help - at least not in theory :P
<br/>
<br/>
If you ARE already using mipmapping, then the non-uniformly resampled textures can make some sense to try. Keep in mind that you need to take the non-uniform scaling into account when picking mip-level.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I figured AF'd be pretty expensive, and it'd definately chew the memory system a bit. I was just going to try all the options to see which gives the best result then pick the one that gives the best quality/performance ratio.
<br/>
<br/>
So...if you were to code this, what would you do? Ta mate :-)
<br/>
</td> </tr></table><span class="postbody">
<br/>
First, I would try to avoid steep angles when mip-mapping. This might not always be possible, though - especially not in interactive environments. Second, I don't think I'd try anisotropic filtering when performance is an issue - it's simply too expensive. Bilinear filtering in itself is pretty damn expensive, at least when implemented in traditional way. All these techniques multiply the amount of memory-fetches by quite a lot, and texture-swizzling to improve locality is often quite expensive in software, due to most CPUs lack of bit-interleaving operations. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">PS: what other options do I have to improve my texture mapped results other than mip maps/bilinear/trilinear/AF?</td> </tr></table><span class="postbody">
<br/>
I'm a sucker for per-pixel effects. dot3-bumpmapping and embm looks ace, imo. And they are both feasible, even on GBA ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153982 - simonjhall - Tue Apr 08, 2008 11:12 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">Well, that effect is basically due to mip-mapping; sampling more times along the axis that stretches the texels the most allows you to pick a higher resolution mipmap without getting aliasing. It does not apply without mipmapping.</td> </tr></table><span class="postbody">M'kay, I'll check it out with and without mip mapping and see what happens. Isn't the whole point of mip-mapping the improvement in texture-cache performance, not the improvement in image quality? Shouldn't I (in an ideal world) be increasing the number of texture samples the further away the pixel I'm writing out is from the camera? (as in more Z, more samples?)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I don't want to sound like a critique here, but do you know why your artifacts appear, or are you just randomly stabbing at the problem?</td> </tr></table><span class="postbody">Stabby stabby stab stab!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">If you ARE already using mipmapping, then the non-uniformly resampled textures can make some sense to try. Keep in mind that you need to take the non-uniform scaling into account when picking mip-level.</td> </tr></table><span class="postbody">Yeah I was wondering how you'd pick which mip-level to pick as I've only done it before on regular half-sized/quarter-sized/etc-sized mip images. Can't be too hard, right? I guess I just need to check out my U and V step values to infer what to do...
<br/>
<br/>
Btw I guess it's obvious that graphics isn't what my speciality is - thanks for the help!<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153993 - kusma - Wed Apr 09, 2008 1:20 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">Isn't the whole point of mip-mapping the improvement in texture-cache performance, not the improvement in image quality? Shouldn't I (in an ideal world) be increasing the number of texture samples the further away the pixel I'm writing out is from the camera? (as in more Z, more samples?)
<br/>
</td> </tr></table><span class="postbody">
<br/>
Yes, but it's also a matter of image quality. Since one usually uses a box-filter to calculate a mipmap level from the base texture, you end up actually doing more samples. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Yeah I was wondering how you'd pick which mip-level to pick as I've only done it before on regular half-sized/quarter-sized/etc-sized mip images. Can't be too hard, right? I guess I just need to check out my U and V step values to infer what to do...
<br/>
</td> </tr></table><span class="postbody">
<br/>
It's actually quite simple. For uniformly scaled miplevels, "just" take log2(max(max(abs(dudx), abs(dudy)), max(abs(dvdx), abs(dvdy))))  at each pixel. Yeah, so choosing mipmap level per pixel might be a bit expensive, but I'm sure you can use this info to find your own way of doing a per-polygon mipmap selection.
<br/>
<br/>
For non-uniformly scaled miplevels, just lookup your table based on
<br/>
log2(max(abs(dudx), abs(dudy))) and log2(max(abs(dvdx), abs(dvdy))).
<br/>
<br/>
If it wasn't for that damn perspective correction the per-pixel mipmap level would be the same as the per-polygon mipmap level, but because of the division dudx, dudy, dvdx and dvdy changes from each pixel to the next. (or usually, 2x2 pixel group, but that's a whole different story)
<br/>
<br/>
Oh, and in case you're not aware of this quite commonly used terminology (I'm sure you are, but here you go anyway):
<br/>
<br/>
dudx is the amount the u coordinate (texture space "x") changes between two pixels in the x-direction in screenspace. dudy is the same, but in y-direction. dvdx and dvdy are the same, but for the v coordinate (texture space "y"). Also keep in mind this commonly used texture space definition:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
t=1, v=4
<br/>
          .-------------------.
<br/>
          |    |    |    |    |
<br/>
          |----+----+----+----|
<br/>
          |    |    |    |    |
<br/>
          |----+----+----+----|
<br/>
          |    |    |    |    |
<br/>
          |----+----+----+----|
<br/>
          |    |    |    |    |
<br/>
t=0, v=0  `-------------------?
<br/>
          s=0                  s=1
<br/>
          u=0                  u=4
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
As you can see, &lt;s,t&gt; is the un-normalized texture coordinates. They range from &lt;0,0&gt; to &lt;1,1&gt; across the texture, while &lt;u,v&gt; are normalized and range from &lt;0,0&gt; to &lt;w,h&gt;. As you probably understand, the mipmap level is calculated from the &lt;u,v&gt;-set, as the texture size would have to be taken into account.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#153997 - silent_code - Wed Apr 09, 2008 2:59 am</h4>
    <div class="postbody"><span class="postbody">i hope i'm not wrong with my understanding, but:
<br/>
<br/>
- mipmapping should reduce pixel oversampling (often seen in nds games as high frequency color changes due to distant objects' texture samples - and thus colors - being changed too fast). i fail to see any memory benefits when you have multiple different sized instances of one image in memory... le't not talk about the special cases, where you have only a few low res instances in memory. nds games tend not to have great view distances anyway. ;^)
<br/>
<br/>
- af is - to my knowledge -, as kusma already wrote, rather an improvement to mipmapping or better: trilinear filtering. you could still do it without the mips, but i don't know if that would pay off in the end. well, in general i'd say, it's a way to minimize undersampling... and maybe oversampling, too. man, you got me thinking right now! i'll check that asap. ;^D
<br/>
<br/>
did you think about rip mapping? it's like a computationally less expensive, although limited, inbetween step towards af. although it would require more mip levels... :^S
<br/>
<br/>
i guess anything beyond trilinear mapping would be insane, though. but actually i wish you'll manage to pull it off anyway. :^D
<br/>
<br/>
well, i just wonder what you want to do with that neat little piece of software when it's done? :^)
<br/>
<br/>
greets!
<br/>
<br/>
ps: nice infos kusma (mip level formula!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154005 - kusma - Wed Apr 09, 2008 9:27 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>silent_code wrote:</b></span></td> </tr> <tr> <td class="quote">i fail to see any memory benefits when you have multiple different sized instances of one image in memory... 
<br/>
</td> </tr></table><span class="postbody">
<br/>
While the visual quality is definately a good property of mipmapping, you also have the benefit of better cache-locality; if less memory is required for a texture-surface, less cache-lines will have to be read in to the cpu. This applies only to cached architectures, but you CAN in theory take benefit from it even on non-cached architectures like GBA by having an explicit TCM/IWRAM texture cache. That's however quite tricky to get efficient.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">trilinear filtering. you could still do it without the mips, but i don't know if that would pay off in the end. well, in general i'd say, it's a way to minimize undersampling... and maybe oversampling, too. man, you got me thinking right now! i'll check that asap. ;^D
<br/>
</td> </tr></table><span class="postbody">
<br/>
uuuh... trilinear filtering is by definition linear interpolating between two different mip-map levels based on the fractional part of the LOD (the equation I gave was basically the LOD-formula - it might have an off-by one or something when I think about it). So it makes no sense in talking about trilinear filtering without mipmapping.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">did you think about rip mapping? it's like a computationally less expensive, although limited, inbetween step towards af. although it would require more mip levels... :^S
<br/>
</td> </tr></table><span class="postbody">
<br/>
Indeed, "rip mapping" is a commonly used term for non-uniform scaled mipmaps, and it was the name I was looking for but couldn't remember ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154006 - simonjhall - Wed Apr 09, 2008 9:44 am</h4>
    <div class="postbody"><span class="postbody">@ kusma
<br/>
Hang on, I thought UVs went from 0-1 (hence the normalised thing), and ST co-ordinates went from 0-width and 0-height?
<br/>
<br/>
And cool on that big ol' log formula. However I obviously don't want to do that per-pixel. The maxes I can do easily enough but the log2 looks a bit of an arse! Are there any cheats that I can do to avoid doing this computation too frequently?
<br/>
I reckon I can get away with just doing a per-poly mipmap selection as my geometry isn't unlikely to cross mipmap boundaries too frequently...
<br/>
<br/>
Just to clarify, if I'm going for non-uniform mipmaps do I select them like
<br/>
the u dimension: log2(max(abs(dudx), abs(dudy)))
<br/>
the v dimension: log2(max(abs(dvdx), abs(dvdx)))
<br/>
?
<br/>
<br/>
Oh and I completely forgot that mip-maps were resampled offline - I was definately having a special moment there! So I guess it is effectively the same as having more samples per pixel as the Z increases.
<br/>
<br/>
@ silent_code
<br/>
rip mapping is the same as non-uniform mip mapping, right? As in you've got your big texture (say) 512x512, then rather than having 256x256, 128x128, 64x64 etc you've got 512x256, 256x512, 256x256, 256x128 etc, right?
<br/>
<br/>
I'm trying to use this piece of tech in some image processing software and the results of this are going to be machine-analysed, which is why quality's an issue. I would do this on the GPU but that'd mean I'd have to wait until the end of the frame (and use a shader to do the image processing) but that's much too late.
<br/>
I think you're right about anything more than trilinear being tough. I was in the shower earlier trying to figure out the asm for bilinear/trilinear and was kicking myself (in the shower) for considering more samples per pixel! Nearest-neighbour seems a whole lot easier in comparison ;-)<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154010 - kusma - Wed Apr 09, 2008 11:22 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Hang on, I thought UVs went from 0-1 (hence the normalised thing), and ST co-ordinates went from 0-width and 0-height?
<br/>
</td> </tr></table><span class="postbody">
<br/>
No, that's not how it's usually defined. Check figure 3.10 in the OpenGL 2.0 specification if you don't believe me. Ofcourse, this is just a commonly used terminology, though. What you call your coordinates is completely up to you - I'm just trying to keep a somewhat consistent terminology so we don't talk in circles :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
And cool on that big ol' log formula. However I obviously don't want to do that per-pixel. The maxes I can do easily enough but the log2 looks a bit of an arse!
<br/>
</td> </tr></table><span class="postbody">
<br/>
How so? Remember that what you really want to do (as long as there's no trilinear filtering) is floor(log2(x)). For fixed-point numbers, log2() is just a clz-instruction with input-shift on an ARM9 (there's an x86 instruction as well, but I don't remember it's name right now), and you can do it easily with two iterations of binary search and an 256 element lookup-table for the rest.
<br/>
<br/>
For floating point it should be a matter of picking the exponent-bits from the binary representation - if a fast log2() function isn't already available, that is.
<br/>
<br/>
Or how about clamping the delta-values to some range, and looking up the most significant bits in a LUT to decide miplevels?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Are there any cheats that I can do to avoid doing this computation too frequently?
<br/>
</td> </tr></table><span class="postbody">
<br/>
Sure. Most perspective correct mappers use scanline subdivision to reduce the amount of RCPs, and you could pick the miplevel for each span, I guess.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I reckon I can get away with just doing a per-poly mipmap selection as my geometry isn't unlikely to cross mipmap boundaries too frequently...
<br/>
</td> </tr></table><span class="postbody">
<br/>
The Quake software rasterizer used something like z-distance only, and it worked out quite well there, so I guess you're right. All in all, you just have to try it out and see how it looks. Stabby stab stab stab ;)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Just to clarify, if I'm going for non-uniform mipmaps do I select them like
<br/>
the u dimension: log2(max(abs(dudx), abs(dudy)))
<br/>
the v dimension: log2(max(abs(dvdx), abs(dvdx)))
<br/>
?
<br/>
</td> </tr></table><span class="postbody">
<br/>
Apart from the typo, yes. It's not supposed to be dvdx twice.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Oh and I completely forgot that mip-maps were resampled offline - I was definately having a special moment there! So I guess it is effectively the same as having more samples per pixel as the Z increases.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Absolutely, yeah. You can do SOME filtering online if it makes sense, but usually just pre-filtering everything works well.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154017 - simonjhall - Wed Apr 09, 2008 1:57 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">No, that's not how it's usually defined.</td> </tr></table><span class="postbody">Word.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">For floating point it should be a matter of picking the exponent-bits from the binary representation - if a fast log2() function isn't already available, that is.</td> </tr></table><span class="postbody">Kewl. I'll look into this. Yeah I guess this makes sense and I should be able to do this in just a couple of instructions.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Sure. Most perspective correct mappers use scanline subdivision to reduce the amount of RCPs, and you could pick the miplevel for each span, I guess.</td> </tr></table><span class="postbody">Cool. I was thinking about this but have yet to get round to coding it as I'm stuck in meetings all day today! Again, it's all about how good it looks. If it doesn't make too much of a difference to the image quality (even at dramatic angles) then I'll do this! Also depends how much faster I can make it without the divides, I guess. Might only save me one clock per loop...hmm...
<br/>
<br/>
Ugh, I'm so bored today! I have zero motivation to doing anything. I did just go and get my shoes reheeled though, so I guess that's exciting. Ugh.<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154020 - silent_code - Wed Apr 09, 2008 3:23 pm</h4>
    <div class="postbody"><span class="postbody">yepp, you're right about the rip maps. ;^D
<br/>
<br/>
@kusma: i know af works like that, but not knowing too much about the impementation, i was just wondering if it ould contribute anything to unmipped textures. that's because all my old software renderers didn't have texturing - i kind of skipped that chapter in favor of learning to use hw acc. ;^D
<br/>
<br/>
aaaand i misunderstood parts of your first two posts. that and simons posts got me thinking if i had missed something about af. to me it has always been a better trilin. then i just thought ... not a good idea when it's 3 in the morning and you're just happen to go to bed. ;^)
<br/>
<br/>
EDIT: ok, i tested it on the pc and af without mipmapping does *reduce* image quality. basically, it introduces border texel artifacts due to oversampling (because of the lack of mipmapping, i guess). when disabled, the image looks as expected. i might temporarily upload some images showing these artifacts when needed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154121 - simonjhall - Fri Apr 11, 2008 4:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">(or usually, 2x2 pixel group, but that's a whole different story)</td> </tr></table><span class="postbody">I forgot to ask you - what did you mean by this?
<br/>
I'm implementing the rip-maps (rip-raps, cos I think that sounds cooler) right now and have re-read this post about nine times :-)<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154126 - silent_code - Fri Apr 11, 2008 7:29 pm</h4>
    <div class="postbody"><span class="postbody">iirc, persp. corr. isn't computed for all pixels, but for small pixel blocks, e.g. 2x2 pixels. i haven't done anything in that field for years, so i don't quite remember enough to tell you how you could benefit from this... thinking about memory access, it makes more sense to me to do it per scanline and make the needed subdivisions occurs every few (2, 4, 8, whatever) pixels.
<br/>
<br/>
i imagine one could use a list (read: array) for the blocks and after precomputing the correction values per block, the scanline filler could access those values. again, i don't know about memory access. such a list could fit into the cache for rather medium to small triangles (as usually depending on screen resolution), but small triangles don't need p.c.
<br/>
<br/>
i hope i'm not totally wrong this time. as i said, it's been a while. ;^)
<br/>
hope kusma will clarify things and post about the effect on memory access etc. :^)
<br/>
<br/>
that's a rather interesting topic. i feel a little bit warm on the inside when writing about software rendering... :^D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#154130 - kusma - Fri Apr 11, 2008 8:13 pm</h4>
    <div class="postbody"><span class="postbody">The 2x2 comment was basically that you need the derivate function for the perspective corrected texture coordinates (not the deltas before perspective correction), and calculating this analytic is a bitch - and things gets even more complicated when doing indirect texturemapping. So instead of trying to do that, graphics hardware make fragments from pixels in 2x2 pixel groups "meet" in the pipeline, and assign all four pixels the difference in sampling-coordinates as derivative. This mechanism also makes it possible to take the derivate of any function in a fragment shader. The down-side is that 2x2 pixels groups gets the same derivate values, and hence the same texture-lod.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#155235 - silent_code - Sun Apr 27, 2008 12:28 am</h4>
    <div class="postbody"><span class="postbody">hey, simon!
<br/>
i was wondering in what direction you went with the renderer?
<br/>
greetings! :^D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157284 - simonjhall - Wed May 21, 2008 6:59 pm</h4>
    <div class="postbody"><span class="postbody">Alright, I'm back on this bad boy full time now rather than the the messing around that I was doing before. I really wanna give more background info etc...but I can't because of the confidential nature of the game etc.
<br/>
<br/>
Anyway, the kind of textures that I'm using are quite small and are likely to always be small-ish. However there's gonna come a time when I need to use big textures, but I've only got a small amount of memory dedicated to my 'live' texture store (with my entire texture collection living elsewhere in memory).
<br/>
<br/>
I can see three texturing scenarios:
<br/>
1) I've got a handful of small textures - their combined sizes is less than the live textures store, therefore they can all be loaded in upfront into this memory and I can texture directly from it
<br/>
2) I've got lots of small textures - no one texture is larger than the live texture store so I can pull them in on an LRU basis (like I do in Quake ;-)
<br/>
3) I've got a number of large textures - but at least one texture is larger than my live store. I'm gonna have to pull in small blocks of the full texture and evict them based on a LRU scheme.
<br/>
<br/>
Any other scenarios?
<br/>
<br/>
The beef that I have with #3 is that it's gonna be well slower compared to the first two - with them I can get the texel that I want in just a handful of clock cycles, but with the third I'm going to have to compute which block of my texture that texel lies in then see if that block exists within the cache. Assuming it is, I can pick out the texel. If not then I've got to evict an old block and load in a new one then pull out the texel. I've got to do this scheme *per texel* too, right? (this would normally be all done in hardware...)
<br/>
<br/>
This is obviously a pretty phat bit of code just to fetch one texel. Are there any other ways of doing this? Are there any assumptions that I can make about a triangle/scanline/block of pixels?
<br/>
One way I've been thinking about is given the current scanline output a list of all the texels that I'm going to need to compose the output pixel and then whilst I'm doing my rasterisation for the next scanline I can be reading in my texels for the previous scanline - no caching involved.
<br/>
<br/>
Anyone got any things to try/suggest/whatever?
<br/>
<br/>
/random thoughts...<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157296 - silent_code - Wed May 21, 2008 9:11 pm</h4>
    <div class="postbody"><span class="postbody">as an extension to your curent approach:
<br/>
you're sure doing perspective correction once in a while (every so and so pixels and scanlines). maybe you could find out what "pixel blocks" (about the "blocks" / tiles: think of how the power vr renders stuff [if i'm not totally wrong here], only you use the PCT pixel and scanlines as blocks) would need what texture during that step.
<br/>
then, you could render those pixel blocks in an order, that would require a minimum change in textures (so that a texture fragment [a texture pixel block, that may or may not represent the whole texture or just a part of it that firts the cache] wouldn't have to be fetched more than once for a given primitive.)
<br/>
i haven't tried it out, as i've not gotten into sw rendering for quite a while, but you might be able to pull this off. after all, the x360 has a quite similar problem with high resolutions and AA, because the "render buffer" memory is only 10mb. ;^D
<br/>
<br/>
as most of the time, this was just a friendly suggestion. it would be nice to read, if that helped *anything* at all. ;^D<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157306 - simonjhall - Wed May 21, 2008 10:26 pm</h4>
    <div class="postbody"><span class="postbody">I am actually doing all my rendering into small tiles (like you mention, roughly 128x128) as I can't fit either the frame buffer nor the depth buffer into memory. But that does imply that there can only be so many texels needed within one of these tiles for a given triangle, so maybe there's something that I can do with that...
<br/>
<br/>
Hmm...
<br/>
<br/>
In fact re-reading what you said, I think the thing about rendering the tiles in an order that some how guaranteed that I don't need to switch out a texture cache block would be just plain mega. I'll have to think about that!
<br/>
Really, I don't want to be 99% sure that the texel I want is in memory (as that would require me to do a check per access) so some kind of guarantee would be just great!
<br/>
<br/>
Hmm! Good stufff. Any more ideas?
<br/>
<br/>
(oh and the 360 thing - a graphics programmer that I work with used to do 360 and said the same thing, and mentioned that when you use AA "you need three tiles" or something!)<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157688 - simonjhall - Tue May 27, 2008 9:12 pm</h4>
    <div class="postbody"><span class="postbody">Anyone ever tried the large model data set from Standford University?
<br/>
<a href="http://graphics.stanford.edu/data/3Dscanrep/" target="_blank">http://graphics.stanford.edu/data/3Dscanrep/</a>
<br/>
I've been staring at spinning teapots for a week and feel a need for a change...but they're a little high poly for my taste. Although the file format doesn't look too hard to load.
<br/>
<br/>
Actually, does anyone know how a modern 3D card will handle rendering a model with a shit load of faces? Some of those models have millions of vertices and I've never tried drawing something like that with OpenGL before.<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157692 - silent_code - Tue May 27, 2008 9:21 pm</h4>
    <div class="postbody"><span class="postbody">i've seen some of them being used in research, so, i guess it's possible. although, i'll have to check it out some day, as it's really interesting. :^)
<br/>
<br/>
but i honestly don't know if you'd sort for vertex cache hits or overdraw with the really hughe models. i guess the former, as they don't look like having too much overdraw, right? (the me is stupid. [because this sounds soooo random!])<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157697 - DensitY - Tue May 27, 2008 9:51 pm</h4>
    <div class="postbody"><span class="postbody">I don't use opengl on PC (generally Direct3d). millions of vertices, generally depending on the scene I'd stuff it all into 1 vertex buffer and setup a indices buffer indexing the vertices for the triangles and just render it out. the only time u need to stop todo anything else is if there is state or texture changes. overall most modern 3d cards will just draw that much data reasonable well, alot of games have scenes with up to a million triangles now, so long as you can fit it into video memory it just renders. 
<br/>
<br/>
modern 3d cards are amazing things.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157715 - kusma - Wed May 28, 2008 12:50 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">Anyone ever tried the large model data set from Standford University?
<br/>
<a href="http://graphics.stanford.edu/data/3Dscanrep/" target="_blank">http://graphics.stanford.edu/data/3Dscanrep/</a>
<br/>
</td> </tr></table><span class="postbody">
<br/>
I'm sorry, but I have PROPER real-world datasets, not just university-thesis bullcrap :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157724 - simonjhall - Wed May 28, 2008 7:43 am</h4>
    <div class="postbody"><span class="postbody">Can you share? ;-)
<br/>
<br/>
But yeah how is scanning a bunny a thesis? I can just imagine it when you go for an interview:
<br/>
"so what did you do for your thesis?"
<br/>
"oh, I spent years developing a bunny scanner. now we can scan as many bunnys as we like in high-res, so that we can render them back out again. it was a reeeeaally hard degree."
<br/>
"ok... next?"<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
