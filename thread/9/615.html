<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Writing to VRAM in mode 4 - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Graphics > Writing to VRAM in mode 4</h2>
<div id="posts">
<div class="post">
    <h4>#3137 - mantrid - Tue Feb 18, 2003 10:24 pm</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
<br/>
Mode 4, the pallete mode. It says in the documentation I have gbatek.txt that you have to wite to ram 16 bits at a time...fair enough. Now does that 16 bit also have to be 2 byte aligned also like memory acces?
<br/>
<br/>
I.e.
<br/>
<br/>
is static tUint8 * const ScreenRamPtr = (tUint8*)0x6000000;
<br/>
<br/>
*(u16*)ScreenRamPtr+1 = 0xff;
<br/>
<br/>
Ok?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3140 - peebrain - Tue Feb 18, 2003 10:44 pm</h4>
    <div class="postbody"><span class="postbody">It has to be aligned.
<br/>
<br/>
~Sean<br/>_________________<br/><a href="http://www.pbwhere.com" target="_blank">http://www.pbwhere.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3143 - mantrid - Tue Feb 18, 2003 10:59 pm</h4>
    <div class="postbody"><span class="postbody">Yes I would have thought so too, but the code below seems to work ok, but in theory each 32 bit access to the screen is on an odd address. I surpose that the least significant bit is just ignored then and the cpu doesn't generate any bus faults.
<br/>
<br/>
static tUint16 * ScreenRamPtr = (tUint16*)0x6000001;
<br/>
<br/>
tBool UB_SoftKeysPresent;
<br/>
tBool UB_SoftKeysRightLeft;
<br/>
<br/>
unsigned UB_PanScreenDelta;
<br/>
<br/>
/* Exported Functions */
<br/>
<br/>
<br/>
void TargetScreenUpdate(void)
<br/>
{
<br/>
	register int	i;
<br/>
<br/>
	for (i = 0; i &lt; (UB_PhysicalScreenWidth&gt;&gt;2) * UB_PhysicalScreenHeight ; ++i)
<br/>
	{
<br/>
		((tUint32*)ScreenRamPtr)[i] = ((tUint32*)UB_PhysicalScreenRamPtr)[i];
<br/>
	}
<br/>
<br/>
}</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3156 - DekuTree64 - Wed Feb 19, 2003 5:16 am</h4>
    <div class="postbody"><span class="postbody">I think a 32-bit write to an address like 0x6000001 would be the same as one to 0x6000000, but a 32-bit write to 0x6000002 would write the first 2 bytes (halfword) to 0x6000002, and the second halfword to 0x6000000. I haven't tested writing to a 4-byte aligned +3 (like 0x6000003), but I'd guess it'd be the same as +2. Also, 16-bit writes to odd adresses swap the 2 bytes the same as misaligned 32-bit writes swap the 2 halfwords.
<br/>
<br/>
So the bottom line is you have to write at least 2 pixels at a time in mode 4.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3169 - mantrid - Wed Feb 19, 2003 11:37 am</h4>
    <div class="postbody"><span class="postbody">Thanks for the info. I also see that there is some stuff about this in the Cowbite docs.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
