<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Large Maps - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Graphics > Large Maps</h2>
<div id="posts">
<div class="post">
    <h4>#348 - snug - Mon Jan 06, 2003 6:53 pm</h4>
    <div class="postbody"><span class="postbody">I've come up with a few ways of doing large maps, like using a hardware BG map and reloading it with an offset after every 8 pixels. I'm just curious how other people are doing this.
<br/>
<br/>
Adam</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#355 - sgeos - Mon Jan 06, 2003 8:25 pm</h4>
    <div class="postbody"><span class="postbody">It is done something like that.  That is the solution I'd use.  Have you seen how Breath of Fire solves that problem?  It's kind of neat.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#358 - snug - Mon Jan 06, 2003 8:44 pm</h4>
    <div class="postbody"><span class="postbody">No I haven't. Would you mind sharing with me? I'm working on an engine and I'm trying to find the best way to do it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#370 - sgeos - Mon Jan 06, 2003 11:28 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>snug wrote:</b></span></td> </tr> <tr> <td class="quote">No I haven't. Would you mind sharing with me? I'm working on an engine and I'm trying to find the best way to do it.</td> </tr></table><span class="postbody">
<br/>
<br/>
It uses a 64 tile wide by 32 tile high scheme.  With a 32 tile wide scheme you can only load 8 by 8 bg tiles, but it looks like they are using 16 by 16 bg tiles.  As you walk, the BG keeps scrolling (in a circular manner, no 8 pixel deal) and writes over the old stuff when it gets there.  I'm not sure exactly how it works, but it seemed to load 'half tiles', that is 8 by 8 tiles.  I thought it was an interesting solution.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#382 - Costis - Tue Jan 07, 2003 3:00 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
16x16 pixel background tiles are not supported in hardware. Only 8x8 BG tiles can be used. All other tiles that are in BG layers and appear to be larger are just "meta-tiles", which are really just 8x8 tiles placed together.
<br/>
<br/>
Costis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#394 - anli - Tue Jan 07, 2003 9:55 am</h4>
    <div class="postbody"><span class="postbody">You can get 16x16 bit tiles if you use bg scaling :)
<br/>
<br/>
If you have a big map, I would recommend using a small bg and
<br/>
do the hardscroll by modifying the screenbase data every 8th scroll tick.
<br/>
<br/>
Then you can decide the dimensions freely.
<br/>
<br/>
Just how I would do
<br/>
<br/>
/anli</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#396 - ampz - Tue Jan 07, 2003 10:04 am</h4>
    <div class="postbody"><span class="postbody">I have a bitmap game where all the tiles are unique and changing all the time.
<br/>
I use a text BG with tiles just to get hardware scrolling.
<br/>
There is space in video RAM for "almost" one unique tile for every tile position on screen, left me with a small border, perfect for the menu ;)
<br/>
It's quite complicated to do pixel modifications in a text BG, but I got it working.
<br/>
<br/>
I don't know if others use the same "trick" just to get hardware scrolling when a bitmap mode should really be used?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#397 - Lord Graga - Tue Jan 07, 2003 10:05 am</h4>
    <div class="postbody"><span class="postbody">But in a engine it might be necesary to have 16x16 tiles in a engine because of the lack of variable space. Then a small map only need 256 variables in a array (that is four times smaller).
<br/>
A sample loading method could be (note, it is untested):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int i,j;
<br/>
<br/>
for(i=0;i&lt;16;i++) //Every other vertical line of mem
<br/>
{
<br/>
for(j=0;j&lt;16;i++) //Every other horizontal line of mem
<br/>
{
<br/>
ScreenMem[i*2+j*2] = map[i*j];
<br/>
ScreenMem[i*2+j*2+1] = map[i*j];
<br/>
ScreenMem[i*2+j*2+32] = map[i*j];
<br/>
ScreenMem[i*2+j*2+33] = map[i*j];
<br/>
}
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#2441 - Francis Lillie - Tue Feb 04, 2003 1:07 am</h4>
    <div class="postbody"><span class="postbody">There are a number of ways of doing large maps, but the one I am going for, and which will work well for what I need (as I did it on the Megadrive), is to have the tile screen made up of unique character numbers.  That is have the map numbered 0-31 across the top row, then 32-63, and so on for a screen size of 32x22.  This means that I need room in VRAM for 704 unique characters.  When I scroll 8 pixels, I know which row or colum goes off screen, and therefore which characters are now free in VRAM, and upload tiles to those slots.  The actual "map" in VRAM never changes.  Worst case scenario is that a row and a column of characters gets sent to VRAM each frame, which is either 1728bytes or 3456 bytes.  A complete map screen of 32x22 is 1408 bytes.  Take your pick.  Using this method, having meta-tile sizes of 64x64 I plan to have map sizes of 3km x 3km, where 1 8x8 character represents 1m x 1m.  Another advantage of the unique character approach is that I can store certain events, such as tyre marks (yes, I'm doing a driving game) and alter the character data as I upload it without affecting any other place that that character data is used on screen.  Effectivley a bitmap based character map.  it's the way the deformable landscapes were done on Worms back on the Megadrive and SNES.  Hope this helps.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4169 - DiscoStew - Fri Mar 21, 2003 11:23 pm</h4>
    <div class="postbody"><span class="postbody">I new to this forum, but I have a little knowledge about programming for the GBA, and after looking at some of the docs, I've come to this conclusion (I haven't tried this, since I'm not around my own computer to try it out).
<br/>
<br/>
The way the Text Backgrounds are laid out (according to my understanding from ThePernProject), each 256x256 (or 32x32 tiles) is it's own block of data. What I mean is that the structure is in an order like this...
<br/>
32 tiles from left to right on 1st vertical block, then
<br/>
32 tiles from left to right on 2nd vertical block, ... until
<br/>
32 tiles from left to right on 32nd vertical block.
<br/>
<br/>
Of course you all knew that, but where I'm getting at is that with the other background dimensions of Text Backgrounds,  it's laid out the same way, but the first 32x32 tiles on the top-left side is structured first, then the next 32x32 tiles on the top-right side are next, then 32x32 tiles of bottom-left, then lastly, 32x32 tiles on bottom-right (as structured of a 512x512 size background). For this size of a background, to my knowledge, it isn't ordered like...
<br/>
64 tiles from left to right on 1st vertical block,... until
<br/>
64 tiles from left to right on 64th vertical block...
<br/>
but is structured like I said above.
<br/>
<br/>
So, to have a large map, I would have every map before compiling into the GBA format be split into even 32x32 tiles from whatever width to whatever height, as long as it is divisable by 32 each way. Then the regular load map into external RAM, and load a 2x2 section of your 32x32 tile split map (whichever you wish to start from) into the VRAM where your data for the 512x512 text background is like so...
<br/>
1st section placed into mapdatalocation,
<br/>
2nd section placed into mapdatalocation + 32x32x2bytes,
<br/>
3rd section placed into mapdatalocation + ((32x32x2bytes) x2),
<br/>
4th section placed into mapdatalocation + ((32x32x2bytes) X3),...
<br/>
<br/>
...and when you scroll your background, when entering a new 32x32 section, just offset your x and y counters (whatever is needed) that locate the complete map data comprised of your 32x32 sections, and load them into you mapdatalocation like above.
<br/>
<br/>
Like I said before, I haven't tried this procedure yet, but to me it looks like it should work. I'd draw a picture or something, but I am unable to at this time. I hope those of you who read this understand it, and that you can use it to your advantage.
<br/>
<br/>
Just my 2 cents.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4175 - tepples - Sat Mar 22, 2003 2:49 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DiscoStew wrote:</b></span></td> </tr> <tr> <td class="quote">So, to have a large map, I would have every map before compiling into the GBA format be split into even 32x32 tiles ...and when you scroll your background, when entering a new 32x32 section, just offset your x and y counters (whatever is needed) that locate the complete map data comprised of your 32x32 sections, and load them into you mapdatalocation like above.</td> </tr></table><span class="postbody">
<br/>
Some games actually do this, but there is one slight potential problem with this technique.  It may be possible for the player to walk back and forth across the borders so as to require loading two new map segments quite often.  If your maps are compressed, loading a new map segment can take a long time (possibly longer than one frame), making the scrolling appear jumpy.
<br/>
<br/>
In addition, using a 64x64 tile map uses 6 KB more VRAM than using a 32x32 tile map.  Be prepared to give up 192 tiles.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#4255 - DiscoStew - Wed Mar 26, 2003 12:54 am</h4>
    <div class="postbody"><span class="postbody">6K VRAM? Dang, I never thought of it that way. Though there is 64K total for both tiles and map data, losing 192 tiles (or more depending on how many 64x64 map sizes you have) can be bad. I guess it all depends on how you set up everything.
<br/>
<br/>
The jumpiness that you described could be fixed (somewhat). Instead of each section being 32x32, the actual sections could be 30x30 with a tile extra for each of the 4 sides, still making it 32x32. Then when loading up a new portion, just reposition the background coordinates to make it look like it's still moving as it should. By doing this, when you move over to a new section, you'll be 8 pixels (1 tile) away from the edge of reloading the last section of map data, so the jumpiness will not exist (or at least not as frequent).
<br/>
<br/>
This is one reason why I like these forums. You give your comment, someone gives you a question concerning it, and you (usually) find out the solution. It helps me think a little more.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
