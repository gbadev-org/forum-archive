<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Stylus & PAD-friendly GUI's - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>DS Misc > Stylus & PAD-friendly GUI's</h2>
<div id="posts">
<div class="post">
    <h4>#141920 - keldon - Mon Oct 01, 2007 5:37 pm</h4>
    <div class="postbody"><span class="postbody">How do you generally go about implementing GUI's on the DS where the user interface is more in the form of an application than a game in regards to GUI element navigation.
<br/>
<br/>
I could tackle it by allowing each screen to have both dynamic navigation hints, and to be able to read from a file. This is how I did my uni project; I edit not_so_easily_computable (or at least quicker to etch in GIMP) via SVG editing, and leave anything with a uniform arrangement down to algorithms. Of course you can also have a search method that will search for the best candidate in a particular direction using simple distance heuristics.
<br/>
<br/>
Having said that, I've just examined the approach used in Windows; it just goes for the shortest distance within 45 degrees in the direction you are aiming at!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#141969 - keldon - Tue Oct 02, 2007 5:34 pm</h4>
    <div class="postbody"><span class="postbody">After a quick jot on the paper and examination of Windows' implementation, I decided that I might as well just write a simple search method. I haven't tested it with anything other than two items, but Windows appears to be doing nothing other than finding the nearest object clipped to a view of 45 degrees!
<br/>
<br/>
I've inserted the code in case anybody wanted to look at it (for whatever reason).
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   GUI_OBJ* find_next_object ( DIRECTION direction, GUI_OBJ&amp; current_object, GUI_OBJ** obj_list, int obj_list_cnt )
<br/>
   {
<br/>
      int min_dist = 1024*1024 + 1024*1024;   // The maximum distance should be 256*256 + 384*384
<br/>
      GUI_OBJ* nearest_object = NULL;
<br/>
      
<br/>
      const int current_object_x = current_object.get_x() + (current_object.get_width()/2);
<br/>
      const int current_object_y = current_object.get_y() + (current_object.get_height()/2);
<br/>
      
<br/>
      for ( int i = 0; i &lt; obj_list_cnt; ++i )
<br/>
      {
<br/>
         GUI_OBJ&amp; potential_object = *obj_list[i];
<br/>
         DIRECTION current_direction;
<br/>
         
<br/>
         const int potential_object_x = potential_object.get_x() + (potential_object.get_width()/2);
<br/>
         const int potential_object_y = potential_object.get_y() + (potential_object.get_height()/2);
<br/>
         const int x = potential_object_x - current_object_x;
<br/>
         const int y = potential_object_y - current_object_y;
<br/>
         const int xx = x*x;
<br/>
         const int yy = y*y;
<br/>
         
<br/>
         if ( &amp;current_object == &amp;potential_object )
<br/>
         {
<br/>
            continue;
<br/>
         }
<br/>
         
<br/>
         /*
<br/>
         *   Identify direction between current_object and potential_object
<br/>
         */
<br/>
         if ( (y&gt;=0) &amp; (xx&lt;=yy) )
<br/>
         {
<br/>
            current_direction = DIR_DOWN;
<br/>
         }
<br/>
         else if ( (x&gt;=0) &amp; (yy&lt;=xx) )
<br/>
         {
<br/>
            current_direction = DIR_RIGHT;
<br/>
         }
<br/>
         else if ( (y&lt;0) &amp; (xx&lt;=yy) )
<br/>
         {
<br/>
            current_direction = DIR_UP;
<br/>
         }
<br/>
         else if ( (x&lt;0) &amp; (yy&lt;=xx) )
<br/>
         {
<br/>
            current_direction = DIR_LEFT;
<br/>
         }
<br/>
         else
<br/>
         {
<br/>
            K_ASSERT(FALSE, "Direction of object is uncertain, which should be impossible!\n");
<br/>
         }
<br/>
         
<br/>
         if ( current_direction != direction )
<br/>
         {
<br/>
            continue;
<br/>
         }
<br/>
         
<br/>
         if ( (xx+yy) &lt;= min_dist || (NULL == nearest_object) )
<br/>
         {
<br/>
            nearest_object = &amp;potential_object;
<br/>
            min_dist = xx+yy;
<br/>
         }
<br/>
      }
<br/>
      
<br/>
      return nearest_object;
<br/>
   } // find_next_object (DIRECTION,GUI_OBJ&amp;,GUI_OBJ**,int)</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145535 - keldon - Sat Nov 17, 2007 11:25 am</h4>
    <div class="postbody"><span class="postbody">Although this is the type used in Windows it does provide some odd behaviour which may not be desirable for gui navigation.
<br/>
<br/>
I haven't put it here, but my code is updated to alter the distance of along a particular plane based on the direction (while still keeping the 45 degree window). I multiplied the distance in the direction adjacent to where you are facing by 10.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
