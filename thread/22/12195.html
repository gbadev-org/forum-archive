<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Accelerometers and gyroscope :Interpretation and calibration - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>DS Motion Sensor > Accelerometers and gyroscope :Interpretation and calibration</h2>
<div id="posts">
<div class="post">
    <h4>#115743 - mastertop101 - Thu Jan 18, 2007 10:03 pm</h4>
    <div class="postbody"><span class="postbody">Hello, I know how to use DS motion sensor but fully understanding the data can be pretty difficult...
<br/>
<br/>
<span style="font-weight: bold">Accelerometers : interpretation</span>
<br/>
Well, I learned what Gs and m/s^2 are, but im not sure how I should understand this, since if I rotate my DS, the X acceleration could be at 300mG for example; even though i'm not moving it; so how can I know whether the DS is <span style="font-weight: bold">moving</span> or just <span style="font-weight: bold">rotated</span>. I guess it's possible to know the "real acceleration" but how..
<br/>
<br/>
<span style="font-weight: bold"> Calibration </span>
<br/>
I'm currently working on a car racing game and we can control the Steerwheel with the stylus <span style="font-style: italic">or</span> de Ds motion sensor. Initially, the ds motion sensor outputs a small, but existent, rotation (and motion..) even when it's not rotating. So, I've done something to calibrate it :
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
for (calibrationtimer=0;calibrationtimer&lt;1800;calibrationtimer++) //30 seconds calibration, 10 seconds (600) or less is enough though
<br/>
      {
<br/>
         Zrot = readGyro(); // this returns a value between 0 and 4095
<br/>
         Zrot = (Zrot - Goffset)*1000/60/Gsens; // this converts to deg/frame (degrees per 1/60 second) (modified by me)
<br/>
         ZrotAdjustement-=Zrot;
<br/>
         PA_WaitForVBL(); // or swi_waitforvbl..
<br/>
      }
<br/>
ZrotAdjustement/=1800;
<br/>
</td> </tr></table><span class="postbody">
<br/>
It works quite well, but then again it still outputs a small (smaller). For most games, this small rotation at "iddle" state shouldn't be a problem, except for a car racing game ;) Because when we hold the DS "straight" we don't want the car to be turning as if the steerwheel/DS was turned 30 degrees. What should I do ? I should use the accelerometer for rotation instead.. ? Role inversing perhaps ? :D
<br/>
<br/>
<br/>
<span style="font-weight: bold">Thank you</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115752 - KeithE - Thu Jan 18, 2007 11:11 pm</h4>
    <div class="postbody"><span class="postbody">You have found the weakness of gyros.  They measure angular rate, not angle, so they are a bit tricky to use in situations where you are using them to measure angle.  But there are some things you can do to improve the situation.
<br/>
<br/>
One thing you could try is to have a "dead zone" for the gyro.  For example, if the gyro outputs 1680 at zero rotation, then don't actually move your game character until the gyro output is outside of 1680 +/-5.  I picked 5 out of my head, so I don't know if it is the best number to use - you can do some experimentation.
<br/>
<br/>
Another idea would be to implement a high pass filter.  This will filter out any low frequency (not changing or changing very slowly) signals, such as a constant offset.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115775 - HyperHacker - Fri Jan 19, 2007 1:04 am</h4>
    <div class="postbody"><span class="postbody">The big problem with a handheld motion sensor is that the player may hold their system in any manner of ways - it could be sitting flat on a table, they could be standing and holding it in front of their face, or they could be laying in bed holding it above their head. The simple solution is gravity. Notice if you sit the system on a flat surface and run the test app you get something like 980 mg/s for the Z axis - the Earth's gravitational pull. You can use this constant along with some trig to figure out which way is down when the system isn't moving. (Just keep in mind that since sensors vary, and these are quite sensitive, you can't rely on it being 980, but it will probably average out to about that.)
<br/>
<br/>
As explained to me in another thread, these are very sensitive so you will get a small reading on each axis, including the rotation, when not moving. You basically need to filter these out using the methods KeithE mentioned.
<br/>
<br/>
Also, watch the order of operations in your code:
<br/>
<span style="font-style: italic">Zrot = (Zrot - Goffset)*1000/60/Gsens;</span>
<br/>
Should be read (IIRC) as:
<br/>
<span style="font-style: italic">Zrot = (Zrot - Goffset)*((1000/60)/Gsens);</span>
<br/>
but could also be read as, for example:
<br/>
<span style="font-style: italic">Zrot = ((Zrot - Goffset)*1000)/(60/Gsens);</span>
<br/>
or various other ways. Make sure what you're writing is what you intend! Brackets are useful for cases like this.<br/>_________________<br/>I'm a PSP hacker now, but I still &lt;3 DS.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115784 - mastertop101 - Fri Jan 19, 2007 1:50 am</h4>
    <div class="postbody"><span class="postbody">So I did a deadzone thing, but it makes it not so precise (and worst then my first calibration system) So, soon, i'm going to try with Accelerometers.. but going to be a bit more complicated..</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116322 - JessTicular - Wed Jan 24, 2007 12:39 pm</h4>
    <div class="postbody"><span class="postbody">The way I got around it was to just check when the values are continually in the same direction.
<br/>
<br/>
Since you'll be getting a fluctuating reading when at a stand-still, then you can tell the difference between a fluctuating value and a constant-moving value.
<br/>
<br/>
You'll no-doubt want to be able to tell when the DS is rotated CW and when it goes CCW, so you can easily set up two situations (<span style="font-style: italic">if</span> into them) where you are checking if the current value returned is continuatlly increasing (or decreasing) compared to the previous value.
<br/>
<br/>
Then, from there you simply take that difference and determine the angle the DS is at.
<br/>
<br/>
<br/>
It would be quite simple to do it with the Accelerometers provided the DS isn't held perfectly horizontal.
<br/>
<br/>
You just take the current accelerations, and using simple trig, you can determine the angle the DS is held at.
<br/>
(The reason you can't do it when holding horizontal is that you'll be rotating around the Z-axis, which will not change when you rotate the DS).<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="font-weight: bold">Nintendo DS &amp; Dominos :: <a class="postlink" href="http://dsdominos.sourceforge.net" target="_blank">DS Dominos</a></span>
<br/>
<a class="postlink" href="http://jt0.org" target="_blank">http://jt0.org</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116323 - JessTicular - Wed Jan 24, 2007 12:41 pm</h4>
    <div class="postbody"><span class="postbody">The way I got around it was to just check when the values are continually in the same direction.
<br/>
<br/>
Since you'll be getting a fluctuating reading when at a stand-still, then you can tell the difference between a fluctuating value and a constant-moving value.
<br/>
<br/>
You'll no-doubt want to be able to tell when the DS is rotated CW and when it goes CCW, so you can easily set up two situations (<span style="font-style: italic">if</span> into them) where you are checking if the current value returned is continuatlly increasing (or decreasing) compared to the previous value.
<br/>
<br/>
Then, from there you simply take that difference and determine the angle the DS is at.
<br/>
<br/>
<br/>
It would be quite simple to do it with the Accelerometers provided the DS isn't held perfectly horizontal.
<br/>
<br/>
You just take the current accelerations, and using simple trig, you can determine the angle the DS is held at.
<br/>
(The reason you can't do it when holding horizontal is that you'll be rotating around the Z-axis, which will not change when you rotate the DS).<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="font-weight: bold">Nintendo DS &amp; Dominos :: <a class="postlink" href="http://dsdominos.sourceforge.net" target="_blank">DS Dominos</a></span>
<br/>
<a class="postlink" href="http://jt0.org" target="_blank">http://jt0.org</a></span></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
