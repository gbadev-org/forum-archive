<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>basic physics, direction and motion issue - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > basic physics, direction and motion issue</h2>
<div id="posts">
<div class="post">
    <h4>#20426 - tethered - Tue May 11, 2004 4:59 am</h4>
    <div class="postbody"><span class="postbody">hello,
<br/>
<br/>
before i post i just want to say thanks for all your assistance thus far. this forum is an invaluable resource to anyone who is curious about developing on the gba console, and, quite frankly, i couldn't have gotten as far as i have in such a short time period without your help. thanks!
<br/>
<br/>
with that said... i've created a multiple layer, parallax scrolling background in tile mode 0, text bg 0. originally, you could scroll up, down, left, right, and all of the diagonals in between by pressing the corresponding d-pad button. i've decided to take it a step further now by adding some basic physics.
<br/>
<br/>
the intention is to allow the user to "steer" by pressing left and right (i.e., they press left, and it decreases the angle of direction, they press right, and it increases the angle of direction). and then when the user presses up, it should provide forward motion in the direction that you are facing. for now, to keep things simple, as i dont have much experience with sprites, i'm moving just the background around. eventually, i would like to have a ship sprite in the center of the screen that rotates to reflect the angle, but thats something i will do in a later session.
<br/>
<br/>
anyway, i've gotten the basic formula down...
<br/>
<br/>
the velocity is a constant 3 units per loop iteration, the direction vector is represented as an angle ranging from 0 - 359, and to calculate the x and y components of the velocity based on the direction vector, i'm using sine and cosine, respectively. 
<br/>
<br/>
here's the full source:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "math.h"
<br/>
#include "gba.h"
<br/>
#include "master.pal.c"
<br/>
#include "lvl1bg0.raw.c"
<br/>
#include "lvl1bg0.map.c"
<br/>
#include "lvl1bg1.raw.c"
<br/>
#include "lvl1bg1.map.c"
<br/>
<br/>
<br/>
void SetVideoMode(void);
<br/>
void LoadPalette(void);
<br/>
void LoadBackground(void);
<br/>
<br/>
<br/>
int main()
<br/>
{
<br/>
    float f_x = 0, f_y = 0;
<br/>
    float f_velocity = 3;
<br/>
    float f_angle = 0;
<br/>
    float f_x_displacement = 0, f_y_displacement = 0;
<br/>
<br/>
    SetVideoMode();
<br/>
    LoadPalette();
<br/>
    // vdraw . . .
<br/>
    while (REG_VCOUNT &lt; 160);
<br/>
    LoadBackground();
<br/>
<br/>
    while(1) {
<br/>
        
<br/>
        f_x_displacement = 0;
<br/>
        f_y_displacement = 0;
<br/>
        
<br/>
        // When LEFT is pressed, the ship should rotate to the left, thus
<br/>
        // decrease angle by the specified rate... When it reaches 0,
<br/>
        // roll over to 359...
<br/>
        if(keyDown(KEY_LEFT))
<br/>
        {
<br/>
            f_angle = f_angle - .05;
<br/>
            if (f_angle &lt; 0)
<br/>
                f_angle = 359;
<br/>
        }
<br/>
<br/>
        // When RIGHT is pressed, the ship should rotate to the right, thus
<br/>
        // increase the angle by the specified rate... When it reaches 359,
<br/>
        // roll over to 0...
<br/>
        if(keyDown(KEY_RIGHT))
<br/>
        {
<br/>
            f_angle = f_angle + .05;
<br/>
            if (f_angle &gt; 359)
<br/>
                f_angle = 0;
<br/>
        }
<br/>
<br/>
        // When UP is pressed, the ship should move at the specified velocity
<br/>
        // in the direction it is facing... sin(angle) * velocity calculates
<br/>
        // the displacement of the x component, and cos(angle) * velocity
<br/>
        // calculates the displacement of the y component
<br/>
        if(keyDown(KEY_UP))
<br/>
        {
<br/>
            f_x_displacement = f_x_displacement + sin(f_angle) * f_velocity;
<br/>
            f_y_displacement = f_y_displacement + cos(f_angle) * f_velocity;
<br/>
        }
<br/>
<br/>
        // vdraw . . .
<br/>
        while (REG_VCOUNT &lt; 160);
<br/>
<br/>
        // update x and y coordinates for background
<br/>
        f_x = f_x + f_x_displacement;
<br/>
        f_y = f_y - f_y_displacement; // inverted :)
<br/>
        REG_BG0HOFS = f_x;
<br/>
        REG_BG0VOFS = f_y;
<br/>
        REG_BG1HOFS = (f_x / 2) + 100; // 100 == offset
<br/>
        REG_BG1VOFS = (f_y / 2) + 100;
<br/>
        REG_BG2HOFS = f_x / 7.5;
<br/>
        REG_BG2VOFS = f_y / 7.5;
<br/>
<br/>
        // wait for vblank . . .
<br/>
        while (REG_VCOUNT &gt;= 160);
<br/>
    }
<br/>
<br/>
    return 0;
<br/>
<br/>
}
<br/>
<br/>
<br/>
void SetVideoMode(void)
<br/>
{
<br/>
    // set video mode
<br/>
    SetMode(MODE_0 | BG0_ENABLE | BG1_ENABLE | BG2_ENABLE);
<br/>
}
<br/>
<br/>
<br/>
void LoadPalette(void)
<br/>
{
<br/>
    int i;
<br/>
<br/>
    // load palette data
<br/>
    for (i = 0; i &lt; 256; i++)
<br/>
        BG_PaletteMem[i] = master_Palette[i];
<br/>
}
<br/>
<br/>
<br/>
void LoadBackground(void)
<br/>
{
<br/>
    u16* ScreenBB0 = (u16*)ScreenBaseBlock(0);
<br/>
    u16* ScreenBB1 = (u16*)ScreenBaseBlock(1);
<br/>
    u16* CharBB1 = (u16*) CharBaseBlock(1);
<br/>
    u16* CharBB2 = (u16*) CharBaseBlock(2);
<br/>
    int i;
<br/>
    
<br/>
    // set bg control register
<br/>
    REG_BG0CNT = BG_COLOR_256 | TEXTBG_SIZE_256x256 | (0 &lt;&lt; SCREEN_SHIFT) | (1 &lt;&lt; CHAR_SHIFT);
<br/>
    REG_BG1CNT = BG_COLOR_256 | TEXTBG_SIZE_256x256 | (0 &lt;&lt; SCREEN_SHIFT) | (1 &lt;&lt; CHAR_SHIFT);
<br/>
    REG_BG2CNT = BG_COLOR_256 | TEXTBG_SIZE_256x256 | (1 &lt;&lt; SCREEN_SHIFT) | (2 &lt;&lt; CHAR_SHIFT);
<br/>
        
<br/>
    // load map data
<br/>
    // -------------
<br/>
    // layer 0
<br/>
    for (i = 0; i &lt; 1024; i++)
<br/>
        ScreenBB0[i] = lvl1bg0_Map[i];
<br/>
    // layer 1
<br/>
    for (i = 0; i &lt; 1024; i++)
<br/>
        ScreenBB1[i] = lvl1bg1_Map[i];
<br/>
<br/>
    // load tile data
<br/>
    // --------------
<br/>
    // layer 0
<br/>
    for (i = 0; i &lt; (23 * 64) / 2; i++)
<br/>
        CharBB1[i] = ((u16*) lvl1bg0_Tiles)[i];
<br/>
    // layer 1
<br/>
    for (i = 0; i &lt; (232 * 64) / 2; i++)
<br/>
        CharBB2[i] = ((u16*) lvl1bg1_Tiles)[i];
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
for the most part this seems to work. there is some slow down but that's not an issue at this point (i was kind of expecting it and i'm aware that you can pre-calculate the sine and cosine values). also, i'm aware that a lot of the other source isn't exactly the most efficient. as i said in an earlier thread, clarity is more important than optimization right now. <span style="font-weight: bold">the problem i'm running into, however, is that when you first begin to turn to the left it immediately jerks over to the right, and at various points around the rotation it jerks in different directions.</span>
<br/>
<br/>
here is the compiled GBA rom:
<br/>
<a class="postlink" href="http://cemmel.com/gbadev/demos/direction_and_motion.gba" target="_blank">http://cemmel.com/gbadev/demos/direction_and_motion.gba</a>
<br/>
<br/>
i suspect it has something to do w/ my if statements that i'm using to roll over from 359 to 0, and 0 to 359, but i can't seem to make any real sense of it.
<br/>
<br/>
if anyone has any experience, please comment and let me know what i'm doing wrong. 
<br/>
<br/>
thanks,
<br/>
<br/>
<br/>
chuck</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20427 - poslundc - Tue May 11, 2004 5:31 am</h4>
    <div class="postbody"><span class="postbody">The cause of the jerkiness is that the math library trig functions take radians as their input parameters, not degrees. So when your variable jumps from 0 to 359, you're actually jumping from 0 to 49 degrees. To fix this, multiply your angles by (PI / 180) before passing them to the trig functions.
<br/>
<br/>
When it comes time to optimize, you should consider abandoning both degrees and radians in favour of using a unit of measurement that divides evenly into a circle by a power of two. For example, you can make a cosine look-up table that has 256 entries (or 512 for more accuracy), and is periodic such that cos 256 = cos 0 = 1. This way you can wrap your variable around from 0 to 255 just by bitwise-ANDing it with 255 (rather than having to use the if statements). For that to work, you need to abandon floats for integers (which is a good idea anyway; you can check out the Beginner's FAQ for more info).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20428 - DiscoStew - Tue May 11, 2004 5:40 am</h4>
    <div class="postbody"><span class="postbody">Poslundc is right. At first when I looks at your code, I was thinking in degrees, and would have only said something about going from 0 to 359, even though you are only using increments/decrements of .05, but when poslundc said radians, it all made sense. No wonder when you make a full counter-clockwise rotation is doesn't bring up the jerking problem until a few more full rotations, because when working in radians, 359 is considered a big number, and it slowly counts down to 0, while making its revolutions.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20430 - tethered - Tue May 11, 2004 5:45 am</h4>
    <div class="postbody"><span class="postbody">thanks a lot guys.
<br/>
<br/>
<br/>
- chuck</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20432 - tethered - Tue May 11, 2004 6:33 am</h4>
    <div class="postbody"><span class="postbody">Works beautifully. To continue the discussion, another thread (<a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=2771&amp;highlight=physics" target="_blank">http://forum.gbadev.org/viewtopic.php?t=2771&amp;highlight=physics</a>) mentions the following algorithm for applying basic ateroids-like physics:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">dx += cos_table[heading] * thrust; 
<br/>
dy += sin_table[heading] * thrust + gravity; 
<br/>
dx = dx * drag; 
<br/>
dy = dy * drag; 
<br/>
x += dx; 
<br/>
y += dy;</td> </tr></table><span class="postbody">
<br/>
<br/>
I was able to implement this successfully, my only issue now being that as thrust is applied it speeds up into infinity... I'm fiddling with methods of capping the maximum speed, but I'm getting nothing but awkward results. Any input would be helpful...
<br/>
<br/>
<br/>
- Chuck</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20437 - yaustar - Tue May 11, 2004 1:36 pm</h4>
    <div class="postbody"><span class="postbody">wouldnt something like
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if(thrust &gt; MAX_THRUST)
<br/>
{
<br/>
   thrust = MAX_THRUST;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Then do all the calcuations<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20447 - tepples - Tue May 11, 2004 3:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tethered wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">dx += cos_table[heading] * thrust; 
<br/>
dy += sin_table[heading] * thrust + gravity; 
<br/>
dx = dx * drag; 
<br/>
dy = dy * drag; 
<br/>
x += dx; 
<br/>
y += dy;</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
I was able to implement this successfully, my only issue now being that as thrust is applied it speeds up into infinity</span></td> </tr></table><span class="postbody">
<br/>
In this pseudocode, thrust is a force, not a speed. Think of a rocket-propelled craft floating in free 2-space, as in <span style="font-style: italic">Asteroids</span>. If there's no fire coming out of the rocket, then thrust = 0. To cap speed, set your craft's thrust capacity such that (max_speed + thrust) * drag = max_speed.
<br/>
<br/>
What kind of handling do you eventually expect to have in your craft? I can help you implement kinematics for it.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20456 - tethered - Tue May 11, 2004 5:55 pm</h4>
    <div class="postbody"><span class="postbody">tepples, i appreciate your help. at this point, the kinematics should be quite simple. you can change your direction vector by pressing left or right, and by pressing up it provides thrust. 
<br/>
<br/>
right now, the result of all this is that the background layers shift around according to displacement. eventually, i'll have a ship sprite in the center of the screen that rotates around and can shoot and so forth.
<br/>
<br/>
here's my source at this point:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define PI 3.14159265
<br/>
<br/>
int main()
<br/>
{
<br/>
    int i;
<br/>
    float f_x = 0, f_y = 0;
<br/>
    float f_thrust = .05;
<br/>
    float f_angle = 0;
<br/>
    float f_radian = f_angle * (PI / 180);
<br/>
    float f_x_displacement = 0, f_y_displacement = 0;
<br/>
    float f_drag = .95;
<br/>
    float f_sin_array[128], f_cos_array[128];
<br/>
<br/>
    // generate SIN array
<br/>
    f_angle = 0;
<br/>
    for (i = 0; i &lt; 128; i++)
<br/>
    {
<br/>
        f_radian = f_angle * (PI / 180);
<br/>
        f_sin_array[i] = sin(f_radian);
<br/>
        f_angle+=2.8125;
<br/>
    }
<br/>
<br/>
    // generate COS array
<br/>
    f_angle = 0;
<br/>
    for (i = 0; i &lt; 128; i++)
<br/>
    {
<br/>
        f_radian = f_angle * (PI / 180);
<br/>
        f_cos_array[i] = cos(f_radian);
<br/>
        f_angle+=2.8125;
<br/>
    }
<br/>
    f_angle = 0;
<br/>
<br/>
    SetVideoMode();
<br/>
    LoadPalette();
<br/>
    // vdraw . . .
<br/>
    while (REG_VCOUNT &lt; 160);
<br/>
    LoadBackground();
<br/>
<br/>
    while(1) {
<br/>
<br/>
        // When LEFT is pressed, the ship should rotate to the left, thus
<br/>
        // decrease angle by the specified rate... When it reaches 0,
<br/>
        // roll over to 127...
<br/>
        if(keyDown(KEY_LEFT))
<br/>
        {
<br/>
            f_angle = f_angle - 1;
<br/>
            if (f_angle &lt; 0)
<br/>
                f_angle = 127;
<br/>
        }
<br/>
<br/>
        // When RIGHT is pressed, the ship should rotate to the right, thus
<br/>
        // increase the angle by the specified rate... When it reaches 128,
<br/>
        // roll over to 0...
<br/>
        if(keyDown(KEY_RIGHT))
<br/>
        {
<br/>
            f_angle = f_angle + 1;
<br/>
            if (f_angle &gt; 127)
<br/>
                f_angle = 0;
<br/>
        }
<br/>
<br/>
        // When UP is pressed, the ship should move at the specified velocity
<br/>
        // in the direction it is facing... sin(angle) * thrust calculates
<br/>
        // the displacement of the x component, and cos(angle) * thrust
<br/>
        // calculates the displacement of the y component
<br/>
        if(keyDown(KEY_UP))
<br/>
        {
<br/>
            f_x_displacement = f_x_displacement + f_sin_array[((int)f_angle)] * f_thrust;
<br/>
            f_y_displacement = f_y_displacement + f_cos_array[((int)f_angle)] * f_thrust;
<br/>
        }
<br/>
        
<br/>
        // DOWN acts as a brake (for now)
<br/>
        if(keyDown(KEY_DOWN))
<br/>
        {
<br/>
            f_x_displacement = f_x_displacement * f_drag;
<br/>
            f_y_displacement = f_y_displacement * f_drag;
<br/>
        }
<br/>
<br/>
        // vdraw . . .
<br/>
        while (REG_VCOUNT &lt; 160);
<br/>
<br/>
        // update x and y coordinates for background
<br/>
        f_x = f_x + f_x_displacement;
<br/>
        f_y = f_y - f_y_displacement; // inverted :)
<br/>
        REG_BG0HOFS = f_x;
<br/>
        REG_BG0VOFS = f_y;
<br/>
        REG_BG1HOFS = (f_x / 2) + 100; // 100 == offset
<br/>
        REG_BG1VOFS = (f_y / 2) + 100;
<br/>
        REG_BG2HOFS = f_x / 7.5;
<br/>
        REG_BG2VOFS = f_y / 7.5;
<br/>
<br/>
        // wait for vblank . . .
<br/>
        while (REG_VCOUNT &gt;= 160);
<br/>
    }
<br/>
<br/>
    return 0;
<br/>
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
here's the compiled gba rom:
<br/>
<a class="postlink" href="http://cemmel.com/gbadev/demos/direction_and_motion2.gba" target="_blank">http://cemmel.com/gbadev/demos/direction_and_motion2.gba</a>
<br/>
<br/>
i'm not sure i understood your formula for limiting thrust capacity, tepples. i've fooled around w/ some of my own formulas (if sqrt of x_displacement^2 + y_displacement^2 &gt; max_velocity then thrust = 0), but again, everything seems to act flakey.
<br/>
<br/>
thanks again...
<br/>
<br/>
<br/>
- chuck</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20459 - tepples - Tue May 11, 2004 6:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tethered wrote:</b></span></td> </tr> <tr> <td class="quote">here's my source at this point:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    // generate SIN array
<br/>
    f_angle = 0;
<br/>
    for (i = 0; i &lt; 128; i++)
<br/>
    {
<br/>
        f_radian = f_angle * (PI / 180);
<br/>
        f_sin_array[i] = sin(f_radian);
<br/>
        f_angle+=2.8125;
<br/>
    }
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
I'd suggest precomputing this table on a PC and then storing it in the ROM so that you don't get the huge startup delay. I'd also suggest fixed-point arithmetic across the board.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    // generate COS array
<br/>
    f_angle = 0;
<br/>
    for (i = 0; i &lt; 128; i++)
<br/>
    {
<br/>
        f_radian = f_angle * (PI / 180);
<br/>
        f_cos_array[i] = cos(f_radian);
<br/>
<br/>
        f_angle+=2.8125;
<br/>
    }
<br/>
    f_angle = 0;
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
I'd suggest implementing sin() in terms of cos() or vice versa to save memory.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">        // DOWN acts as a brake (for now)
<br/>
        if(keyDown(KEY_DOWN))
<br/>
        {
<br/>
            f_x_displacement = f_x_displacement * f_drag;
<br/>
            f_y_displacement = f_y_displacement * f_drag;
<br/>
        }
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
Kinematics question: What is your frame of reference for the displacements? What significance in the game world does the origin have?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">here's the compiled gba rom:
<br/>
<a class="postlink" href="http://cemmel.com/gbadev/demos/direction_and_motion2.gba" target="_blank">http://cemmel.com/gbadev/demos/direction_and_motion2.gba</a>
<br/>
</td> </tr></table><span class="postbody">
<br/>
Tested.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">i'm not sure i understood your formula for limiting thrust capacity, tepples.</td> </tr></table><span class="postbody">
<br/>
I was assuming the craft was working against air resistance. In a gas, drag is roughly proportional to velocity relative to the gas. When a craft is moving at terminal velocity, its thrust is equal to the drag. One would apply thrust every frame and drag every frame, and at terminal velocity, they would cancel out.
<br/>
<br/>
But in space, there is no air, so one would never apply drag. Because there is no air, there is also no still frame of reference for velocity and thus no maximum speed except as one approaches <span style="font-style: italic">c</span>. The down key would apply thrust in the opposite direction. And in space, a parallax starfield would never scroll nearly that fast; think of how far away stars are and how fast your craft moves. Or are those points of light supposed to represent space junk instead?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">i've fooled around w/ some of my own formulas (if sqrt of x_displacement^2 + y_displacement^2 &gt; max_velocity then thrust = 0)</td> </tr></table><span class="postbody">
<br/>
I thought of that one too, but I didn't suggest it because I had no idea what kind of handling you wanted, whether in air or in space. Anyway, a multiplication is faster than a sqrt(), so square both sides of the inequality. Instead of
<br/>
if(sqrt(dx*dx + dy*dy) &gt; max_velocity)
<br/>
Do
<br/>
if(dx*dx + dy*dy &gt; max_velocity*max_velocity)
<br/>
<br/>
If you're working relative to air or to a surface, you might have to create a piecewise thrust curve based on velocity squared.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20462 - tethered - Tue May 11, 2004 7:38 pm</h4>
    <div class="postbody"><span class="postbody">optimization suggestions noted. 
<br/>
<br/>
about the frame of reference, i'm not sure exactly what the correct answer to that is... what happens when you move about is the x and y coordinates of the background layers are changing, which gives the effect of a "camera" moving about a 2D plane. the ship that the player controls will be dead center on the screen at all times. 
<br/>
<br/>
about the stars moving so fast, i suppose i'm going for more of an arcade kind of feel than a simulation, so i'm overlooking certain aspects for the sake of gameplay. that may change in the future.
<br/>
<br/>
regarding the formula for limiting the maximum velocity:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if (dx*dx + dy*dy &gt;= max_velocity*max_velocity)
<br/>
     thrust = 0;</td> </tr></table><span class="postbody">
<br/>
<br/>
what this does is it determines whether the displacement is greater than the maximum velocity, and if it is, it cuts the thrust. but, since there's no drag (we're in space), what happens is once you reach maximum velocity you lose your thrust and then lose your ability to maneuver. for example, say you reach maximum velocity, then you turn 180 degrees, and try to apply thrust in the opposite direction, you'll have no thrust to apply.
<br/>
<br/>
so i was thinking about possibly doing something along the lines of if (ship is at max velocity AND still accelerating) cut thrust, else turn thrust back on... but that causes its own problems. for example, if in the last iteration you cut thrust b/c you reached maximum velocity, in the next frame you wouldn't have accelerated, so it would turn thrust back on.
<br/>
<br/>
perhaps i've been looking at this too long and just need a break. hmph.
<br/>
<br/>
<br/>
- chuck</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20465 - tepples - Tue May 11, 2004 8:03 pm</h4>
    <div class="postbody"><span class="postbody">I'll start with some definitions:<ul><li>The "dot product" of two vectors is the sum of the products of their corresponding components. For example, v1 dot v2 = x1*x2 + y1*y2 + z1*z2. To learn where it is useful, go to Google.</li><li>A "unit vector" is a vector whose length is 1.</li><li>A "heading vector" is a unit vector describing a direction.</li></ul>Try this formula to determine when you should autodrag after applying thrust:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if(heading dot velocity &gt; max_speed)
<br/>
{
<br/>
  apply drag;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
But I still wonder about the validity of the concept of a not-even-close-to-relativistic "maximum velocity" in space, other than to limit temporal aliasing in order to keep from missing collisions from objects that just went right past each other.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">for example, if in the last iteration you cut thrust b/c you reached maximum velocity, in the next frame you wouldn't have accelerated, so it would turn thrust back on.</td> </tr></table><span class="postbody">
<br/>
This is perfectly fine in practice.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20467 - tethered - Tue May 11, 2004 8:17 pm</h4>
    <div class="postbody"><span class="postbody">thanks for your advice. i'm sure its sound but i dont have the facilities to verify it at the moment. it's clear that i'm gonna have to spend some alone time with vectors.
<br/>
<br/>
thanks!
<br/>
<br/>
<br/>
- chuck</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20573 - LOst? - Thu May 13, 2004 8:20 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Anyway, a multiplication is faster than a sqrt(), so square both sides of the inequality. Instead of
<br/>
if(sqrt(dx*dx + dy*dy) &gt; max_velocity)
<br/>
Do
<br/>
if(dx*dx + dy*dy &gt; max_velocity*max_velocity)</td> </tr></table><span class="postbody">
<br/>
<br/>
tepples, this is one good way for me to get rid of calling sqrt(). Thanks for the info. No the question is, is this method better when programming on a PC? Is it faster to do multiplication instead of sqrt() on a PIII or P4?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20577 - Cearn - Thu May 13, 2004 11:48 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote"> No the question is, is this method better when programming on a PC? Is it faster to do multiplication instead of sqrt() on a PIII or P4?</td> </tr></table><span class="postbody">
<br/>
Since multiplication is one of the most basic arithmatic operatorsand sqrt a relatively complicated procedure, it should always be faster. On any system. That goes for all the routines in math.h, like sin, cos, tan, atan, ln, exp, etc, etc.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20585 - poslundc - Thu May 13, 2004 2:13 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Cearn wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote"> No the question is, is this method better when programming on a PC? Is it faster to do multiplication instead of sqrt() on a PIII or P4?</td> </tr></table><span class="postbody">
<br/>
Since multiplication is one of the most basic arithmatic operatorsand sqrt a relatively complicated procedure, it should always be faster. On any system. That goes for all the routines in math.h, like sin, cos, tan, atan, ln, exp, etc, etc.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
I would add, however, that such a mathematical optimization - while extremely important on the GBA - may be premature for a PC game, since there are very few 16 MHz PCs still floating around and most have sophisticated math coprocessors that make square-root processing much quicker.
<br/>
<br/>
I would be inclined to leave the sqrt() in the game for sake of clarity of the code and the mathematical basis until such time as it became necessary to optimize it out. YMMV.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20816 - Cearn - Tue May 18, 2004 8:52 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b> poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">... sophisticated math coprocessors that make square-root processing much quicker</td> </tr></table><span class="postbody">
<br/>
True, but quicker than a single multiplication? I mean, there has to be some sort of interpolation to find the correct value, right?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20827 - poslundc - Tue May 18, 2004 2:27 pm</h4>
    <div class="postbody"><span class="postbody">I'm out of touch with what newer systems are capable of, but keep in mind that even if the instructions are slower they can often be executed in parallel with the main CPU, so you can increase your throughput considerably.
<br/>
<br/>
But this is not intended as an argument in favour of sqrt() over multiplication, only to show that what was a necessary design-level optimization on less powerful computers has been made far less critical on modern systems.
<br/>
<br/>
Put another way: I am opposed to premature optimization. Ideally, I would leave my distance-comparison algorithm as a comparison of two actual distances, rather than the squared distances, just for the sake of clarity and engine portability. In the practical world of GBA programming, however, I wouldn't allow the unnecessary sqrt() anywhere near my code; I would optimize the heck out of it. If I was programming for a P6 or whatever, though, I would probably leave it in until it became necessary to remove it for the sake of optimization.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20850 - Miked0801 - Tue May 18, 2004 6:38 pm</h4>
    <div class="postbody"><span class="postbody">Agreed - sqrt() is evil as are most inverse trig functions which is why vector math is so cool compared against geometric math :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
