<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>DMA overlapping concerns... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > DMA overlapping concerns...</h2>
<div id="posts">
<div class="post">
    <h4>#19518 - TaleriaKNT - Wed Apr 21, 2004 7:40 am</h4>
    <div class="postbody"><span class="postbody">Do I need to worry about trying to do another DMA transfer before the previous one has finished? If so, what would the exact effects be of doing that? Also, if so, how would I make sure not to do it?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19520 - NoMis - Wed Apr 21, 2004 9:50 am</h4>
    <div class="postbody"><span class="postbody">The DMA copy process starts not emidiatly after you set the REG_DMAxCNT to Enable. You have to wait 2 cycles i think thill the process starts. So you must not access the Source and Target registers in this time. I figured it out once, when i was doing more than 1 DMA copy in a row and just the last one was working.
<br/>
If you have other things in you programm which have to be done put them between the DMA Copys. You can also use a fake loop wich does nothing or using Interrupts. There is an interrupt which is fired when an DMA copy has finished.
<br/>
<br/>
NoMis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19528 - poslundc - Wed Apr 21, 2004 2:56 pm</h4>
    <div class="postbody"><span class="postbody">In my experience, it works out cycle-wise if you assign 0 to REG_DMAXCNT before attempting to set up the next DMA transfer.
<br/>
<br/>
The incremental timing issues notwithstanding, the DMA halts the CPU, so you won't return to your program until after the DMA is finished. But yes, be careful if you are performing multiple DMA transfers in a row that you make sure to turn off the DMA before setting up the next transfer.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19546 - TaleriaKNT - Wed Apr 21, 2004 6:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">assign 0 to REG_DMAXCNT before attempting to set up the next DMA transfer.</td> </tr></table><span class="postbody">
<br/>
Wouldn't this have the adverse affect of canceling the transfer?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">the DMA halts the CPU, so you won't return to your program until after the DMA is finished...make sure to turn off the DMA before setting up the next transfer.</td> </tr></table><span class="postbody">
<br/>
Halt it for the entirety of the transfer? Doesn't that defeat the purpose of DMA, or am I missing something? And again, wouldn't turning it off stop the previous transfer and leave you with a half copied chunk of data?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19548 - sajiimori - Wed Apr 21, 2004 7:31 pm</h4>
    <div class="postbody"><span class="postbody">It halts the CPU.  DMA is fast because the CPU doesn't have to keep fetching and executing load, store, compare, and branch instructions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19552 - TaleriaKNT - Wed Apr 21, 2004 9:07 pm</h4>
    <div class="postbody"><span class="postbody">So then, just to make sure I'm clear on this...
<br/>
<br/>
It would be safe to:
<br/>
1) Start a DMA transfer.
<br/>
2) Set the appropriate DMA count(EDIT: Oops, I meant control...) register to 0 as the next command in order to make sure there's not a problem starting another.
<br/>
3) Immediately initiate another transfer.
<br/>
<br/>
Sound right?</span><span class="gensmall"><br/><br/>Last edited by TaleriaKNT on Thu Apr 22, 2004 12:06 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#19555 - Gopher - Wed Apr 21, 2004 10:31 pm</h4>
    <div class="postbody"><span class="postbody">I've done consecutive DMA copies (one followed immediately by another, with no instructions inbetween) and yes, this is how it works. I didn't even set the count to 0 inbetween, since the count will be 0 when the previous DMA is done anyway.<br/>_________________<br/>"Only two things are infinite: the universe, and human stupidity. The first is debatable." -Albert Einstein</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19563 - tepples - Thu Apr 22, 2004 12:24 am</h4>
    <div class="postbody"><span class="postbody">If you want to waste two cycles after starting a DMA, then just loading the source address from your constant pool will do that.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19564 - Gopher - Thu Apr 22, 2004 12:26 am</h4>
    <div class="postbody"><span class="postbody">yeah, I was unaware of the need for the 2-cycle delay, so this must be why mine hasn't broken, heh
<br/>
hmmm... I just realised this might be why an old project of mine wasn't working right, that was doing some odd hblank tricks... &lt;runs to look&gt;<br/>_________________<br/>"Only two things are infinite: the universe, and human stupidity. The first is debatable." -Albert Einstein</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19593 - White Owl - Thu Apr 22, 2004 3:37 pm</h4>
    <div class="postbody"><span class="postbody">so, the code like that should work?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
REG_DMA3SAD = (u32)source1;
<br/>
REG_DMA3DAD = (u32)dest1;
<br/>
REG_DMA3CNT =Â  count1 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE |DMA_32; 
<br/>
REG_DMA3CNT = 0; 
<br/>
REG_DMA3SAD = (u32)source2;
<br/>
REG_DMA3DAD = (u32)dest2;
<br/>
REG_DMA3CNT = count2 | DMA_ENABLE | DMA_TIMEING_IMMEDIATE |DMA_32; 
<br/>
REG_DMA3CNT = 0; 
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19603 - TaleriaKNT - Thu Apr 22, 2004 7:12 pm</h4>
    <div class="postbody"><span class="postbody"><span style="font-weight: bold">tepples</span>, are you saying to copy the source address a second time once you've set everything up, like...</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">REG_DMA3SAD = (u32)source;
<br/>
REG_DMA3DAD = (u32)dest;
<br/>
REG_DMA3CNT = count | DMA_ENABLE | DMA_TIMEING_IMMEDIATE |DMA_32;
<br/>
REG_DMA3SAD = (u32)source;
<br/>
</td> </tr></table><span class="postbody">
<br/>
If your source is from a variable instead of a constant, would it be better to do the set to zero thing?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19606 - poslundc - Thu Apr 22, 2004 7:29 pm</h4>
    <div class="postbody"><span class="postbody">I think that part of the problem is that with an optimizing compiler you can't be assured of what order it is doing things. Even with the registers declared volatile (which will make the statements execute in the proper order) it could be loading in the values to store earlier on, and therefore not wasting the necessary cycles in between DMA uses.
<br/>
<br/>
Setting REG_DMAXCNT to 0 <span style="font-style: italic">in between</span> consecutive or tightly-looped DMA sequences is something that I've found will eliminate just about any errors that can occur due to timing and control issues with the DMA. You don't need to bother if you're just using the DMA in an isolated situation, but if you're either tightly looping or running a bunch of DMA transfers in a row, you can get errors on hardware if you don't do something like this.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
