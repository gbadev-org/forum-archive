<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Sorting Algorithm Question (A* Related) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Beginners > Sorting Algorithm Question (A* Related)</h2>
<div id="posts">
<div class="post">
    <h4>#35945 - Celeryface - Sun Feb 13, 2005 1:44 pm</h4>
    <div class="postbody"><span class="postbody">Hi there,
<br/>
<br/>
I'm trying to decide on an algorithm to use for the sorting portion my A* implementation (Sorting the nodes to have the highest F value at the top of the heap). I will be using C, for reference. 
<br/>
<br/>
I have implemented A* using C++ and the priority queue (heap sort) from STL on the PC, but I want to use C for the GBA implementation.
<br/>
<br/>
Can anyone recommend which sorting algorithm I should use in C that will be fast on the GBA to sort the nodes? 
<br/>
<br/>
Thanks in advance. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35946 - sasq - Sun Feb 13, 2005 2:02 pm</h4>
    <div class="postbody"><span class="postbody">qsort()
<br/>
<br/>
part of the standard c-library and pretty fast for general cases.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35948 - Celeryface - Sun Feb 13, 2005 2:34 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sasq wrote:</b></span></td> </tr> <tr> <td class="quote">qsort()
<br/>
<br/>
part of the standard c-library and pretty fast for general cases.</td> </tr></table><span class="postbody">
<br/>
<br/>
For qsort(), can you specify a comparison function so that it can compare a certain value within a structure?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35952 - ymalik - Sun Feb 13, 2005 3:48 pm</h4>
    <div class="postbody"><span class="postbody">Yes.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35953 - Celeryface - Sun Feb 13, 2005 3:50 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Yes.</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35990 - DiscoStew - Sun Feb 13, 2005 10:15 pm</h4>
    <div class="postbody"><span class="postbody">To use qsort() on the GBA, what is needed (like what files and such need to be included)? Also, how much memory would such a function take up, and could it be implemented into IWRAM? I'm currently using my own sorting algorithm that I think runs pretty well, but I'm open to anything faster.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35992 - Miked0801 - Sun Feb 13, 2005 10:18 pm</h4>
    <div class="postbody"><span class="postbody">Howe many nodes are you sorting?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36003 - Celeryface - Mon Feb 14, 2005 12:23 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Howe many nodes are you sorting?</td> </tr></table><span class="postbody">
<br/>
<br/>
The node grid array would be 32x32 max.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36029 - sasq - Mon Feb 14, 2005 11:09 am</h4>
    <div class="postbody"><span class="postbody">qsort sorts "in place" and does not take any extra memory. That's also it's weekness since it uses memcpy to move things around which is a overhead you may not want when you can just sort pointers and read/write them without the function-call overhead.
<br/>
<br/>
A good way is to use the source of qsort() directly, make it work as it is and then maybe eliminate the memcpy() if necessary.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36051 - tepples - Mon Feb 14, 2005 5:58 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sasq wrote:</b></span></td> </tr> <tr> <td class="quote">qsort sorts "in place" and does not take any extra memory.</td> </tr></table><span class="postbody">
<br/>
Not necessarily, for two reasons: <ul><li>qsort() implemented as Quicksort uses a data-size-dependent amount of stack space. On the other hand, Metrowerks CodeWarrior for Mac implemented qsort as Heapsort, a true in-place sort that takes constant extra memory.
<br/>
<a class="postlink" href="http://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank">Learn more about sorting algorithms</a> </li><li>Your comparison function could be written such that qsort() does in fact sort pointers as you suggest. This would involve dereferencing each pointer inside the comparison function. </li></ul>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">That's also it's weekness since it uses memcpy to move things around which is a overhead you may not want when you can just sort pointers and read/write them without the function-call overhead.</td> </tr></table><span class="postbody">
<br/>
If you can fit your comparison function into five registers, the function-call overhead on ARM isn't nearly as bad as it is on x86.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36054 - sasq - Mon Feb 14, 2005 6:19 pm</h4>
    <div class="postbody"><span class="postbody">This is what I use in pogoshell; it's only slightly modified from something I found on the net. It does need enough stack for recursive calls to partition() so you're right about  it needing more memory.
<br/>
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static char *tmp_item;
<br/>
static int item_size;
<br/>
static int (*cmp_func)(void *a, void *b);
<br/>
<br/>
static int partition(char *a, int low, int high)
<br/>
{
<br/>
   int left, right, pivot;
<br/>
   char *pivot_item;
<br/>
<br/>
   pivot_item = &amp;a[low * item_size];
<br/>
   pivot = left = low;
<br/>
   right = high;
<br/>
<br/>
   while(left &lt; right)
<br/>
   {
<br/>
      // Move left while item &lt; pivot
<br/>
      while(cmp_func(&amp;a[left * item_size], pivot_item) &lt;= 0) left++;
<br/>
      // Move right while item &gt; pivot
<br/>
      while(cmp_func(&amp;a[right * item_size], pivot_item) &gt; 0) right--;
<br/>
      if(left &lt; right)
<br/>
      {
<br/>
         // Swap elements
<br/>
         memcpy(tmp_item, &amp;a[left * item_size], item_size);
<br/>
         memcpy(&amp;a[left * item_size], &amp;a[right * item_size], item_size);
<br/>
         memcpy(&amp;a[right * item_size], tmp_item, item_size);
<br/>
      }
<br/>
   }
<br/>
   // right is final position for the pivot
<br/>
   memcpy(tmp_item, pivot_item, item_size);
<br/>
   memcpy(&amp;a[low * item_size], &amp;a[right * item_size], item_size);
<br/>
   memcpy(&amp;a[right * item_size], tmp_item, item_size);
<br/>
<br/>
   // low -&gt; right-1 AND right+1 -&gt; high
<br/>
<br/>
   if((right-1) &gt; low)
<br/>
      partition(a, low, right-1);
<br/>
<br/>
   if(high &gt; (right+1))
<br/>
      partition(a, right+1, high);
<br/>
<br/>
   return right;
<br/>
}
<br/>
<br/>
void qsort(void *array, int count, int size, int cf(void *a, void *b))
<br/>
{
<br/>
   cmp_func = cf;
<br/>
   item_size = size;
<br/>
   tmp_item = malloc(size);
<br/>
   partition((char *)array, 0, count-1);
<br/>
   free(tmp_item);
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36077 - Celeryface - Mon Feb 14, 2005 9:46 pm</h4>
    <div class="postbody"><span class="postbody">Would a heapsort work well on the GBA?
<br/>
<br/>
<a href="http://en.wikipedia.org/wiki/Heapsort" target="_blank">http://en.wikipedia.org/wiki/Heapsort</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36080 - tepples - Mon Feb 14, 2005 10:06 pm</h4>
    <div class="postbody"><span class="postbody">Yes. In theory, best-first search algorithms such as A* just need a selection, not a sort, so you could use heapsort to sort the elements at first and then later, as an optimization, use the binary heap code you already have as a <a class="postlink" href="http://en.wikipedia.org/wiki/Priority_queue" target="_blank">priority queue</a>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36081 - Celeryface - Mon Feb 14, 2005 10:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Yes. In theory, best-first search algorithms such as A* just need a selection, not a sort, so you could use heapsort to sort the elements at first and then later, as an optimization, use the binary heap code you already have as a <a class="postlink" href="http://en.wikipedia.org/wiki/Priority_queue" target="_blank">priority queue</a>.</td> </tr></table><span class="postbody">
<br/>
<br/>
Have you seen any implementations in C for the binary heap?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36106 - Miked0801 - Tue Feb 15, 2005 2:09 am</h4>
    <div class="postbody"><span class="postbody">Shell sort is my current favorite - but only because I wrote a fast ARM friendly version :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
