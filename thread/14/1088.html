<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Mode 4 - Writing a single pixel - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > Mode 4 - Writing a single pixel</h2>
<div id="posts">
<div class="post">
    <h4>#5298 - Foz - Thu Apr 24, 2003 8:01 pm</h4>
    <div class="postbody"><span class="postbody">Hi all,
<br/>
<br/>
I'm a bit of a noob with a small background with Mode 13h(DOS).  I am trying to plot a single pixel to the GBA screen, and I'm having a heck of a time.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define SCREEN_WIDTH   240
<br/>
#define SCREEN_HEIGHT   160
<br/>
#define FrontBuffer       (u16*)0x6000000
<br/>
#define BackBuffer      (u16*)0x600A000
<br/>
<br/>
//GLOBALS///////////////////////////////////////////////////////
<br/>
<br/>
u16* videoBuffer;
<br/>
<br/>
////////////////////////////////////////////////////////////////////
<br/>
void setMode(u16 mode)
<br/>
{
<br/>
REG_DISPCNT = mode;
<br/>
}
<br/>
<br/>
void writePixel(int x,int y, u8 color)
<br/>
{
<br/>
   videoBuffer[(y*SCREEN_WIDTH) + x] = (u8)color;
<br/>
<br/>
} // end writePixel
<br/>
<br/>
void Flip(void) 
<br/>
{ 
<br/>
  if(REG_DISPCNT &amp; BACK_BUFFER) 
<br/>
  { 
<br/>
   REG_DISPCNT &amp;= ~BACK_BUFFER;  
<br/>
   videoBuffer = BackBuffer;  
<br/>
  } 
<br/>
  else 
<br/>
  { 
<br/>
   REG_DISPCNT |= BACK_BUFFER;  
<br/>
   videoBuffer = FrontBuffer;  
<br/>
   } 
<br/>
} 
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   u8 i;
<br/>
   u16 color;
<br/>
   
<br/>
        //I suspect the problem is here
<br/>
       u16 *palette = (u16 *)0x05000000; 
<br/>
      
<br/>
   setMode(MODE_4|BG_2);
<br/>
   
<br/>
   for(i=0; i&lt;256; i++)
<br/>
   {
<br/>
   color=31;
<br/>
   palette[i] =(u16)color;
<br/>
   }   
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
   writePixel(10,50,1);
<br/>
   Flip();
<br/>
   }
<br/>
   return 0;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
This fills the entire screen with red. I am using VGBA as my emulator(vgba8).  Incidentally, if I comment out the writePixel function it fills the screen anywayand if I set color to a math function it doesn't display anything. I've looked around, and searched the forums but the docs on Mode 4 seem to be light.  I know that I have to write to VRAM two bytes at a time, but the palette should be an 8-bit index. I thought I'd get two pixels. I'm confused. Any help would be appreciated.  Be gentle. ;)  Thanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5299 - niltsair - Thu Apr 24, 2003 8:11 pm</h4>
    <div class="postbody"><span class="postbody">First, <span style="font-weight: bold">Color 0 of the palette is the background color</span>, thus you get the red color even though you don't write any pixel. (It is also the transparent color when used for tiles/sprites)
<br/>
<br/>
Secondly, the video memory can only be accessed using 16bits pointers. You just tried to write a 8bits value. You need to Write 2 pixels at a time by basicly doing this 
<br/>
<br/>
u16 pix = (pixA&lt;&lt;8) | pixB; 
<br/>
<br/>
There, pix contains the value of both pixels (pixA and pixB). You can now write pix to the video memory at you location.
<br/>
<br/>
To find a position, you alos have to remember that 1 entry of the video memory represent 2 pixels, thus to find the position it would be :
<br/>
<br/>
u16 pos = (240/2)*Line + Col/2
<br/>
<br/>
(Put clearly, but there's more optimized way to write it)
<br/>
<br/>
To access a pixel in a even Column, you take the 8High bits, for the Odd Column, you pick the LowBits (or vice-versa)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5341 - Foz - Fri Apr 25, 2003 6:23 pm</h4>
    <div class="postbody"><span class="postbody">Thank you niltsair.  That's the first time I've seen it put so concisely.  I'll give that a try.
<br/>
<br/>
That makes sense about Color 0.  I should have realized that one.  I guess that means that I properly populated the palette.
<br/>
<br/>
If I take the 8 high bits for the pixel on the left (even or odd) will the pixel next to it be filled with the background color? I guess I could flag it as transparent :)
<br/>
<br/>
Anyway, thanks again you've been more of a help than you know.
<br/>
<br/>
-Foz</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5343 - niltsair - Fri Apr 25, 2003 6:42 pm</h4>
    <div class="postbody"><span class="postbody">Yes, if you leave it to 0, it'll take the background color. In mode 3,4,5 we can't really say 'transparent' for the background, since there's only 1 layer.
<br/>
<br/>
In mode 0,1-2 you use maps, and can have 4 layer stacked, so then you have a 'transparent' color.
<br/>
<br/>
The sprites though are showed above the background in mode 3,4,5 and they use their own palette. If you set one fo their pixel to 0, you'll see the background behing it. (Sprites are also used with mode 0-1-2, and beware, in mode 3,4,5 only the sprite tiles of 512 and up are accessible)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5356 - Foz - Fri Apr 25, 2003 11:42 pm</h4>
    <div class="postbody"><span class="postbody">It all makes perfect sense now.  There's no need for a transparent color in Mode 4 unless your using sprites.  The halfword writes are more of a blessing than a hinderance.  There's one bit shift operation and a logical OR and two colors can be sent to the screen at the same time.
<br/>
<br/>
I here people talk about Mode 4 being a little slower but I used to send one color at a time in 13h, it seems this would be a little faster.
<br/>
<br/>
It's so satisfying plotting that first pixel. Thanks again.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6565 - hzx - Thu May 29, 2003 8:50 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Foz wrote:</b></span></td> </tr> <tr> <td class="quote">It all makes perfect sense now.  There's no need for a transparent color in Mode 4 unless your using sprites.  The halfword writes are more of a blessing than a hinderance.  There's one bit shift operation and a logical OR and two colors can be sent to the screen at the same time.
<br/>
<br/>
I here people talk about Mode 4 being a little slower but I used to send one color at a time in 13h, it seems this would be a little faster.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, if you know both colors. But in practice you usually need to write only one pixel and you have to save the other one. So my plotpixel is:
<br/>
<br/>
- calculate pixel position in video buffer
<br/>
- read the u16
<br/>
- decide if your pixel goes into the lower or into the higher byte
<br/>
- modify the u16 respecively
<br/>
- write it back
<br/>
<br/>
You can speed it up by using bit shifting in calculating the pixel position, and bit ops to calculate the byte position in the u16.<br/>_________________<br/>.hzx</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6698 - hnager - Mon Jun 02, 2003 2:06 am</h4>
    <div class="postbody"><span class="postbody">I fumbled around with that same problem - this is where I ended up...In terms of 13h it's near identical you how you would use WORD sized bytes:
<br/>
<br/>
void PlotPixel(int x, int y, char color){
<br/>
<br/>
	if(x &amp; 0x0001){
<br/>
		VideoBuffer[(y*(SCREEN_WIDTH/2)) + (x&gt;&gt;1)] = color &lt;&lt; 8;
<br/>
	}else{
<br/>
		VideoBuffer[(y*(SCREEN_WIDTH/2)) + (x&gt;&gt;1)] = color;
<br/>
	}
<br/>
<br/>
}</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6703 - niltsair - Mon Jun 02, 2003 3:22 am</h4>
    <div class="postbody"><span class="postbody">I'm thinking that this last tidbit of code is wrong. You can't only write 8Bits, you need to write 16bits...
<br/>
<br/>
With this :  VideoBuffer[(y*(SCREEN_WIDTH/2)) + (x&gt;&gt;1)] = color &lt;&lt; 8
<br/>
You Lose the lower value.
<br/>
<br/>
And with this :  VideoBuffer[(y*(SCREEN_WIDTH/2)) + (x&gt;&gt;1)] = color
<br/>
You lose the upper value.
<br/>
<br/>
You have to get the current value first, overwrite the part you want to write, and the copy it back.
<br/>
<br/>
Something like this : </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void PlotPixel(int x, int y, u8 color)
<br/>
{
<br/>
u16* vidMem;
<br/>
<br/>
    vidMem = &amp;VideoBuffer[  ((y*SCREEN_WIDTH) + x)&gt;&gt;1 ];
<br/>
<br/>
    if(x % 2)
<br/>
        *vidMem = (*vidMem &amp; 0x00FF) | (color&lt;&lt;8);
<br/>
    else
<br/>
        *vidMem = (*vidMem &amp; 0xFF00) | color;
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6705 - hnager - Mon Jun 02, 2003 3:43 am</h4>
    <div class="postbody"><span class="postbody">hmmm, I haven't had a problem plotting a pixel at an x value of 10 and then 11 - they both show up. But I'll try your recommendation and see what happens.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6706 - niltsair - Mon Jun 02, 2003 3:49 am</h4>
    <div class="postbody"><span class="postbody">That would be because your emulator allow 8bits access. I'm thinking it wouldn't work on hardware. Not 100% certain though.
<br/>
<br/>
The reason i created a pointer instead of using an index, was for speed sake, since we're accessing it 3 times.
<br/>
<br/>
Take note that i haven't tested the code, so small adjustements might be required, but should do the trick.</span><span class="gensmall"><br/><br/>Last edited by niltsair on Mon Jun 02, 2003 3:53 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#6707 - hnager - Mon Jun 02, 2003 3:52 am</h4>
    <div class="postbody"><span class="postbody">Not to worry - I just tested it out and it seems to work well - thanks for the tip :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#6708 - niltsair - Mon Jun 02, 2003 3:54 am</h4>
    <div class="postbody"><span class="postbody">Better yet, declare this code as inline or a define, you'll get better speed still (no function calling overhead)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
