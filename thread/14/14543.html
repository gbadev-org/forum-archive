<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>help with macro taking user input(gba) - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Beginners > help with macro taking user input(gba)</h2>
<div id="posts">
<div class="post">
    <h4>#145556 - speedemon35 - Sun Nov 18, 2007 1:05 am</h4>
    <div class="postbody"><span class="postbody">Hello all. Name is Daniel and i'm currently studying computer games technology. As the name implies at some point in the near future i'll be programming games. I'm in first year and sadly i need help with programming the gba. I'm using dev kit pro if that will make any difference btw. A few things you should know before hand: My current games technology teacher is possibly the last person you'll ever want to meet or have teaching you. Only support he ever gives is the word google so that will probably explain why i don't have a clue on what to actually look for in the gba tutorials.
<br/>
<br/>
Anyway i'm hoping someone here can give me some serious help as i've been trying to figure this out for a full week and i still can't get any of it right:
<br/>
The tasks i was was set seem simple enough:
<br/>
<br/>
<br/>
1.	Write a function or macro, which takes three values between 0 and 31, and converts this to BGR 16 bit format. For example, the function prototype should look like u16 BGR(u16 b, u16 g, u16 r);
<br/>
^ my actual problem^
<br/>
<br/>
2.	Draw a yellow pixel in the centre of the screen (in mode3).
<br/>
^done this one as it was just a guessing numbers game^
<br/>
<br/>
3.	Allow the pixel to be moved around using the D-Pad (make sure it doesn?t go past the boundaries of the screen). (guessing something like offset limit will do the trick here)
<br/>
<br/>
<br/>
4.	Change pixel colour using A and B buttons. 
<br/>
^no clue about that either as i haven't even looked at any possible tutorial on how to do it^
<br/>
<br/>
anyway here is the code:
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//================
<br/>
//    HEADERS
<br/>
//================
<br/>
#include "gba.h"
<br/>
<br/>
//================
<br/>
//   CONSTANTS
<br/>
//================
<br/>
<br/>
#define BG2_ENABLE      0x400    
<br/>
#define MODE3         0x3
<br/>
#define FRONTBUFFER      (u16*)0x6000000
<br/>
<br/>
#define RGB(r,g,b) ((b&lt;&lt;10)+(g&lt;&lt;5)+r) //u16 --&gt; unsigned short, this is macro for RGB() 15bit color format
<br/>
#define ScreenWidth 240
<br/>
#define ScreenHeight 160
<br/>
<br/>
//================
<br/>
//    GLOBALS
<br/>
//================
<br/>
u16* g_uspVideoBuffer   = FRONTBUFFER; //This is were we are currently drawing 
<br/>
<br/>
//================
<br/>
//   FUNCTIONS
<br/>
//================
<br/>
<br/>
//================
<br/>
//   Function: PlotPixel16(int, int, unsigned short int)
<br/>
//      Notes: Plots a pixel in the specified colour
<br/>
//       Date: 14/2/2002
<br/>
//================
<br/>
void PlotPixel16(int in_iX,int in_iY, unsigned short int in_usColour) 
<br/>
{
<br/>
   g_uspVideoBuffer[(in_iY) * ScreenWidth + (in_iX)] = (in_usColour);
<br/>
}
<br/>
<br/>
<br/>
//================
<br/>
//   Function: main()
<br/>
//      Notes: Main entry point into rom
<br/>
//       Date: 14/2/2002
<br/>
//================
<br/>
int main()
<br/>
{
<br/>
<br/>
   //REG_DISPCNT (defined in gba.h) is the main display register that controls
<br/>
   //the mode of operation which backgrounds are enabled and which buffer is
<br/>
   //currently being drawn by the GPU.
<br/>
   //this sets the screen mode to mode three and enables background 2
<br/>
   //background 2 is required for all bitmap modes(3-5)
<br/>
   REG_DISPCNT = MODE3 | BG2_ENABLE;
<br/>
   
<br/>
   unsigned short yellow  = RGB(31,31,15);
<br/>
   //unsigned short green= RGB(0,31,0);
<br/>
   //unsigned short blue = RGB(0,0,31);
<br/>
   //unsigned short white= RGB(31,31,31);
<br/>
   
<br/>
   
<br/>
   //draw a pixel on GBA screen
<br/>
   PlotPixel16(120,80,yellow);
<br/>
   //PlotPixel16(130,70,green);
<br/>
   //PlotPixel16(110,90,blue);
<br/>
   //PlotPixel16(130,90,white);
<br/>
   
<br/>
   
<br/>
   while(1){}
<br/>
<br/>
   return 0;
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
the actual macro is here:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define RGB(r,g,b) ((b&lt;&lt;10)+(g&lt;&lt;5)+r)</td> </tr></table><span class="postbody">
<br/>
and i'm supposed to edit it inside the code so that it does what task 1 asks
<br/>
<br/>
Write a function or macro, which takes three values between 0 and 31, and converts this to BGR 16 bit format.
<br/>
<br/>
As you might have guessed by now i honestly don't have the smallest clue on how to properly edit the code without messing things up.
<br/>
That entire thing was programmed in C, and the closest thing i know to c is C++. But between C++, C, and actual gba programming there are quite fine differences.
<br/>
<br/>
I know how to do what the task asks me in C++ as its just a simple matter of defining the macro, passing parameters with a cin user input in the middle. I wasn't quite able to do the same thing in C since parameters are handled a bit differently in C and i couldn't quite get the cout and cin part in C either since i don't know what the reserved keywords are for it.
<br/>
<br/>
With all that i still did try to edit the code to make it work on the gba but I'm never able to do anything correctly. NO matter what i write i keep on getting error not in scope of function regardless of where I put it in. I tried declaring my stuff globally but even then it complained about not in scope of function and just said ERROR 1 and fails to load the gba correctly.
<br/>
<br/>
I'm terribly sorry for wasting your time as this must sound pretty pathetic and its probably something basic for all of you but i simply got stuck with the worst possible imbecile for a teacher who is unable to provide any actual support what so ever.
<br/>
<br/>
<br/>
Thank you for your time,
<br/>
Sincerely
<br/>
Daniel</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145557 - tepples - Sun Nov 18, 2007 1:22 am</h4>
    <div class="postbody"><span class="postbody">The C equivalents of cout and cin are stdout and stdin, respectively. But as far as I can tell, the Game Boy Advance system has no useful counterpart to cin or stdin, in part because consoleInit() of libgba does not install an on-screen keyboard or any other stdin handler.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145579 - speedemon35 - Sun Nov 18, 2007 1:10 pm</h4>
    <div class="postbody"><span class="postbody">Oh well so much for ever getting this junk to work. Thanks for your help though</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#145638 - ScottLininger - Mon Nov 19, 2007 7:41 pm</h4>
    <div class="postbody"><span class="postbody">Hello, Daniel! Welcome to the forums.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>speedemon35 wrote:</b></span></td> </tr> <tr> <td class="quote">Oh well so much for ever getting this junk to work. Thanks for your help though</td> </tr></table><span class="postbody">
<br/>
<br/>
Whoa, don't give up so easily. Trying to understand a macro when you're still trying to grasp the programming basics isn't the best place to start. I'd begin with problem #3.
<br/>
<br/>
You already have a function that is successfully drawing a pixel, right? So don't worry about the color macro just yet. Let's start with getting some user input from the GBA and making your pixel move.
<br/>
<br/>
<span style="font-weight: bold">Step 1: Create some variables for the current pixel position:</span>
<br/>
<br/>
Do you understand the PlotPixel16 function? It takes three numbers as parameters and pokes a single, colored pixel into the GBA's video RAM, which is the region of memory that stores the screen as a long series of color values. 
<br/>
<br/>
You already figured out that the following function call draws a yellow pixel in the center of the screen:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">PlotPixel16(120,80,yellow); </td> </tr></table><span class="postbody">
<br/>
<br/>
Here's a bit of code that does the same thing, but does so by passing two variables instead of fixed numbers. 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int x;  // creates an integer (int) variable called "x" 
<br/>
int y; // creates an integer variable called "y"
<br/>
x=120; // stores the number "120" into x
<br/>
y=80; // stores the number "80" into y
<br/>
PlotPixel16(x,y,yellow); // draws a yellow pixel at screen position x,y
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Get it? Functions can be passed either fixed values OR the values that are stored in variables. Now, let's *alter* the value of y and call our function a second time. Replace the code above with the following:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int x;  // creates an integer (int) variable called "x" 
<br/>
int y; // creates an integer variable called "y"
<br/>
x=120; // stores the number "120" into x
<br/>
y=80; // stores the number "80" into y
<br/>
PlotPixel16(x,y,yellow); // draws a yellow pixel at screen position x,y
<br/>
y = y + 1; // adds "1" to y. After this line of code, y will contain "81"
<br/>
PlotPixel16(x,y,yellow); // draws a yellow pixel at screen position 120,81
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Run this and you'll see two yellow pixels on the screen. Even though the PlotPixel function call looks exactly the same on both lines, the fact that you altered Y between calls means that the pixel location changed.
<br/>
<br/>
<span style="font-weight: bold">2. Change X and Y inside the WHILE loop</span>
<br/>
<br/>
The while(1) {} line inside your code is a "while loop", which is a way to repeat code execution in C. Any lines of code that you put <span style="font-style: italic">between</span> the curly brackets {} will be repeated over and over again so long as the expression inside the round parentheses () is "true." In this case, the number "1" always evaluates to true, so any lines of code you put between the brackets will repeat forever.
<br/>
<br/>
Try replacing the while(1) {} line with the following bit of code. Can you predict what this will do?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
x = 120;
<br/>
y = 0;
<br/>
<br/>
while(y&lt;160)  // do this over and over until y &gt;= 160
<br/>
{
<br/>
  y=y+1;
<br/>
  PlotPixel16(x,y,yellow);
<br/>
}
<br/>
<br/>
while (1) {} // do this loop forever
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This (should) draw a yellow line from the top of the screen to the bottom.
<br/>
<br/>
Try these couple of exercises first, and write us back with how it went. The next steps from here are:
<br/>
<br/>
<span style="font-weight: bold">3. Getting user input on the GBA </span>
<br/>
(Hint: the GBA doesn't have cin, but there are macros in gba.h that tell you whether the user is pressing any of the buttons.)
<br/>
<br/>
<span style="font-weight: bold">4. Making user input change variables inside the while loop</span>
<br/>
(Hint: If the user presses "left" on the pad, change X, then draw a new pixel at X,Y, etc.)
<br/>
<br/>
<span style="font-weight: bold">5. Checking for "going off the screen"</span>
<br/>
(Hint: It's all about C's if/then code structure.)
<br/>
<br/>
<span style="font-weight: bold">6. Color macros</span>
<br/>
(Hint: You'll need to understand bit shifting and what a macro is.)<br/>_________________<br/>Some of my <a class="postlink" href="http://www.scottlininger.com/" target="_blank">GBA projects</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#146255 - speedemon35 - Sat Dec 01, 2007 3:14 pm</h4>
    <div class="postbody"><span class="postbody">ScottLininger I'd like to thank you very very much for that:) Your post got me through a great deal of my troubles and i managed to hand in my project.
<br/>
<br/>
Also sorry for only replying back now but my internet sort of has a will of its own and i had other course work to do all the time so:(
<br/>
<br/>
and btw Scott your website is down which is quite a shame. I?m sure it would prove to be quite a handy learning resource 
<br/>
<br/>
This is what the code looks like. According to the teacher its not the best code speed wise but i really couldn't care too much about that right now. important thing is that it works
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//Add the header
<br/>
#include "gba.h"
<br/>
<br/>
//Define the constants
<br/>
#define BG2_ENABLE      0x400    
<br/>
#define MODE3         0x3
<br/>
#define FRONTBUFFER      (u16*)0x6000000
<br/>
<br/>
#define RGB(r,g,b) ((b&lt;&lt;10)+(g&lt;&lt;5)+r) //u16 --&gt; unsigned short, this is the macro for RGB() 15bit color format
<br/>
#define ScreenWidth 240
<br/>
#define ScreenHeight 160
<br/>
<br/>
//Define a couple of colors for the pixel
<br/>
#define Black 0x0000
<br/>
#define White 0xFFFF
<br/>
#define Cyan 0xFF00
<br/>
#define Magenta 0xF00F
<br/>
#define Yellow 0x0FDF
<br/>
#define Blue 0xEE00
<br/>
#define Red 0x00FF
<br/>
#define Green 0x0EE0
<br/>
#define Brown 0x0D0D
<br/>
#define Gray 0x0B0B
<br/>
#define Dark_gray 0x0D0D
<br/>
#define Light_blue 0x0B0F
<br/>
#define Light_green 0x0B0D
<br/>
#define Light_cyan 0x0F0D
<br/>
#define Light_magenta 0x0F00
<br/>
<br/>
//Key Definitions from Nokturn's key demo
<br/>
#define KEY_A 1
<br/>
#define KEY_B 2
<br/>
#define KEY_SELECT 4
<br/>
#define KEY_START 8
<br/>
#define KEY_RIGHT 16
<br/>
#define KEY_LEFT 32
<br/>
#define KEY_UP 64
<br/>
#define KEY_DOWN 128
<br/>
#define KEY_R 256
<br/>
#define KEY_L 512
<br/>
<br/>
//Global variables
<br/>
u16* g_uspVideoBuffer   = FRONTBUFFER; //This is where we are currently drawing 
<br/>
<br/>
volatile int* KEYS = (volatile int*)0x04000130;
<br/>
short col[14];
<br/>
bool buttons[10];
<br/>
<br/>
/*Function: PlotPixel16(int, int, unsigned short int)
<br/>
  Notes: Plots a pixel in the specified colour*/
<br/>
<br/>
void PlotPixel16(int X,int Y, unsigned short int colour) 
<br/>
{
<br/>
   g_uspVideoBuffer[(Y) * ScreenWidth + (X)] = (colour);
<br/>
}
<br/>
<br/>
<br/>
//=================
<br/>
//   Function: clearscreen()
<br/>
//      notes: refreshes screen by filling all pixels in black
<br/>
//=================
<br/>
void clearscreen()
<br/>
{
<br/>
   int x, y;
<br/>
   unsigned short black= RGB(0,0,0);
<br/>
   
<br/>
   for ( x = 0; x &lt; (ScreenWidth); x+=1)
<br/>
   {
<br/>
      for ( y = 0; y &lt; (ScreenHeight); y+=1)
<br/>
      {PlotPixel16(x,y,black);}
<br/>
   }
<br/>
}
<br/>
<br/>
//================
<br/>
//   Function: checkbuttons()
<br/>
//      notes: polls the status of all the buttons
<br/>
//================
<br/>
void checkbuttons()
<br/>
{
<br/>
   buttons[0] = !((*KEYS) &amp; KEY_A);
<br/>
   buttons[1] = !((*KEYS) &amp; KEY_B);
<br/>
   buttons[2] = !((*KEYS) &amp; KEY_UP);
<br/>
   buttons[3] = !((*KEYS) &amp; KEY_DOWN);
<br/>
   buttons[4] = !((*KEYS) &amp; KEY_LEFT);
<br/>
   buttons[5] = !((*KEYS) &amp; KEY_RIGHT);
<br/>
   buttons[6] = !((*KEYS) &amp; KEY_START);
<br/>
   buttons[7] = !((*KEYS) &amp; KEY_SELECT);
<br/>
   buttons[8] = !((*KEYS) &amp; KEY_L);
<br/>
   buttons[9] = !((*KEYS) &amp; KEY_R);
<br/>
}
<br/>
<br/>
int main()
<br/>
{
<br/>
<br/>
   /*REG_DISPCNT (defined in gba.h) is the main display register that controls
<br/>
     the mode of operation which backgrounds are enabled and which buffer is
<br/>
     currently being drawn by the GPU.   This sets the screen mode to mode 3 
<br/>
     and enables background 2 which is required for all bitmap modes(3-5)*/
<br/>
   REG_DISPCNT = MODE3 | BG2_ENABLE;
<br/>
   
<br/>
   col[0] = White;
<br/>
   col[1] = Cyan;
<br/>
   col[2] = Magenta;
<br/>
   col[3] = Yellow;
<br/>
   col[4] = Red;
<br/>
   col[5] = Blue;
<br/>
   col[6] = Green;
<br/>
   col[7] = Brown;
<br/>
   col[8] = Gray;
<br/>
   col[9] = Dark_gray;
<br/>
   col[10] = Light_blue;
<br/>
   col[11] = Light_green;
<br/>
   col[12] = Light_cyan;
<br/>
   col[13] = Light_magenta;
<br/>
<br/>
   int n = 5; //counter for color change
<br/>
   
<br/>
   int x = 50;
<br/>
   int y = 50;
<br/>
<br/>
   //draw the yellow pixel on the GBA screen
<br/>
   PlotPixel16(x,y,Yellow);
<br/>
   
<br/>
   //loop to change pixel color depending on what buttons the user presses. If the correct buttons are pressed pixel changes color
<br/>
   while(1)
<br/>
   {
<br/>
      checkbuttons();
<br/>
      
<br/>
      if (buttons[2])
<br/>
      {
<br/>
         if (y &gt; 0)
<br/>
         {clearscreen(); y = y - 1; PlotPixel16(x,y,col[n]);}
<br/>
      }
<br/>
      if (buttons[3])
<br/>
      {
<br/>
         if (y &lt; (ScreenHeight - 1))
<br/>
         {clearscreen(); y = y + 1; PlotPixel16(x,y,col[n]);}
<br/>
      }
<br/>
      if (buttons[4])
<br/>
      {
<br/>
         if ( x &gt; 0 )
<br/>
         {clearscreen(); x = x - 1; PlotPixel16(x,y,col[n]);}
<br/>
      }
<br/>
      if (buttons[5])
<br/>
      {
<br/>
         if ( x &lt; (ScreenWidth - 1))
<br/>
         {clearscreen(); x = x + 1; PlotPixel16(x,y,col[n]);}
<br/>
      }   
<br/>
      if (buttons[0])
<br/>
      {
<br/>
         switch (n)
<br/>
         {
<br/>
            case 0: {n = 1; break;}
<br/>
            case 1: {n = 2; break;}
<br/>
            case 2: {n = 3; break;}
<br/>
            case 3: {n = 4; break;}
<br/>
            case 4: {n = 5; break;}
<br/>
            case 5: {n = 6; break;}
<br/>
            case 6: {n = 7; break;}
<br/>
            case 7: {n = 8; break;}
<br/>
            case 8: {n = 9; break;}
<br/>
            case 9: {n = 10; break;}
<br/>
            case 10: {n = 11; break;}
<br/>
            case 11: {n = 12; break;}
<br/>
            case 12: {n = 13; break;}
<br/>
            case 13: {n = 0; break;}
<br/>
            PlotPixel16(x,y,col[n]);
<br/>
         }
<br/>
      }
<br/>
      if (buttons[1])
<br/>
      {
<br/>
         switch (n)
<br/>
         {
<br/>
            case 0: {n = 6; break;}
<br/>
            case 1: {n = 0; break;}
<br/>
            case 2: {n = 1; break;}
<br/>
            case 3: {n = 2; break;}
<br/>
            case 4: {n = 3; break;}
<br/>
            case 5: {n = 4; break;}
<br/>
            case 6: {n = 5; break;}
<br/>
            case 7: {n = 8; break;}
<br/>
            case 8: {n = 9; break;}
<br/>
            case 9: {n = 10; break;}
<br/>
            case 10: {n = 11; break;}
<br/>
            case 11: {n = 12; break;}
<br/>
            case 12: {n = 13; break;}
<br/>
            case 13: {n = 0; break;}
<br/>
            PlotPixel16(x,y,col[n]);
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
   
<br/>
   return 0;
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
