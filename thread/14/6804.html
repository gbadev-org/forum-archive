<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Changing screen fading during hblank - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Beginners > Changing screen fading during hblank</h2>
<div id="posts">
<div class="post">
    <h4>#53577 - Dan_attacker - Fri Sep 09, 2005 1:29 pm</h4>
    <div class="postbody"><span class="postbody">In my game, I have the top part of the screen fade while the lower part stays bright. I'm doing this by using a vcount interrupt and then changing the REG_COLEY value to make the screen bright in the middle of drawing the screen. It works perfectly on VisualBoyAdvance, but when I run it on actual hardware, the left of the first line that I changed the brightness for is still dark. About 8 pixels are still dark, and it also wiggles (kind of hard to explain). I've tried disabling all other interrupts but the problem still exists. Here's the code that is run when the vcount interrupt is triggered...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void dialogsprdim()
<br/>
{
<br/>
   dialogirqon=1;
<br/>
   WaitForHblank();
<br/>
   SetMode(MODE_0 | H_BLANK_OAM | OBJ_ENABLE | OBJ_MAP_2D | BG0_ENABLE | BG1_ENABLE | BG2_ENABLE | BG3_ENABLE);
<br/>
   REG_COLY = 0;
<br/>
   while (REG_VCOUNT!=161)
<br/>
   {
<br/>
   }
<br/>
   SetMode(MODE_0 | H_BLANK_OAM | OBJ_ENABLE | OBJ_MAP_1D | BG0_ENABLE | BG1_ENABLE | BG2_ENABLE | BG3_ENABLE);
<br/>
   REG_COLY = sintensity2;
<br/>
   kramWorker();
<br/>
   dialogirqon=0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
If I can't resolve this problem then I will have to do fading using the palette. Any ideas?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#53592 - tepples - Fri Sep 09, 2005 4:49 pm</h4>
    <div class="postbody"><span class="postbody">Is the "wiggling" the same sort of wiggling that happens at the top left corner of the status bar when you play Super Mario Bros. 3 on NES hardware? If so, I know the problem: You're using an hblank interrupt to make a raster effect, and because the code for the first line takes longer than one hblank period, the effect happens during draw time.
<br/>
<br/>
Try setting a vcount interrupt that makes a one-shot hblank DMA.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#53664 - Dan_attacker - Sat Sep 10, 2005 12:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Try setting a vcount interrupt that makes a one-shot hblank DMA.
<br/>
</td> </tr></table><span class="postbody">
<br/>
How would I go about doing this? Thanks in advance.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#53667 - Dan_attacker - Sat Sep 10, 2005 1:16 pm</h4>
    <div class="postbody"><span class="postbody">Ok, it works now. Is this what you wanted me to do?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 fadeset = (BIT0|BIT1|BIT2|BIT6|BIT7);
<br/>
void dialogsprdim()
<br/>
{
<br/>
   REG_DMA3SAD = (u32)&amp;fadeset;
<br/>
   REG_DMA3DAD = 0x4000050;
<br/>
   REG_DMA3CNT = 1 | DMA_16HBLANK;
<br/>
   SetMode(MODE_0 | H_BLANK_OAM | OBJ_ENABLE | OBJ_MAP_2D | BG0_ENABLE | BG1_ENABLE | BG2_ENABLE | BG3_ENABLE);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
If there is a more correct way of doing it, please feel free to share it. Thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61528 - curious - Mon Nov 21, 2005 6:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Is the "wiggling" the same sort of wiggling that happens at the top left corner of the status bar when you play Super Mario Bros. 3 on NES hardware? If so, I know the problem: You're using an hblank interrupt to make a raster effect, and because the code for the first line takes longer than one hblank period, the effect happens during draw time.</td> </tr></table><span class="postbody">
<br/>
<br/>
I have this problem too, and I'd like to ask about it.
<br/>
<br/>
Part of my program walks through slices of a colour cube, in double buffered MODE_4.  As that's an indexed mode, I intercept the HBlank, and rewrite the palette on each line.  Works great in Boycott Advance, but I get this same incomplete execution of the ISR before the line completes - but again, only on the first line.
<br/>
<br/>
I'm not sure of two things - why does <span style="font-style: italic">only</span> the first line appear to be slow?  Second, will a DMA transfer help me?  I'm not sure if there'll be a speed saving going from EWRAM to PAL RAM as compared to just unrolling the loop, which is what I had.  But I couldn't find cycle timings in Cowbite for direct assignment, and I don't know a lot about ARM ( my program is in Thumb, by the way ).
<br/>
<br/>
Is my only alternative to attempt to construct a new palette in EWRAM as the line is being painted by hardware, and use a repeating DMA triggered on HSync to blast it across, with my fingers crossed it'll all synch up properly?
<br/>
<br/>
Finally, I have one last question - I apologise if this has been covered in a FAQ or something, but I must have missed it - My DMA transfers / bulk loops &amp; assignments, etc, use 32 bit values where possible.  However, I'm told that as I'm writing my code in Thumb, and hence, I think, residing in EWRAM land, my transfers will really be all 16 bit.  Am I getting any value here?  Do I need to rebuild my code into ARM and sock it into IWRAM?
<br/>
<br/>
Thanks for your time - I hope this was alright for a first post.
<br/>
<br/>
Edit: Here's the ISR - it's handed off to by libgba's Interrupt Switchboard:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void isrHCHBlank()
<br/>
{
<br/>
        REG_IE = 0;
<br/>
        // Lines 16 .. 143 are set as simple implementing gradients
<br/>
        // with a step size of four ( double ) pixels.  As this is
<br/>
        // firing in the HBlank, it needs to be done on the line
<br/>
        // *before* the line you want the colours to effect. 
<br/>
        if( REG_VCOUNT &gt;= 15 &amp;&amp; REG_VCOUNT &lt;= 142 )
<br/>
        {
<br/>
                u32 baseColour = blueSlice | ( ( ( REG_VCOUNT - 15 ) &gt;&gt; 2 ) &lt;&lt; 5 ) | ( ( ( REG_VCOUNT - 15 ) &gt;&gt; 2 ) &lt;&lt; 21 );
<br/>
                ((u32 *)BG_COLORS)[  0 ] = baseColour | 0x00010000;
<br/>
                ((u32 *)BG_COLORS)[  1 ] = baseColour | 0x00030002;
<br/>
                ((u32 *)BG_COLORS)[  2 ] = baseColour | 0x00050004;
<br/>
                ((u32 *)BG_COLORS)[  3 ] = baseColour | 0x00070006;
<br/>
                ((u32 *)BG_COLORS)[  4 ] = baseColour | 0x00090008;
<br/>
                ((u32 *)BG_COLORS)[  5 ] = baseColour | 0x000B000A;
<br/>
                ((u32 *)BG_COLORS)[  6 ] = baseColour | 0x000D000C;
<br/>
                ((u32 *)BG_COLORS)[  7 ] = baseColour | 0x000F000E;
<br/>
                ((u32 *)BG_COLORS)[  8 ] = baseColour | 0x00110010;
<br/>
                ((u32 *)BG_COLORS)[  9 ] = baseColour | 0x00130012;
<br/>
                ((u32 *)BG_COLORS)[ 10 ] = baseColour | 0x00150014;
<br/>
                ((u32 *)BG_COLORS)[ 11 ] = baseColour | 0x00170016;
<br/>
                ((u32 *)BG_COLORS)[ 12 ] = baseColour | 0x00190018;
<br/>
                ((u32 *)BG_COLORS)[ 13 ] = baseColour | 0x001B001A;
<br/>
                ((u32 *)BG_COLORS)[ 14 ] = baseColour | 0x001D001C;
<br/>
        }
<br/>
        else ( ( u32 * ) BG_COLORS )[ 0 ] = 0x7FFF0000;
<br/>
<br/>
        REG_IF |= IE_HBL;
<br/>
        REG_IE = 1;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Curious.<br/>_________________<br/>I thought they was prunes!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61539 - DekuTree64 - Mon Nov 21, 2005 10:26 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dan_attacker wrote:</b></span></td> </tr> <tr> <td class="quote">If there is a more correct way of doing it, please feel free to share it. Thanks!</td> </tr></table><span class="postbody">
<br/>
Nope, that's about as good as it gets. As for why the problem happened in the first place, it's because the VCount interrupt triggers at the START of the line. That means it has already started drawing, so the first few pixels get missed.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>curious wrote:</b></span></td> </tr> <tr> <td class="quote">Part of my program walks through slices of a colour cube, in double buffered MODE_4. As that's an indexed mode, I intercept the HBlank, and rewrite the palette on each line. Works great in Boycott Advance, but I get this same incomplete execution of the ISR before the line completes - but again, only on the first line.</td> </tr></table><span class="postbody">
<br/>
This is actually the opposite problem from what the OP was having :)
<br/>
The HBlank interrupt happens AFTER the line is drawn, but before moving onto the next line. So in your ISR, if REG_VCOUNT is 0, that means line 0 has already been drawn, and whatever changes you make will be visible on line 1.
<br/>
<br/>
Usually that means your effect will be off by one line from what you intended, plus the first line being missed entirely.  
<br/>
To correct for the off-by-one, just add 1 to VCount before plugging it into your formula. To fix the first line, wrap your vcount around to 0 if it's the last line (therefore setting up the first line for next frame).
<br/>
<br/>
I think the HBlank interrupt keeps firing during VBlank, so you'll probably want to bail out if VCount is &gt;= 160. Something like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void isrHCHBlank()
<br/>
{
<br/>
    u32 vcount = REG_VCOUNT;
<br/>
    if (vcount &lt; 160)
<br/>
    {
<br/>
        vcount += 1;       // Correct off-by-one
<br/>
        if (vcount == 160)
<br/>
            vcount = 0;    // Set up first line for next frame
<br/>
<br/>
        // ...do stuff like before, but using vcount instead of REG_VCOUNT
<br/>
    }
<br/>
    REG_IF = IE_HBL;   // Don't need the |= here (funky hardware thing)
<br/>
    // Also don't need to mess with REG_IE, because interrupts 
<br/>
    // are automatically disabled by the CPU
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Here's <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=4064" target="_blank">another thread</a> on HBlank stuff, if you feel like reading. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">My DMA transfers / bulk loops &amp; assignments, etc, use 32 bit values where possible.  However, I'm told that as I'm writing my code in Thumb, and hence, I think, residing in EWRAM land, my transfers will really be all 16 bit.  Am I getting any value here?</td> </tr></table><span class="postbody">
<br/>
ARM or THUMB code won't affect the speed of copying data around. That's determined by the waitstates of the memory areas being accessed.
<br/>
<br/>
A 32-bit transfer will be done as 2 16-bit transfers by the hardware, but it will still be faster than doing 2 16-bit transfers by yourself, since each load instruction takes 2 cycles in addition to the memory transfer time, and stores are 1+transfer time.
<br/>
<br/>
For DMA, check the DMA timing chart in Cowbite, but generally just use 32-bit unless you have a reason not to.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61540 - curious - Mon Nov 21, 2005 11:12 am</h4>
    <div class="postbody"><span class="postbody">Edit: I just found another odd artifact in my program.  Might be best to hold off looking into this any further until I run it down.  Cheers!
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">The HBlank interrupt happens AFTER the line is drawn, but before moving onto the next line. So in your ISR, if REG_VCOUNT is 0, that means line 0 has already been drawn, and whatever changes you make will be visible on line 1.</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks for taking the time out to have a look at this. :-) Unfortunately, I'm still not quite sure where I'm going wrong! D-:
<br/>
<br/>
I understand what you're saying about the HBlank being fired with the line in VCOUNT already painted in, but I <span style="font-style: italic">think</span> I've already compensated for this - the lines I want affected are 16 to 143, and so the ISR will fire according to:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">        if( REG_VCOUNT &gt;= 15 &amp;&amp; REG_VCOUNT &lt;= 142 ) </td> </tr></table><span class="postbody">I agree with what you said about not rewriting the palette past VCOUNT &gt;160.  In fact, it really only needs to be written after the "crazy colour" section is finished ( VCOUNT == 143 ) and once before starting the effect.  I will fix that when I get home.
<br/>
<br/>
I'm still not sure how this is causing just the first three or four pixels to not get their colour though - especially as those first four pixels are all the same colour ( check the note in the comment about the eight pixel blocks ).  I can only surmise that the palette is not being updated quick enough, but surely the first palette entry, if anything, should go through on time?
<br/>
<br/>
I will have a look at the other article when I get home, but thanks again for all the help ( particularly for clearing up the word size thing ).  Would it possibly help if I posted a rom of my program ( just this colour blending section ) online for someone to look at?<br/>_________________<br/>I thought they was prunes!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61541 - Cearn - Mon Nov 21, 2005 11:18 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>curious wrote:</b></span></td> </tr> <tr> <td class="quote">I'm not sure of two things - why does <span style="font-style: italic">only</span> the first line appear to be slow?</td> </tr></table><span class="postbody">
<br/>
By first line, do you mean the first scanline (i.e., at the top) or the first line of code in the isr?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>curious wrote:</b></span></td> </tr> <tr> <td class="quote"> Second, will a DMA transfer help me?  I'm not sure if there'll be a speed saving going from EWRAM to PAL RAM as compared to just unrolling the loop, which is what I had.  But I couldn't find cycle timings in Cowbite for direct assignment, and I don't know a lot about ARM ( my program is in Thumb, by the way ).
<br/>
<br/>
Is my only alternative to attempt to construct a new palette in EWRAM as the line is being painted by hardware, and use a repeating DMA triggered on HSync to blast it across, with my fingers crossed it'll all synch up properly?
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void isrHCHBlank()
<br/>
{
<br/>
        REG_IE = 0;
<br/>
        // Lines 16 .. 143 are set as simple implementing gradients
<br/>
        // with a step size of four ( double ) pixels.  As this is
<br/>
        // firing in the HBlank, it needs to be done on the line
<br/>
        // *before* the line you want the colours to effect. 
<br/>
        if( REG_VCOUNT &gt;= 15 &amp;&amp; REG_VCOUNT &lt;= 142 )
<br/>
        {
<br/>
                u32 baseColour = blueSlice | ( ( ( REG_VCOUNT - 15 ) &gt;&gt; 2 ) &lt;&lt; 5 ) | ( ( ( REG_VCOUNT - 15 ) &gt;&gt; 2 ) &lt;&lt; 21 );
<br/>
                ((u32 *)BG_COLORS)[  0 ] = baseColour | 0x00010000;
<br/>
                ((u32 *)BG_COLORS)[  1 ] = baseColour | 0x00030002;
<br/>
                ((u32 *)BG_COLORS)[  2 ] = baseColour | 0x00050004;
<br/>
                ((u32 *)BG_COLORS)[  3 ] = baseColour | 0x00070006;
<br/>
                ((u32 *)BG_COLORS)[  4 ] = baseColour | 0x00090008;
<br/>
                ((u32 *)BG_COLORS)[  5 ] = baseColour | 0x000B000A;
<br/>
                ((u32 *)BG_COLORS)[  6 ] = baseColour | 0x000D000C;
<br/>
                ((u32 *)BG_COLORS)[  7 ] = baseColour | 0x000F000E;
<br/>
                ((u32 *)BG_COLORS)[  8 ] = baseColour | 0x00110010;
<br/>
                ((u32 *)BG_COLORS)[  9 ] = baseColour | 0x00130012;
<br/>
                ((u32 *)BG_COLORS)[ 10 ] = baseColour | 0x00150014;
<br/>
                ((u32 *)BG_COLORS)[ 11 ] = baseColour | 0x00170016;
<br/>
                ((u32 *)BG_COLORS)[ 12 ] = baseColour | 0x00190018;
<br/>
                ((u32 *)BG_COLORS)[ 13 ] = baseColour | 0x001B001A;
<br/>
                ((u32 *)BG_COLORS)[ 14 ] = baseColour | 0x001D001C;
<br/>
        }
<br/>
        else ( ( u32 * ) BG_COLORS )[ 0 ] = 0x7FFF0000;
<br/>
<br/>
        REG_IF |= IE_HBL;
<br/>
        REG_IE = 1;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
There are a few simple ways of speeding up this code, even without resorting to ARM code. First, don't use REG_VCOUNT everywhere. It is volatile, so it will be loaded into a register every time. Capture it in a variable and use that instead. Also, in THUMB code ORring is rather limited, if you can use ADD if you can.
<br/>
<br/>
Other things that can be taken into consideration: ARM CPUs don't like large constants like 0x00050004, which have to be constructed in multiple tries (or put in a lut and then loaded, which is what actually happens). Using incremental offsets is faster. GCC doesn't particularly care for #defined arrays like BG_COLORS either: creating a separate pointer and incrementing that should be faster. 
<br/>
<br/>
So, instead of 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u32 baseColour = blueSlice | ( ( ( REG_VCOUNT - 15 ) &gt;&gt; 2 ) &lt;&lt; 5 ) | ( ( ( REG_VCOUNT - 15 ) &gt;&gt; 2 ) &lt;&lt; 21 ); 
<br/>
    ((u32 *)BG_COLORS)[  0 ] = baseColour | 0x00010000; 
<br/>
    ((u32 *)BG_COLORS)[  1 ] = baseColour | 0x00030002; 
<br/>
...
<br/>
</td> </tr></table><span class="postbody">
<br/>
try 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u32 vc= REG_VCOUNT-15;
<br/>
u32 clr= blueSlice | ( ((vc&gt;&gt;2)&lt;&lt;5 ) | ((vc&gt;&gt;2)&lt;&lt;21); 
<br/>
clr += 0x00010000;
<br/>
u32 clrofs= 0x00020002;
<br/>
u32 *pal= (u32*)BG_COLORS;
<br/>
<br/>
*pal++ = clr;
<br/>
clr += clrofs;
<br/>
</td> </tr></table><span class="postbody">
<br/>
Now, this <span style="font-style: italic">should</span> have been faster, but now that I check the asm code, it seems that GCC is particularly inept at optimising it ... even when you do it for it. It seems that it just ignores what I say and uses a lut/load for both the palette and color offset regardless.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ generated asm for (more for background info than anything else. 
<br/>
@ feel free to skip)
<br/>
@   *pal++ = clr;
<br/>
@   clr += ofs;
<br/>
<br/>
@ what I get
<br/>
    ldr r3, .L65+8  @ r3=ofs[ii],           S+N+I
<br/>
    add r1, r2, r3  @ r1= clr0+ofs,         S
<br/>
    ldr r3, .L65+12 @ r3= &amp;BG_COLORS[ii]    S+N+I
<br/>
    str r1, [r3]    @ *r3= clr0+ofs         2N
<br/>
@ total: 3S+4N+2I
<br/>
<br/>
@ should be:
<br/>
@ r0=pal, r1=clr, r2=ofs
<br/>
    stmia   r0!, {r1}       2N
<br/>
    add     r1, r1, r2      1S
<br/>
@ 1S+2N
<br/>
</td> </tr></table><span class="postbody">
<br/>
For code run from EWRAM this comes down to 23 (maybe even 25 due to loading u32 through the 16 bit bus) vs 9 cycles. Quite a difference I should say. If you can do it in asm, go for it. 
<br/>
As for precalculating+HDMA: you won't win much in terms of cycles (per haps even lose some), but you will win some because of where those cycles are spent, in the much larger Vblank instead of the skimpy Hblank. But you'll have to add two VCount interrupts to make sure it starts and stops at the correct time.
<br/>
<br/>
[quote="curious]Finally, I have one last question - I apologise if this has been covered in a FAQ or something, but I must have missed it - My DMA transfers / bulk loops &amp; assignments, etc, use 32 bit values where possible.  However, I'm told that as I'm writing my code in Thumb, and hence, I think, residing in EWRAM land, my transfers will really be all 16 bit.  Am I getting any value here?  Do I need to rebuild my code into ARM and sock it into IWRAM?
<br/>
[/quote]
<br/>
What Deku said: a single 32bit transfer will always be faster than doing it in two 16bit ones because you'll use fewer instructions. Plus there maybe some fringe benefits too. 
<br/>
Putting things in IWRAM will always be faster than anywhere else; whether you <span style="font-style: italic">need</span> to is a pretty much up to you. If it works with the current code, fine. If it doesn't, try the ARM+IWRAM thing and see how that works out.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61579 - tepples - Mon Nov 21, 2005 8:50 pm</h4>
    <div class="postbody"><span class="postbody">You'll definitely want to do this sort of thing as hblank DMA instead of an hblank ISR. Use a vcount interrupt on the line above the gradient to start the HDMA, and then use another vcount interrupt on the line below the gradient to stop the HDMA.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61597 - curious - Mon Nov 21, 2005 11:48 pm</h4>
    <div class="postbody"><span class="postbody">Thanks, Tepples!  Seems like I'm going to be firing a hell of a lot of VCount interrupts though. :-(
<br/>
<br/>
In line with earlier suggestions, I tried assembling some of the loop.  The following works great in the emulator:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void isrHCHBlank()
<br/>
{
<br/>
        u32 nvVCount = REG_VCOUNT;
<br/>
        REG_IE = 0;
<br/>
<br/>
        // Lines 16 .. 143 are set as simple implementing gradients
<br/>
        // with a step size of four ( double ) pixels.  As this is
<br/>
        // firing in the HBlank, it needs to be done on the line
<br/>
        // *before* the line you want the colours to effect. 
<br/>
<br/>
        if( nvVCount &gt;= 15 &amp;&amp; nvVCount &lt;= 142 )
<br/>
        {
<br/>
                u32 *palPointer = ((u32 *)BG_COLORS);
<br/>
                u32 newColour, colourOffset;
<br/>
<br/>
                nvVCount -= 15;
<br/>
                newColour = blueSlice | ( ( nvVCount &gt;&gt; 2 ) &lt;&lt; 5 ) | ( ( nvVCount &gt;&gt; 2 ) &lt;&lt; 21 );
<br/>
<br/>
                newColour += 0x00010000;
<br/>
                colourOffset = 0x00020002;
<br/>
<br/>
                asm( "  mov     r0,     #16\n\t"
<br/>
                     "teleport:\n\t"
<br/>
                     "  stmia   %0!,    {%1}\n\t"
<br/>
                     "  add     %1,     %1,     %2\n\t"
<br/>
                     "  sub     r0,     r0,     #1\n\t"
<br/>
                     "  cmp     r0,     #0\n\t"
<br/>
                     "  bne     teleport"
<br/>
                     : /* */
<br/>
                     : "r" (palPointer), "r" (newColour), "r" (colourOffset)
<br/>
                     : "r0" );
<br/>
        }
<br/>
        else ( ( u32 * ) BG_COLORS )[ 0 ] = 0x7FFF0000;
<br/>
<br/>
        REG_IF |= IE_HBL;
<br/>
        REG_IE = 1;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
... but it behaves very strangely on hardware. Namely, while the lines are coloured correctly, the VBlank interrupt which steps the value of blueSlice doesn't seem to be firing ( edit - this stops the program from progressing, as it counts off a certain number of blanks before continuing ). 
<br/>
<br/>
Commenting out the block of assembly makes the problem go away. Bah!  I hope I got the assembly thing correct too - I left the "outputs" line empty, although palPointer and newColour are both modified by the routine, because they were already in the "inputs" section ( edit: actually, this is kind of irrelevant, as I don't care what their values are after the loop completes ).
<br/>
<br/>
Curious.<br/>_________________<br/>I thought they was prunes!</span><span class="gensmall"><br/><br/>Last edited by curious on Tue Nov 22, 2005 1:14 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#61604 - DekuTree64 - Tue Nov 22, 2005 12:23 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>curious wrote:</b></span></td> </tr> <tr> <td class="quote">... but it behaves very strangely on hardware. Namely, while the lines are coloured correctly, the VBlank interrupt which steps the value of blueSlice doesn't seem to be firing.</td> </tr></table><span class="postbody">
<br/>
The REG_IF |= IE_HBL may be what's blocking your VBlank. When you write a 1 to a bit in IF, that bit is cleared. If the HBlank on the last line runs over until VBlank sets its bit, the |= will clear it, and the interrupt will never fire (normally it would wait until your HBlank returns, and then fire immediately).
<br/>
<br/>
In other words, just do REG_IF = IE_HBL to clear only the HBlank bit, leaving any other active bits to fire off after you return.
<br/>
<br/>
And just to check, is your REG_IE defined as address 0x4000200, or 0x4000208? 
<br/>
Normally 0x4000200 is called REG_IE, and 0x4000208 is called REG_IME, but if that was the case here I don't think your HBlank would work at all...<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#61608 - curious - Tue Nov 22, 2005 1:03 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">The REG_IF |= IE_HBL may be what's blocking your VBlank. When you write a 1 to a bit in IF, that bit is cleared. If the HBlank on the last line runs over until VBlank sets its bit, the |= will clear it, and the interrupt will never fire (normally it would wait until your HBlank returns, and then fire immediately).</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not quite sure why this problem never manifested before ( I've been using the |= construction since I started on this program ), but this change fixed my problem, and better yet - combined with the assembly, fixed the amazing missing opening pixels!  To be quite honest, I don't really understand the magic that drives REG_IF... it seems to work a little counterintuitively.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">And just to check, is your REG_IE defined as address 0x4000200, or 0x4000208? </td> </tr></table><span class="postbody">
<br/>
<br/>
This build of libgba defines it as *(vu16*)(REG_BASE+0x200), which yes, should resolve to 0x4000200.  Thanks again!  I will play "Deku's Palace" on my ocarina tonight in your honor.
<br/>
<br/>
curious<br/>_________________<br/>I thought they was prunes!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
