<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>DMA Overuse - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Beginners > DMA Overuse</h2>
<div id="posts">
<div class="post">
    <h4>#20611 - CyberSlag5k - Thu May 13, 2004 6:25 pm</h4>
    <div class="postbody"><span class="postbody">How often should one use the DMA? Should it only be used in special occasions when you want to move alot of data really quickly? Or should I try and use it as much as possible?<br/>_________________<br/><span style="font-style: italic">When you find yourself in the company of a halfling and an ill-tempered Dragon, remember, you do not have to outrun the Dragon... </span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20613 - sajiimori - Thu May 13, 2004 6:37 pm</h4>
    <div class="postbody"><span class="postbody">Use DMA for any copy of significant size (except to SRAM).  It seems to me that even very small copies (in the double digits) would be faster with DMA, because the overhead is so small.
<br/>
<br/>
I just heard today that DMA is slower for fills (which was news to me), but you probably read that too.
<br/>
<br/>
The DMAx_SAD register should have been used as an immediate value for fills.  Seems kinda silly.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20620 - poslundc - Thu May 13, 2004 8:15 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">I just heard today that DMA is slower for fills (which was news to me), but you probably read that too.</td> </tr></table><span class="postbody">
<br/>
<br/>
DekuTree64 does a little analysis and comparison of the various options in <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=1803" target="_blank">this thread</a>.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">The DMAx_SAD register should have been used as an immediate value for fills.  Seems kinda silly.</td> </tr></table><span class="postbody">
<br/>
<br/>
The real kicker is that the CPUFastSet BIOS routines also behave the same way the DMA does in this regard. I was cursing a blue streak for hours trying to figure out why my palette-clear routine wasn't working until I realized it was because I was passing a literal zero to the routine, rather than the address of a variable that held zero. :P
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20625 - Miked0801 - Thu May 13, 2004 10:18 pm</h4>
    <div class="postbody"><span class="postbody">For very small memsets, struct to struct copies are going to be faster - even in thumb (32 bytes or less.)  That's because there's at least 70 cycles overhead just in entrance and exit code to the bios routines - not even counting setting up the registers for the copy.  You also need to set 5 IO registers for a dma as well (With care this can be done as a load mutliple (ldm) but C compilers won't do this without serious hand holding) so that's at least 15 cycles for the loads and whatever else getting the info ready.  So here's an example:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef struct _foo
<br/>
{
<br/>
    u32 word1;
<br/>
    u32 word2;
<br/>
    u32 word3;
<br/>
    u32 word4;
<br/>
} STRUCT_32_BYTES;
<br/>
<br/>
// Somewhere in code:
<br/>
<br/>
void contrivedCopy(u32 *src, u32 *dest, u32 size)
<br/>
{
<br/>
    STRUCT_32_BYTES *src32, *dest32;
<br/>
<br/>
    src32 = (STRUCT_32_BYTES *) src;
<br/>
    dest32 = (STRUCT_32_BYTES *) dest;
<br/>
<br/>
    *dest = *src;
<br/>
}
<br/>
<br/>
// Or
<br/>
    *((STRUCT_32_BYTES *) dest) = *((STRUCT_32_BYTES *) src);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
In Thumb, this will compile into 3 ldm/stm instruction - in Arm - it turns into 1 ldm/stm for maximum efficiency.  Yes, it does eat some registers but for the most part, the spilling won't hurt performance as bad as the overhead to get to BIOS or DMA.
<br/>
<br/>
Mike</span><span class="gensmall"><br/><br/>Last edited by Miked0801 on Wed May 19, 2004 7:00 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#20643 - NoMis - Fri May 14, 2004 8:08 am</h4>
    <div class="postbody"><span class="postbody">I didn't know that the cycle overhead for bios functions is this high. Whats the purpose they made them then. With the given overhead i can't realy see a good use of the most bios functions.
<br/>
<br/>
NoMis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20676 - Miked0801 - Fri May 14, 2004 6:08 pm</h4>
    <div class="postbody"><span class="postbody">Neither do I which is why I almost never use them :)
<br/>
<br/>
We use them for stuff where we don't care about speed or early in development when we didn't have our own routines ready.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20900 - LOst? - Wed May 19, 2004 2:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
    *((STRUCT_32_BYTES *) dest) = *((STRUCT_32_BYTES *) src);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Mike, I know you are really good at programming, but is that possible? Copying data with a =?
<br/>
<br/>
It is not possible for me to copy structs by doing = without making an operator= (slow C++ way).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20903 - Cearn - Wed May 19, 2004 3:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
    *((STRUCT_32_BYTES *) dest) = *((STRUCT_32_BYTES *) src);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Mike, I know you are really good at programming, but is that possible? Copying data with a =?
<br/>
<br/>
It is not possible for me to copy structs by doing = without making an operator= (slow C++ way).</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, it works. Though maybe it helps to see it without all the pointers
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct tagFOO 
<br/>
{
<br/>
    int pa, pb, pc, pd;    
<br/>
} FOO; 
<br/>
<br/>
FOO src= { 0xda, 0x9ba, 0x15, 0x1337 }, dest;
<br/>
dest= src;
<br/>
// contents of dest are now the same as src
<br/>
</td> </tr></table><span class="postbody">
<br/>
This kind of stuff is actually why all C books tell you to use pointers to structs as function arguments instead of structs: in the latter case you'll just create a full copy.
<br/>
<br/>
I've been actually using this for my hand-written tiles for while, until I saw the offputting generated assembly and switched to dma. But now it seems I'm going to put it back in again. (I'll probably also have to rethink the use of software interrupts ... 70 cycles overhead, you gotta be kidding me)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20908 - sajiimori - Wed May 19, 2004 6:11 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, I was wondering why Mike mentioned BIOS at all.  I thought everybody used macros or static inlines for DMA.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20912 - poslundc - Wed May 19, 2004 7:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">I thought everybody used macros or static inlines for DMA.</td> </tr></table><span class="postbody">
<br/>
<br/>
Not me!
<br/>
<br/>
(Never quite seen the point, frankly.)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
