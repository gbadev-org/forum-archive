<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>function pointers - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > function pointers</h2>
<div id="posts">
<div class="post">
    <h4>#8848 - hnager - Mon Jul 21, 2003 6:30 pm</h4>
    <div class="postbody"><span class="postbody">Hmmm, having a bit of trouble getting function pointers working - I have one member function pointer called update which I want to point at a variety of other member functions (to replace a case/switch) which I currently evaluate everyframe - if you're moving do this, otherwise do that, etc.
<br/>
<br/>
But everytime I try to compile i get an error - can't convert void (*) to void(*Sprite::) or something along those lines...(I don't have devkit set up at work)
<br/>
<br/>
Are function pointers possible with g++?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8849 - sgeos - Mon Jul 21, 2003 6:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>hnager wrote:</b></span></td> </tr> <tr> <td class="quote">void (*) ... void(*Sprite::) ... g++?</td> </tr></table><span class="postbody">
<br/>
<br/>
I don't do the C++ thing, but in C I've always declared function pointers like this:
<br/>
<br/>
void *(*fptr)(void) = map_init;  // map_init() is a function
<br/>
void (*fptr2)(int, int, const char *) = text_e;  // text_e() is a function
<br/>
int (*rng)(int, int) = dice; // dice() is a function
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8852 - hnager - Mon Jul 21, 2003 7:24 pm</h4>
    <div class="postbody"><span class="postbody">I'm basically doing that same thing (from what I can remember):
<br/>
<br/>
class Sprite {
<br/>
    Sprite();
<br/>
   ~ Sprite(){}
<br/>
    void move(){};
<br/>
    void (*Sprite::update)();
<br/>
    ...
<br/>
}
<br/>
<br/>
Sprite::Sprite(){
<br/>
    update = &amp;Sprite::move; //this has less complaints than update = move
<br/>
}
<br/>
<br/>
What needs to change to work within a class?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8855 - sgeos - Mon Jul 21, 2003 11:24 pm</h4>
    <div class="postbody"><span class="postbody">Again, I don't do the C++ thing, so I'm not sure how classes work.  I've been trained to always be explicit and resort to defaults, so if this is what you mean, then it is what I'd type in:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">    void (*Sprite::update)(void);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Function pointers are very particular about return types and the parameters passed to them.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int a(void)
<br/>
{
<br/>
}
<br/>
<br/>
int b(void)
<br/>
{
<br/>
}
<br/>
<br/>
void c(int)
<br/>
{
<br/>
}
<br/>
<br/>
int (*fptr)(void);  // will work with a() or b() but not c()</td> </tr></table><span class="postbody">
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8856 - col - Tue Jul 22, 2003 12:01 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>hnager wrote:</b></span></td> </tr> <tr> <td class="quote">I'm basically doing that same thing (from what I can remember):
<br/>
<br/>
class Sprite {
<br/>
    Sprite();
<br/>
   ~ Sprite(){}
<br/>
    void move(){};
<br/>
    void (*Sprite::update)();
<br/>
    ...
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
you have the '*' in the wrong place - try this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
class Sprite {
<br/>
    Sprite();
<br/>
   ~ Sprite(){}
<br/>
    void move(){};
<br/>
    void (Sprite::*update)();
<br/>
    ...
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Sprite::Sprite(){
<br/>
    update = &amp;Sprite::move; //this has less complaints than update = move
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
your assumption is correct, you _must_ use the address of operator '&amp;' explicitly when assigning a member function to a pointer
<br/>
<br/>
then to use its somthing like
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Sprite sprite1;
<br/>
Sprite* sprite2 = new Sprite();
<br/>
...
<br/>
...
<br/>
(sprite1.*update)();
<br/>
(sprite2-&gt;*update)();
<br/>
...
<br/>
...
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
hope this helps
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8859 - hnager - Tue Jul 22, 2003 1:32 am</h4>
    <div class="postbody"><span class="postbody">Thanks ! That did the trick - well, until I tried to derive from Sprite:
<br/>
<br/>
class Sprite { 
<br/>
    Sprite(); 
<br/>
   ~ Sprite(){} 
<br/>
    void move(){}; 
<br/>
    void (Sprite::*update)(); 
<br/>
    ... 
<br/>
};
<br/>
<br/>
class Ant : public Sprite {
<br/>
    Ant();
<br/>
    ~Ant(){}
<br/>
    void crawl(){};
<br/>
};
<br/>
<br/>
Ant::Ant(){
<br/>
    update= &amp;Ant::crawl;
<br/>
}
<br/>
<br/>
no surprise:
<br/>
<br/>
cannot convert `void (Ant::*)()' to `void (Sprite::*)()' in 
<br/>
   assignment
<br/>
<br/>
Any ideas - workarounds? basically I want to have all of my sprites derive from the base class so that they come predefined with the function pointer so that I can have a vector of 'Sprites' and tell each to update() each frame...the different classes and instances would take care of knowing what update should do.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8863 - Quirky - Tue Jul 22, 2003 7:34 am</h4>
    <div class="postbody"><span class="postbody">I think you're trying to use a C "trick" (function pointers) to do something that you should really be using a C++ approach to accomplish.
<br/>
<br/>
You should have your Ant class override move() so that calling mySprite.move() where mySprite is an instance of Ant, though you only know it to be "some Sprite-type class" will at run time call the Ant class's move(). Internally, Ant's move would call crawl (which could be a private function, for example)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8865 - hnager - Tue Jul 22, 2003 12:14 pm</h4>
    <div class="postbody"><span class="postbody">Makes sense - as a work around i defined update as a virtual method of Sprite:
<br/>
<br/>
virtual void update(){}
<br/>
<br/>
and then within Ant (derived from Sprite) I have a function pointer decalared then assigned in the constructor. The overriden method update() in Ant just calls that function pointer. I have an 'event engine' in place which loops through all of the Sprites registered to it and tells them to update() every frame.
<br/>
<br/>
That works, but I was hoping to take care of the function pointer declaration within Sprite and then just assign it in derived classes, for example, I have variables x and y inheritted from Sprite which can be set just as if declaed as part of Ant.
<br/>
<br/>
Is the problem with the function pointer that I have to explicitly declare it as part of Sprite? (Sprite::*update)();</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8867 - Sweex - Tue Jul 22, 2003 3:05 pm</h4>
    <div class="postbody"><span class="postbody">No no nooh!;-) 
<br/>
<br/>
As far as I understand the problem, you should not call the function pointer from your virtual function Update. The actual implementation of the function pointer it is calling should be in there. No messing about with function pointers at anymore!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8872 - hnager - Tue Jul 22, 2003 3:45 pm</h4>
    <div class="postbody"><span class="postbody">??
<br/>
<br/>
Not sure if I understand what you mean - what is the issue with calling a function pointer from the virtual function update? I'm overriding update() in derived classes - it itself is not the function pointer (that's called funcptr for now), it just calls the function pointer.
<br/>
<br/>
My approach previously was to use a case/switch to figure out what to do in the update() function - but instead I was hoping to just reassign funcptr and call that,</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8873 - Sweex - Tue Jul 22, 2003 4:05 pm</h4>
    <div class="postbody"><span class="postbody">...Example... (This is pretty basic C++ btw.)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
class Sprite
<br/>
{ 
<br/>
  Sprite(); 
<br/>
  ~Sprite(){} 
<br/>
<br/>
  virtual void move() {};
<br/>
  void update() { move(); }
<br/>
}; 
<br/>
<br/>
class Ant : public Sprite
<br/>
{ 
<br/>
  Ant(); 
<br/>
  ~Ant(){} 
<br/>
<br/>
  void move(){ /* "Crawl" code should go here*/ };
<br/>
}; 
<br/>
<br/>
// Another class to indicate it's generic use
<br/>
class AntQueen : public Ant
<br/>
{ 
<br/>
  AntQueen(); 
<br/>
  ~AntQueen(){} 
<br/>
<br/>
  virtual void move(){ /* Ant queen specific code */ };
<br/>
}; 
<br/>
<br/>
<br/>
// your main function
<br/>
void main()
<br/>
{
<br/>
  Ant ant();
<br/>
  AntQueen queen();
<br/>
<br/>
  // Move your insects, each by calling update
<br/>
  ant.Update();
<br/>
  queen.Update();
<br/>
<br/>
  // And even better
<br/>
  Sprite* insects[2];
<br/>
  insect[0] = &amp;
<br/>
  insect[1] = &amp;
<br/>
<br/>
  // Update all your insects in a loop
<br/>
  for (int i=0;i&lt;2;i++)
<br/>
  {
<br/>
    insect[i].Update(); // The program will work out which Update function to call
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Good luck!:)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8880 - hnager - Tue Jul 22, 2003 6:26 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for the example - that's what I had prior - the problem I have is that update() for one instance of a sprite may be different than another - in one case an ant may be moving, in another it may be 'resting' - that's where my case/switch used to come in to play...what i want to do is just reassign the function pointer so when i tell an ant to 'rest' it assigns the function pointer to be 'rest()' - it all works except that I can't declare the function pointer in the base class, so I have to assign it in every derived class.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8881 - Sweex - Tue Jul 22, 2003 7:10 pm</h4>
    <div class="postbody"><span class="postbody">Ah, I get it now... Can obviously be done in ++ as well, but then you can argue whether it's worth the trouble.
<br/>
<br/>
Can't help you much further with the function pointers then. Personally I'd either program a switch statement or use a statemachine (Read some articles about them if you're unfamiliar with them; they're very useful for this problem!)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#8882 - hnager - Tue Jul 22, 2003 8:14 pm</h4>
    <div class="postbody"><span class="postbody">I'm trying to get away from the switch statement - I'll do some looking around for state machines - thanks!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
