<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Bit shifting to clear bits - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > Bit shifting to clear bits</h2>
<div id="posts">
<div class="post">
    <h4>#44357 - Ultima2876 - Tue May 31, 2005 11:37 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">collmask_target &lt;&lt; shiftamount;
<br/>
collmask_target_temp = (collmask_target &lt;&lt; (64 - shiftamount)) &gt;&gt; (64 - shiftamount);</td> </tr></table><span class="postbody">
<br/>
<br/>
This'll be a short one, but it's been bothering me for hours because it's stopping me putting the code in iwram (and it needs it otherwise the thing runs too slow). Is there any trick to acheive the same effect as that second line of code (which chops off some dodgy, unwanted bits) - or at least can someone help me to get it to compile into iwram? I think it's the length of the instructions or something, but I've tried splitting it  up into seperate lines, and although I can get the code to compile, I can't get it to do the same thign as the original line.
<br/>
<br/>
Thanks in advance.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44360 - strager - Tue May 31, 2005 11:50 pm</h4>
    <div class="postbody"><span class="postbody">Use a complemented AND:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
filtered = origional &amp; ~filter;
<br/>
<br/>
Example:
<br/>
origional = 01010110
<br/>
filter    = 00010011
<br/>
filtered  = origional &amp; ~filter;
<br/>
filtered  = 01010110  &amp; ~00010011;
<br/>
filtered  = 01010110  &amp;  11101100;
<br/>
  01010110
<br/>
&amp; 11101100
<br/>
----------
<br/>
  01010000
<br/>
filtered = 01010000
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
filtered is the result.
<br/>
origional is the origional data to be filtered.
<br/>
filter is the bits you want removed.
<br/>
<br/>
Clear enough?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44367 - DekuTree64 - Wed Jun 01, 2005 12:42 am</h4>
    <div class="postbody"><span class="postbody">Hmm, is collmask_target a 64-bit int? Those are known to do squirrely things sometimes, since they're not natively supported.
<br/>
Also, for speed critical code, it's generally best to work in 32-bit ints and 'emulate' 64-bit yourself, so you know exactly what's being done. 
<br/>
<br/>
As for the actual problem, it looks like you're wanting to clear all the bits above shiftamount? That may be the fastest way there, but you could also do it by AND masking, like 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">collmask_target_temp = collmask_target &amp; ~(((u64)1 &lt;&lt; shiftamount) - (u64)1);</td> </tr></table><span class="postbody">
<br/>
Let's see what could be done in assembly, for 64 bits...
<br/>
First method, doing it by shifting:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">rTarget_lo = collmask_target, bottom 32 bits
<br/>
rTarget_hi = collmask_target, top 32 bits
<br/>
rShift = shiftamount
<br/>
<br/>
rsb   rShift, rShift, #64   // rShift = 64 - rShift
<br/>
mov   rTarget_lo, rTarget_lo, lsl rShift
<br/>
mov   rTarget_lo, rTarget_lo, lsr rShift
<br/>
sub   rShift, rShift, #32
<br/>
mov   rTarget_hi, rTarget_hi, lsl rShift
<br/>
mov   rTarget_hi, rTarget_hi, lsr rShift</td> </tr></table><span class="postbody">
<br/>
10 cycles (2 for each shift by register, 1 for each sub).
<br/>
Using masking:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Starting regs same as before.
<br/>
<br/>
mvn   r3, #0
<br/>
bic   rTarget_lo, rTarget_lo, r3, lsl rShift   // lo &amp;= ~(0xffffffff &lt;&lt; shiftamount)
<br/>
rsb   rShift, rShift, #64
<br/>
and   rTarget_hi, rTarget_hi, r3, lsr rShift   // hi &amp;= (0xffffffff &gt;&gt; (64 - shiftamount))
<br/>
</td> </tr></table><span class="postbody">
<br/>
6 cycles, but uses a temporary register. Worth the trade, I think, but I doubt a compiler would be smart enough to generate code like that.
<br/>
Heck, I'm not even sure it would work myself :)
<br/>
<br/>
I'm guessing this is for pixel-perfect collision detection? I'd suggest doing the inner loop in assembly to begin with. ARM assembly is so nice that sometimes it's easier to write directly than to try to convince a compiler to generate fast code for you.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44374 - Ultima2876 - Wed Jun 01, 2005 1:06 am</h4>
    <div class="postbody"><span class="postbody">It turns out I'm stupid - long longs are signed by default, which was the cause of my shifts producing the horrible F's. I made them unsigned, and now I don't need to do any fixing up at all, I merely shift and use the value straight away.
<br/>
<br/>
Yep, it is for pixel perfect collisions using bitmasks. Putting that code in iwram was a final optimisation - I now have it running at ~86 FPS (and this is worst case - I've forced it to create all the objects I'll ever really need). However, if I find that I need to optimise further, I know to take a look at those long longs.
<br/>
<br/>
Thanks for the info DekuTree, and I appreciate that you looked into it so much. Sorry for wasting your time like that x.x
<br/>
<br/>
Anyhow, I'm fairly sure it'll come in useful later on, there things usually do for me. Same to you strager, that AND stuff looks like it wouldn't be out of place in a dozen other bits of my game's code.
<br/>
<br/>
Thanks again, both of you.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
