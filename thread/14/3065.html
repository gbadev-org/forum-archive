<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>why use unsigned short - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Beginners > why use unsigned short</h2>
<div id="posts">
<div class="post">
    <h4>#17914 - xadeu - Wed Mar 17, 2004 5:54 am</h4>
    <div class="postbody"><span class="postbody">As a GBA Developer why does one go through the trouble of declaring vars to be 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">unsigned short x;</td> </tr></table><span class="postbody">
<br/>
and so on. why not 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int x;</td> </tr></table><span class="postbody">
<br/>
Is it because the memory is in high 
<br/>
demand and one should not 
<br/>
waste it by wastefully declaring 
<br/>
a var as an int?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17915 - poslundc - Wed Mar 17, 2004 6:35 am</h4>
    <div class="postbody"><span class="postbody">There are a number of reasons to declare a variable using a specific data type.
<br/>
<br/>
1. <span style="font-weight: bold">To conserve memory.</span> Although this <span style="font-style: italic">doesn't apply</span> to local/global variables unless they are in an array or part of a struct. (The compiler will always pad your variable length to 4 bytes.)
<br/>
<br/>
2. <span style="font-weight: bold">To expose relevant characteristics of the data.</span> I generally use the nomenclature that sajimori suggests in <a class="postlink" href="http://forum.gbadev.org/viewtopic.php" target="_blank">this thread</a> where I will use ints for anything general-purpose (counters, most calculations, etc). but will use typedefs that reveal information about the kind of data stored (eg. u16, s32) whenever it matters to the program or the algorithm.
<br/>
<br/>
3. <span style="font-weight: bold">To conform to data.</span> Within structs it is important to specify the length of each field so that it matches the data format being used.
<br/>
<br/>
4. <span style="font-weight: bold">Mathematical reasons.</span> It can make a big difference whether a variable is signed or not. Aside from the difference in range it provides, it also determines whether a right bitshift is logical or arithmetic. 8-bit and 16-bit variables will overflow at different values than their 32-bit counterparts.
<br/>
<br/>
There may be others, too.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17942 - johnny_north - Wed Mar 17, 2004 9:41 pm</h4>
    <div class="postbody"><span class="postbody">This falls under Conserving Memory:
<br/>
<br/>
You might choose a 16 bit variable to use as a bit field, say where each bit of the variable is essentially 1(true) or 0(false) and you need between 8 and 17 boolean values (not inclusive). I think a bool type uses 32 bits. Although it physically doesn't matter if you declare this a s16 or a u16, declaring it as a signed value doesn't seem to make much sense.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17963 - Miked0801 - Wed Mar 17, 2004 11:10 pm</h4>
    <div class="postbody"><span class="postbody">Personally, I only use signed values if it needs to be signed.  It makes much easier on my soft optimizer if I don't have to worry about sign bits when doing bit-wise arithmetic on stuff.  The compiler seems to handle it better as well</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17967 - sajiimori - Wed Mar 17, 2004 11:14 pm</h4>
    <div class="postbody"><span class="postbody">Sheesh -- what ever happened to the 80/20 rule??  =D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17971 - poslundc - Thu Mar 18, 2004 12:34 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Personally, I only use signed values if it needs to be signed.  It makes much easier on my soft optimizer if I don't have to worry about sign bits when doing bit-wise arithmetic on stuff.  The compiler seems to handle it better as well</td> </tr></table><span class="postbody">
<br/>
<br/>
What does it affect, other than right-shifts, the mode of the multiplication instruction and the mode of the load instruction?
<br/>
<br/>
The only advantage I can see is that the u8 data type can use a different addressing mode than the s8 data type.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17976 - Miked0801 - Thu Mar 18, 2004 12:53 am</h4>
    <div class="postbody"><span class="postbody">Just when looking at asm output when compiling, it seems that signed stuff tends to make (very slightly) larger code.  Again, I could be wrong.  Still, I prefer unsigned just for myself - and whenever I use a countdown to 0 for loop, I invariably get burned :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17977 - ampz - Thu Mar 18, 2004 12:53 am</h4>
    <div class="postbody"><span class="postbody">Smaller variables improve performance if the variable is located in a memory with a 16 or 8 bit bus.
<br/>
There are alot of good reasons to use variables of proper size, especially on systems with limited memory and computing resources.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17981 - poslundc - Thu Mar 18, 2004 1:55 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">Smaller variables improve performance if the variable is located in a memory with a 16 or 8 bit bus.</td> </tr></table><span class="postbody">
<br/>
<br/>
Good one; I missed that on my list. The corollary, however, is that it works both ways. On the GBA, with the exception of the savegame areas, it's always more efficient (though not always more practical) to load 16 bits at a time instead of 8 bits. In IWRAM and the I/O registers you get more efficiency loading 32 bits at a time than 16 or 8.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">There are alot of good reasons to use variables of proper size, especially on systems with limited memory and computing resources.</td> </tr></table><span class="postbody">
<br/>
<br/>
This is true, but it's also important to keep in mind that very often the compiler will pad your variable length anyway. As far as I'm aware, structs and arrays are the only places where specifying the size of your primitive data type will affect how it is stored.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17982 - poslundc - Thu Mar 18, 2004 2:09 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Still, I prefer unsigned just for myself - and whenever I use a countdown to 0 for loop, I invariably get burned :)</td> </tr></table><span class="postbody">
<br/>
<br/>
That's unusual... counting down to zero with signed variables should work exactly the same way as with unsigned variables.
<br/>
<br/>
In fact, the added advantage to using signed variables is that if you aren't using a monotonically decreasing function for loop termination you can express your termination condition as an inequality (eg. "while (x-- &gt; 0)" instead of just "while (x--)").
<br/>
<br/>
In general, though, I don't worry about whether a variable is signed or unsigned unless it actually <span style="font-style: italic">matters</span> to the algorithm. In C, this usually means that variables are signed by default (except I think chars are by default unsigned). I find this makes things less confusing for other programmers reading my code: I don't use either an explicitly signed or an unsigned type unless there's a reason within the program.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17984 - Miked0801 - Thu Mar 18, 2004 2:13 am</h4>
    <div class="postbody"><span class="postbody">lol.  Then you'll get burned too:
<br/>
<br/>
(edit - made my example a bit better)
<br/>
<br/>
A fast clear of 4? words of memory :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u32 i;
<br/>
u32 foo[4];
<br/>
<br/>
for(i=3; i&gt;=0; i--)
<br/>
{
<br/>
    foo[i] = 0;
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17985 - tepples - Thu Mar 18, 2004 2:21 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Still, I prefer unsigned just for myself - and whenever I use a countdown to 0 for loop, I invariably get burned :)</td> </tr></table><span class="postbody">
<br/>
That's unusual... counting down to zero with signed variables should work exactly the same way as with unsigned variables.</span></td> </tr></table><span class="postbody">
<br/>
Unless you anticipate often having 32768 to 65535 of something.
<br/>
<br/>
Miked0801: For one thing, your code will probably trigger a GCC warning that the comparison is always true. For another, explicitly unrolling the loop will probably make the code more predictably faster:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">foo[0] = 0;
<br/>
foo[1] = 0;
<br/>
foo[2] = 0;
<br/>
foo[3] = 0;</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17986 - Miked0801 - Thu Mar 18, 2004 2:25 am</h4>
    <div class="postbody"><span class="postbody">I wish my version of GCC did, it does not though (3.2.2 nor 2.9.5) :( 
<br/>
<br/>
And yes, of course I know there are faster ways to clear words.  This was just a quick, contrived example to show a difference between signed and unsigned for loops that has burned me a few times in the past.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17987 - poslundc - Thu Mar 18, 2004 2:27 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">That's unusual... counting down to zero with signed variables should work exactly the same way as with unsigned variables.</td> </tr></table><span class="postbody">
<br/>
Unless you anticipate often having 32768 to 65535 of something.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
That's why I use plain and simple ints for general counters. If I need to worry about values between 2-4 billion, then presumably I will have anticipated the need for making the variable unsigned somewhere along the way. :)
<br/>
<br/>
Mike: I thought you were making the case <span style="font-style: italic">against</span> using signed variables as decrementing counters? If you're getting burned by situations like that, take my suggestion and stop declaring your variables as unsigned when you don't have to. ;)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17988 - Miked0801 - Thu Mar 18, 2004 2:30 am</h4>
    <div class="postbody"><span class="postbody">Yep.  Signed are better unless you have reason to not use them.  I just like unsigned because I do :P
<br/>
<br/>
I may have to re-evaluate though.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17991 - ampz - Thu Mar 18, 2004 3:42 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">Smaller variables improve performance if the variable is located in a memory with a 16 or 8 bit bus.</td> </tr></table><span class="postbody">
<br/>
Good one; I missed that on my list. The corollary, however, is that it works both ways. On the GBA, with the exception of the savegame areas, it's always more efficient (though not always more practical) to load 16 bits at a time instead of 8 bits. In IWRAM and the I/O registers you get more efficiency loading 32 bits at a time than 16 or 8.
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
Using a 32bit counter is not more efficient than using a 16bit counter.
<br/>
Only time it is more efficient to use a 32bit variable instead of a 16bit variable is when you actually want the extra 16bits.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">There are alot of good reasons to use variables of proper size, especially on systems with limited memory and computing resources.</td> </tr></table><span class="postbody">
<br/>
This is true, but it's also important to keep in mind that very often the compiler will pad your variable length anyway. As far as I'm aware, structs and arrays are the only places where specifying the size of your primitive data type will affect how it is stored.</span></td> </tr></table><span class="postbody">
<br/>
That is certainly compiler specific. I have not investigated the matter in detail, but if there is no way of making GCC store variables efficiently, then it is not much of a optimizing compiler.
<br/>
Why write memory consuming code just because your compiler sucks?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17997 - poslundc - Thu Mar 18, 2004 5:07 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">That is certainly compiler specific. I have not investigated the matter in detail, but if there is no way of making GCC store variables efficiently, then it is not much of a optimizing compiler.
<br/>
Why write memory consuming code just because your compiler sucks?</td> </tr></table><span class="postbody">
<br/>
<br/>
Well, the compiler needs to keep everything word-aligned to be compatible with the hardware. Theoretically it could see a combination of 8-bit or 16-bit variables and pack them together to maintain 32-bit alignment, but this isn't something that GCC does. I don't know about other compilers.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#17998 - tepples - Thu Mar 18, 2004 5:29 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">the compiler needs to keep everything word-aligned to be compatible with the hardware. Theoretically it could see a combination of 8-bit or 16-bit variables and pack them together to maintain 32-bit alignment, but this isn't something that GCC does.</td> </tr></table><span class="postbody">
<br/>
GCC does pack variables in structs if they come listed in a naturally aligned order.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18006 - poslundc - Thu Mar 18, 2004 2:12 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">GCC does pack variables in structs if they come listed in a naturally aligned order.</td> </tr></table><span class="postbody">
<br/>
<br/>
Are you saying that it will pack my global and local variables as if they were in structs, without just padding each individual variable to 4 bytes?
<br/>
<br/>
If so, is there an option to turn this behaviour on/off in GCC? Because this is not the behaviour I have observed when using it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18011 - ampz - Thu Mar 18, 2004 5:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">That is certainly compiler specific. I have not investigated the matter in detail, but if there is no way of making GCC store variables efficiently, then it is not much of a optimizing compiler.
<br/>
Why write memory consuming code just because your compiler sucks?</td> </tr></table><span class="postbody">
<br/>
<br/>
Well, the compiler needs to keep everything word-aligned to be compatible with the hardware. Theoretically it could see a combination of 8-bit or 16-bit variables and pack them together to maintain 32-bit alignment, but this isn't something that GCC does. I don't know about other compilers.
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
Other compilers certainly pack variables properly.
<br/>
I compiled this piece of code on our "IAR Systems" ARM compiler.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">volatile char pelle;
<br/>
volatile int calle;
<br/>
volatile char hugo;
<br/>
volatile short per;
<br/>
<br/>
int main(void){
<br/>
  calle=0;
<br/>
  pelle=1;
<br/>
  hugo=2;
<br/>
  per=3;
<br/>
}</td> </tr></table><span class="postbody">Four gloabls of different size, they are not even declared in any useful packing order.
<br/>
The compiler nicely allocated theese memory locations for the variables:
<br/>
int calle: 0x100000
<br/>
short per: 0x100004
<br/>
char pelle: 0x100006
<br/>
char hugo: 0x100007
<br/>
This was with optimizations completely turned off.
<br/>
<br/>
The only thing a compiler has to do is sort the variables by size. Put the 32bit variables first, then the 16bit variables, and the 8bit variables at the end. That's it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18016 - poslundc - Thu Mar 18, 2004 6:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ampz wrote:</b></span></td> </tr> <tr> <td class="quote">The only thing a compiler has to do is sort the variables by size. Put the 32bit variables first, then the 16bit variables, and the 8bit variables at the end. That's it.</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not arguing with the sensibility of it. If anyone knows how to make GCC do this (without using structs), I'd love to hear.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#18021 - Miked0801 - Thu Mar 18, 2004 7:50 pm</h4>
    <div class="postbody"><span class="postbody">There are ways to get this to happen with the align command in the link script.  I'm no expert there, but playing with where align is called and how (and reading the docs at the gcc site), I managed to get things to align better to save RAM.  Check it out.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19753 - TaleriaKNT - Sat Apr 24, 2004 8:44 pm</h4>
    <div class="postbody"><span class="postbody">You could also make the loop work <span style="font-style: italic">with</span> the overflow.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u32 i; 
<br/>
u32 foo[4]; 
<br/>
<br/>
for(i=3; i&lt;4; i--) 
<br/>
{ 
<br/>
    foo[i] = 0; 
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19778 - sgeos - Sun Apr 25, 2004 3:31 pm</h4>
    <div class="postbody"><span class="postbody">"why use unsigned short"
<br/>
<br/>
Why not?  Somebody has to.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Yep.  Signed are better unless you have reason to not use them.  I just like unsigned because I do :P
<br/>
<br/>
I may have to re-evaluate though.</td> </tr></table><span class="postbody">
<br/>
Consider and reject!  Consider and reject!
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19791 - sajiimori - Sun Apr 25, 2004 6:33 pm</h4>
    <div class="postbody"><span class="postbody">TaleriaKNT, you did it wrong.  Here is the correct code for clearing everything except an array:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int array[12];
<br/>
for(u32 i = 0; i != 11; --i)
<br/>
  array[i] = 0;
<br/>
</td> </tr></table><span class="postbody">
<br/>
Edit: well I guess it clears the first element, but fixing that would be a detrement to readability.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19798 - DekuTree64 - Sun Apr 25, 2004 7:59 pm</h4>
    <div class="postbody"><span class="postbody">No, I think he was clearing the array itself, using a backward loop with an unsigned counter. Normally you'd just say while i &gt;= 0 for the same effect if it was signed, but saying while i &lt; 4 makes it so when it overflows to 65535, it's greater than 4, and breaks. Same thing going on in the processor either way, just different ways of looking at it.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
