<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Noob : Bit masking/shifting - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > Noob : Bit masking/shifting</h2>
<div id="posts">
<div class="post">
    <h4>#11253 - goro - Tue Sep 30, 2003 8:53 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I'm trying to "wait for n frames" before updating my sprite animation.
<br/>
(my main character has 6 frames in his walk.)
<br/>
<br/>
I have implemented a global timing system that uses vblanks. it has a global "counter",  
<br/>
"frames" and "seconds".
<br/>
<br/>
I know the gba is slow at division and a workaround is bit-masking or shifting. something like:-
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">bg1.mapData[y * 32 + ((bg1.x_scroll&gt;&gt;3) &amp; 31)]
<br/>
         =  temp[y * 256 + (bg1.x_scroll&gt;&gt;3)];</td> </tr></table><span class="postbody">I know this code is for scrolling bg's but I think I'm trying to understand the &gt;&gt;3
<br/>
part.
<br/>
<br/>
Please help using simple comparisons to everyday objects such as bread 
<br/>
because I'm a newbie!!
<br/>
<br/>
Never mind - I just learned about it -
<br/>
<br/>
A shift-right effectively divides a number by 2 and a shift-left multiplies it by two.
<br/>
<br/>
ie </span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
x=7;            // 00000111     value of x is 7
<br/>
x=x&lt;&lt;1;      // 00001110     value of x is 14
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The bitwise number is shifted left and a 0 comes in from the right.
<br/>
<br/>
Now to understand how the &amp; part works...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11255 - yaustar - Tue Sep 30, 2003 11:26 am</h4>
    <div class="postbody"><span class="postbody">&amp; is bitwise AND
<br/>
| is bitwise OR
<br/>
<br/>
Don't know if I can explain this clearly, but I give it a shot
<br/>
<br/>
0010 &amp; 0111 = 0010
<br/>
0110 &amp; 0100 = 0100
<br/>
<br/>
&amp; isolates the bits that are the same
<br/>
<br/>
0101 | 0111 = 0010
<br/>
0100 | 0100 = 0000
<br/>
<br/>
| isolates the bits that are not the same
<br/>
<br/>
Someone correct me if I am wrong<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11257 - NoMis - Tue Sep 30, 2003 1:59 pm</h4>
    <div class="postbody"><span class="postbody">&amp; isolates the bits that are the same 
<br/>
<br/>
0101 | 0111 = 0010 
<br/>
0100 | 0100 = 0000
<br/>
<br/>
you made a littel mistake yaustar.
<br/>
<br/>
What you showed up there is the exlusive or (^).
<br/>
<br/>
<br/>
The bitwise or operator would produce a result as the following
<br/>
<br/>
0101 | 0111 = 0111
<br/>
0100 | 0100 = 0100
<br/>
<br/>
So you must have a bit at least at one of the numbers set to have the coresponding bits in the result.
<br/>
<br/>
Here is a table for this
<br/>
<br/>
Bitwise OR |
<br/>
<br/>
--- 0 | 1
<br/>
-------------
<br/>
0 | 0   1
<br/>
1 | 1   1
<br/>
<br/>
Bitwise AND &amp;
<br/>
<br/>
--- 0 | 1
<br/>
-------------
<br/>
0 | 0   0
<br/>
1 | 0   1
<br/>
<br/>
Bitwise XOR ^
<br/>
<br/>
--- 0 | 1
<br/>
-------------
<br/>
0 | 0   1
<br/>
1 | 1   0
<br/>
<br/>
<br/>
The bitwise shifting operatior simply shifting the bits to the left or to the right as far as the number specified behind the operator
<br/>
<br/>
011001000 &gt;&gt; 2 = 000110010
<br/>
<br/>
When shifting 1 bit to the right it's a division by 2
<br/>
When shifting 1 bit to the left it's a multiplication by 2
<br/>
<br/>
This calculation are 3 times faster than normal calculations (as i remember)
<br/>
<br/>
<br/>
<br/>
NoMis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11259 - yaustar - Tue Sep 30, 2003 2:44 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for clearing that up, always had a problem with sets in Maths :p<br/>_________________<br/>[<a class="postlink" href="http://parabellumgames.no-ip.org" target="_blank">Blog</a>] [<a class="postlink" href="http://yaustar.no-ip.org" target="_blank">Portfolio</a>]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11261 - poslundc - Tue Sep 30, 2003 2:47 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>goro wrote:</b></span></td> </tr> <tr> <td class="quote">Now to understand how the &amp; part works...</td> </tr></table><span class="postbody">
<br/>
<br/>
In the bit of code you supplied, &amp; 31 is effectively the same as saying % 32, ie. modulus 32.
<br/>
<br/>
What this means is that if your background scroll value gets bigger than 32, it will be automatically brought back down to zero.
<br/>
<br/>
In other words:
<br/>
<br/>
0 % 32 == 0
<br/>
1 % 32 == 1
<br/>
...
<br/>
31 % 32 == 31
<br/>
32 % 32 == 0
<br/>
33 % 32 == 1
<br/>
etc.
<br/>
<br/>
Modulus is extremely useful in general C programming; however, it is dirt slow on the GBA (because it has no hardware divide). The &amp; (modvalue-1) trick is good for getting the same result when you are taking the modulus of a power of two (such as 32 == 2 ^ 5).
<br/>
<br/>
Others have already explained what the &amp; operator does; I'll throw in a quick explanation as well in case you haven't had enough:
<br/>
<br/>
&amp; (aka bitwise AND) lets you <span style="font-style: italic">mask</span> the bits of a number, so that only the bits you want will show through into the result.
<br/>
<br/>
Every single bit of the number in question is compared with every corresponding bit of the mask, and then the bit that results is determined by the following table:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Input Bit  |  Mask Bit  |  Output Bit
<br/>
-----------+------------+------------
<br/>
     0     |     0      |      0
<br/>
     0     |     1      |      0
<br/>
     1     |     0      |      0
<br/>
     1     |     1      |      1
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
In other words, the resultant bit will only be a 1 if both the input bit and the bit in your mask are both 1's.
<br/>
<br/>
In the case of your example, 31d = 0000 0000 0001 1111b.
<br/>
<br/>
If you were to apply this mask to any other number, all of the bits except for the bottom five would be changed to zero. As a result, any number greater than 31 would disappear, except for the remainder when divided by 32, which is what you want from modulus.
<br/>
<br/>
Hope this helps,
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
