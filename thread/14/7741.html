<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Overflow in fixed point calculation - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Beginners > Overflow in fixed point calculation</h2>
<div id="posts">
<div class="post">
    <h4>#63232 - Ultima2876 - Sat Dec 10, 2005 10:02 am</h4>
    <div class="postbody"><span class="postbody">Hey all.
<br/>
<br/>
When I do a fixed point calculation, such as:
<br/>
<br/>
score / 100000, = score * 0.00001, ~= (score * 168) &gt;&gt; 24.
<br/>
<br/>
That's fine, but what if score is a value that goes up to 999999? That calculation would need way more than 32 bits... would the GBA have to go into some slow software 64-bit mode, or would it simply lop off the upper bits (bad)? Or even some other magic solution that happens to solve my problem? I can't use 16 bit fixed point because, apart from having the same problem (to a lesser extent), it's not accurate enough.
<br/>
<br/>
This is more out of curiousity as to how the internals work more than anything, but info and/or ideas are appreciated nonetheless.
<br/>
<br/>
Thanks =P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63234 - keldon - Sat Dec 10, 2005 10:09 am</h4>
    <div class="postbody"><span class="postbody">Arm has 64 bit long multiplication
<br/>
<a href="http://www.work.de/nocash/gbatek.htm#arm8multiplylongandmultiplyaccumulatelongmullmlal" target="_blank">http://www.work.de/nocash/gbatek.htm#arm8multiplylongandmultiplyaccumulatelongmullmlal</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63235 - Ultima2876 - Sat Dec 10, 2005 10:27 am</h4>
    <div class="postbody"><span class="postbody">o_O
<br/>
<br/>
Trying it, it seems like even 24 bits isn't accurate enough. Wierd. As for the 64 bit multiplication - cool, so I could try 32 bits as well... I'll look into that.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#63236 - DekuTree64 - Sat Dec 10, 2005 10:45 am</h4>
    <div class="postbody"><span class="postbody">An easy way to use 64-bit mul:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define fixedMul(a, b) ((s32)(((s64)(a) * (s64)(b)) &gt;&gt; FRAC_BITS))</td> </tr></table><span class="postbody">
<br/>
The compiler should have enough sense to use smull instead of a series of 32-bit muls and additions. It will only be fast in ARM mode though, since THUMB has no umull/smull. I'm not sure if it would be faster to let the compiler emulate it with 32-bit multiplies, or to make a function compiled as ARM and call it.
<br/>
Either way, if it's a tight enough loop to really matter, it should be ARM in IWRAM anyway.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
