<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>coordinate of two segments crossing. - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Beginners > coordinate of two segments crossing.</h2>
<div id="posts">
<div class="post">
    <h4>#67491 - deltree - Wed Jan 18, 2006 4:20 pm</h4>
    <div class="postbody"><span class="postbody">I need a function that take 4 coordinates (two segments) and return 2 coordinate and wether the segment cross or not....
<br/>
I  can't find a good code for this. do you have a good and speed function for that ?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#67494 - Mucca - Wed Jan 18, 2006 5:02 pm</h4>
    <div class="postbody"><span class="postbody">From Graphics Gems 2:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/* lines_intersect:  AUTHOR: Mukesh Prasad
<br/>
 *
<br/>
 *   This function computes whether two line segments,
<br/>
 *   respectively joining the input points (x1,y1) -- (x2,y2)
<br/>
 *   and the input points (x3,y3) -- (x4,y4) intersect.
<br/>
 *   If the lines intersect, the output variables x, y are
<br/>
 *   set to coordinates of the point of intersection.
<br/>
 *
<br/>
 *   All values are in integers.  The returned value is rounded
<br/>
 *   to the nearest integer point.
<br/>
 *
<br/>
 *   If non-integral grid points are relevant, the function
<br/>
 *   can easily be transformed by substituting floating point
<br/>
 *   calculations instead of integer calculations.
<br/>
 *
<br/>
 *   Entry
<br/>
 *        x1, y1,  x2, y2   Coordinates of endpoints of one segment.
<br/>
 *        x3, y3,  x4, y4   Coordinates of endpoints of other segment.
<br/>
 *
<br/>
 *   Exit
<br/>
 *        x, y              Coordinates of intersection point.
<br/>
 *
<br/>
 *   The value returned by the function is one of:
<br/>
 *
<br/>
 *        DONT_INTERSECT    0
<br/>
 *        DO_INTERSECT      1
<br/>
 *        COLLINEAR         2
<br/>
 *
<br/>
 * Error conditions:
<br/>
 *
<br/>
 *     Depending upon the possible ranges, and particularly on 16-bit
<br/>
 *     computers, care should be taken to protect from overflow.
<br/>
 *
<br/>
 *     In the following code, 'long' values have been used for this
<br/>
 *     purpose, instead of 'int'.
<br/>
 *
<br/>
 */
<br/>
<br/>
#define   DONT_INTERSECT    0
<br/>
#define   DO_INTERSECT      1
<br/>
#define COLLINEAR         2
<br/>
<br/>
/**************************************************************
<br/>
 *                                                            *
<br/>
 *    NOTE:  The following macro to determine if two numbers  *
<br/>
 *    have the same sign, is for 2's complement number        *
<br/>
 *    representation.  It will need to be modified for other  *
<br/>
 *    number systems.                                         *
<br/>
 *                                                            *
<br/>
 **************************************************************/
<br/>
<br/>
#define SAME_SIGNS( a, b )   \
<br/>
      (((long) ((unsigned long) a ^ (unsigned long) b)) &gt;= 0 )
<br/>
<br/>
int lines_intersect( x1, y1,   /* First line segment */
<br/>
           x2, y2,
<br/>
<br/>
           x3, y3,   /* Second line segment */
<br/>
           x4, y4,
<br/>
<br/>
           x,
<br/>
           y         /* Output value:
<br/>
                      * point of intersection */
<br/>
               )
<br/>
long
<br/>
    x1, y1, x2, y2, x3, y3, x4, y4,
<br/>
    *x, *y;
<br/>
{
<br/>
    long a1, a2, b1, b2, c1, c2; /* Coefficients of line eqns. */
<br/>
    long r1, r2, r3, r4;         /* 'Sign' values */
<br/>
    long denom, offset, num;     /* Intermediate values */
<br/>
<br/>
    /* Compute a1, b1, c1, where line joining points 1 and 2
<br/>
     * is "a1 x  +  b1 y  +  c1  =  0".
<br/>
     */
<br/>
<br/>
    a1 = y2 - y1;
<br/>
    b1 = x1 - x2;
<br/>
    c1 = x2 * y1 - x1 * y2;
<br/>
<br/>
    /* Compute r3 and r4.
<br/>
     */
<br/>
<br/>
<br/>
    r3 = a1 * x3 + b1 * y3 + c1;
<br/>
    r4 = a1 * x4 + b1 * y4 + c1;
<br/>
<br/>
    /* Check signs of r3 and r4.  If both point 3 and point 4 lie on
<br/>
     * same side of line 1, the line segments do not intersect.
<br/>
     */
<br/>
<br/>
    if ( r3 != 0 &amp;&amp;
<br/>
         r4 != 0 &amp;&amp;
<br/>
         SAME_SIGNS( r3, r4 ))
<br/>
        return ( DONT_INTERSECT );
<br/>
<br/>
    /* Compute a2, b2, c2 */
<br/>
<br/>
    a2 = y4 - y3;
<br/>
    b2 = x3 - x4;
<br/>
    c2 = x4 * y3 - x3 * y4;
<br/>
<br/>
    /* Compute r1 and r2 */
<br/>
<br/>
    r1 = a2 * x1 + b2 * y1 + c2;
<br/>
    r2 = a2 * x2 + b2 * y2 + c2;
<br/>
<br/>
    /* Check signs of r1 and r2.  If both point 1 and point 2 lie
<br/>
     * on same side of second line segment, the line segments do
<br/>
     * not intersect.
<br/>
     */
<br/>
<br/>
    if ( r1 != 0 &amp;&amp;
<br/>
         r2 != 0 &amp;&amp;
<br/>
         SAME_SIGNS( r1, r2 ))
<br/>
        return ( DONT_INTERSECT );
<br/>
<br/>
    /* Line segments intersect: compute intersection point. 
<br/>
     */
<br/>
<br/>
    denom = a1 * b2 - a2 * b1;
<br/>
    if ( denom == 0 )
<br/>
        return ( COLLINEAR );
<br/>
    offset = denom &lt; 0 ? - denom / 2 : denom / 2;
<br/>
<br/>
    /* The denom/2 is to get rounding instead of truncating.  It
<br/>
     * is added or subtracted to the numerator, depending upon the
<br/>
     * sign of the numerator.
<br/>
     */
<br/>
<br/>
    num = b1 * c2 - b2 * c1;
<br/>
    *x = ( num &lt; 0 ? num - offset : num + offset ) / denom;
<br/>
<br/>
    num = a2 * c1 - a1 * c2;
<br/>
    *y = ( num &lt; 0 ? num - offset : num + offset ) / denom;
<br/>
<br/>
    return ( DO_INTERSECT );
<br/>
    } /* lines_intersect */
<br/>
<br/>
/* A main program to test the function.
<br/>
 */
<br/>
<br/>
main()
<br/>
{
<br/>
    long x1, x2, x3, x4, y1, y2, y3, y4;
<br/>
    long x, y;
<br/>
<br/>
    for (;;) {
<br/>
        printf( "X1, Y1: " );
<br/>
   scanf( "%ld %ld", &amp;x1, &amp;y1 );
<br/>
        printf( "X2, Y2: " );
<br/>
   scanf( "%ld %ld", &amp;x2, &amp;y2 );
<br/>
        printf( "X3, Y3: " );
<br/>
   scanf( "%ld %ld", &amp;x3, &amp;y3 );
<br/>
        printf( "X4, Y4: " );
<br/>
   scanf( "%ld %ld", &amp;x4, &amp;y4 );
<br/>
<br/>
        switch ( lines_intersect( x1, y1, x2, y2, x3, y3, x4, y4, &amp;x, &amp;y )) {
<br/>
            case DONT_INTERSECT:
<br/>
          printf( "Lines don't intersect\n" );
<br/>
          break;
<br/>
            case COLLINEAR:
<br/>
                         printf( "Lines are collinear\n" );
<br/>
                         break;
<br/>
            case DO_INTERSECT:
<br/>
          printf( "Lines intersect at %ld,%ld\n", x, y );
<br/>
                         break;
<br/>
            }
<br/>
        }
<br/>
    } /* main */
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Strength here is that no 'real' divides are required until it is known that segments intersect, and point is calculated. Its also pretty trivial to alter the last stage of the algorithm to output a point in fixed point or float, if you require more accuracy. If going for fixed point, be very careful with overflows.
<br/>
<br/>
There are other ways of doing this algorithm, the most important thing is what input you have. For segments described by their end points, this algorithm is pretty good, but if, for example, you already have a slope, or cartesian equation or something, another algorithm might be better.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#67592 - LOst? - Thu Jan 19, 2006 5:37 am</h4>
    <div class="postbody"><span class="postbody">Is that function above using vector math? Is any of those formulas dot or cross products?<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#67605 - Mucca - Thu Jan 19, 2006 11:25 am</h4>
    <div class="postbody"><span class="postbody">Not really. Its a way of solving simultaneous equations, to find the intersection point of a line. Actually I lie, the checks on r1,r2 and r3,r4 are essentially finding the cross product (known as perproduct in 2D) of each point of a segment relative to the other segment. If they are both the same sign, then they both lie on the same side of the other segment, and thus the segments do not intersect. Then the algorithm solves simultaneously to find the intersection point.
<br/>
<br/>
Look at <a class="postlink" href="http://www.harveycartel.org/metanet/tutorials/tutorialA.html" target="_blank">http://www.harveycartel.org/metanet/tutorials/tutorialA.html</a>  on seperating axis theorem for collision detection, for clues as to the theory behind basic vector math.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#67687 - crossraleigh - Thu Jan 19, 2006 10:11 pm</h4>
    <div class="postbody"><span class="postbody">If you just want to know if the segments intersect (and not <span style="font-style: italic">where</span> they intersect), Miked0801 <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?p=61001#61001" target="_blank">has explained</a> how to remove divides altogether. Just think of "current tic position" and "last tic position" as the points that define the second segment.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#67791 - Mucca - Fri Jan 20, 2006 11:17 am</h4>
    <div class="postbody"><span class="postbody">Well thats exactly what the first half of the algorithm does, like I said r1-r4 are perproducts representing what side of the other segment the endpoint of a segment lie. You can just remove code from where COLINEAR is returned, and return intersection instead.
<br/>
<br/>
If its for collision detection and response purposes, the intersection point can be used to reflect the ball. Alternatively, with the point, you could solve for time to get the time of collision.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#67863 - Miked0801 - Fri Jan 20, 2006 11:21 pm</h4>
    <div class="postbody"><span class="postbody">Sigh - all that work to figure out the math on my own and here's a nice gem book to do it for you :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#67884 - Ultima2876 - Sat Jan 21, 2006 2:11 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Sigh - all that work to figure out the math on my own and here's a nice gem book to do it for you :)</td> </tr></table><span class="postbody">
<br/>
<br/>
Hate when that stuff happens =/</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
