<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Help with tile mode and sample program - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > Help with tile mode and sample program</h2>
<div id="posts">
<div class="post">
    <h4>#31930 - ymalik - Thu Dec 16, 2004 1:33 am</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
I have questions about the following sample program.  The program is from Jonathan Harbour's book <span style="font-style: italic">Programming the Nintendo Game Boy Advance</span>.  He does not explain some of the stuff in the program.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//////////////////////////////////////////////////////////// 
<br/>
// Programming The Game Boy Advance
<br/>
// Chapter 6: Tile-Based Video Modes
<br/>
// TileMode0 Project
<br/>
// main.c source code file
<br/>
////////////////////////////////////////////////////////////
<br/>
<br/>
#define MULTIBOOT int __gba_multiboot;
<br/>
MULTIBOOT
<br/>
<br/>
//include the sample tileset/map
<br/>
#include "test.pal.c"
<br/>
#include "test.raw.c"
<br/>
#include "test.map.c"
<br/>
<br/>
//function prototype
<br/>
void DMAFastCopy(void*, void*, unsigned int, unsigned int);
<br/>
<br/>
//defines needed by DMAFastCopy
<br/>
#define REG_DMA3SAD *(volatile unsigned int*)0x40000D4
<br/>
#define REG_DMA3DAD *(volatile unsigned int*)0x40000D8
<br/>
#define REG_DMA3CNT *(volatile unsigned int*)0x40000DC
<br/>
#define DMA_ENABLE 0x80000000
<br/>
#define DMA_TIMING_IMMEDIATE 0x00000000
<br/>
#define DMA_16 0x00000000
<br/>
#define DMA_32 0x04000000
<br/>
#define DMA_32NOW (DMA_ENABLE | DMA_TIMING_IMMEDIATE | DMA_32)
<br/>
#define DMA_16NOW (DMA_ENABLE | DMA_TIMING_IMMEDIATE | DMA_16)
<br/>
<br/>
//scrolling registers for background 0
<br/>
#define REG_BG0HOFS *(volatile unsigned short*)0x4000010
<br/>
#define REG_BG0VOFS *(volatile unsigned short*)0x4000012
<br/>
<br/>
//background setup registers and data
<br/>
#define REG_BG0CNT *(volatile unsigned short*)0x4000008
<br/>
#define REG_BG1CNT *(volatile unsigned short*)0x400000A
<br/>
#define REG_BG2CNT *(volatile unsigned short*)0x400000C
<br/>
#define REG_BG3CNT *(volatile unsigned short*)0x400000E
<br/>
#define BG_COLOR256 0x80
<br/>
#define CHAR_SHIFT 2
<br/>
#define SCREEN_SHIFT 8
<br/>
#define WRAPAROUND 0x1
<br/>
<br/>
//background tile bitmap sizes
<br/>
#define TEXTBG_SIZE_256x256 0x0
<br/>
#define TEXTBG_SIZE_256x512 0x8000
<br/>
#define TEXTBG_SIZE_512x256 0x4000
<br/>
#define TEXTBG_SIZE_512x512 0xC000
<br/>
<br/>
//background memory offset macros
<br/>
#define CharBaseBlock(n) (((n)*0x4000)+0x6000000)
<br/>
#define ScreenBaseBlock(n) (((n)*0x800)+0x6000000)
<br/>
<br/>
//background mode identifiers
<br/>
#define BG0_ENABLE 0x100
<br/>
#define BG1_ENABLE 0x200
<br/>
#define BG2_ENABLE 0x400
<br/>
#define BG3_ENABLE 0x800
<br/>
<br/>
//video identifiers
<br/>
#define REG_DISPCNT *(unsigned int*)0x4000000
<br/>
#define BGPaletteMem ((unsigned short*)0x5000000)
<br/>
#define SetMode(mode) REG_DISPCNT = (mode)
<br/>
<br/>
//vertical refresh register
<br/>
#define REG_DISPSTAT *(volatile unsigned short*)0x4000004
<br/>
<br/>
//button identifiers
<br/>
#define BUTTON_RIGHT 16
<br/>
#define BUTTON_LEFT 32
<br/>
#define BUTTON_UP 64
<br/>
#define BUTTON_DOWN 128
<br/>
#define BUTTONS (*(volatile unsigned int*)0x04000130)
<br/>
<br/>
//wait for vertical refresh
<br/>
void WaitVBlank(void)
<br/>
{
<br/>
  while((REG_DISPSTAT &amp; 1));
<br/>
} 
<br/>
<br/>
////////////////////////////////////////////////////////////
<br/>
int main(void)
<br/>
{
<br/>
  int x = 0, y = 0;
<br/>
  int n;
<br/>
<br/>
  //create a pointer to background 0 tilemap buffer
<br/>
  unsigned short* bg0map =(unsigned short*)ScreenBaseBlock(31);
<br/>
  
<br/>
  //set up background 0
<br/>
  REG_BG0CNT = BG_COLOR256 | TEXTBG_SIZE_256x256 | (31 &lt;&lt; SCREEN_SHIFT) | WRAPAROUND;
<br/>
<br/>
  //set video mode 0 with background 0
<br/>
  SetMode(0 | BG0_ENABLE);
<br/>
<br/>
  //copy the palette into the background palette memory
<br/>
  DMAFastCopy((void*)test_Palette, (void*)BGPaletteMem, 256, DMA_16NOW);
<br/>
<br/>
  //copy the tile images into the tile memory
<br/>
  DMAFastCopy((void*)test_Tiles, (void*)CharBaseBlock(0), 57984/4, DMA_32NOW); 
<br/>
<br/>
  //copy the tile map into background 0
<br/>
  DMAFastCopy((void*)test_Map, (void*)bg0map, 512, DMA_32NOW);
<br/>
<br/>
  //main game loop
<br/>
  while(1)
<br/>
  { 
<br/>
    //wait for vertical refresh
<br/>
    WaitVBlank();
<br/>
<br/>
    //D-pad moves background
<br/>
    if(!(BUTTONS &amp; BUTTON_LEFT)) x--;
<br/>
<br/>
    if(!(BUTTONS &amp; BUTTON_RIGHT)) x++;
<br/>
<br/>
    if(!(BUTTONS &amp; BUTTON_UP)) y--;
<br/>
 
<br/>
    if(!(BUTTONS &amp; BUTTON_DOWN)) y++;
<br/>
<br/>
    //use hardware background scrolling
<br/>
    REG_BG0VOFS = y ;
<br/>
    REG_BG0HOFS = x ;
<br/>
<br/>
    //wait for vertical refresh
<br/>
    WaitVBlank();
<br/>
<br/>
    for(n = 0; n &lt; 4000; n++);
<br/>
  }
<br/>
<br/>
  return 0;
<br/>
}
<br/>
<br/>
////////////////////////////////////////////////////////////
<br/>
// Function: DMAFastCopy
<br/>
// Fast memory copy function built into hardware
<br/>
void DMAFastCopy(void* source, void* dest, unsigned int count, unsigned int mode)
<br/>
{
<br/>
  if (mode == DMA_16NOW || mode == DMA_32NOW)
<br/>
  {
<br/>
    REG_DMA3SAD = (unsigned int)source;
<br/>
    REG_DMA3DAD = (unsigned int)dest;
<br/>
    REG_DMA3CNT = count | mode;
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Now for my questions:
<br/>
1. What do the count and mode paramaters do in DMAFastCopy()?
<br/>
2. What are DMA_16 and DMA_32?
<br/>
3. In tilemode, the 256x256 bitmap image was broken up into 8x8 tiles, like a jigsaw puzzle, right?
<br/>
4. If the tile map (specified by test_Map) specifies where each tile (specified in test_Tiles) is stored in order to create the entire map, how come the program seems to scroll for "infinity?"
<br/>
<br/>
Thanks,
<br/>
Yasir</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31932 - ScottLininger - Thu Dec 16, 2004 1:48 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">1. What do the count and mode paramaters do in DMAFastCopy()?</td> </tr></table><span class="postbody">
<br/>
<br/>
I believe that count is how many "chunks" of data that DMA copies. Mode is how big the chunks are (32 bit or 16 bit).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">2. What are DMA_16 and DMA_32?</td> </tr></table><span class="postbody">
<br/>
<br/>
DMA_16 copies 16bit chunks are a time. DMA_32 copies 32. There are certain areas of memory that can only be copied with DMA_16 (such as VRAM, if I'm remembering right.) DMA_32 will obviously be faster in cases where you can use it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">3. In tilemode, the 256x256 bitmap image was broken up into 8x8 tiles, like a jigsaw puzzle, right?</td> </tr></table><span class="postbody">
<br/>
<br/>
Yup. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">4. If the tile map (specified by test_Map) specifies where each tile (specified in test_Tiles) is stored in order to create the entire map, how come the program seems to scroll for "infinity?"</td> </tr></table><span class="postbody">
<br/>
<br/>
Because tile mode backgrounds "wrap around". So if you're at scroll position (256,256), you'll see the same exact screen as you do at (0,0). 
<br/>
<br/>
What's more, the REG_BG0VOFS and REG_BG0HOFS registers, which contol scrolling, also "wrap around" as all unsigned integers do. So if you scroll to postion (64000++, 64000++) (or whatever the hell is the maximum value for that register), you're right back to (0,0).
<br/>
<br/>
Cheers,
<br/>
<br/>
Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31933 - ymalik - Thu Dec 16, 2004 2:30 am</h4>
    <div class="postbody"><span class="postbody">Thanks, Scott, for your fast response.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ScottLininger wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
I believe that count is how many "chunks" of data that DMA copies. Mode is how big the chunks are (32 bit or 16 bit).
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
mode is being passed using the define #define DMA_32NOW (DMA_ENABLE | DMA_TIMING_IMMEDIATE | DMA_32), so how can that be the size of the chunk?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31966 - Lupin - Thu Dec 16, 2004 8:20 am</h4>
    <div class="postbody"><span class="postbody">DMA_32 specifies the size of the chunk (32 bit)
<br/>
<br/>
DMA_ENABLE just enables your DMA transfer (obvious...)
<br/>
<br/>
DMA_TIMING_IMMEDIATE lets the GBA execute the DMA transfer immediately (also quite obvious)
<br/>
<br/>
There are also other constants that you can set for the mode parameter, allowing you to use DMA for nice effects or just for memory clearing<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32048 - ymalik - Fri Dec 17, 2004 3:24 pm</h4>
    <div class="postbody"><span class="postbody">I have a question about following code which implements tiles and rotation
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
////////////////////////////////////////////////////////////
<br/>
// Programming The Game Boy Advance
<br/>
// Chapter 6: Tile-Based Video Modes
<br/>
// RotateMode2 Project
<br/>
// main.c source code file
<br/>
////////////////////////////////////////////////////////////
<br/>
#define MULTIBOOT int __gba_multiboot;
<br/>
MULTIBOOT
<br/>
<br/>
#include "rotation.h"
<br/>
#include "tiles.pal.c"
<br/>
#include "tiles.raw.c"
<br/>
#include "tilemap.h"
<br/>
<br/>
//prototypes
<br/>
void DMAFastCopy(void*, void*, unsigned int, unsigned int);
<br/>
void RotateBackground(int, int, int, int);
<br/>
<br/>
//defines needed by DMAFastCopy
<br/>
#define REG_DMA3SAD *(volatile unsigned int*)0x40000D4
<br/>
#define REG_DMA3DAD *(volatile unsigned int*)0x40000D8
<br/>
#define REG_DMA3CNT *(volatile unsigned int*)0x40000DC
<br/>
#define DMA_ENABLE 0x80000000
<br/>
#define DMA_TIMING_IMMEDIATE 0x00000000
<br/>
#define DMA_16 0x00000000
<br/>
#define DMA_32 0x04000000
<br/>
#define DMA_32NOW (DMA_ENABLE | DMA_TIMING_IMMEDIATE | DMA_32)
<br/>
#define DMA_16NOW (DMA_ENABLE | DMA_TIMING_IMMEDIATE | DMA_16)
<br/>
<br/>
//background movement/rotation registers
<br/>
#define REG_BG2X *(volatile unsigned int*)0x4000028
<br/>
#define REG_BG2Y *(volatile unsigned int*)0x400002C
<br/>
#define REG_BG2PA *(volatile unsigned short *)0x4000020
<br/>
#define REG_BG2PB *(volatile unsigned short *)0x4000022
<br/>
#define REG_BG2PC *(volatile unsigned short *)0x4000024
<br/>
#define REG_BG2PD *(volatile unsigned short *)0x4000026
<br/>
<br/>
//background 2 stuff
<br/>
#define REG_BG2CNT *(volatile unsigned short *)0x400000C
<br/>
#define BG2_ENABLE 0x400
<br/>
#define BG_COLOR256 0x80
<br/>
<br/>
//background constants
<br/>
#define ROTBG_SIZE_128x128 0x0
<br/>
#define ROTBG_SIZE_256x256 0x4000
<br/>
#define ROTBG_SIZE_512x512 0x8000
<br/>
#define ROTBG_SIZE_1024x1024 0xC000
<br/>
#define CHAR_SHIFT 2
<br/>
#define SCREEN_SHIFT 8
<br/>
#define WRAPAROUND 0x1
<br/>
#define BG_MOSAIC_ENABLE 0x40
<br/>
<br/>
//video-related memory
<br/>
#define REG_DISPCNT *(volatile unsigned int*)0x4000000
<br/>
#define BGPaletteMem ((unsigned short *)0x5000000)
<br/>
#define REG_DISPSTAT *(volatile unsigned short *)0x4000004
<br/>
#define BUTTON_A 1
<br/>
#define BUTTON_B 2
<br/>
#define BUTTON_RIGHT 16
<br/>
#define BUTTON_LEFT 32
<br/>
#define BUTTON_UP 64
<br/>
#define BUTTON_DOWN 128
<br/>
#define BUTTON_R 256
<br/>
#define BUTTON_L 512
<br/>
#define BUTTONS (*(volatile unsigned int*)0x04000130)
<br/>
#define CharBaseBlock(n) (((n)*0x4000)+0x6000000)
<br/>
#define ScreenBaseBlock(n) (((n)*0x800)+0x6000000)
<br/>
#define SetMode(mode) REG_DISPCNT = (mode)
<br/>
<br/>
//some variables needed to rotate the background
<br/>
int x_scroll=0,y_scroll=0;
<br/>
int DX=0,DY=0;
<br/>
int PA,PB,PC,PD;
<br/>
int zoom = 2;
<br/>
int angle = 0;
<br/>
int center_y,center_x;
<br/>
<br/>
////////////////////////////////////////////////////////////
<br/>
// Function: main()
<br/>
// Entry point for the program
<br/>
////////////////////////////////////////////////////////////
<br/>
int main(void)
<br/>
{
<br/>
 int n;
<br/>
 int charbase = 0;
<br/>
 int screenbase = 31;
<br/>
 unsigned short * bg2map = (unsigned short *)ScreenBaseBlock(screenbase);
<br/>
<br/>
 //set up background 0
<br/>
 REG_BG2CNT = BG_COLOR256 | ROTBG_SIZE_128x128 |
<br/>
              (charbase &lt;&lt; CHAR_SHIFT) | (screenbase &lt;&lt; SCREEN_SHIFT);
<br/>
<br/>
 //set video mode 0 with background 0
<br/>
 SetMode(2 | BG2_ENABLE);
<br/>
<br/>
 //set the palette
<br/>
 DMAFastCopy((void*)tiles_Palette, (void*)BGPaletteMem, 256, DMA_16NOW);
<br/>
<br/>
 //set the tile images
<br/>
 DMAFastCopy((void*)tiles_Tiles, (void*)CharBaseBlock(0), 256/4, DMA_32NOW);
<br/>
<br/>
 //copy the tile map into background 0
<br/>
 DMAFastCopy((void*)tiles_Map, (void*)bg2map, 256/4, DMA_32NOW);
<br/>
<br/>
 while(1)
<br/>
 {
<br/>
  while(!(REG_DISPSTAT &amp; 1));
<br/>
<br/>
  //use the hardware to scroll around some
<br/>
  if(!(BUTTONS &amp; BUTTON_LEFT)) x_scroll--;
<br/>
  if(!(BUTTONS &amp; BUTTON_RIGHT)) x_scroll++;
<br/>
  if(!(BUTTONS &amp; BUTTON_UP)) y_scroll--;
<br/>
  if(!(BUTTONS &amp; BUTTON_DOWN)) y_scroll++;
<br/>
  if(!(BUTTONS &amp; BUTTON_A)) zoom--;
<br/>
  if(!(BUTTONS &amp; BUTTON_B)) zoom++;
<br/>
  if(!(BUTTONS &amp; BUTTON_L)) angle--;
<br/>
<br/>
  if(!(BUTTONS &amp; BUTTON_R)) angle++;
<br/>
<br/>
  if(angle &gt; 359)
<br/>
   angle = 0;
<br/>
<br/>
  if(angle &lt; 0)
<br/>
   angle = 359;
<br/>
<br/>
  //rotate the background
<br/>
  RotateBackground(angle,64,64,zoom);
<br/>
<br/>
  while((REG_DISPSTAT &amp; 1));
<br/>
<br/>
  //update the background
<br/>
  REG_BG2X = DX;
<br/>
  REG_BG2Y = DY;
<br/>
  REG_BG2PA = PA;
<br/>
  REG_BG2PB = PB;
<br/>
  REG_BG2PC = PC;
<br/>
  REG_BG2PD = PD;
<br/>
<br/>
  while((REG_DISPSTAT &amp; 1));
<br/>
  for(n = 0; n &lt; 100000; n++);
<br/>
 }
<br/>
}
<br/>
<br/>
////////////////////////////////////////////////////////////
<br/>
// Function: RotateBackground
<br/>
// Helper function to rotate a background
<br/>
////////////////////////////////////////////////////////////
<br/>
void RotateBackground(int ang, int cx, int cy, int zoom)
<br/>
{
<br/>
 center_y = (cy * zoom) &gt;&gt; 8;
<br/>
 center_x = (cx * zoom) &gt;&gt; 8;
<br/>
 DX = (x_scroll - center_y * SIN[ang] - center_x * COS[ang]);
<br/>
 DY = (y_scroll - center_y * COS[ang] + center_x * SIN[ang]);
<br/>
 PA = (COS[ang] * zoom) &gt;&gt; 8;
<br/>
 PB = (SIN[ang] * zoom) &gt;&gt; 8;
<br/>
 PC = (-SIN[ang] * zoom) &gt;&gt; 8;
<br/>
 PD = (COS[ang] * zoom) &gt;&gt; 8;
<br/>
}
<br/>
<br/>
////////////////////////////////////////////////////////////
<br/>
// Function: DMAFastCopy
<br/>
// Fast memory copy function built into hardware
<br/>
////////////////////////////////////////////////////////////
<br/>
void DMAFastCopy(void* source, void* dest, unsigned int count,
<br/>
                unsigned int mode)
<br/>
{
<br/>
 if (mode == DMA_16NOW || mode == DMA_32NOW)
<br/>
 {
<br/>
  REG_DMA3SAD = (unsigned int)source;
<br/>
  REG_DMA3DAD = (unsigned int)dest;
<br/>
  REG_DMA3CNT = count | mode;
<br/>
 }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
What do the registers REG_BG2X, REG_BG2Y, REG_BG2PA, REG_BG2PB, REG_BG2PC, and REG_BG2PD do?  I know that they control rotation, but what does each represent and do?
<br/>
<br/>
Thanks,
<br/>
Yasir</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32056 - Cearn - Fri Dec 17, 2004 4:32 pm</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://user.chem.tue.nl/jakvijn/tonc/affine.htm" target="_blank">This</a> is what they do. And the specifics of affine backgrounds are explained a little <a class="postlink" href="http://user.chem.tue.nl/jakvijn/tonc/affbg.htm" target="_blank">further down</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32546 - ymalik - Thu Dec 23, 2004 8:08 pm</h4>
    <div class="postbody"><span class="postbody">I have questions about main() and WaitVBlank():
<br/>
1. What is the difference between vertical retrance and vertical blank?
<br/>
2. Can anything be done during the vertical blank period?  And why wait for the vertical blank?
<br/>
3. Is there a reason to wait for the horizontal retrace?
<br/>
4. Are REG_BG0V0FS and REG_BG0H0FS referenced from the center of the screen?
<br/>
<br/>
Thanks,
<br/>
Yasir</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32557 - tepples - Thu Dec 23, 2004 9:29 pm</h4>
    <div class="postbody"><span class="postbody">These signals come from the terminology of CRT and TV signals: <ul><li>Vertical blanking ("vblank") means that time when no pixels are being drawn between one frame and the next. </li><li>Vertical retrace means that time when the electron beam is deflected toward the top of the display. This happens within vblank, and it takes time to complete because of how CRT electron guns work. </li><li>Vertical sync is the signal, embedded in the signal, that tells the CRT to start vertical retrace. </li></ul> On LCDs, it doesn't take any time to start redrawing pixels at the top (thus no vertical retrace is needed), but display systems still insert a vertical blank so that the game can update the video memory while the video circuitry isn't using it. Waiting for vertical blank is useful because it gives you a consistent timer (guaranteed to occur every 280896 cycles, or about 59.7 times a second) on which to base animation, and it lets you know when you can update that animation without causing display artifacts (or on older 8-bit and 16-bit systems, without bus contention).
<br/>
<br/>
Waiting for horizontal blanking is useful when doing raster effects such as palette modification, image warping, XZ plane rotation and scaling, distance fog, and the like.
<br/>
<br/>
The background scroll registers, called REG_BG0VOFS and REG_BG0HOFS in many header files, are offsets from the upper-left corner of the screen. Increasing the values of these registers will make the pixels of the map move up and to the left respectively, just as scrollbars in Mac OS and Windows work.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32564 - ymalik - Thu Dec 23, 2004 11:02 pm</h4>
    <div class="postbody"><span class="postbody">Thanks, tepples, for your indepth answer.
<br/>
How do you "update the video memory while the video circuitry isn't using it" during the vertical blank?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32586 - ymalik - Fri Dec 24, 2004 4:21 am</h4>
    <div class="postbody"><span class="postbody">Wait, would you use an interrupt?  But I still don't see what you could have in the code for a vblank interrupt.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32594 - tepples - Fri Dec 24, 2004 6:43 am</h4>
    <div class="postbody"><span class="postbody">Most single-player games seem to use a game loop that boils down to this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">while(!done)
<br/>
{
<br/>
  wait_for_vblank();  /* synchronize to a time base */
<br/>
  update_animation();  /* draw all characters in their new positions */
<br/>
  check_controls();  /* translate keypresses into commands for the player character */
<br/>
  run_behaviors();  /* move all characters according to game rules */
<br/>
}</td> </tr></table><span class="postbody">
<br/>
You need the vblank interrupt primarily because of a quirk in how the BIOS handles low-power mode.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32642 - ymalik - Fri Dec 24, 2004 2:58 pm</h4>
    <div class="postbody"><span class="postbody">Why does the first program that I posted have two calls to WaitVBlank(), one at the top of the loop and one at the bottom?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32646 - identitycrisisuk - Fri Dec 24, 2004 3:48 pm</h4>
    <div class="postbody"><span class="postbody">Oh yeah, I didn't notice that before. Looks like it's maybe trying to deliberately half the frame rate? That's the only reason I can think why it has the for loop doing nothing after it as well.<br/>_________________<br/></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">CanIKickIt(YES_YOU_CAN);</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32647 - Cearn - Fri Dec 24, 2004 3:53 pm</h4>
    <div class="postbody"><span class="postbody">Like tepples said, "Waiting for vertical blank ...lets you know when you can update that animation without causing display artifacts", for small loops you really only need one, so the second is probably redundant. There are a number of little indiscrepancies in the book, you may have noticed he uses another WaitVblank in another chapter and ....
<br/>
<br/>
wait hang on ...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void WaitVBlank(void) 
<br/>
{
<br/>
    while((REG_DISPSTAT &amp; 1)); 
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
Isn't REG_DISPSTAT&amp;1 true when you're <span style="font-style: italic">inside</span> the VBlank period, meaning that this function actually waits till the VBlank is over, instead of starting?
<br/>
<br/>
Anyway, one of the problems with using REG_VCOUNT or REG_DISPSTAT for vsyncing is that you might still be inside the VBlank period when the next game-loop comes along. For example
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
while(1)
<br/>
{
<br/>
   while(!(REG_DISPSTAT&amp;1));
<br/>
   // REG_VCOUNT will be 160 here
<br/>
   // do a LITTLE game stuff
<br/>
   // REG_VCOUNT might be, say, 164 here
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Now, at the next iteration, REG_DISPSTAT&amp;1 will still be true, so you won't actually have waited for the next VSync at all and your timing will be all wrong. To remedy this, you could make sure you're in the next refresh already, like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
while(1)
<br/>
{
<br/>
   while(!(REG_DISPSTAT&amp;1));
<br/>
<br/>
   // REG_VCOUNT will be 160 here
<br/>
   // do a LITTLE game stuff
<br/>
   // REG_VCOUNT might be, say, 164 here
<br/>
<br/>
   while((REG_DISPSTAT&amp;1));
<br/>
   // REG_VCOUNT will be 0 (I think)
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
This is actually what the second demo uses. You could combine the two into one function like this
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// wait for the next VBlank
<br/>
void WaitVBlank(void)
<br/>
{
<br/>
   while((REG_DISPSTAT&amp;1)); // wait till VDraw
<br/>
   while((REG_DISPSTAT&amp;1)); // wait till VBlank
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
In the end, though it's prefereable to use interrupts for this, specifically the BIOS VBlankIntrWait routine. The VBlank interrupt itself will only fire ONCE, so you don't have the still-in-VBlank problem. VBlankIntrWait has an additional benefit in that it saves battery power. Tonc has a demo on how to use it, but I don't know how to do it in HAM. I'd point you to other threads on the subject, but university is closing in 5 minutes, so I have to leave right about now (which reminds me: merry christmas and happy newyear, everyone)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32673 - tepples - Fri Dec 24, 2004 10:33 pm</h4>
    <div class="postbody"><span class="postbody">If you use VBlankIntrWait(), then you have to have at least a 2-file project: one for Thumb code (main()), and one for ARM code (the ISR). The inability to get interrupts going in a 1-file project is one of the reasons that a lot of homebrew demos wait for vblank with a while loop rather than with VBlankIntrWait().<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32676 - ymalik - Fri Dec 24, 2004 11:18 pm</h4>
    <div class="postbody"><span class="postbody">Why can't you have the ISR in the same file?  Just point the memory address where the interrupts branch to to your ISR, right?
<br/>
What are "display artifacts?"</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32688 - identitycrisisuk - Sat Dec 25, 2004 12:44 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Why can't you have the ISR in the same file?  Just point the memory address where the interrupts branch to to your ISR, right?
<br/>
What are "display artifacts?"</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, I wouldn't mind a bit of clarification on this, the new VS6 thing that Abscissa posted about gives you the option to create a simple program that uses VBlankIntrWait in one file. The contents are as follows:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// main.cpp : Small sample project
<br/>
//
<br/>
// This program demonstrates:
<br/>
//   - Setting up the screen mode
<br/>
//   - Drawing a moving pixel
<br/>
//   - Enabling VBlank interrupt
<br/>
//   - Correct way to wait for VBlank, using
<br/>
//     the BIOS's battery-saving VBlankIntrWait
<br/>
<br/>
#define REG_DISPCNT      *((unsigned short  *)0x4000000)
<br/>
#define REG_DISPSTAT   *((unsigned short  *)0x4000004)
<br/>
#define REG_IE         *((unsigned short  *)0x4000200)
<br/>
#define REG_IF         *((unsigned short  *)0x4000202)
<br/>
#define REG_IME         *((unsigned short  *)0x4000208)
<br/>
#define REG_INTMAIN      *((unsigned short **)0x3007FFC)
<br/>
#define REG_IFBIOS      *((unsigned short  *)0x3007FF8)
<br/>
<br/>
#define SCREEN          ((unsigned short  *)0x6000000)
<br/>
<br/>
 // Put InterruptHandler in speedy iwram
<br/>
void InterruptHandler() __attribute__ ((section(".iwram")));
<br/>
<br/>
 // This must be Arm, not Thumb
<br/>
void InterruptHandler()
<br/>
{
<br/>
   // Basically do nothing
<br/>
<br/>
   // Disable Interrupts
<br/>
   REG_IME = 0x0000;
<br/>
<br/>
   // Reset REG_IF and REG_IFBIOS
<br/>
   REG_IF |= 0x0001;
<br/>
   REG_IFBIOS |= 0x0001;
<br/>
<br/>
   // Enable Interrupts
<br/>
   REG_IME = 0x0001;
<br/>
}
<br/>
<br/>
int main()
<br/>
{
<br/>
   int x=10;
<br/>
   int y=20;
<br/>
<br/>
   // Setup screen mode: Mode 3, 1D Object Mode, BG2 and Objects on.
<br/>
   REG_DISPCNT = 0x1443;
<br/>
   
<br/>
   // Turn on VBlank interrupt
<br/>
   REG_DISPSTAT = 0x0008;
<br/>
   REG_IE = 0x0001;
<br/>
<br/>
   // Enable Interrupts
<br/>
   REG_INTMAIN = (unsigned short *)InterruptHandler;
<br/>
   REG_IME = 0x0001;
<br/>
<br/>
   while(1)
<br/>
   {
<br/>
      // Wait for VBlank using BIOS funtion VBlankIntrWait
<br/>
      // Remove "&lt;&lt;16" if using Thumb instructions
<br/>
      asm volatile("swi 5&lt;&lt;16" ::: "r0", "r1", "r2", "r3");
<br/>
<br/>
      // Erase pixels
<br/>
      SCREEN[(    y*240) + x  ] = 0x0000; // Black
<br/>
      SCREEN[((y+1)*240) + x  ] = 0x0000;
<br/>
      SCREEN[(    y*240) + x+1] = 0x0000;
<br/>
      SCREEN[((y+1)*240) + x+1] = 0x0000;
<br/>
<br/>
      // Move pixels
<br/>
      x += 2;
<br/>
      if(x &gt;= 230)
<br/>
         x = 10;
<br/>
<br/>
      y += 1;
<br/>
      if(y &gt;= 150)
<br/>
         y = 10;
<br/>
<br/>
      // Draw pixels
<br/>
      SCREEN[(   y  * 240) + x  ] = 0x7FFF; // White
<br/>
      SCREEN[((y+1) * 240) + x  ] = 0x7FFF;
<br/>
      SCREEN[(   y  * 240) + x+1] = 0x7FFF;
<br/>
      SCREEN[((y+1) * 240) + x+1] = 0x7FFF;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I still need to read up a bit more on the differences between arm and thumb and when they can both be used, they're only now becoming slightly important to me.<br/>_________________<br/></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">CanIKickIt(YES_YOU_CAN);</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32689 - ymalik - Sat Dec 25, 2004 1:07 am</h4>
    <div class="postbody"><span class="postbody">Chapter 9 of <span style="font-style: italic">Programming the Nintendo Gameboy Advance</span> has an example of having an ISR in the same file.  It is just a simple C function.  The interrupt is on hblank.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32711 - tepples - Sat Dec 25, 2004 5:31 am</h4>
    <div class="postbody"><span class="postbody">True, but now main() is still running as ARM code and eating battery power to access twice as large instructions from slow ROM, unless you put it in IWRAM too.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
