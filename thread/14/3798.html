<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Non-const pointer to const data... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Beginners > Non-const pointer to const data...</h2>
<div id="posts">
<div class="post">
    <h4>#24180 - DialogPimp - Thu Jul 29, 2004 7:12 am</h4>
    <div class="postbody"><span class="postbody">...is not allowed.
<br/>
<br/>
As my brain has collapsed for the day, how would I get around my requirement of having a C++ class-member being able to point to different structures that have been declared as const ?
<br/>
<br/>
In a nutshell I have a bunch of const structures describing various animation states and frames, and I want my pointer to point to the current "active state", which naturally changes in response to player input (move left, move right, climb ladder etc).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24181 - abilyk - Thu Jul 29, 2004 7:23 am</h4>
    <div class="postbody"><span class="postbody">In C, at least (so I assume C++ as well), just use a cast.  
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">const u16 my_variable;
<br/>
<br/>
u16* my_ptr;
<br/>
<br/>
void function()
<br/>
{
<br/>
     my_ptr = (u16)my_variable;
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24182 - MumblyJoe - Thu Jul 29, 2004 7:53 am</h4>
    <div class="postbody"><span class="postbody">Exerpt from the Borland C++ docs:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Category
<br/>
<br/>
C++-Specific Keywords
<br/>
<br/>
Syntax
<br/>
<br/>
const_cast&lt; T &gt; (arg)
<br/>
<br/>
Description
<br/>
<br/>
Use the const_cast operator to add or remove the const or volatile modifier from a type.
<br/>
<br/>
In the statement, const_cast&lt; T &gt; (arg), T and arg must be of the same type except for const and volatile modifiers. The cast is resolved at compile time. The result is of type T. Any number of const or volatile modifiers can be added or removed with a single const_cast expression.
<br/>
<br/>
A pointer to const can be converted to a pointer to non-const that is in all other respects an identical type. If successful, the resulting pointer refers to the original object.
<br/>
<br/>
A const object or a reference to const cast results in a non-const object or reference that is otherwise an identical type.
<br/>
<br/>
The const_cast operator performs similar typecasts on the volatile modifier. A pointer to volatile object can be cast to a pointer to non-
<br/>
volatile object without otherwise changing the type of the object. The result is a pointer to the original object. A volatile-type object or a reference to volatile-type can be converted into an identical non-volatile type.</td> </tr></table><span class="postbody">
<br/>
<br/>
Edit: Just thought I would point out that the compiler will not fold values in at compile-time for a const object that is casted to non-const.
<br/>
<br/>
So if you do this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">const int ahar = 10;
<br/>
int* pahar = const_cast&lt;int&gt;(ahar);</td> </tr></table><span class="postbody">
<br/>
<br/>
The compiler will not fold 10 into places where you use ahar, it just assumes you know what you are doing and that you are only using the const modifier to be type safe or something.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24191 - DialogPimp - Thu Jul 29, 2004 11:29 am</h4>
    <div class="postbody"><span class="postbody">Geez I embarrass myself sometimes.  Why I didn't just try casting it I'll never know.  My only consolation is I discussed this with a senior software engineer at work and he didn't have any answers either.  Being as dumb as this when I'm paid to write code every day makes me wonder whether I should be mowing lawns for a job ;)
<br/>
<br/>
Thanks for your help again guys.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24207 - sajiimori - Thu Jul 29, 2004 6:14 pm</h4>
    <div class="postbody"><span class="postbody">You can have a non-const pointer to const data.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const int* non_const_ptr_to_const_data;
<br/>
int* const const_ptr_to_non_const_data;
<br/>
</td> </tr></table><span class="postbody">
<br/>
If you find yourself casting away constness, rethink your design.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24215 - jma - Thu Jul 29, 2004 10:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">You can have a non-const pointer to const data.
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const int* non_const_ptr_to_const_data;
<br/>
int* const const_ptr_to_non_const_data;
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
<br/>
These statements are exactly the same. There is no difference in the compiler between them. You can place the <span style="font-style: italic">const</span> operator wherever you want. You can specify as many <span style="font-style: italic">const</span> operators as you want:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">const int i = 10;
<br/>
const const const int x = 20;
<br/>
int const const *y = &amp;x;
<br/>
const int **z = &amp;y;</td> </tr></table><span class="postbody">
<br/>
<br/>
All of these work on an ANSI C compliant compiler. And there is no difference in their meaning (based on the location of <span style="font-style: italic">const</span>). The compiler may optionally throw a warning like "multiple type qualifiers used", but it isn't an error.
<br/>
<br/>
The only time the position of a 'const' matters is in C++ when declaring function methods for a class (this is done quite often for operator overloading, for example).
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24216 - sajiimori - Thu Jul 29, 2004 10:11 pm</h4>
    <div class="postbody"><span class="postbody">False.  Try this code, and note that lines 9 and 11 give errors:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void test()
<br/>
{
<br/>
   int i = 10;
<br/>
   int j = 20;
<br/>
   const int* cip = &amp;i;
<br/>
   int* const cpi = &amp;i;
<br/>
<br/>
   cip = &amp;j;
<br/>
   cpi = &amp;j;
<br/>
<br/>
   *cip = 30;
<br/>
   *cpi = 30;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24217 - jma - Thu Jul 29, 2004 10:14 pm</h4>
    <div class="postbody"><span class="postbody">Yes and no. I misread your post slightly. I didn't notice that you put the * before the const vs. after the const. That makes a different :)
<br/>
<br/>
There is no difference between
<br/>
<br/>
const int *
<br/>
int const *
<br/>
<br/>
It all lies in where the * is.
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24218 - sajiimori - Thu Jul 29, 2004 10:19 pm</h4>
    <div class="postbody"><span class="postbody">Heheh... I could equally say that it depends on where the 'const' is, but I'd be saying the same thing!
<br/>
<br/>
The way I remember the rule is, "the const goes next to the thing that is const".  It goes on the pointer's side if the pointer is const, or on the data type side if the data is const.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24219 - jma - Thu Jul 29, 2004 10:21 pm</h4>
    <div class="postbody"><span class="postbody">I would normally agree, except for the fact that the const <span style="font-style: italic">can</span> go anywhere relative to the type and there <span style="font-style: italic">can</span> be as many as you want. The same isn't true of the *:
<br/>
<br/>
* int x; // ack!
<br/>
int **x != int *x;
<br/>
<br/>
But I hear what you're saying ;)
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24232 - DialogPimp - Fri Jul 30, 2004 5:46 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">If you find yourself casting away constness, rethink your design.</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm more than happy to rethink my design (even though it is all working now) and listen to suggestions.  I'll explain what I'm doing...
<br/>
<br/>
The purpose is a sprite animation system based around a heirarchy of structures.  At the lowest level the "sprite cell" stores a pointer to the GFX data in ROM and it's size.  Next level up is the "sprite frame" which stores x &amp; y flip, palette, frame delay/ticks, and a pointer to it's sprite cell.  Finally an "anim state" is an array of sprite frames that defines the frames necessary to achieve a particular animation sequence.  At the highest level an array of states defines all the possible actions that a particular sprite may undertake.  An enumeration of all states provides me with a convenient way to index into the state array.
<br/>
<br/>
All of this data is fixed and known at compile time of course and there is no reason why it needs to be in RAM.  My sprite class just maintains a pointer to the current state and a pointer to the current frame within that state in order to update the graphics on a frame by frame basis.
<br/>
<br/>
So that's it.  In response to user input I tell the sprite class to change states from STAND to WALK_R for example.  The update method takes care of incrementing the defined frame delay, looping back to the beginning if necessary and then DMA'ing in the appropriate cell of graphics data to VRAM on frame changes.
<br/>
<br/>
I got it all working last night to the stage where I have Arthur from Ghosts 'n Goblins sitting on my screen and animating left or right depending on what direction keys I use.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#24233 - sajiimori - Fri Jul 30, 2004 6:39 am</h4>
    <div class="postbody"><span class="postbody">Sounds good to me.  Giving your RAM structures pointers to the const data should work fine.  Here's one simple approach:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
struct Sprite
<br/>
{
<br/>
  const StateArray* states;
<br/>
  int cur_state;
<br/>
  int cur_frame;
<br/>
  const Frame* GetFramePtr() { return states[cur_state][cur_frame]; }
<br/>
};
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
