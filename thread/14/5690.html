<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Button handler interface - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>Beginners > Button handler interface</h2>
<div id="posts">
<div class="post">
    <h4>#42439 - ymalik - Wed May 11, 2005 2:41 pm</h4>
    <div class="postbody"><span class="postbody">Hello,
<br/>
What is the best button handler interface?  One that can be used for each module (start menu, game play screen, etc.)?  I just have a process buttons function that goes through each possible key combination.
<br/>
<br/>
Thanks,
<br/>
Yasir</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42451 - sajiimori - Wed May 11, 2005 6:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">enum Key
<br/>
{
<br/>
   KEY_A,
<br/>
   KEY_B,
<br/>
   ...
<br/>
};
<br/>
<br/>
void keyUpdate();  // Call once per game loop.
<br/>
bool keyIsPressed(Key);
<br/>
bool keyJustPressed(Key);
<br/>
bool keyJustReleased(Key);
<br/>
<br/>
void menuControl()
<br/>
{
<br/>
   if(keyJustPressed(KEY_DOWN))
<br/>
      moveCursorDown();
<br/>
   else if(keyJustPressed(KEY_UP))
<br/>
      moveCursorUp();
<br/>
   else if(keyJustPressed(KEY_A))
<br/>
      activateCurrentOption();
<br/>
}
<br/>
<br/>
void playerControl()
<br/>
{
<br/>
   if(keyIsPressed(KEY_LEFT))
<br/>
      movePlayerLeft();
<br/>
   else if(keyIsPressed(KEY_RIGHT))
<br/>
      movePlayerRight();
<br/>
<br/>
   if(keyJustPressed(KEY_A))
<br/>
      jump();
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42453 - jma - Wed May 11, 2005 7:25 pm</h4>
    <div class="postbody"><span class="postbody">As usual, Saj's code is great. 
<br/>
<br/>
However, something for the OP to be aware of is that keyUpdate() being called once per frame could case potential problems. If the player is able to tap a button (press and release it) very quickly in between calls to keyUpdate(), then nothing will happen. This is a problem (mainly) when your framerate is, say, less than 30 or so.
<br/>
<br/>
Another method would be to set up key interrupt handlers (or even use the vblank interrupt), which would ensure that the previous and current controller states would remain up-to-date at all times. 
<br/>
<br/>
Most of the time, Saj's method is just fine. But it is something to keep in mind if you start noticing fast button presses not taking effect.
<br/>
<br/>
Jeff M.<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42457 - poslundc - Wed May 11, 2005 7:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>jma wrote:</b></span></td> </tr> <tr> <td class="quote">However, something for the OP to be aware of is that keyUpdate() being called once per frame could case potential problems.
<br/>
<br/>
...
<br/>
<br/>
This is a problem (mainly) when your framerate is, say, less than 30 or so.</td> </tr></table><span class="postbody">
<br/>
<br/>
In this case, I'd say the problem most likely lies with the framerate being less than 30 Hz. The vast majority of GBA games run at 60 Hz. And even for the ones that don't, polling the keystate once per frame is usually more than sufficient.
<br/>
<br/>
If for some reason you're making an exceptional game, then by all means do exceptional programming. But don't anticipate problems that are highly unlikely, and I'm willing to bet more than 95% of published games aren't afflicted with.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42461 - sajiimori - Wed May 11, 2005 8:08 pm</h4>
    <div class="postbody"><span class="postbody">In this case, the cost is low for changing implementations late in a project because the interface doesn't change significantly.  Good abstraction lessens the need for anticipation.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42462 - ymalik - Wed May 11, 2005 8:13 pm</h4>
    <div class="postbody"><span class="postbody">Ok, that's what I've been doing.  It just seemed to unprofessional.  Our project architect wanted to have an array of structures where each structure element has a button mask and the corresponding function pointer.  And then you would loop through the array each vdraw period.  I thought this was unnecessarily complex.
<br/>
Sajiimori, in your code, what is difference between
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">bool keyIsPressed(Key);</td> </tr></table><span class="postbody">
<br/>
and
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">bool keyJustPressed(Key);</td> </tr></table><span class="postbody">
<br/>
<br/>
And how do you check for a button that is released?
<br/>
<br/>
Thanks,
<br/>
Yasir</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42464 - poslundc - Wed May 11, 2005 8:33 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Our project architect wanted to have an array of structures where each structure element has a button mask and the corresponding function pointer. </td> </tr></table><span class="postbody">
<br/>
<br/>
O_o
<br/>
<br/>
Did he give a reason?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42465 - sajiimori - Wed May 11, 2005 8:41 pm</h4>
    <div class="postbody"><span class="postbody">Tell your architect that the structure you described turns into a great burden, mostly for two reasons.
<br/>
<br/>
First is the lack of lexical closures.  Function pointers have no context, and many input events need a great deal of context to produce their desired effect.  In C and C++, you have to bend over backwards to provide parameterized behavior.
<br/>
<br/>
Second is the amount of state that must be maintained.  If a game mode needs to map a set of events to behaviors, it must remember to clear all of those events when exiting, or else the next game mode may behave incorrectly.  In C++, you can solve this problem by using event binding objects with destructors that automatically unbind the event.  In practice, the amount of code required to <span style="font-style: italic">use</span> this scheme (and I'm not even talking about implementing it) is significantly greater than direct polling.
<br/>
<br/>
keyJustPressed() only returns true if the key was pressed during the last game loop.
<br/>
<br/>
I thought it would be obvious that if keyIsPressed() returns false, then the key is not pressed, and therefore it is released...?  If you're talking about detecting when a key was just released, I listed a seperate function for that.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42467 - jma - Wed May 11, 2005 8:46 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">And how do you check for a button that is released?</td> </tr></table><span class="postbody">
<br/>
<br/>
Just keep the previous button state and the current state. So, your keyUpdate() function might look something like:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define KEY_PRESSED 0
<br/>
<br/>
void keyUpdate() {
<br/>
  g_prev_key_state = g_cur_key_state;
<br/>
  g_cur_key_state = REG_KEYP1;
<br/>
}
<br/>
<br/>
bool keyJustReleased(int key) {
<br/>
  if (g_prev_key_state &amp; key == KEY_PRESSED) {
<br/>
    return g_cur_key_state &amp; key != KEY_PRESSED;
<br/>
  }
<br/>
  return false;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
It has been a while since I've coded the GBA, so treat the above as pseudo-code :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">But don't anticipate problems that are highly unlikely...</td> </tr></table><span class="postbody">
<br/>
<br/>
I agree. Just giving the OP additional information that may prove beneficial in the future.
<br/>
<br/>
Jeff M.<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42499 - tepples - Thu May 12, 2005 2:34 am</h4>
    <div class="postbody"><span class="postbody">Incomplete example:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/* code fragment dedicated to the public domain by author Damian Yerrick
<br/>
   ABSOLUTELY NO WARRANTY */
<br/>
<br/>
#define KEY_A 0x0001
<br/>
#define KEY_B 0x0002
<br/>
#define KEY_UP 0x0040
<br/>
/* etc. */
<br/>
<br/>
int main(void)
<br/>
{
<br/>
  unsigned int last_keys;
<br/>
<br/>
  while(1) {
<br/>
    unsigned int keys = (*(volatile unsigned short *)0x04000130) ^ 0x03FF;
<br/>
    unsigned int pressed_keys = keys &amp; ~last_keys;
<br/>
    unsigned int released_keys = ~keys &amp; last_keys;
<br/>
    last_keys = keys;
<br/>
<br/>
    if(pressed_keys &amp; KEY_A)
<br/>
    {
<br/>
      beep();
<br/>
    }
<br/>
    /* do other stuff */
<br/>
    vsync();
<br/>
    /* do vblank stuff */
<br/>
  }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I also have code for keyboard-style autorepeat if you want the player to control a moving cursor or a moving falling block.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42538 - ymalik - Thu May 12, 2005 7:15 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ymalik wrote:</b></span></td> </tr> <tr> <td class="quote">Our project architect wanted to have an array of structures where each structure element has a button mask and the corresponding function pointer. </td> </tr></table><span class="postbody">
<br/>
<br/>
O_o
<br/>
<br/>
Did he give a reason?
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
Well, let me give you an example of what he was taking about.  Here's the struct:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define NMODULES        5
<br/>
<br/>
typedef void (*keyfunc_t)(u32);
<br/>
/*
<br/>
 * masks allow you to map multiple inputs, such as all directional pad keys
<br/>
 * to a single function, which will be passed a single argument: the input as
<br/>
 * an unsigned, 32-bit integer.
<br/>
 */
<br/>
struct keymap {
<br/>
   u32 input_mask;
<br/>
   keyfunc_t func;
<br/>
};
<br/>
<br/>
struct keymap * module_keymaps[NMODULES];
<br/>
</td> </tr></table><span class="postbody">
<br/>
And here's how it's being used:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static struct keymap m_keymap[] = {
<br/>
        { KEY_A,   keyboard_action_select },
<br/>
        { KEY_B,   keyboard_action_backspace },
<br/>
        { KEYPAD_ANY, keyboard_move_cursor },
<br/>
        { 0, NULL }
<br/>
};
<br/>
<br/>
void keyboard_run ()
<br/>
{
<br/>
    unsigned int i;
<br/>
    int input;
<br/>
    struct keymap * module_keymap;
<br/>
<br/>
    module_keymap = module_keymaps[MODULE_KEYBOARD];
<br/>
<br/>
    for (;;) {
<br/>
<br/>
       input = *m_buttons;
<br/>
<br/>
       for (i = 0; (module_keymap[i]).func != NULL; i++) {
<br/>
           if (!((module_keymap[i]).input_mask &amp; input))
<br/>
              ((module_keymap[i]).func)(input);
<br/>
<br/>
           if (m_quit)
<br/>
              return;
<br/>
<br/>
           if (m_sprite_redraw) {
<br/>
              keyboard_sprite_draw();
<br/>
              m_sprite_redraw = 0;
<br/>
           }
<br/>
<br/>
           if (m_string_redraw) {
<br/>
              keyboard_string_draw();
<br/>
              m_string_redraw = 0;
<br/>
           }
<br/>
        }
<br/>
<br/>
        while ((input &amp; 0x0001) == 0)
<br/>
                input = *m_buttons;
<br/>
<br/>
        WAIT_VBLANK();
<br/>
        WAIT_VBLANK();
<br/>
        WAIT_VBLANK();
<br/>
        WAIT_VBLANK();
<br/>
        WAIT_VBLANK();
<br/>
        WAIT_VBLANK();
<br/>
     }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
That code is my partener's.  I didn't follow that interface because I thought it was too complicated.  We had to present examples of good and bad code in front of the class, and the architect made me present my code as bad code, and my parteners's code as good code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42539 - ymalik - Thu May 12, 2005 7:18 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">keyJustPressed() only returns true if the key was pressed during the last game loop.
<br/>
<br/>
I thought it would be obvious that if keyIsPressed() returns false, then the key is not pressed, and therefore it is released...?  If you're talking about detecting when a key was just released, I listed a seperate function for that.</td> </tr></table><span class="postbody">
<br/>
Oh, ok, so when would you use keyJustPressed()?  Isn't ketIsPressed() enough (you only want to know whether a key has been pressed or not in a game, right?)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42540 - sajiimori - Thu May 12, 2005 7:52 pm</h4>
    <div class="postbody"><span class="postbody">Sounds like you let yourself get pushed around.
<br/>
<br/>
The usage example I posted shows situations where you'd use keyJustPressed versus keyIsPressed, specifically, jumping versus walking.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42551 - poslundc - Thu May 12, 2005 10:10 pm</h4>
    <div class="postbody"><span class="postbody">ymalik: The main problem I have with this system (and sajimori said something like this, but now I'm saying it my way) is that it binds the state of the game to the functionality of the buttons, instead of the buttons to the state of the game.
<br/>
<br/>
Think about the process you are following here. Every frame (well, every 6 frames in your code for some reason, plus waiting for a certain button to be depressed in between for some other mysterious reason) you are doing the following for <span style="font-style: italic">each button</span>:
<br/>
<br/>
1. Check to see if the button has been pressed
<br/>
2. Call that button's function
<br/>
3. Make sprite changes based on that particular button
<br/>
<br/>
Does partitioning out the whole course of a frame by virtue of what to do this frame if "A" is pressed, then what to do this frame if "Up" is pressed, etc. seem like a sensible course of action?
<br/>
<br/>
A far better strategy would be to treat a frame as your body of interest. Keep track of the state of the game from frame to frame, and each frame update the state based on the effect the controls can have <span style="font-style: italic">for that state</span>. ie. delegate the problem of dealing with individual buttons to the state, not the problem of dealing with state to the individual buttons.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42566 - sajiimori - Thu May 12, 2005 11:49 pm</h4>
    <div class="postbody"><span class="postbody">The given example is indeed terrible.  I don't even know where to begin.
<br/>
<br/>
1)  Event driven programming can be good in some situations.
<br/>
<br/>
2)  Event driven programming is a bitch to pull off well in C++, let alone plain C.
<br/>
<br/>
3)  Event driven programming is virtually never appropriate in games.
<br/>
<br/>
4)  Your partner produced a crappy implementation of event driven programming for many reasons, not least of which is that the callbacks have zero context, forcing all of your state to be global.
<br/>
<br/>
That about sums it up.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42572 - poslundc - Fri May 13, 2005 1:09 am</h4>
    <div class="postbody"><span class="postbody">I don't necessarily have a problem with event-driven programming in games, so long as the events are tied to entities that have some relevance to the state.
<br/>
<br/>
The system described above would be like trying to code an operating system by listing all possible responses when the user presses "q", all possible responses when they press "w", when they press "e", "r", "t", "y", etc.
<br/>
<br/>
A button in a menu on the screen can receive and respond to events effectively, because its very existence is tied to the state of the program. The keys are the method of input; they have no direct relevance to the state of the machine, and having them process events is useful only in the most exceptional cases.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42605 - sgeos - Fri May 13, 2005 2:31 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote"> the callbacks have zero context, forcing all of your state to be global.</td> </tr></table><span class="postbody">
<br/>
That can easily be fixed by changing the type of function pointers to something like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct game_state_t
<br/>
{
<br/>
    /* Details */
<br/>
} game_state_t;
<br/>
typedef int fp_return_t;
<br/>
<br/>
fp_return_t (*function_pointer)(int, game_state_t *);  /* if you really need the int */</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not convinced that binding buttons to functionality is the wrong solution for all games, but you'd have to register an input table with every state change.  The difference is do you want to write a new input table for each state, or a new function.  I think it would be just about as easy to accomodate custom controls with either method.
<br/>
<br/>
You need to be careful to make sure that your input table only ties keys to abstract functions that change the game state.  Somehow it seems to me that to get the button&lt;-&gt;function method to work, the functions would have to set flags in the game state and have some other function work out the details.  I don't like it, but as I said I'm not sure it's the wrong solution for all games.
<br/>
<br/>
If you need to respond to just_pressed(), is_pressed(), and just_released() keypad events, you really don't want to do the binding thing.  Now that I look at it, thats where your partners code is really bad.  If I hold A, then the A function gets called until I release it.  (Why is he calling vblank six times!?  Thats a bad sign.  Really bad.)
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42615 - Suboptimal - Fri May 13, 2005 3:56 pm</h4>
    <div class="postbody"><span class="postbody">There are many different methods of handling input, the two most common being polling and event-driven.  Both are very viable, and both are used in commercial games, sometimes even mixed. For example, Half-Life 2 uses messaging,  which is a sort of filtered event-driven method, for UI, but uses polling for character control.  Before picking any method, you need to first understand what type of game you're making, and how it is going to work. For instance, in your program design, when is it legal to have input change the state of the game? Do all of those things need to happen before physics, ai, sound, etc are processed? If you have a solid understanding of how your game is going to work, then as long as you understand the trade-offs between polling and event-driven, the choice between the two will probably be obvious. 
<br/>
<br/>
I suspect your teacher was saying that the event-driven approach was better, more or less because it is NOT polling, which is often people's first approach to solving the problem. Really, what the teacher SHOULD have done, is make you analyze both in the strcture of the of the game and figure out which method will reduce the overall complexity of the code base, etc.  Don't worry about it too much, since the skills you need to design really good software aren't going to come from a classroom. Just try to expose yourself to as many different ways of solving problems as you can. This will add more tools to your sort of coding tool-box, and over time you'll find yourself getting better at applying tools to fit the problem. 
<br/>
<br/>
<br/>
If you're curious,  this write up includes one game's method of handing player control in the game: 
<br/>
<br/>
<a class="postlink" href="http://www.gamasutra.com/features/20050414/rouwe_01.shtml" target="_blank">http://www.gamasutra.com/features/20050414/rouwe_01.shtml</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42636 - sajiimori - Fri May 13, 2005 6:33 pm</h4>
    <div class="postbody"><span class="postbody">Brendan, having all the functions take the entire game state involves essentially the same cost as making the game state global.  All state will be visible to all functions, and the state must contain all the information that could possibly be relevant to every game mode.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42837 - sgeos - Sun May 15, 2005 3:03 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Brendan, having all the functions take the entire game state involves essentially the same cost as making the game state global.  All state will be visible to all functions, and the state must contain all the information that could possibly be relevant to every game mode.</td> </tr></table><span class="postbody">
<br/>
You could pass a (game_mode_x *) to every function when in game mode x.  The table driven method is seeming less and less pretty.
<br/>
In theory the table struct could look something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef int fp_return_t; 
<br/>
typedef fp_return_t (*input_fp_t)(void *);
<br/>
typedef struct input_action_t {
<br/>
    int        input_mask;
<br/>
    input_fp_t action;
<br/>
    void *     data;
<br/>
} input_action_t;</td> </tr></table><span class="postbody">
<br/>
<br/>
Where it is used like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">input_action_t action_table[] =
<br/>
{
<br/>
    {D_PAD, move_player, &amp;player},
<br/>
    {START, show_map,    &amp;some_other_struct},
<br/>
    {0, NULL, NULL}
<br/>
}
<br/>
<br/>
fp_return_t move_player(void *p_data)
<br/>
{
<br/>
    /* IMPORTANT!!!  Cast to the right type to get feedback from the compiler */
<br/>
    player_struct_t *player = (player_struct_t *)p_data;
<br/>
<br/>
    /* calculation not shown */
<br/>
}
<br/>
<br/>
void call_loop(input_action_table *p_action)
<br/>
{
<br/>
    int i;
<br/>
<br/>
    for (i = 0; NULL != p_action[i]-&gt;action; i++)
<br/>
    {
<br/>
        int        mask = p_action[i]-&gt;input_mask;
<br/>
        input_fp_t action = p_action[i]-&gt;action;
<br/>
        void *     data = p_action[i]-&gt;data;
<br/>
<br/>
        if (pressed(mask))
<br/>
            action(data);
<br/>
    }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
It seems to me that registering the data to be passed the fuctions might really suck.  The table would need to be declared in a place where everything is in scope.  I don't really like it, but for interest's sake does anyone have any ideas to make the table based method suck less?  Registered actions could be dropped onto a linked list, but that seem 100 times more complicated than just polling.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42851 - sajiimori - Sun May 15, 2005 5:44 pm</h4>
    <div class="postbody"><span class="postbody">Having a fairly complete knowledge of C++ helps a lot.  I took the idea to its logical conclusion, and it was dissatisfying.  Let me try to remember what the code looked like.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class GameMode
<br/>
{
<br/>
public:
<br/>
   GameMode() :
<br/>
      mKeyLeft (KEY_EVENT_HOLD, KEY_LEFT,  this, &amp;moveLeft),
<br/>
      mKeyRight(KEY_EVENT_HOLD, KEY_RIGHT, this, &amp;moveRight),
<br/>
      mKeyJump (KEY_EVENT_TRIG, KEY_A,     this, &amp;jump)
<br/>
   {
<br/>
   }
<br/>
<br/>
private:
<br/>
   void moveLeft();
<br/>
   void moveRight();
<br/>
   void jump();
<br/>
<br/>
   KeyBinding&lt;GameMode&gt; mKeyLeft, mKeyRight, mKeyJump;
<br/>
};
<br/>
</td> </tr></table><span class="postbody">
<br/>
Constructing a KeyBinding object establishes the binding, and it's automaticallly released when the binding object goes out of scope.  There was something aesthetically appealing about it.
<br/>
<br/>
But in real life, it was a nightmare.  Things that used to be simple became ridiculously circular.  If you're in the middle of a method and you want to know if a key is being held... oh god, I can't even explain it in words.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class IJustWantToKnowIfTheFsckingKeyIsDown
<br/>
{
<br/>
public:
<br/>
   IJustWantToKnowIfTheFsckingKeyIsDown() :
<br/>
      mIsPressed(false),
<br/>
      mPress(KEY_EVENT_TRIG, KEY_A, this, &amp;press),
<br/>
      mRelease(KEY_EVENT_FALL, KEY_A, this, &amp;release)
<br/>
   {
<br/>
   }
<br/>
<br/>
   void update()
<br/>
   {
<br/>
      if(mIsPressed)
<br/>
         ohMyGodThatWasAWasteOfTime();
<br/>
   }
<br/>
<br/>
private:
<br/>
   void press()
<br/>
   {
<br/>
      mIsPressed = true;
<br/>
   }
<br/>
<br/>
   void release()
<br/>
   {
<br/>
      mIsPressed = false;
<br/>
   }
<br/>
<br/>
   KeyBinding&lt;IJustWantToKnowIfTheFsckingKeyIsDown&gt;
<br/>
      mPress, mRelease;
<br/>
   bool mIsPressed;
<br/>
};
<br/>
</td> </tr></table><span class="postbody">
<br/>
Gee, we should go write a utility class to encapsulate all this complexity.  Then we'd have a super-advanced interface that looks something like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">bool keyIsPressed(Key);</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42879 - DekuTree64 - Sun May 15, 2005 10:44 pm</h4>
    <div class="postbody"><span class="postbody">...yeah. Horrible for in-game, and even for menus it's just a roundabout way of doing an if/else or switch.
<br/>
Whatever system I'm working on, I wrap up the input however I must and make 3 simple macros, KEYTRIG, KEYDOWN and KEYFALL, so I can give them the key I want to check and be done with it.
<br/>
<br/>
One thing that can be handy though, but more for the DS where you have the touch screen, is to make a generic button class that checks the input state automatically and does something if it's pushed. Like if you want your buttons to do a little animation, put that into the class so it happens without any special code in every menu. 
<br/>
Still, I would keep the game logic in an if/else/switch, just asking those button objects if they had been pressed.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42948 - sgeos - Tue May 17, 2005 10:49 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Things that used to be simple became ridiculously circular.  If you're in the middle of a method and you want to know if a key is being held... oh god, I can't even explain it in words.</td> </tr></table><span class="postbody">Why would binding keys for 'automatic' actions and polling otherwise be a bad way of doing things?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Gee, we should go write a utility class to encapsulate all this complexity.  Then we'd have a super-advanced interface that looks something like:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">bool keyIsPressed(Key);</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody"><span style="font-weight: bold">lol</span>
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42969 - poslundc - Tue May 17, 2005 5:31 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">Why would binding keys for 'automatic' actions and polling otherwise be a bad way of doing things?</td> </tr></table><span class="postbody">
<br/>
<br/>
I think any mixed-model like that tends to lead to a lot of confusion and design problems down the road. Any situation where it's ambiguous how a control mode ought to be implemented will create code that's much harder to debug and maintain.
<br/>
<br/>
There are exceptions: for example, binding the A-B-Start-Select combo to a soft-reset by using an interrupt. But that functionality is the only key binding that ever remains at all consistent throughout a game.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42971 - sajiimori - Tue May 17, 2005 5:45 pm</h4>
    <div class="postbody"><span class="postbody">But Dan, programming wouldn't be any fun at all if there were only one way to do things!  :)  Seriously though, flexibility is good.
<br/>
<br/>
My recommendation: Make the most beautiful and full-featured event-based input system you can imagine.  Then keep it in your toolbelt, ready to apply it when it will result in a significant improvement.
<br/>
<br/>
My prediction: It will never result in a significant improvement.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42974 - poslundc - Tue May 17, 2005 6:15 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">But Dan, programming wouldn't be any fun at all if there were only one way to do things!  :)</td> </tr></table><span class="postbody">
<br/>
<br/>
One should always strive to apply the most appropriate tool to solve a problem, and never assume that one tool is the correct solution for every problem.
<br/>
<br/>
But I wouldn't use both a hammer and a saw to pound in a nail.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45001 - Shade - Tue Jun 07, 2005 3:12 am</h4>
    <div class="postbody"><span class="postbody">...sorry, I had to say this. Man, this forum is just freakin' great. Gotta love this topic. And people are so civilized, too. Reminds me of the good ol' times in lua-l.
<br/>
<br/>
Cheers!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45111 - Suboptimal - Tue Jun 07, 2005 7:17 pm</h4>
    <div class="postbody"><span class="postbody">I've been thinking about this thread for awhile. The line of thought usually comes down to "The right tool for the right job, and just checking the button state is the right tool for the job of checking input". 
<br/>
<br/>
However, I think the problem is that people have been thinking about his in terms of registers, or elegant C++, or in just about any framework other than what it is that actually makes a game. Your UI doesn't care about the state of a register, it cares about whether the user wants to scroll up or down in a list. Blanka doesn't care about what button is being mashed, he cares about what move the player has just told him to execute.
<br/>
<br/>
In other words, a good input system will translate the current state of the controls into a a set of events or actions based on the state of the game. It can store those events to be polled by other systems, it can feed them into an event queue, or it can send them to game modules to be executed. Most importantly, if your game is at all complicated, it can reduce the underlying complexity of the code. This will have the benefit of increased flexibility as the project matures. Finally, if you ever work on a platform that supports multiple input types, or input rebinding, it will be absolutely nessisary.
<br/>
<br/>
So, yes, if you're making pong or asteroids, you can probably just check the button state and get on with your game. If you're shooting for something more complicated like an RPG, then a good event system could definately strengthen the code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45127 - sajiimori - Tue Jun 07, 2005 8:38 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">If you're shooting for something more complicated like an RPG, then a good event system could definately strengthen the code.</td> </tr></table><span class="postbody">You seem confident.  Have you ever tried it?
<br/>
<br/>
Let me give you a challenge.  Pretend you have the coolest event-based input system imaginable.  Forget about the implementation of the system.  Just show me a <span style="font-style: italic">usage</span> sample for a realtime game that's better than polling.  Not just cooler or more impressive, but <span style="font-style: italic">better</span> in some concrete way: code length, flexibility, modularity, anything.  I'm not saying there isn't one -- I honestly don't know.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Your UI doesn't care about the state of a register, it cares about whether the user wants to scroll up or down in a list.</td> </tr></table><span class="postbody">UIs tend to be more event-based because of their non-realtime nature and because of the number of components that can potentially handle the same input.  Rather than iterating over every component and checking if any input is relevant for it, it is better to recursively desend through the hierarchy of objects and funnel events through them, stopping when the event is handled.  This is not like a normal game.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Blanka doesn't care about what button is being mashed, he cares about what move the player has just told him to execute.</td> </tr></table><span class="postbody">Blanka shouldn't be handling input.  Another module should poll input and send Blanka the appropriate commands, such as "quickPunch".  Blanka doesn't even care if the player told him to do it -- it could have been the AI or a recorded demo.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Finally, if you ever work on a platform that supports multiple input types, or input rebinding, it will be absolutely necessary.</td> </tr></table><span class="postbody">Polled input can be translated by a key binding table.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45179 - sgeos - Wed Jun 08, 2005 9:37 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Blanka doesn't care about what button is being mashed, he cares about what move the player has just told him to execute.</td> </tr></table><span class="postbody">Blanka shouldn't be handling input.  Another module should poll input and send Blanka the appropriate commands, such as "quickPunch".  Blanka doesn't even care if the player told him to do it -- it could have been the AI or a recorded demo.</span></td> </tr></table><span class="postbody">
<br/>
Agree.  The input module should sit apart from the blanka module.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45326 - Suboptimal - Thu Jun 09, 2005 5:35 pm</h4>
    <div class="postbody"><span class="postbody">I'm not certain we're in disagreement here, I think the differences might ones of language. I'm not nessisarily advocating a system like half-baked callback table that the original poster talked about. My core thesis was this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">A good input system will translate the current state of the controls into a  set of events or actions based on the state of the game. It can store those events to be polled by other systems, it can feed them into an event  queue, or it can send them to game modules to be executed.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Which, in my experience, is ultimately better than littering the codebase with " if ( REGISTER &amp; KEY_BIT ) " statements. 
<br/>
<br/>
Beyond that, the benfits of an input system often depend on the game in question. Many times, a well designed input system can reduce complexity by using context early in the chain of decision making to cut down on the number of things that need to be checked against when sub systems decide whether or not to change their state. For example: 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if ( bFoo1 )
<br/>
{
<br/>
    if ( bBar )
<br/>
        Function1();
<br/>
}
<br/>
else if ( bFoo2 )
<br/>
{
<br/>
    if ( bBar )
<br/>
        Function2();
<br/>
}
<br/>
else  if ( bFoo3 )
<br/>
{
<br/>
  if ( bBar )
<br/>
        Function3();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
It's easy to see that this can be optimized to :
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if ( bBar )
<br/>
{
<br/>
    if ( bFoo1 )
<br/>
         Function1();
<br/>
    else if ( bFoo2 )
<br/>
        Function2();
<br/>
    else if ( bFoo3 )
<br/>
        Function3();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
A good input system can essentially do the same thing by taking a high-level view of the state of the game, leaving individual modules to handle the details. 
<br/>
<br/>
I'm very new to GBA programming, so I don't have any examples here to show you. But I've worked on several large games for other platforms that relied on one or sometimes several layers of systems between raw input gathering and that input actually driving changes in the game. Some of them were completely awful, and I've never seen one that didn't have it's own problems, but I would say most were better than simply having the individual game systems to directly access the raw input state.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45333 - sajiimori - Thu Jun 09, 2005 6:49 pm</h4>
    <div class="postbody"><span class="postbody">Cook input data until it doesn't help any more.  How much do you need to get from registers to mario-&gt;jump()?  Well, you only want to jump when the key is triggered, and the registers only say what is currently pressed.  So there should be a layer that keeps track of both the previous and current key states.  If you want the player to be able to reconfigure their controls, then add another layer that translates a game action to a key.  That may sound backwards, but it isn't:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void checkInput()
<br/>
{
<br/>
  if(keyTriggered(keyMap[ACTION_JUMP]))
<br/>
    mario-&gt;jump();
<br/>
}</td> </tr></table><span class="postbody">I disagree that input should be at a higher level than game logic.  Game logic should be implemented in terms of the topmost input modules, and the design of the input module should be in service of simplifying game logic.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
