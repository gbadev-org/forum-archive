<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Fastest way to scroll - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > Fastest way to scroll</h2>
<div id="posts">
<div class="post">
    <h4>#31362 - QuantumDoja - Fri Dec 10, 2004 2:35 pm</h4>
    <div class="postbody"><span class="postbody">Hi, I have come to the stage of my little gameboy project now where I can display a background image on the screen, from what is in memory, of course now i want to scroll..
<br/>
<br/>
my tiles are set up as<span style="font-weight: bold"> 8 by 8</span>.
<br/>
<br/>
They are drawn, by working out position from a level array, loading the correct tile, and using a plot pixel method to fill that tile space. So in effect I have <span style="font-weight: bold">30(width)</span> by <span style="font-weight: bold">20(height)</span> tiles on my screen.
<br/>
<br/>
Which is going to be the best method for me to draw the next screen, ie 1px -&gt; onwards, so when as the user presses the direction it <span style="font-style: italic">scrolls smoothly</span>?????
<br/>
<br/>
Thanks<br/>_________________<br/>Chris Davis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31364 - Lupin - Fri Dec 10, 2004 2:50 pm</h4>
    <div class="postbody"><span class="postbody">I am not sure but i think there are 2 ways... first way is to use a 256x256 map and scroll it pixel wise (using the BG H/V offset registers) and when you advance 8 pixels you change the data of that layer so that it starts at the new tile in X or Y direction and set the pixel wise offset back to 0.
<br/>
<br/>
Another, and faster, way is to set up a 512x512 or whatever layer (a large one ;)) and then ONLY use the offset registers to scroll it pixel wise, but then the size for the map is limited.<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31368 - ScottLininger - Fri Dec 10, 2004 3:59 pm</h4>
    <div class="postbody"><span class="postbody">Once you've drawn a map and made it appear (which it sounds like your have?) the scrolling part is easy. You just modify a couple of scroll registers and it works.
<br/>
<br/>
In your case it's extremely easy, since your 20x30tile map is small enough to fit onto a single 256x256px background. (If you maps gets bigger than the largest possible tile background, then you have to start loading tiles dynamically... that's what Lupin is talking about above.)
<br/>
<br/>
Anyway, here's an example:
<br/>
<br/>
The following assumes you are using background layer #3. There are similar registers for other backgrounds. Try the <a class="postlink" href="http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm" target="_blank">cowbite spec</a> for a complete list of registers and what they do.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define PADUP              !(*KEYS &amp; KEY_UP)
<br/>
#define PADDOWN            !(*KEYS &amp; KEY_DOWN)
<br/>
#define PADLEFT            !(*KEYS &amp; KEY_LEFT)
<br/>
#define PADRIGHT           !(*KEYS &amp; KEY_RIGHT)
<br/>
<br/>
// use some vars to keep track of your scroll
<br/>
int scrollX = 0;
<br/>
int scrollY= 0;
<br/>
<br/>
while (1) {
<br/>
    
<br/>
    // this code would be ridiculously fast, but you get the idea
<br/>
    if (PADUP) scrollY--;
<br/>
    if (PADDOWN) scrollY++;
<br/>
    if (PADRIGHT) scrollX++;
<br/>
    if (PADLEFT) scrollX --;
<br/>
 
<br/>
    // modify those registers!
<br/>
    REG_BG3HOFS = scrollX;
<br/>
    REG_BG3VOFS = scrollY;
<br/>
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Cheers,
<br/>
<br/>
-Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31507 - Cepheus - Sat Dec 11, 2004 2:55 pm</h4>
    <div class="postbody"><span class="postbody">Dovoto have an example on how to scroll big maps in his gba tutorials ( <a href="http://www.thepernproject.com/English/tutorial_Making_The_Game.html" target="_blank">http://www.thepernproject.com/English/tutorial_Making_The_Game.html</a> ).</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
