<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Fixed Point Math with negative numbers - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>Beginners > Fixed Point Math with negative numbers</h2>
<div id="posts">
<div class="post">
    <h4>#19126 - alek - Sun Apr 11, 2004 7:35 pm</h4>
    <div class="postbody"><span class="postbody">I get the weired results when I wan't to work with fixed point numbers with a negative sign. I got these defines  while I was searching google
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
#define itofx(x) ((x) &lt;&lt; 8)      // Integer to fixed point
<br/>
#define ftofx(x) (long)((x) * 256)   // Float to fixed point
<br/>
#define dtofx(x) (long)((x) * 256)   // Double to fixed point
<br/>
#define fxtoi(x) ((x) &gt;&gt; 8)      // Fixed point to integer
<br/>
#define fxtof(x) ((float) (x) / 256)   // Fixed point to float
<br/>
#define fxtod(x) ((double)(x) / 256)   // Fixed point to double
<br/>
#define Mulfx(x,y) (((y) * (x)) &gt;&gt; 8)   // Multiply a fixed by a fixed
<br/>
#define Divfx(x,y) ((y &lt;&lt; 8) / (x))       // Divide a fixed by a fixed
<br/>
#define Printfx(x) printf("%ld.%ld", x &gt;&gt; 8, 100 * (unsigned long) ((x) &amp; 0x00ff) &gt;&gt; 8)                                            // Print fixed point.
<br/>
#define NDPrintfx(x) printf("%ld", x &gt;&gt; 8)   // Print fixed point out a decimal point.
<br/>
typedef long fixed;                                   // Our new fixed point type.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
When i write
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
long test = ftofx(-1.37);
<br/>
long test2 = Mulfx(test,ftofx(0.234));
<br/>
Printfx(test2);
<br/>
</td> </tr></table><span class="postbody">
<br/>
It prints -1,68, the answer should be -0,32058
<br/>
But if I write the same thing without the - sign
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
long test = ftofx(1.37);
<br/>
long test2 = Mulfx(test,ftofx(0.234));
<br/>
Printfx(test2);
<br/>
</td> </tr></table><span class="postbody">
<br/>
 it prints 0.31 wich is much closer to the truth(0,32058).
<br/>
<br/>
Another thing, when I write
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
long test = ftofx(1.37);
<br/>
Printfx(test);
<br/>
</td> </tr></table><span class="postbody">
<br/>
it print 1.36... why doesn't it print 1.37?
<br/>
<br/>
Thanks in advance...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19129 - poslundc - Sun Apr 11, 2004 7:53 pm</h4>
    <div class="postbody"><span class="postbody">Well, simply put, the formula being used for printing doesn't work with negative numbers because of the way negative numbers are represented internally (two's-complement). The formula only works for positive numbers. If you want it to work for negative numbers, check to see if the number is less than zero, and if it is, print a negative sign and then call your print macro on the negative of the variable.
<br/>
<br/>
For your second question: the macros you are using are creating 24.8 fixed numbers, which means 24 bits of integer precision (up to +/- 8 million or so, 16 million unsigned) and 8 bits of fractional precision. With only 8 bits of fractional precision, 0.36 is as close as you're gonna get to accurate internal representation of your number.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19137 - alek - Sun Apr 11, 2004 9:48 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">Well, simply put, the formula being used for printing doesn't work with negative numbers because of the way negative numbers are represented internally (two's-complement). The formula only works for positive numbers.</td> </tr></table><span class="postbody">
<br/>
<br/>
Does that also apply for the other formulas, like Mulfx, Divfx,...?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19141 - poslundc - Sun Apr 11, 2004 10:43 pm</h4>
    <div class="postbody"><span class="postbody">No, those will all work on signed values, but you still should be careful. These macros are not an insulated wrapper against the numbers' internal representations, and you are very likely to run into overflow and underflow errors if you don't attempt a greater understanding of how fixed-point math works.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19158 - alek - Mon Apr 12, 2004 6:29 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
For your second question: the macros you are using are creating 24.8 fixed numbers, which means 24 bits of integer precision (up to +/- 8 million or so, 16 million unsigned) and 8 bits of fractional precision. With only 8 bits of fractional precision, 0.36 is as close as you're gonna get to accurate internal representation of your number. </td> </tr></table><span class="postbody">
<br/>
<br/>
I changed to 16.16 fixed numbers but got the same result. Then I simply added 0.5 (in accordance with Tricks of the 3D game programming gurus) to the number when I converted to fixed point and that did the trick.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">you are very likely to run into overflow and underflow errors if you don't attempt a greater understanding of how fixed-point math works.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I've searched the web but I couldn't find any good tutorials on the subject, does anybody know a good tutorial on fixed point math?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19159 - poslundc - Mon Apr 12, 2004 7:00 pm</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://www.google.com/search?q=fixed+point+math" target="_blank">http://www.google.com/search?q=fixed+point+math</a>
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19160 - alek - Mon Apr 12, 2004 7:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><a class="postlink" href="http://www.google.com/search?q=fixed+point+math" target="_blank">http://www.google.com/search?q=fixed+point+math</a>
<br/>
<br/>
Dan.</td> </tr></table><span class="postbody">
<br/>
<br/>
Tried that, guess I'll go threw them I little more carefully.
<br/>
<br/>
Thanks for the help</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19161 - Lupin - Mon Apr 12, 2004 7:20 pm</h4>
    <div class="postbody"><span class="postbody">you just got to know that if you multiply (1&lt;&lt;16) with (1&lt;&lt;16), the result won't be (1&lt;&lt;16) as you would assume it when multiplying 1.0 with 1.0, the result will be 4294967296 or -1 (i am not quite sure, but it will be a very large number that barely fits into 32 bits). 
<br/>
This is because if you mutliply a number with 16 bit fraction with another number with 16 bit fraction you will get a 0.32 fixed point number (16+16=32).
<br/>
<br/>
Because of this most people use 24.8 fixed point math, it won't overflow too soon. If you don't do any mutliplies it is not a problem though.<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19162 - poslundc - Mon Apr 12, 2004 8:37 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lupin wrote:</b></span></td> </tr> <tr> <td class="quote">you just got to know that if you multiply (1&lt;&lt;16) with (1&lt;&lt;16), the result won't be (1&lt;&lt;16) as you would assume it when multiplying 1.0 with 1.0, the result will be 4294967296 or -1 (i am not quite sure, but it will be a very large number that barely fits into 32 bits).</td> </tr></table><span class="postbody">
<br/>
<br/>
;)
<br/>
<br/>
You should try it and see. I think you'll be surprised.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19163 - Lupin - Mon Apr 12, 2004 9:33 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, it should be 0. I didn't thought about it because it doesn't matter, multiplying 16.16 by 16.16 will always screw up the result if you forget to shift the numbers :)<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19164 - poslundc - Mon Apr 12, 2004 10:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Lupin wrote:</b></span></td> </tr> <tr> <td class="quote">Yeah, it should be 0. I didn't thought about it because it doesn't matter, multiplying 16.16 by 16.16 will always screw up the result if you forget to shift the numbers :)</td> </tr></table><span class="postbody">
<br/>
<br/>
No it doesn't, it just gives you a result in 0.32 notation, which is useful in many applications.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19165 - Lupin - Mon Apr 12, 2004 11:18 pm</h4>
    <div class="postbody"><span class="postbody">it screws up the integer part, ok?<br/>_________________<br/><a class="postlink" href="http://pokeme.shizzle.it/" target="_blank">Team Pokeme</a>
<br/>
<a class="postlink" href="http://lupin.shizzle.it/" target="_blank">My blog and PM ASM tutorials</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19166 - poslundc - Tue Apr 13, 2004 1:01 am</h4>
    <div class="postbody"><span class="postbody">Actually, if you use the long long datatype (or the UMULL or SMULL assembly instructions) you get 64 bits of precision, with 32 bits for your integer portion.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19196 - tepples - Tue Apr 13, 2004 11:32 pm</h4>
    <div class="postbody"><span class="postbody">GCC's ARM backend is highly suboptimal with respect to smull.
<br/>
<br/>
I wrote this C code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int fixmul(int r0, int r1)
<br/>
{
<br/>
  return ((long long)r0 * r1) &gt;&gt; 16;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
and compiled it on GCC 3.2.3 (DevKit Advance R5b3): using -O3 -marm -mthumb-interwork:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">fixmul:
<br/>
  str r4, [sp, #-4]!
<br/>
  smull r3, r4, r0, r1
<br/>
  mov r1, r4
<br/>
  mov r0, r3
<br/>
  mov r2, r3, lsr #16
<br/>
  orr r0, r2, r1, asl #16
<br/>
  ldmfd sp!, {r4}
<br/>
  bx lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
Compare this to handcoded assembly language:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">@ int fixmul(int a, int b)
<br/>
fixmul:
<br/>
  smull r1, r2, r0, r1     @ r2:r1 = (long long)r0 * r1
<br/>
  mov r0, r2, lsl #16      @ r0 = r2 &lt;&lt; 16
<br/>
  orr r0, r0, r1, lsr #16  @ r0 |= (unsigned int)r1 &gt;&gt; 16
<br/>
  bx lr                    @ return r0
<br/>
</td> </tr></table><span class="postbody">
<br/>
and you'll see why anything involving 16.16 fixed-point will eventually need to be rewritten in ARM assembly language and stashed in IWRAM. The code that GCC emits juggles more registers and even has to hit the stack, making it a total of seven cycles longer. It looks to me like another symptom of GCC's register allocator's trouble with handling destructive sub-operations such as &lt;&lt;= and |=.
<br/>
<br/>
Has this improved in more recent GCC? If so, can somebody point me to a HOWTO for getting started with Wintermute's devkitARM, given that DevKit Advance hasn't been updated in over nine months?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#19213 - poslundc - Wed Apr 14, 2004 3:10 am</h4>
    <div class="postbody"><span class="postbody">If the function were inlined, you might be able to avoid the stack hit.
<br/>
<br/>
But I agree that it's a lousy implementation overall.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
