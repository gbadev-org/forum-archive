<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>SRAM, Structs and memcpy - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>Beginners > SRAM, Structs and memcpy</h2>
<div id="posts">
<div class="post">
    <h4>#20938 - TheMikaus - Thu May 20, 2004 6:25 am</h4>
    <div class="postbody"><span class="postbody">I've been messing with the SRAM and I can save using the ((char *)SRAM)[offset] and load using the same just fine, but I was trying to get memcpy to work.  That way I can just have a savegame struct.
<br/>
<br/>
typedef struct tagSaveGame
<br/>
{
<br/>
   char data;
<br/>
   int moredata;
<br/>
   blah blah blah...
<br/>
} SaveGame;
<br/>
<br/>
....
<br/>
SaveGame theSave;
<br/>
memcpy((char *)SRAM, &amp;theSave, sizeof(theSave));
<br/>
and memcpy(&amp;theSave,(char *)SRAM,sizeof(theSave));
<br/>
<br/>
but it doesn't work.  at all.  I was just wondering if there was a way to get it to work right. (Mainly asking what I'm doing wrong)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20945 - f(DarkAngel) - Thu May 20, 2004 1:18 pm</h4>
    <div class="postbody"><span class="postbody">You have 8-bit rw access to SRAM. Using str or strh will pass only lower byte.
<br/>
<br/>
I don't know what libc memcpy does exactly, but if memcpy isn't writing 8-bit at time, then it sure will fail.<br/>_________________<br/>death scream...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#20952 - TheMikaus - Thu May 20, 2004 3:15 pm</h4>
    <div class="postbody"><span class="postbody">Yeah.  I realized that before I went to bed.  I think memcpy is 16bit.  So I made my own memcpy function that works (so far).
<br/>
<br/>
void mmcpy(void * dest, void * src, int size)
<br/>
{
<br/>
   while(size &gt; 0)
<br/>
    ((char *)dest)[size] = ((char *)src[size--];
<br/>
}
<br/>
<br/>
seems to work.  Just means it writes the data in backwards but it's not a big deal .  Might be a small performance hit if the GBA is particular, but easily fixable.  I haven't tried this with funny sized structs (those that use bit fields), but I plan on doing that later.
<br/>
<br/>
Thanks for the fast reply :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21006 - sasq - Fri May 21, 2004 3:33 pm</h4>
    <div class="postbody"><span class="postbody">since that is for chars only, a nicer way to write it would be;
<br/>
<br/>
void mmcpy(char * dest, char * src, int size) 
<br/>
{ 
<br/>
    while(size--)  *dest++ = *src++;
<br/>
}</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21287 - TheMikaus - Wed May 26, 2004 7:04 pm</h4>
    <div class="postbody"><span class="postbody">The problem with having the parameters passed in as chars is the idea that you would have to type cast the variables going in.
<br/>
<br/>
I'm 90% sure that if you use void * you wont have to type cast. you just have to reference.
<br/>
<br/>
so instead of mmcpy((char *)&amp;bob,(char *)&amp;bobnew);
<br/>
it would just be mmcpy(&amp;bob,&amp;bobnew);
<br/>
<br/>
So like a one line change in what yours says (looks much nicer your way) :)
<br/>
<br/>
and I don't know if I'm reading wrong, but the only reason I use the variable type char is because it uses 8 bits which is how much you're allowed to copy to SRAM at one time.  It's not necessarily characters.  I don't think you meant just coping letters, but I wasn't sure.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
