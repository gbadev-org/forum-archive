<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Div7 - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>OffTopic > Div7</h2>
<div id="posts">
<div class="post">
    <h4>#148552 - naleksiev - Mon Jan 07, 2008 3:16 am</h4>
    <div class="postbody"><span class="postbody">I'm preparing for job interview and going through some interview tests. One of the question is how to write function 
<br/>
unsigned int div7(unsigned int val); 
<br/>
without using division, mod or multiply. I figured out if it can be optimized someone here will know how :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148555 - DekuTree64 - Mon Jan 07, 2008 4:30 am</h4>
    <div class="postbody"><span class="postbody">So the goal is to write a function that returns the same value as this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">unsigned int div7(unsigned int val)
<br/>
{
<br/>
    return val / 7;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Without using division?
<br/>
The obvious way is repeated subtraction, but that's no fun, and gets very time consuming with large numbers. The "standard" division algorithm is to use bitshifts so there's at most one iteration per bit of the values. Here's a generic unsigned 32-bit divde off the top of my head:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">unsigned int div(unsigned int numer, unsigned int denom)
<br/>
{
<br/>
    unsigned int result = 0;
<br/>
    int shift = 0;
<br/>
<br/>
    // Figure out how high we can shift it without overflow
<br/>
    while(!((denom &lt;&lt; shift) &amp; BIT31))
<br/>
        shift++;
<br/>
<br/>
    for (; shift &gt;= 0; shift--)
<br/>
    {
<br/>
        if (numer &gt;= (denom &lt;&lt; shift))
<br/>
        {
<br/>
            numer -= denom &lt;&lt; shift;
<br/>
            result += 1 &lt;&lt; shift;
<br/>
        }
<br/>
    }
<br/>
<br/>
    return result;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
You can specialize it for the number 7 if you want. Also for an interview test you might not want to assume that an unsigned int is 32 bits :)
<br/>
<br/>
Oh, and another technique you can use is fixed-point reciprocal multiplication. But you have to be aware of the range of numbers you're working with to make sure it's fully accurate.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148557 - keldon - Mon Jan 07, 2008 5:20 am</h4>
    <div class="postbody"><span class="postbody">Hmm, well they just said not to use div or mul, so do just that! I really don't think it's a trick question, but you can store a multiplication table, such as 7 multiplied by all powers of 2 (or even 10), etc, making this a whole lot faster. There's even an optimisation for finding the shift using 2 steps of a binary search followed by an 8-byte lookup.
<br/>
<br/>
But like I said, I don't think it's a trick question -  this might just be a question to see you code!
<br/>
<br/>
(can't sleep :()</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148560 - naleksiev - Mon Jan 07, 2008 5:45 am</h4>
    <div class="postbody"><span class="postbody">The reciprocal doesn't work because you can't do multiplication.
<br/>
<br/>
I was trying to google it. Apparently there are similar threads but not with a good answer.
<br/>
<br/>
I'm not sure if this is a tricky question. The previews question is multiplyBy123. There are 61 more questions in the test. I do believe there should be a simpler answer.
<br/>
<br/>
p.s. Please stop with the interview tips. I just thought it will be fun to brainstorm it :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148562 - keldon - Mon Jan 07, 2008 6:10 am</h4>
    <div class="postbody"><span class="postbody">61 questions pretty much says that they just want 61 quick answers to me!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148569 - Jim e - Mon Jan 07, 2008 7:36 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>naleksiev wrote:</b></span></td> </tr> <tr> <td class="quote">The reciprocal doesn't work because you can't do multiplication.</td> </tr></table><span class="postbody">Nonsense, I come from assembly where you don't even have a mul instruction, and we did reciprocal multiplication just fine.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//-----------------
<br/>
// Divide by 7 using reciprocal multiplication
<br/>
// (2^32)/7 = 100 100 100 100 100 100 100 100 100 100 . 1
<br/>
// round up that last digit for accurracy.
<br/>
<br/>
unsigned int div7(unsigned int val) {
<br/>
   unsigned long long num = 0;
<br/>
   int i;
<br/>
   for(i=0;i&lt;10;i++) {
<br/>
      num  = num&lt;&lt;1;
<br/>
      num += val;
<br/>
      num  = num&lt;&lt;2;
<br/>
   }
<br/>
   num += val;
<br/>
   num  = num&gt;&gt;32;
<br/>
   return num;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
This WILL lose accuracy on larger integers(off by one or 2). It is possible to try to correct for it though by checking the range of the number.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148581 - naleksiev - Mon Jan 07, 2008 5:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jim e wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
This WILL lose accuracy on larger integers(off by one or 2). It is possible to try to correct for it though by checking the range of the number.</td> </tr></table><span class="postbody">
<br/>
<br/>
I tried your solution for range 0 to 1 billion there's no a single error</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148584 - naleksiev - Mon Jan 07, 2008 6:10 pm</h4>
    <div class="postbody"><span class="postbody">Hey Jim e,
<br/>
<br/>
I kind of understand your solution.
<br/>
I'll inline to make it more readable for me ... sorry.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static uint div7(uint val)
<br/>
{
<br/>
    ulong v = val;
<br/>
    return (uint)((val + (val &lt;&lt; 2) + (val &lt;&lt; 5) + (val &lt;&lt; 8) + (val &lt;&lt; 11) + (val &lt;&lt; 14) + (val &lt;&lt; 17)) &gt;&gt; 20);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I don't know how you come up with the <span style="font-weight: bold">val + ...</span>. If it's up to me I'll write it as <span style="font-weight: bold">(val &gt;&gt; 1) + (val &lt;&lt; 2) + ...</span> and I'll make a mistake.
<br/>
<br/>
Actually, now when I'm writing this post I think I figure it out. Is the other 3.5 before devision with 7 is coming from the half that I need to add when converting fixed point to int?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148585 - Lick - Mon Jan 07, 2008 6:43 pm</h4>
    <div class="postbody"><span class="postbody">Isn't <span style="font-weight: bold">long long</span> 64-bit? A single long is 32-bit? Not sure for 64-bit machines.<br/>_________________<br/><a class="postlink" href="http://licklick.wordpress.com" target="_blank">http://licklick.wordpress.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148589 - wintermute - Mon Jan 07, 2008 7:10 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>naleksiev wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<br/>
I don't know how you come up with the <span style="font-weight: bold">val + ...</span>. If it's up to me I'll write it as <span style="font-weight: bold">(val &gt;&gt; 1) + (val &lt;&lt; 2) + ...</span> and I'll make a mistake.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
What he's doing here is factoring 1/7 in powers of two.
<br/>
<br/>
(1 + 4 + 32 + 256 + 2048 + 16384 + 131072) / 1048576 = ~ 1/7
<br/>
<br/>
basically you take a large(ish) power of two, divide by 7, remove the fraction part, multiply your numerator by this value &amp; divide by the power of two you used earlier. This can be a good approximation for pretty much any division.
<br/>
<br/>
<br/>
Multiplies are much easier to do, you can factor any integer in powers of 2. With the mul123 example for instance
<br/>
<br/>
64 + 32 + 16  + 8 + 2 + 1 = 123
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
uint mul123 ( uint val ) {
<br/>
  return ( val &lt;&lt; 6 ) + ( val &lt;&lt; 5 ) + ( val &lt;&lt; 4 ) + ( val &lt;&lt; 3 ) + ( val &lt;&lt; 1) + val;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148590 - wintermute - Mon Jan 07, 2008 7:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">61 questions pretty much says that they just want 61 quick answers to me!</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, but this sort of binary arithmetic is a quick answer if you already know the answer. Not so much if you've never seen any of this kind of thing before.
<br/>
<br/>
Do things like this get taught on any programming courses anywhere? I remember a lot of this kind of theory from when I learned z80 a long, long time ago but I've worked with several graduate programmers who didn't have a firm grasp on binary logic never mind this sort of manipulation.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148592 - Miked0801 - Mon Jan 07, 2008 7:35 pm</h4>
    <div class="postbody"><span class="postbody">Or, if you can subtract, you can reduce your mul further to :
<br/>
128 - 4 - 1
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
return (val &lt;&lt; 7) - (val &lt;&lt; 2) - val;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Which is probably the answer they wanted.  Bit-shifting and binary operators are kinda a lost art anymore.  It's this lack of knowledge that makes most new programmers have no clue about how fixed point arithmetic works.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148594 - Miked0801 - Mon Jan 07, 2008 7:42 pm</h4>
    <div class="postbody"><span class="postbody">BTW, Jim E, I loved your solution.  I immediately went to the cmp, adc, sbc solution, but yours is much nicer/quicker for the problem at hand.  Factoring like that is brilliant, and I should have seen it earlier.  I never realized that a divide by seven had such a regular pattern in binary.  Very pretty.
<br/>
<br/>
A new technique has been added to my toolbox :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148595 - simonjhall - Mon Jan 07, 2008 7:44 pm</h4>
    <div class="postbody"><span class="postbody">I've suggested this dividing question to the head of my group so they can stick it in their programming test. It's gotta be more interesting than macro questions that have '++' in them :-)
<br/>
<br/>
...but yeah, I do believe bit shifting and bit manipulation etc is becoming a lost art. But there's a reason for this - it nakes difficult to read and understand code!
<br/>
I recently converted a piece of heavily-optimised assembler that I'd written to C (yeah...) and this C version was pretty unreadable as a result! It does make you look pretty 1337 though, and makes it harder (or easier?) for them to fire you.<br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148606 - kusma - Mon Jan 07, 2008 9:22 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>simonjhall wrote:</b></span></td> </tr> <tr> <td class="quote">But there's a reason for this - it nakes difficult to read and understand code!</td> </tr></table><span class="postbody">
<br/>
Not to mention that it's slow on modern CPUs :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148607 - Jim e - Mon Jan 07, 2008 9:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Do things like this get taught on any programming courses anywhere? I remember a lot of this kind of theory from when I learned z80 a long, long time ago but I've worked with several graduate programmers who didn't have a firm grasp on binary logic never mind this sort of manipulation.</td> </tr></table><span class="postbody">Most of the programming teachers I've met don't have a firm grasp of such low levelness. People just seem to take division, multiplication and square roots for granted.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//-----------------
<br/>
// Jim e
<br/>
// Divide by 7 using reciprocal multiplication
<br/>
// (2^32)/7 = 100 100 100 100 100 100 100 100 100 100 . 1
<br/>
unsigned int div7(unsigned int val) {
<br/>
   unsigned long long num = val;   // 0
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 1
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 2
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 3
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 4
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 5
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 6
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 7
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 8
<br/>
   num &lt;&lt;= 3;
<br/>
   num  += val;      // 9
<br/>
   num &lt;&lt;= 2;   
<br/>
   //Correct accuracy pass 1/3 mark
<br/>
   if (val &lt; 0x55555555 ) num += val;
<br/>
   else num += ((val&gt;&gt;1)+(val&gt;&gt;3));
<br/>
   return num&gt;&gt;32;
<br/>
}</td> </tr></table><span class="postbody">I added correction for the accuracy, which happens to fail at 1.5 billion or so. So now its identical to divide by 7. Assembler its generally a good idea to unroll loops with few iterations, it saves registers and potentially a good chunk of time.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148608 - Cearn - Mon Jan 07, 2008 9:46 pm</h4>
    <div class="postbody"><span class="postbody">Divide-and-conquer is also fun here:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
/* N = (2^20+7-1)/7 = 149797
<br/>
                      100100100100100101  =
<br/>
                  1001001001001001*100+1  =
<br/>
           1001001 *    1000000001*100+1  =
<br/>
 (((1000+1)*1000+1)*(1000000000+1)*100+1
<br/>
*/
<br/>
unsigned int div7(unsigned int x)
<br/>
{
<br/>
   unsigned int y;
<br/>
<br/>
   y= (x&lt;&lt;3) + x;
<br/>
   y= (y&lt;&lt;3) + x;
<br/>
   y= (y&lt;&lt;9) + y;
<br/>
   y= (y&lt;&lt;2) + x;
<br/>
   return y &gt;&gt; 20;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Note that ARM can do <span style="font-style: italic">x</span>*(1 + 2^<span style="font-style: italic">n</span>) in one instruction, so this should be pretty fast (if multiplication is not allowed, of course). 
<br/>
<br/>
Theoretically, the lower limit for an accurate result with 20 bits is roughly 350000, but you already overflow 32 bits on the 'multiplication' at 28672. Ironically, you get double the safe range by using less bits in this case, since the limit for 19bits is 57344.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148638 - naleksiev - Tue Jan 08, 2008 3:31 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>wintermute wrote:</b></span></td> </tr> <tr> <td class="quote">What he's doing here is factoring 1/7 in powers of two.
<br/>
(1 + 4 + 32 + 256 + 2048 + 16384 + 131072) / 1048576 = ~ 1/7
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'll try to explain again what I didn't understand.
<br/>
<br/>
actualy (<span style="font-weight: bold">0.5</span> + 4 + 32 + 256 + ...) &gt;&gt;32 should be more accurate
<br/>
<br/>
check the Jim e's post 
<br/>
100100100100100100100100100100<span style="font-weight: bold"> . 1</span>
<br/>
<br/>
I did understand how it works from the explanation then I tried to write it myself without looking how Jim e implemented it and mine was wrong about 14% errors +/- 1. Then I run Jim e's implementation and I found no errors. 
<br/>
<br/>
That's why I'm asking how he come up with the +1 instead of +0.5</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148642 - Jim e - Tue Jan 08, 2008 4:31 am</h4>
    <div class="postbody"><span class="postbody">This value comes from saying (2^32) / 7 = 100100100100100100100100100100 . 1.  However if you try 100100100100100100100100100100 . 1 * 7 it will not equal (2^32).
<br/>
<br/>
This is all 32 bits, plus that one decimal bit.
<br/>
001 001 001 001 001 001 001 001 001 001 00 . 1
<br/>
So that multiplied by 7 equals
<br/>
111 111 111 111 111 111 111 111 111 111 11 . 1
<br/>
No matter what, it will never fully restore to 2^32 unless you round up. Basically its the same problem calculators face with 1/3 = 0.3333333...
<br/>
<br/>
<br/>
So I then have to make a choice of what digit to round up from.  Logically I should add val&gt;&gt;1 + val&gt;&gt;4 + val&gt;&gt;7, but it just doesn't work out.
<br/>
<br/>
So for smaller numbers I round up the first digit in the fraction part, That's where <span style="font-weight: bold">num += val;</span> when val is less than (2^32)/3 comes from.
<br/>
<br/>
When the number is larger I need a bit more accuracy to round up from.
<br/>
Thats where <span style="font-weight: bold">num += ((val&gt;&gt;1)+(val&gt;&gt;3)); </span> comes from, its a rounded up form of <span style="font-weight: bold">(val&gt;&gt;1) + (val&gt;&gt;4)</span>.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148675 - Cearn - Tue Jan 08, 2008 8:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">BTW, Jim E, I loved your solution.  I immediately went to the cmp, adc, sbc solution, but yours is much nicer/quicker for the problem at hand.  Factoring like that is brilliant, and I should have seen it earlier.  I never realized that a divide by seven had such a regular pattern in binary.  Very pretty.
<br/>
<br/>
A new technique has been added to my toolbox :)</td> </tr></table><span class="postbody">
<br/>
It seems that for every 2^<span style="font-style: italic">n</span>-1 you have such a pattern. For any integer <span style="font-style: italic">B</span>, you have:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// No math symbols *sigh*
<br/>
<br/>
  SUM(i=0..N, (1/B)^i ) = (1 - (1/B)^(N+1))/(1 - 1/B)
<br/>
                        = (B - B^(-N))/(B-1)
<br/>
                        = B/(B-1) - B^(-N)/(B-1)
<br/>
<br/>
For N -&gt; inf : 
<br/>
  SUM(i=0..inf, (1/B)^i) = B/(B-1)
<br/>
or
<br/>
  SUM(i=1..inf, (1/B)^i) = 1/(B-1)
<br/>
</td> </tr></table><span class="postbody">
<br/>
With B=8, you get 1/7 = SUM( (1/8)^i ) = 0.001001001... (binary)
<br/>
With B=16, you get 1/15 = SUM( (1/16)^i ) = 0.000100010001... (binary)
<br/>
With B=10, you get 1/9 = 0.111... (decimal). Multiply by 9 and you get  1 = 0.9999...  :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#148694 - Miked0801 - Tue Jan 08, 2008 11:27 pm</h4>
    <div class="postbody"><span class="postbody">I had though the same thing.  Probably something similiar with n+1 as well from  1/11 = 0.0909... and such.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
