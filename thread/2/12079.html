<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Programming problem: multiple array removals!!! - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>OffTopic > Programming problem: multiple array removals!!!</h2>
<div id="posts">
<div class="post">
    <h4>#114159 - keldon - Thu Jan 04, 2007 7:13 pm</h4>
    <div class="postbody"><span class="postbody">The problem of the domain was dealing with managing the falling of blocks in Tetris. If you clear a line, then all of the above lines will have to fall down. However if you extend this to a bigger domain you can consider a single array where you are removing a number of elements from it and you want to output the offsets that the new array will have. For example if you have a 10 element array and you are removing the 7th element (starting from 0) then elements 7,8, and 9 will be offset by 1
<br/>
<br/>
Input begins with the size of the array followed by the number of elements to be removed; the elements to be removed are given on the next line seperated by a space. So for this example you have:
<br/>
<br/>
// sample input
<br/>
10 1
<br/>
7
<br/>
// sample output
<br/>
0 0 0 0 0 0 0 1 1 1
<br/>
<br/>
Here is another example where elements 0,1,3, 5 and 8 are removed
<br/>
// sample input
<br/>
20 5
<br/>
0 1 3 5 8
<br/>
// sample output
<br/>
2 3 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
<br/>
<br/>
To make things more complicated the array size can be 2000000, the list of numbers to remove are not ordered, and this is a time critical task; so all solutions are limited to 10 seconds of execution!!! Leway is allowed for slower processors; just as a guideline to the complexity of the problem you.
<br/>
<br/>
Here is the generator code so that you could try out your own data. I would advise all those who are not sure of their solutions speed to change the Size, and also note that the lower the ration of Size:Removed the longer this takes to generate problems.
<br/>
<br/>
Note that I have created a problem creator/solver at <a href="http://thedrugzone.co.uk/LaMightySolution.jar" target="_blank">http://thedrugzone.co.uk/LaMightySolution.jar</a> , copy it to your desktop as it creates its output files in the same directory!
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// Generator.java
<br/>
import java.io.FileNotFoundException;
<br/>
import java.io.FileOutputStream;
<br/>
import java.io.PrintWriter;
<br/>
<br/>
<br/>
public class Generator {
<br/>
   /** number of elements removed from array */
<br/>
   public static final int Removed = 5000000;
<br/>
   
<br/>
   /** size of array */
<br/>
   public static final int Size = 10000000;
<br/>
   
<br/>
   public static void main ( String argv [] ) throws FileNotFoundException {
<br/>
      if ( Size &lt; Removed ) {
<br/>
         System.out.println ("Recompile with Size &gt; Removed");
<br/>
      }
<br/>
      
<br/>
      boolean [] b = new boolean [Size];
<br/>
      int numbers[] = new int[Removed];
<br/>
      
<br/>
      System.out.println("Generating problem!");
<br/>
      
<br/>
      for ( int i = 0; i &lt; Size; i ++ ) b[i]=true;
<br/>
      
<br/>
      int total = 0;
<br/>
      while ( total &lt; Removed){
<br/>
         int rand = (int)(Math.random() * (double)Size);
<br/>
         rand = (rand==Size)?rand-1 : rand;
<br/>
         
<br/>
         if ( b[rand] ){
<br/>
            b[rand] = false;
<br/>
            numbers[total++] = rand;
<br/>
         }
<br/>
      }
<br/>
      
<br/>
      PrintWriter out = new PrintWriter(new FileOutputStream ("problem.txt"));
<br/>
      out.println(Size + " " + Removed);
<br/>
      for ( int i = 0; i &lt; Removed; i ++ ) {
<br/>
         out.print(numbers[i] + (i==Removed-1?"":" "));
<br/>
         if ( i%1000 == 0 ) out.flush();
<br/>
      }
<br/>
      out.close();
<br/>
      
<br/>
      System.out.println("Problem saved as problem.txt");
<br/>
      
<br/>
      
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114168 - gauauu - Thu Jan 04, 2007 9:20 pm</h4>
    <div class="postbody"><span class="postbody">While there might be some "tricky" solutions that do things faster, wouldn't the relatively straightforward solution be nearly optimal?  It's O(n) + whatever your sort requires (probably O(n log n)ish.  although the n in that case is the list to be removed, which certainly cuts things down in most practical cases).  This is untested, but illustrates the general principle....
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//this pretends memory management doesn't need to exist....
<br/>
int* getOffsets(int totalNum, int numRemoved, int * removed)
<br/>
{
<br/>
   //get these bad boys in order
<br/>
   int* list = doSomeFastSort(removed, numRemoved);
<br/>
<br/>
   int offsets[totalNum - numRemoved];
<br/>
<br/>
   //ctr keeps track of how big offset so far, also which 
<br/>
   //item we are in the removed list (it's the same thing)
<br/>
   int ctr = 0;
<br/>
   int * offsetPos = (int*)offsets;
<br/>
<br/>
   for (int i = 0; i &lt; numRemoved; i++)
<br/>
   {
<br/>
<br/>
      int todo = list[i] - ctr;
<br/>
<br/>
      for (int j = 0; j &lt; todo; j++)
<br/>
      {
<br/>
         *offsetPos++ = ctr;
<br/>
      }
<br/>
<br/>
      ctr++;
<br/>
   }
<br/>
<br/>
   //fill in the rest of the values
<br/>
   int todo = numRemoved - ctr;
<br/>
<br/>
   for (int j = 0; j &lt; todo; j++)
<br/>
   {
<br/>
      *offsetPos++ = ctr;
<br/>
   }
<br/>
<br/>
   return offsets;
<br/>
}
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114176 - tepples - Thu Jan 04, 2007 11:36 pm</h4>
    <div class="postbody"><span class="postbody">I thought of a similar solution that involves pushing the line numbers into a priority queue and then popping them out one by one (at every offsetPos++). This is equivalent to gauauu's solution where doSomeFastSort == heapsort.
<br/>
<br/>
I can see how the specification for this programming puzzle might suit <span style="font-style: italic">some</span> variants of the Soviet Mind Game. The problem here is that it doesn't match up for all variants, including variants that have shown up in more than one <span style="font-style: italic">Tetris</span> brand product. Apart from the naive solution of moving blocks down by exactly <span style="font-style: italic">n</span> rows if <span style="font-style: italic">n</span> lines have been cleared beneath them, there are at least two other common types of <a class="postlink" href="http://www.tetrisconcept.com/wiki/index.php/Line_clear#Line_clear_gravity" target="_blank">gravity after line clear</a> in falling block puzzle games. Carbon Engine (basis for TOD) implements "sticky", while Lockjaw Engine (basis for post-TOD games) implements all three types as of version 0.28.
<br/>
<br/>
But there's another application of this code: the output data format is exactly that used by HDMA to the Y offset of text backgrounds on the GBA and DS, where the list of numbers is the list of scanlines to skip.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114186 - keldon - Fri Jan 05, 2007 1:45 am</h4>
    <div class="postbody"><span class="postbody">Well one thing to remember is the knock on effect produced by nearby removals. For example if you remove both the elements at 0,1,2 and 3, then the first offset will be 4. And yes, the solution is O(N); that is why it is possible to do it with a size of 10'000'000 in around 10 seconds.
<br/>
<br/>
I never knew of any other application for this type of code, the thought had not crossed my mind; despite the scenario I wrote. Well I have other problems that are interesting (but not created by me):
<br/>
<br/>
<span style="font-weight: bold">Q1</span>: Arrange all of the numbers from 1-15 so that the sum of two adjacent cells is always a perfect square
<br/>
<br/>
<span style="font-weight: bold">Q2</span>: In the tree-like pattern shown below, the number in every circle form the second row upwards is the sum of the two numbers in the two circles below it. All the circles have different positive whole numbers
<br/>
<br/>
[the bottom of the tree is 2,4,1,7,3]
<br/>
<br/>
(a) How should the five circles at the bottom row be numbered so that when all the others are filles in as above, the top circles has the least possible number. Remember, no two circles should have the same number
<br/>
<br/>
(b) Find numbers for the base so that the top circles is a specific number, say 91. Again, there should be no repetitions.
<br/>
<br/>
I looked at this one and found that if you label the base as a,b,c,d,e that the top of the tree is a+4b+6c+4d+e 
<br/>
<br/>
<span style="font-weight: bold">Q4</span>: Here is a short list of numbers having a common difference (of 43):
<br/>
<br/>
if we read down the list in columns we read:
<br/>
1  2  7  1  9  2  5
<br/>
<br/>
On the same system (but not a difference of 43, what list of numbers gives:
<br/>
1  1  1  8  2  5  9  7  2  7  2  ?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
