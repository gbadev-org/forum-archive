<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Compiler optimising tech - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>OffTopic > Compiler optimising tech</h2>
<div id="posts">
<div class="post">
    <h4>#157682 - simonjhall - Tue May 27, 2008 8:26 pm</h4>
    <div class="postbody"><span class="postbody">I've been recently reading some of that old stuff that Chris Hecker did in the day for Game Developer Magazine and a few of interest to me are about the optimising ability of your compilers. He goes on to test a bunch of compilers (many of which don't exist any more) and tries to get them to generate the best code *without using assembly* with a bit of gentle persuasion.
<br/>
<br/>
<a href="http://chrishecker.com/images/a/ac/Gdmcomp1.pdf" target="_blank">http://chrishecker.com/images/a/ac/Gdmcomp1.pdf</a>
<br/>
<a href="http://chrishecker.com/images/d/db/Gdmcomp2.pdf" target="_blank">http://chrishecker.com/images/d/db/Gdmcomp2.pdf</a>
<br/>
<br/>
First article's about PowerPC code and the second is about Intel.
<br/>
In these articles he talks about the steps that a compiler will perform in order to transform your code into the best meta code before it's turned into machine code and when you can do to make it easier/harder for the compiler to do its job.
<br/>
<br/>
After reading them I thought "ok, let's see how much compiler tech has advanced in the last ten years" and tried Visual C++ (.NET 2003) and a PowerPC GCC (4.something) with the some of the examples.
<br/>
The biggest surprise is that many of the results are worse! The code generation was really poor! (obviously compiler optimisation has improved in other areas though)
<br/>
<br/>
Worth a read if you're bored.
<br/>
<br/>
<span style="font-size: 9px; line-height: normal">This post was dedicated to all the losers out there who are convinced that the inline and const keywords allow your code to run in zero time</span><br/>_________________<br/><span style="font-weight: bold"><a class="postlink" href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=simonjhall%40gmail%2ecom&amp;no_shipping=2&amp;no_note=1&amp;tax=0&amp;currency_code=GBP&amp;lc=GB&amp;bn=PP%2dDonationsBF&amp;charset=UTF%2d8" target="_blank">Big thanks to everyone who donated for Quake2</a></span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157689 - silent_code - Tue May 27, 2008 9:16 pm</h4>
    <div class="postbody"><span class="postbody">"zero time" big laugh! X?D
<br/>
yeah, it's actually scary how much of the "rather recent" holy &lt;youknowwhat&gt; isn't true anymore. now think about how much (i mean much, not many!) people learn off of old tutorials on the net... scary i say!<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157714 - Maxxie - Wed May 28, 2008 12:32 am</h4>
    <div class="postbody"><span class="postbody">On a qick look through Listing5 and 6 in the first pdf, i think he is missing, that the compiler has to expect that the different pointers (through the [][] and *) might be the very same dereferenced variable.
<br/>
<br/>
In the hand-optimization he is doing a change in the execution order (bundles all reads, sets writes to the end), which would cause different results of Listing5 and 6 if some pointeroverlapping would happen:
<br/>
In Listing6 the compiler can expect that once it has read the data into a register that the source will not change by an interrupting write (until the next write happens at the end)
<br/>
<br/>
In detail: In Listing5 it has to make sure to update the read value after the write as it might be changed. Thus in Listing5, everytime pSourceVector[*] is used it has to fetch it's content again. It needs 3 reads for 3 (we know: equal) multiplications.
<br/>
In Listing6 it can assume - because only writes only happen to local vars that were created after the pointers - that pSourceVector[*] keeps the same (it can't have changed within own code, and neither via concurrent events [as they are not volatile]) therefor the one read can be applied to three (the compiler knows: equal) multiplications.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
