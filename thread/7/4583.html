<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Mode 0 - help! - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>C/C++ > Mode 0 - help!</h2>
<div id="posts">
<div class="post">
    <h4>#31280 - ImInABand - Thu Dec 09, 2004 3:30 pm</h4>
    <div class="postbody"><span class="postbody">ok, i still have no idea how to start and run a tile mode.
<br/>
<br/>
could anyone help me on this?  if anyone could tell me how to initialize a tile mode, and using an example tileset and map, show me how to make scrolling bg maps?
<br/>
<br/>
if anyone could help me on this, i would be ever grateful.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31295 - pyros - Thu Dec 09, 2004 6:46 pm</h4>
    <div class="postbody"><span class="postbody">Tonc have sections called:
<br/>
<br/>
Video Introduction. 
<br/>
Regular tiled backgrounds. 
<br/>
Regular tiled backgrounds. 
<br/>
<br/>
as well as plenty more. I have used it to find out how to do rotated sprites and backgrounds and it's very useful indeed.
<br/>
<br/>
<a href="http://user.chem.tue.nl/jakvijn/tonc/toc.htm" target="_blank">http://user.chem.tue.nl/jakvijn/tonc/toc.htm</a>
<br/>
<br/>
Also see:
<br/>
<br/>
<a href="http://www.thepernproject.com/" target="_blank">http://www.thepernproject.com/</a>
<br/>
<br/>
or Sources at <a href="http://www.gbadev.org" target="_blank">http://www.gbadev.org</a>
<br/>
<br/>
and use: <a href="http://www.work.de/nocash/gbatek.htm" target="_blank">http://www.work.de/nocash/gbatek.htm</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31866 - ImInABand - Wed Dec 15, 2004 2:11 pm</h4>
    <div class="postbody"><span class="postbody">wow, i did it.  i cant believe i actually did it.  After about 2 consecutive hours or so of staring at TONC and pern's RPG v3 demo I was able to pool enough knowledge to get mode 0 working.  wow!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31871 - Lord Graga - Wed Dec 15, 2004 4:18 pm</h4>
    <div class="postbody"><span class="postbody">Can I have your babies?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31929 - ImInABand - Thu Dec 16, 2004 12:55 am</h4>
    <div class="postbody"><span class="postbody">*smacks head*
<br/>
<br/>
ok, another dilemma:
<br/>
<br/>
I'm trying to initilize sprites and place an unmoving sprite in the canter of the screen, whilst the bg moves around it.  i get two outputs of which one of them is where nothing happens, or there is a black 8x8 square at the top left corner of the screen, stays there regardless of BG scrolling.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   memcpy( (u16 *)0x06010000, &amp;soldierData, sizeof(soldierData) );
<br/>
<br/>
   sprites[0].attribute0 = COLOR_256 | TALL | 112;
<br/>
   sprites[0].attribute1 = SIZE_8 | 72;
<br/>
   sprites[0].attribute2 = 0;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
mode 0, BG0 is enabled, obj and 1d mapping are enabled.
<br/>
<br/>
does there seem to be anything amiss?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31931 - ScottLininger - Thu Dec 16, 2004 1:36 am</h4>
    <div class="postbody"><span class="postbody">Are you using VisualBoy Advance?
<br/>
<br/>
If so, use the tile viewer to 1st make sure that your tile data is getting copied into the sprite tile memory. If it is, you'll be able to see the sprite tiles for your soldier sitting right there.
<br/>
<br/>
A few common problems:
<br/>
<br/>
1. Not copying in your sprite palette, which can give you black or oddly colored sprites. If you have all of your sprite palette entries set to 0x0000 (black), then this could give you the "black square" problem.
<br/>
<br/>
2. Not copying from your sprites[] array into OAM. OAM is what actually gets stuff displayed. 
<br/>
<br/>
3. Having your source graphic generated as a linear bitmap array rather than a "tiled" array. This is hard to explain, but the idea is that tiled gfx are a different order than a "flat" bitmap. Make sure you're using the appropriate gfx converter. (though this would generally give you garbled sprites rather than nothing at all.)
<br/>
<br/>
You probably have already checked the above, but it's hard to tell from your source. You may want to post a wider view of your code.
<br/>
<br/>
Cheers,
<br/>
<br/>
Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31935 - ImInABand - Thu Dec 16, 2004 2:32 am</h4>
    <div class="postbody"><span class="postbody">i used vba to debug some of this, and i look at the sprite tool, and none of the parameters i set for sprite 0 are correct, in fact they are the default values.  i don't understand this, because i am going about this the _exact_ way i do when im working in mode 4, since sprites operate the same regardless of mode</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#31988 - ScottLininger - Thu Dec 16, 2004 5:42 pm</h4>
    <div class="postbody"><span class="postbody">How are you copying your map tiles into VRAM? Since Sprite tile RAM starts where map VRAM ends, it's possible that you're overwriting your sprite tiles.
<br/>
<br/>
But it sounds more like there's a step missing in your copy to OAM step. Are you waiting for Vblank before copying to OAM? You can only copy to OAM during VBlank, so the standard approach is to do this *immediately* once VBlank begins.
<br/>
<br/>
-Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32075 - ImInABand - Fri Dec 17, 2004 11:38 pm</h4>
    <div class="postbody"><span class="postbody">its ok, i figured out what was wrong.  syntax error that the compiler somehow overlooked [maybe not an ERROR, but the code was missing a few characters to make the code work properly]
<br/>
<br/>
everything is fine now, problem solved, and i am in mode 0 just fine now.
<br/>
<br/>
=)
<br/>
<br/>
quick question though, concerning VRAM writes:
<br/>
<br/>
I used to implement the map data using a loop, as such [mode 4 example, but the principle is the same]:
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 loop;
<br/>
<br/>
for(loop = 0, loop &lt; 256, loop++){
<br/>
FrontBuffer[loop] = BGdata[loop];
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I did a similar thing when i initially used mode 0, just took another declared variable, and two for() expressions.  i yesterday found that you get the same output when you use the memcpy() command, writing the map data directly into VRAM.  
<br/>
<br/>
Is there any sort of downfall to using memcpy(), or is it one of the many cases in C where you can do one thing in a completely different way and still get the same output?
<br/>
<br/>
[/code]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32087 - pyros - Sat Dec 18, 2004 2:14 am</h4>
    <div class="postbody"><span class="postbody">not sure about memcpy() but DMA3 is good for stuff like that. well if you need speed it's handy. tonc also covers it. not so useful if you're only say writing a section of a 2D map rather than the full width though, as it is a linear copy.
<br/>
<a href="http://user.chem.tue.nl/jakvijn/tonc/dma.htm" target="_blank">http://user.chem.tue.nl/jakvijn/tonc/dma.htm</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32406 - Cearn - Wed Dec 22, 2004 12:40 pm</h4>
    <div class="postbody"><span class="postbody">A not-so-little post on memory copies:
<br/>
<br/>
<span style="font-size: 18px; line-height: normal">--&lt; <span style="font-weight: bold">ABSTRACT</span> &gt;--</span>
<br/>
Copy methods on the GBA are like standards: there are so many to choose from. DMA, BIOS, loops, memcpy, and <span style="font-style: italic">then</span> there are still such things as IWRAM vs ROM/EWRAM and ARM vs THUMB code. Although they all do the same thing, where they differ is speed, so here's a list of various ways of copying speeds, as reported by the GBA timers. These tests look at copying data from ROM/EWRAM to VRAM. Compilation was done with -O2 optimization, with interworking on and tests were performed on both hardware and emulator, and under different devkits.
<br/>
<br/>
The main results were:
<br/>
<ul><li>With the exception of the u16 index/u16 array loop-copy, there is <span style="font-weight: bold">no</span> difference between dkArm and dkAdv-r5b3 
<br/>
</li><li> Test were run on a regular GBA, GBA-SP (no difference here fortunately), no$gba and vba. ROM tests were done only on no$gba. Do <span style="color: red"><span style="font-weight: bold">not</span></span> use vba for profiling. no$ does a very good job, though strangely does not work properly for the BIOS functions.
<br/>
</li><li> For copies, <span style="font-weight: bold">DMA</span> is fastest (2 cycles/byte), closely followed by <span style="font-weight: bold">CpuFastSet</span> (2.23). <span style="font-weight: bold">TILE-copy</span> (especially ARMed and IWRAMed) deserves a special mention too, as does <span style="font-weight: bold">memcpy</span>.
<br/>
</li><li> Results for loop-copies depend greatly on where you put them and which instruction set they use. but even in the best case they don't measure up to the earlier mentioned methods. And in the worst case, well, let's not go there.
<br/>
</li></ul>A zip-file with the full results, ROM/multiboot images and code can be found <a class="postlink" href="http://user.chem.tue.nl/jakvijn/files/profile_.zip" target="_blank">here</a>
<br/>
<br/>
<span style="font-size: 18px; line-height: normal">--&lt; <span style="font-weight: bold">TEST CONDITIONS</span> &gt;--</span>
<br/>
Tests were performed on various methods of data-copying, using the GBA timers. Basically, I set up a cascade timer, the lower one using 1 tick/cycle, run the copy-code, then stop the timers. This will give me a 32bit cycle-count for N bytes copied. Using N=38400 and 8192, these numbers will give a cycles/bytes copied value for each of the test cases.
<br/>
<br/>
Profiling macros:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define PROF_START() {                     \
<br/>
   REG_TM2CNT= 0; REG_TM3CNT= 0;       \
<br/>
   REG_TM3CNT= TM_ON | TM_CASCADE;     \
<br/>
   REG_TM2CNT= TM_ON;  }
<br/>
<br/>
#define PROF_END(__time)                  \
<br/>
{   REG_TM2CNT= 0; __time=(REG_TM3D&lt;&lt;16) | REG_TM2D;   }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Test cases:
<br/>
<ul><li>8192 and 38400 bytes to VRAM
<br/>
</li><li>dkARM vs dkADV 5b3
<br/>
</li><li>hardware vs no$gba vs VBA
<br/>
</li><li>EWRAM code/data (i.e. multiboot) vs ROM code/data
<br/>
</li><li>ARM+EWRAM/ROM vs THUMB+EWRAM/ROM vs ARM+IWRAM
<br/>
</li></ul>copy modes:
<br/>
<ul><li>DMA: 
<br/>
- <span style="font-weight: bold">DMA 16</span>: DMA by 16bits
<br/>
- <span style="font-weight: bold">DMA 32</span>: DMA by 32bits
<br/>
</li><li>BIOS
<br/>
- <span style="font-weight: bold">CpuSet</span> (32bits)
<br/>
- <span style="font-weight: bold">CpuFastSet</span>
<br/>
</li><li>good ol' <span style="font-weight: bold">memcpy</span>
<br/>
</li><li>manual looping in C
<br/>
- <span style="font-weight: bold">int/u16</span>: u16 array looped by int index
<br/>
- <span style="font-weight: bold">int/u32</span>: u32 array looped by int index
<br/>
- <span style="font-weight: bold">TILE</span>: TILE array looped by int index
<br/>
- <span style="font-weight: bold">u16/u16</span>: u16 array looped by u16 index
<br/>
</li></ul>
<br/>
A little more info on 'TILE copies': a tile is a struct defined as
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef struct { u32 data[8]; } TILE;
<br/>
</td> </tr></table><span class="postbody">
<br/>
and a copy goes like this 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int ii;
<br/>
TILE dst, src={ blah, blah};
<br/>
dst= src;
<br/>
</td> </tr></table><span class="postbody">
<br/>
This will copy the entire struct from src to dst. Yes, this works. Very well I might add.
<br/>
<br/>
<span style="font-size: 18px; line-height: normal">--&lt; <span style="font-weight: bold">RESULTS</span> &gt;--</span>
<br/>
Units are cycles/byte copied
<br/>
<span style="font-weight: bold">hw</span> = hardware
<br/>
<span style="font-weight: bold">x/y,z</span> = instruction set <span style="font-style: italic">x</span> in section <span style="font-style: italic">y</span>, data in section <span style="font-style: italic">z</span>
<br/>
<span style="font-style: italic">x</span> = T(humb) or A(rm)
<br/>
<span style="font-style: italic">y,z</span>= EW(RAM), IW(RAM) or RO(M)
<br/>
<br/>
Platform comparison
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
 MultiBoot | dkArm/hw | dkArm/no$ | dkArm/vba |dkA5b3
<br/>
-----------+----------+-----------+-----------+-------
<br/>
    DMA 16 |  2.00    |  2.00     |  0.01     |  2.00
<br/>
    DMA 32 |  2.00    |  2.00     |  0.00     |  2.00
<br/>
    CpuSet |  4.00    |  0.00     |  0.00     | -
<br/>
CpuFastSet |  2.23    |  0.00     |  0.00     | -
<br/>
    memcpy |  4.74    |  4.69     |  4.32     |  4.72
<br/>
   int/u16 | 14.53    | 14.50     | 11.50     | 14.53
<br/>
   int/u32 |  8.27    |  8.25     |  6.25     |  8.27
<br/>
      TILE |  3.44    |  3.41     |  3.22     |  3.45
<br/>
    u16/16 | 17.58    | 17.51     | 14.51     | 22.01
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Instruction-set / section comparison. Note that DMA, BIOS calls and memcpy are out of the users control, and cannot be put in IWRAM or be affected by instruction set.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
mode/sec,sec | T/EW,EW | A/IW.EW | T/RO,RO | AR/RO,RO
<br/>
-------------+---------+---------+---------+---------
<br/>
      DMA 16 |  2.00   |   -     |  2.00   |  2.00
<br/>
      DMA 32 |  2.00   |   -     |  2.00   |  2.00
<br/>
      CpuSet |  4.00   |   -     |   -     |  -
<br/>
  CpuFastSet |  2.23   |   -     |   -     |  -
<br/>
      memcpy |  4.74   |   -     |  5.82   |  5.82
<br/>
     int/u16 | 14.53   |  6.53   | 17.51   | 29.51
<br/>
     int/u32 |  8.27   |  4.00   |  9.75   | 14.26
<br/>
        TILE |  3.44   |  2.48   |  3.85   |  4.63
<br/>
      u16/16 | 17.58   |  7.78   | 20.50   | 35.51
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-size: 18px; line-height: normal">--&lt; <span style="font-weight: bold">CONCLUSIONS</span> &gt;--</span>
<br/>
<ul><li><span style="font-style: italic">On method of profiling</span>
<br/>
I did this with the timer registers (see macros given above). The DMA results agree with the <a class="postlink" href="http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#DMANote" target="_blank">CowBite's DMA Transfer ratings</a> and DekuTree's speed tests in <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=1803" target="_blank">this thread</a>, so if I screwed up somewhere at least I'm in good company.
<br/>
The macros do take a few cycles to start/stop, but since the copies themselves run well into the 10k-1M range, this should be insignificant.
<br/>
I don't get the 'exact' same count after every compile / hardware run. For example, the 38400 byte TILE copy with T/EW,EW had 675046 on the first try, but 674988 on the second. This is insignificant, though.
<br/>
</li><li><span style="font-style: italic">All hail DMA (and CpuFastSet too)</span>
<br/>
That DMA is best for copies shouldn't come as too much as a surprise, it's its sole purpose after all. That said, though, CpuFastSet is very close to it, and in the previously mentioned thread DekuTree showed that for memory fills the latter is actually faster. Read GBATek's entry on CpuFastSet carefully before using, though, data alignment could cause trouble. Also, DMA and BIOS have some overhead, so they may not be the best in copies in small doses.
<br/>
</li><li><span style="font-style: italic">memcpy</span>
<br/>
The memcpy function is actually pretty fast, usually beating the loop-copies. I guess one reason it's not seen often is because it might copy by <span style="font-weight: bold">bytes</span>, which wouldn't work for VRAM. See <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=1756" target="_blank">this thread</a> for example. Didn't notice anything of the sort for both dkArm, dkAdv-r5b3 or dkAdv-r4. I distinctly remember having similar problems a long time ago, but then I sometimes distinctly remember things that never happened. Maybe it's only a factor with small copies, I don't know.
<br/>
</li><li><span style="font-style: italic">Loop copies</span>
<br/>
Suck. Well, mostly. This is actually a very complicated case, as can be seen from the measurements. 
<br/>
Two major influences are where the code is stored and which instruction-set it uses. EWRAM and ROM are u16 areas, so the 32bit ARM instructions would take 2 fetches, which the 16bit THUMB code would only take one. While ARM code may need less instructions, it can't really compete with the double fetches, as one can see in the last two columns where ROM+THUMB consistently outperforms ROM+ARM by nearly a factor of 2. When you use IWRAM+ARM code, the opposite is true. In fact, you can get you can get pretty close to DMA/BIOS-routines here.
<br/>
A third major factor is the chunk-size per loop-iteration. The fact is that compiled code has 6 or more instructions PER ITERATION (yes, yes, I know you only need 3 if you punch in the assembly manually, but we're 
<br/>
talking about C-code here). That's regardless of type, so simply because you'd need twice as many iterations for a u16-array than a u32-array, it'll take twice as long. And using a u16 loop variable it'll take even longer, because it will include 2 extra shift instructions to cut the register down to 16bits, so an u16-array with a u16 loop variable is about the worst you can do. The GBA is a 32bit machine, remember? use 32bits variables where you can.
<br/>
The TILE-loop is another beast entirely, because it's a struct copy. If x and y are structs, then x=y copies the <span style="font-style: italic">whole</span> struct, that's why you use pointers when passing these to functions. Apparently, the compiler is smart enough to use stmia/ldmia (STore/LoaD Multiple ImmediAte) pairs for this. you will have a few more instructions per loop iteration, but also a lot fewer (less?) iterations, which is why this one's able to compete.
<br/>
Lastly, although not presented here, optimization-level also has a great effect here. The default (-O0) is absolutely hideous, especially for u16 arrays. O1 and O2 give the same results and strangely enough O3 is actually a little bit worse than O2.
<br/>
</li></ul></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32457 - Miked0801 - Thu Dec 23, 2004 1:46 am</h4>
    <div class="postbody"><span class="postbody">You're forgeting method 4 - the one I like to se on smaller copies - ldmia/stmia direct calls.  To get the compiler to do this for you, do struct to struct assignments.
<br/>
<br/>
typedef struct
<br/>
{
<br/>
u32 a, u32 b;
<br/>
}STRUCT_8_BYTES;
<br/>
<br/>
{
<br/>
    STRUCT_8_BYTES a,b;
<br/>
    a = b;
<br/>
}
<br/>
<br/>
or for other data
<br/>
<br/>
{
<br/>
    u8 data[16] = {sdjkfjsdkhfjklsd};
<br/>
    u32 dest[16];
<br/>
<br/>
   *( (STRUCT_8_BYTES *) dest) = *(STRUCT_8_BYTES *)data);
<br/>
}
<br/>
<br/>
This will beat all methods for less than about 48 bytes due to no setup time.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32475 - crossraleigh - Thu Dec 23, 2004 4:08 am</h4>
    <div class="postbody"><span class="postbody">Mike, isn't your technique the same as Cearn's TILE technique?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#32478 - tepples - Thu Dec 23, 2004 4:40 am</h4>
    <div class="postbody"><span class="postbody">I think the TILE technique uses a struct of 32 bytes, the size of one 16-color tile and half the size of the ARM7 register file:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">struct TILECOPY {
<br/>
  unsigned int a, b, c, d, e, f, g, h;
<br/>
} TILECOPY;</td> </tr></table><span class="postbody">
<br/>
CpuFastSet is just the TILE technique in an unrolled loop, possibly with Duff's device.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
