<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Keypad Interrupt Handling - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>C/C++ > Keypad Interrupt Handling</h2>
<div id="posts">
<div class="post">
    <h4>#1033 - Vortex - Mon Jan 13, 2003 8:58 pm</h4>
    <div class="postbody"><span class="postbody">I am working on a small program trying to call the "Sleep" mode using some of the GBA BIOS functions. 
<br/>
<br/>
My problem is I was not able to find any documentation how to implement a user interrupt handler for GBA. The only clue I have is from GBATEK:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
As shown above, a pointer to the 32bit/ARM-code user handler must be setup in [03007FFCh]. By default, 160 bytes of memory are reserved for interrupt stack at 03007F00h-03007F9Fh
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The explanation sounds very obscure - for example I cannot figure out is [03007FFCh] just a pointer to a function or the function code itself starts there. Also are there any special requirements for the interrupt handling function (like saving registers, etc.)
<br/>
<br/>
Your help will be appreciated.
<br/>
<br/>
Thank you</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1035 - Splam - Mon Jan 13, 2003 10:40 pm</h4>
    <div class="postbody"><span class="postbody">03007FFCh holds a pointer to the irq handler.
<br/>
<br/>
Check in your crt0.s  you should see something setting it up to point to some code. eg
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
        ldr     r1, =INTR_VECTOR_BUF    @ set interrupt address
<br/>
        adr     r0, intr_main
<br/>
        str     r0, [r1]
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
where intr_main is then the irq handler code.
<br/>
<br/>
There should be code near that that sets up the stack pointer for irq mode.
<br/>
<br/>
The basic irq handler usually included in crt0.s tends to be a case of, check which intterupt has been triggered then vector through a C jump table array to the required C routine.  That method is usually slower than necessary but is a good starting point because everything you would need is catered for.  Personally I do my interrupt code in ARM and do the handler and the code all in go which saves time (but I'm a speed freak).
<br/>
<br/>
If you do have the interupt enabled crt0.s then check for the intr_main function,  if you see that then you should also see something like ldr r1, =IntrTable
<br/>
That is fetching the pointer to the C array of irq routines which would be like this....
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const u32 IntrTable[]  = 
<br/>
{
<br/>
   VBLANK,
<br/>
   HBLANK,
<br/>
   VCOUNT,
<br/>
   TIMMER0,
<br/>
   TIMMER1,
<br/>
   TIMMER2,
<br/>
   TIMMER3,
<br/>
   COMUNICATION,
<br/>
   DMA0,
<br/>
   DMA1,
<br/>
   DMA2,
<br/>
   DMA3,
<br/>
   KEYBOARD,
<br/>
   CART
<br/>
};
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
You then just define all of those functions like so..
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void VBLANK()
<br/>
{
<br/>
   REG_IF |= INT_VBLANK;
<br/>
      
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
One for each member of the array  HBLANK, DMAs etc
<br/>
<br/>
That VBLANK code (and corresponding ones for each of the irq types) services the interrupt.  You just add what you want to that routine.
<br/>
<br/>
<br/>
Hope that helps some.  I'm dragging this stuff from oooold files when I did things the C way so I've probably missed lots out.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1103 - Vortex - Tue Jan 14, 2003 5:19 pm</h4>
    <div class="postbody"><span class="postbody">Thank you, sir, for the excellent explanation. I think you have a real talent for technical tutorials. If you decide to write a GBA book at some point please let me know - I will be the first one to buy it. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Personally I do my interrupt code in ARM and do the handler and the code all in go which saves time (but I'm a speed freak). 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Also I am happy that there is at least one "speed freak" left in a world of bloatware and "platform independent" languages :-)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
