<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>DIVIDE: gcc '/' operator vs. swi 0x60000 - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>C/C++ > DIVIDE: gcc '/' operator vs. swi 0x60000</h2>
<div id="posts">
<div class="post">
    <h4>#28455 - pyros - Sun Oct 31, 2004 10:02 pm</h4>
    <div class="postbody"><span class="postbody">It is frequently quoted that it is much faster to use swi 0x60000 than the '/' operator for division as the bios routine is far more efficient than the code that gcc produces.
<br/>
<br/>
However, all the examples i have seen put the bios call in a function which is then called to perform the division. The most concise i have seen is (tonc):
<br/>
<br/>
s32 SWIDiv(s32 num, s32 denom) { asm("swi 0x60000"); }
<br/>
<br/>
and division is performed:
<br/>
<br/>
quotient = SWIDiv(numerator,denominator);
<br/>
<br/>
<span style="font-weight: bold">Surely</span> calling this function means that all the current registers (and possibly more things) are pushed onto the stack causing what could well be more overhead than a simple '/' ?
<br/>
<br/>
So: which is faster in practice?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28459 - poslundc - Sun Oct 31, 2004 11:08 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>pyros wrote:</b></span></td> </tr> <tr> <td class="quote"><span style="font-weight: bold">Surely</span> calling this function means that all the current registers (and possibly more things) are pushed onto the stack causing what could well be more overhead than a simple '/' ?</td> </tr></table><span class="postbody">
<br/>
<br/>
Unfortunately, there's nothing simple about the '/'. Because the ARM7 CPU doesn't have a built-in divide operation, division needs to performed manually using an algorithm that GCC provides, which is very, very ugly.
<br/>
<br/>
The BIOS routine is the fastest alternative if you don't want to do any "real" work (ie. coding your own faster routine, or using a reciprocal lookup table). The overhead of calling the function is relatively negligible compared to the actual division algorithm; there are ways to speed up the entry/exit a bit but nothing I would say that's worth doing unless you find it's slowing down your code, at which point you should replace it with a faster custom algorithm anyway.
<br/>
<br/>
Bear in mind that code that looks more compact in C doesn't necessarily mean the code it generates will be either shorter or faster.
<br/>
<br/>
Another thing to keep in mind is that while GCC's general division is mega-ugly, the compiler is smart enough to do some basic optimizations for you. For example, if it sees you dividing by a constant, even power of two it will do a bitshift instead, or if you are dividing by a constant (but not an even power of two) it will do reciprocal multiplication, which is much, much faster than any division algorithm.
<br/>
<br/>
So don't necessarily shy away from using '/', so long as you are aware of what's happening when you use it.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28460 - DiscoStew - Sun Oct 31, 2004 11:08 pm</h4>
    <div class="postbody"><span class="postbody">The short version to answer your question:
<br/>
<br/>
The BIOS Divide is faster.
<br/>
<br/>
The long, and somewhat off-topic, version to answer your question:
<br/>
<br/>
Probably the best way to do division, in a sense, is to not do it. However, there will be those times where you really do need them.  The FAQ under the Beginner's group shows the order as to what is faster. One thing I would change in that FAQ is that creating an ASM divide function would be faster than the BIOS divide. There is one floating around here; made by a person named Peter Teichman (last name not correct) that is capable of doing divisions in IWRAM as fast as 51 cycles, whereas the BIOS takes hundreds more. Find it, and use it.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28463 - sajiimori - Sun Oct 31, 2004 11:36 pm</h4>
    <div class="postbody"><span class="postbody">As opposed to an odd power of two? =P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28464 - pyros - Sun Oct 31, 2004 11:39 pm</h4>
    <div class="postbody"><span class="postbody">Thankyou both for your help :)
<br/>
<br/>
I was mostly concerned about the function overhead as i had read in a c optimising tutorial that calling a function can require a lot of overhead (with stack pushes).
<br/>
<br/>
I'm dividing unknown numbers (0 to 65536) by other unknown numbers (256 to 512), so i guess that bios will be a lot faster than '/' even with gcc optimising. I shall certainly look up the as-fast-as-51cycle function though :) I'm guessing it could (maybe) be possible to optimise a routine if i'm not using the full 32bits.
<br/>
<br/>
Thankyou :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28467 - poslundc - Sun Oct 31, 2004 11:53 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">As opposed to an odd power of two? =P</td> </tr></table><span class="postbody">
<br/>
<br/>
As opposed to an uneven power of two, smarty. ;)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28471 - sajiimori - Mon Nov 01, 2004 12:36 am</h4>
    <div class="postbody"><span class="postbody">Now I'm curious.  What's an uneven power of two, and why would it prevent shift-divides?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28472 - poslundc - Mon Nov 01, 2004 12:50 am</h4>
    <div class="postbody"><span class="postbody">A power of two that is not a whole number.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28474 - sajiimori - Mon Nov 01, 2004 1:13 am</h4>
    <div class="postbody"><span class="postbody">Ah, I'm not used to thinking of exponents as fractions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28475 - DekuTree64 - Mon Nov 01, 2004 1:16 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>pyros wrote:</b></span></td> </tr> <tr> <td class="quote">I'm dividing unknown numbers (0 to 65536) by other unknown numbers (256 to 512), so i guess that bios will be a lot faster than '/' even with gcc optimising. I shall certainly look up the as-fast-as-51cycle function though :) I'm guessing it could (maybe) be possible to optimise a routine if i'm not using the full 32bits.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, you certainly can optimize it for less bits, but for dividing by such a small range as 256-512, I would definitely recommend a reciprocal table. And only dividing u16's makes it even easier, because you only need 16-bit reciprocals to get perfect accuracy. That means your table can be u16's to save memory, and you don't need to use a long multiply instruction (which involves a function call to switch to ARM mode). 
<br/>
Create your table with
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for(x = 256; x &lt; 512; x++)
<br/>
   table[x-256] = 65536/x;</td> </tr></table><span class="postbody">
<br/>
and to use it, do 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">result = numer * table[denominator-256] &gt;&gt; 16;</td> </tr></table><span class="postbody"><br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28477 - isildur - Mon Nov 01, 2004 1:22 am</h4>
    <div class="postbody"><span class="postbody">On my site, there is a divide routine coded in assembly. It is from Dooby.
<br/>
Here is the link:
<br/>
<br/>
<a href="http://www.geocities.com/v_d_d/gba/math.html" target="_blank">http://www.geocities.com/v_d_d/gba/math.html</a>
<br/>
<br/>
If someone has faster code for this (a general divide routine), please post it ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28499 - Miked0801 - Mon Nov 01, 2004 7:47 pm</h4>
    <div class="postbody"><span class="postbody">[url]
<br/>
<a href="http://www.peter-teichmann.de/adiv1e.html" target="_blank">http://www.peter-teichmann.de/adiv1e.html</a>
<br/>
[/url]
<br/>
<br/>
This will be 10-30% faster, but take more IWRAM</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28509 - isildur - Mon Nov 01, 2004 10:14 pm</h4>
    <div class="postbody"><span class="postbody">Thanks Mike, I will try it. :-)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
