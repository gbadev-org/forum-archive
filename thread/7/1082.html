<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Intro prob - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Intro prob</h2>
<div id="posts">
<div class="post">
    <h4>#5262 - maciel310 - Thu Apr 24, 2003 1:15 am</h4>
    <div class="postbody"><span class="postbody">Hi, I have a little problem making an intro for a game I am in the process of making. I have a some pictures that I made and I have it so when they press the A button it switches between them, but when I tested it, it would keep on going back to the first screen after changing the first time, so it would loop the same image instead of going on. How can I fix this? Ill post the code so you can see what I am doing wrong
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
#include "headers.h"
<br/>
<br/>
u16* theVideoBuffer = (u16*)VideoBuffer;
<br/>
u16* theScreenPalette = (u16*)BGPaletteMem;
<br/>
<br/>
#define RGB(r,g,b) (r+(g&lt;&lt;5)+(b&lt;&lt;10))		//Macro to build a color from its parts
<br/>
<br/>
int main()
<br/>
{
<br/>
	SetMode(MODE_4|BG2_ENABLE);
<br/>
<br/>
	if(!(*KEYS &amp; KEY_A))  //A
<br/>
{
<br/>
	//Copy the palette
<br/>
	u16 i;
<br/>
	for ( i = 0; i &lt; 256; i++ )
<br/>
	           theScreenPalette[ i ] = APalette[ i ];
<br/>
<br/>
	//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily
<br/>
	u16* tempData = (u16*)A;
<br/>
<br/>
	//Write the data
<br/>
	//Note we're using 120 instead of 240 because we're writing 16 bits
<br/>
	//(2 colors) at a time
<br/>
	u16 x, y;
<br/>
	for ( x = 0; x &lt; 120; x++ )
<br/>
	             for ( y = 0; y &lt; 160; y++ )
<br/>
		     theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ];
<br/>
<br/>
<br/>
		if(!(*KEYS &amp; KEY_A))   //B
<br/>
	{
<br/>
		//Copy the palette
<br/>
		u16 i;
<br/>
		for ( i = 0; i &lt; 256; i++ )
<br/>
		           theScreenPalette[ i ] = BPalette[ i ];
<br/>
<br/>
		//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily
<br/>
		u16* tempData = (u16*)B;
<br/>
<br/>
		//Write the data
<br/>
		//Note we're using 120 instead of 240 because we're writing 16 bits
<br/>
		//(2 colors) at a time
<br/>
		u16 x, y;
<br/>
		for ( x = 0; x &lt; 120; x++ )
<br/>
		             for ( y = 0; y &lt; 160; y++ )
<br/>
			     theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ];
<br/>
<br/>
<br/>
		if(!(*KEYS &amp; KEY_A))   //C
<br/>
	{
<br/>
		//Copy the palette
<br/>
		u16 i;
<br/>
		for ( i = 0; i &lt; 256; i++ )
<br/>
		           theScreenPalette[ i ] = CPalette[ i ];
<br/>
<br/>
		//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily
<br/>
		u16* tempData = (u16*)C;
<br/>
<br/>
		//Write the data
<br/>
		//Note we're using 120 instead of 240 because we're writing 16 bits
<br/>
		//(2 colors) at a time
<br/>
		u16 x, y;
<br/>
		for ( x = 0; x &lt; 120; x++ )
<br/>
		             for ( y = 0; y &lt; 160; y++ )
<br/>
			     theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ];
<br/>
<br/>
}
<br/>
}
<br/>
}
<br/>
<br/>
<br/>
	return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanx for any help</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5265 - johnny_north - Thu Apr 24, 2003 3:11 am</h4>
    <div class="postbody"><span class="postbody">In PC development, if you run off the end of main() with a return 0, your program exits to the operating system. Easy enough. On the GBA however, if you don't do something to capture the execution before this happens, the programm will begin to execute again at the first line of main(). So ineffect you will continue to "loop" through main() indefinitely. Just before returning 0 in main(), add the following line:
<br/>
<br/>
while(1){}
<br/>
<br/>
The reason you're only seeing the first screen is because your first button press will trigger all of the rest of your button tests. What you need to is capture the button presses after the first button press. This makes sure that the second screen is not displayed until the player first releases the A button. If you don't add this capture code, you'll blast by the other graphics. See what I mean:
<br/>
<br/>
#include "headers.h" 
<br/>
<br/>
u16* theVideoBuffer = (u16*)VideoBuffer; 
<br/>
u16* theScreenPalette = (u16*)BGPaletteMem; 
<br/>
<br/>
#define RGB(r,g,b) (r+(g&lt;&lt;5)+(b&lt;&lt;10)) //Macro to build a color from its parts 
<br/>
<br/>
int main() 
<br/>
{ 
<br/>
SetMode(MODE_4|BG2_ENABLE); 
<br/>
<br/>
if(!(*KEYS &amp; KEY_A)) //A 
<br/>
{ 
<br/>
//Copy the palette 
<br/>
u16 i; 
<br/>
for ( i = 0; i &lt; 256; i++ ) 
<br/>
theScreenPalette[ i ] = APalette[ i ]; 
<br/>
<br/>
//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily 
<br/>
u16* tempData = (u16*)A; 
<br/>
<br/>
//Write the data 
<br/>
//Note we're using 120 instead of 240 because we're writing 16 bits 
<br/>
//(2 colors) at a time 
<br/>
u16 x, y; 
<br/>
for ( x = 0; x &lt; 120; x++ ) 
<br/>
for ( y = 0; y &lt; 160; y++ ) 
<br/>
theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ]; 
<br/>
<br/>
while(*KEYS &amp; KEY_A){} //wait until the player releases the A button
<br/>
if(!(*KEYS &amp; KEY_A)) //B 
<br/>
{ 
<br/>
//Copy the palette 
<br/>
u16 i; 
<br/>
for ( i = 0; i &lt; 256; i++ ) 
<br/>
theScreenPalette[ i ] = BPalette[ i ]; 
<br/>
<br/>
//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily 
<br/>
u16* tempData = (u16*)B; 
<br/>
<br/>
//Write the data 
<br/>
//Note we're using 120 instead of 240 because we're writing 16 bits 
<br/>
//(2 colors) at a time 
<br/>
u16 x, y; 
<br/>
for ( x = 0; x &lt; 120; x++ ) 
<br/>
for ( y = 0; y &lt; 160; y++ ) 
<br/>
theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ]; 
<br/>
<br/>
while(*KEYS &amp; KEY_A){} //wait until the player releases the A button
<br/>
if(!(*KEYS &amp; KEY_A)) //C 
<br/>
{ 
<br/>
//Copy the palette 
<br/>
u16 i; 
<br/>
for ( i = 0; i &lt; 256; i++ ) 
<br/>
theScreenPalette[ i ] = CPalette[ i ]; 
<br/>
<br/>
//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily 
<br/>
u16* tempData = (u16*)C; 
<br/>
<br/>
//Write the data 
<br/>
//Note we're using 120 instead of 240 because we're writing 16 bits 
<br/>
//(2 colors) at a time 
<br/>
u16 x, y; 
<br/>
for ( x = 0; x &lt; 120; x++ ) 
<br/>
for ( y = 0; y &lt; 160; y++ ) 
<br/>
theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ]; 
<br/>
<br/>
} 
<br/>
} 
<br/>
} 
<br/>
<br/>
while(1){}
<br/>
return 0; 
<br/>
}</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5268 - maciel310 - Thu Apr 24, 2003 5:54 am</h4>
    <div class="postbody"><span class="postbody">Thank you for helping me out there. Checking to see when the button was release worked perfectly, but when I tried adding the line before return 0, my emulator just flashed really fast but wouldnt do anything, I think it was because the thing you do first is you have to push the button so it only gives a split second to allow you to press the button, so right now I dont think I want to have that in, but I will put that into the final thing. Thank you again for your help</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5276 - Maverick - Thu Apr 24, 2003 1:20 pm</h4>
    <div class="postbody"><span class="postbody">Here is your problem, you are doing:
<br/>
<br/>
Check for A then while A is being held, check for A, then while this A is being held, check for A.
<br/>
<br/>
When it gets A for the first time and you release it, the first check is then invalid so it continues to the end and seeing as there is no while(1); it will start all over again with the first check.
<br/>
<br/>
change it to this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include "headers.h" 
<br/>
<br/>
u16* theVideoBuffer = (u16*)VideoBuffer; 
<br/>
u16* theScreenPalette = (u16*)BGPaletteMem; 
<br/>
<br/>
#define RGB(r,g,b) (r+(g&lt;&lt;5)+(b&lt;&lt;10)) //Macro to build a color from its parts 
<br/>
<br/>
int main() 
<br/>
{ 
<br/>
SetMode(MODE_4|BG2_ENABLE); 
<br/>
<br/>
while(*KEYS &amp; KEY_A)
<br/>
{ 
<br/>
//Copy the palette 
<br/>
u16 i; 
<br/>
for ( i = 0; i &lt; 256; i++ ) 
<br/>
theScreenPalette[ i ] = APalette[ i ]; 
<br/>
<br/>
//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily 
<br/>
u16* tempData = (u16*)A; 
<br/>
<br/>
//Write the data 
<br/>
//Note we're using 120 instead of 240 because we're writing 16 bits 
<br/>
//(2 colors) at a time 
<br/>
u16 x, y; 
<br/>
for ( x = 0; x &lt; 120; x++ ) 
<br/>
for ( y = 0; y &lt; 160; y++ ) 
<br/>
theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ]; 
<br/>
}
<br/>
<br/>
while(*KEYS &amp; KEY_A)
<br/>
{ 
<br/>
//Copy the palette 
<br/>
u16 i; 
<br/>
for ( i = 0; i &lt; 256; i++ ) 
<br/>
theScreenPalette[ i ] = BPalette[ i ]; 
<br/>
<br/>
//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily 
<br/>
u16* tempData = (u16*)B; 
<br/>
<br/>
//Write the data 
<br/>
//Note we're using 120 instead of 240 because we're writing 16 bits 
<br/>
//(2 colors) at a time 
<br/>
u16 x, y; 
<br/>
for ( x = 0; x &lt; 120; x++ ) 
<br/>
for ( y = 0; y &lt; 160; y++ ) 
<br/>
theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ]; 
<br/>
}
<br/>
<br/>
while(*KEYS &amp; KEY_A)
<br/>
{ 
<br/>
//Copy the palette 
<br/>
u16 i; 
<br/>
for ( i = 0; i &lt; 256; i++ ) 
<br/>
theScreenPalette[ i ] = CPalette[ i ]; 
<br/>
<br/>
//Cast a 16 bit pointer to our data so we can read/write 16 bits at a time easily 
<br/>
u16* tempData = (u16*)C; 
<br/>
<br/>
//Write the data 
<br/>
//Note we're using 120 instead of 240 because we're writing 16 bits 
<br/>
//(2 colors) at a time 
<br/>
u16 x, y; 
<br/>
for ( x = 0; x &lt; 120; x++ ) 
<br/>
for ( y = 0; y &lt; 160; y++ ) 
<br/>
theVideoBuffer[ y * 120 + x ] = tempData[ y * 120 + x ]; 
<br/>
} 
<br/>
<br/>
while(1); 
<br/>
} 
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
