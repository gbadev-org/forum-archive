<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Dynamic tile assignments while scrolling? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>C/C++ > Dynamic tile assignments while scrolling?</h2>
<div id="posts">
<div class="post">
    <h4>#35837 - ImInABand - Fri Feb 11, 2005 8:09 am</h4>
    <div class="postbody"><span class="postbody">This is a topic that ive been pondering, but never really came up with a method of doing.  In most tile mode games that use scrolling, the bg's are written and rewritten as the character moves through the level.  anybody know of a few methods to accomplish this?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35864 - tepples - Fri Feb 11, 2005 5:28 pm</h4>
    <div class="postbody"><span class="postbody">Keep track of the visible area of the screen and the valid area of the map, both in world coordinates. Then whenever the visible area of the screen gets too close to the edge of the valid area of the map, write a new strip of map tiles and update the valid area. Is there anything specific that you need explained about this?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#35866 - jma - Fri Feb 11, 2005 5:38 pm</h4>
    <div class="postbody"><span class="postbody">Something to keep in mind is that the entire background is not "rewritten". Only a small fraction of it is. Take a side-scroller (moving from left to right) for example:
<br/>
<br/>
Using a single screenblock, increment the BG_n_SCROLL_X register as the player moves right. Once the scroll has been moved 8 pixels, the 20 vertical tiles on the right edge are just updated with the next batch from the level data. The only "difficulties" are in keeping track of which vertical column of tiles should be updated (0-31, then wrap again), when to update them (preferably before the player actually gets to them), and keeping track of where you are in your level data.
<br/>
<br/>
The GBA will wrap screen block data, so you don't need to worry about that (thank you, Nintendo), and the scroll registers all work out nicely so you can just keep incrementing them until they overflow (64K, if I remember correctly). 
<br/>
<br/>
Those are all simple problems, but are typically what people get hung up on.
<br/>
<br/>
HTH,
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#39156 - ImInABand - Tue Apr 05, 2005 6:38 am</h4>
    <div class="postbody"><span class="postbody">Yes, I came to a conclusion on simple dynamic tile assignment.
<br/>
<br/>
I came along with this when i made my text editor [yet unavailable on the web - polishing it first, getting the input configurations set well]
<br/>
<br/>
and i came up with a function that i simply call Write, but the way it works, it should rather be HWrite.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void Write(int ROW, int LETTER0, int LETTER1, int LETTER2, int LETTER3, int LETTER4, int LETTER5, int LETTER6, int LETTER7, int LETTER8, int LETTER9, int LETTER10, int LETTER11, int LETTER12, int LETTER13, int LETTER14, int LETTER15, int LETTER16, int LETTER17, int LETTER18, int LETTER19, int LETTER20, int LETTER21, int LETTER22, int LETTER23, int LETTER24, int LETTER25, int LETTER26, int LETTER27, int LETTER28, int LETTER29, int LETTER30, int LETTER31) {
<br/>
<br/>
MapLayer0[ROW*32 + 0] = LETTER0;
<br/>
MapLayer0[ROW*32 + 1] = LETTER1;
<br/>
MapLayer0[ROW*32 + 2] = LETTER2;
<br/>
MapLayer0[ROW*32 + 3] = LETTER3;
<br/>
MapLayer0[ROW*32 + 4] = LETTER4;
<br/>
MapLayer0[ROW*32 + 5] = LETTER5;
<br/>
MapLayer0[ROW*32 + 6] = LETTER6;
<br/>
MapLayer0[ROW*32 + 7] = LETTER7;
<br/>
MapLayer0[ROW*32 + 8] = LETTER8;
<br/>
MapLayer0[ROW*32 + 9] = LETTER9;
<br/>
MapLayer0[ROW*32 + 10] = LETTER10;
<br/>
MapLayer0[ROW*32 + 11] = LETTER11;
<br/>
MapLayer0[ROW*32 + 12] = LETTER12;
<br/>
MapLayer0[ROW*32 + 13] = LETTER13;
<br/>
MapLayer0[ROW*32 + 14] = LETTER14;
<br/>
MapLayer0[ROW*32 + 15] = LETTER15;
<br/>
MapLayer0[ROW*32 + 16] = LETTER16;
<br/>
MapLayer0[ROW*32 + 17] = LETTER17;
<br/>
MapLayer0[ROW*32 + 18] = LETTER18;
<br/>
MapLayer0[ROW*32 + 19] = LETTER19;
<br/>
MapLayer0[ROW*32 + 20] = LETTER20;
<br/>
MapLayer0[ROW*32 + 21] = LETTER21;
<br/>
MapLayer0[ROW*32 + 22] = LETTER22;
<br/>
MapLayer0[ROW*32 + 23] = LETTER23;
<br/>
MapLayer0[ROW*32 + 24] = LETTER24;
<br/>
MapLayer0[ROW*32 + 25] = LETTER25;
<br/>
MapLayer0[ROW*32 + 26] = LETTER26;
<br/>
MapLayer0[ROW*32 + 27] = LETTER27;
<br/>
MapLayer0[ROW*32 + 28] = LETTER28;
<br/>
MapLayer0[ROW*32 + 29] = LETTER29;
<br/>
MapLayer0[ROW*32 + 30] = LETTER30;
<br/>
MapLayer0[ROW*32 + 31] = LETTER31;
<br/>
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
It's a bit proprietary in design, but code can always be adjusted.  I use 32X32 tile maps so the function rewrites one full horizontal line at a time.  Currently I'm using this function mainly in an arcade shooter i am working on.  
<br/>
<br/>
The way I figure it, My demo-level has 2 bg's used for randomly-generated 'star-field' backgrounds, that scroll at different speeds to simulate depth, one level design bg to scroll at a yet different speed than the star fields, adding to the depth, and one bg for the 'HUD status display'.
<br/>
<br/>
For my level bg, i have a "ScreenCNT" variable increasing at the same speed as the level bg itself, 60 units per second [every vsync] and at every 8th ScreenCNT unit, i write the tile line two lines below the bottom of the screen [the screen scrolls top to bottom, so i gave it ample time to write, even though it executes rather quickly and i could perform this write the instant before the line appears onscreen]
<br/>
<br/>
The function itself operates simply as such:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Write(ROW,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#);
<br/>
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
^^ Where ROW = a number from 0-31 (0 = top bg row, 31 = bottom, respectively) and each # represents the tile's value in memory.  it seems a bit redundant to be coding this sort of thing in row by row, but when you put several function 'templates' on top of each other in notepad, its quite easy to build maps
<br/>
<br/>
The ScreenCNT variable can be used not only to control map-writes, but to orchestrate level events too :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#40667 - sgeos - Thu Apr 21, 2005 11:01 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ImInABand wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void Write(int ROW, int LETTER0, int LETTER1, int LETTER2, int LETTER3, int LETTER4, int LETTER5, int LETTER6, int LETTER7, int LETTER8, int LETTER9, int LETTER10, int LETTER11, int LETTER12, int LETTER13, int LETTER14, int LETTER15, int LETTER16, int LETTER17, int LETTER18, int LETTER19, int LETTER20, int LETTER21, int LETTER22, int LETTER23, int LETTER24, int LETTER25, int LETTER26, int LETTER27, int LETTER28, int LETTER29, int LETTER30, int LETTER31) {
<br/>
<br/>
MapLayer0[ROW*32 + 0] = LETTER0;
<br/>
MapLayer0[ROW*32 + 1] = LETTER1;
<br/>
MapLayer0[ROW*32 + 2] = LETTER2;
<br/>
MapLayer0[ROW*32 + 3] = LETTER3;
<br/>
MapLayer0[ROW*32 + 4] = LETTER4;
<br/>
MapLayer0[ROW*32 + 5] = LETTER5;
<br/>
MapLayer0[ROW*32 + 6] = LETTER6;
<br/>
MapLayer0[ROW*32 + 7] = LETTER7;
<br/>
MapLayer0[ROW*32 + 8] = LETTER8;
<br/>
MapLayer0[ROW*32 + 9] = LETTER9;
<br/>
MapLayer0[ROW*32 + 10] = LETTER10;
<br/>
MapLayer0[ROW*32 + 11] = LETTER11;
<br/>
MapLayer0[ROW*32 + 12] = LETTER12;
<br/>
MapLayer0[ROW*32 + 13] = LETTER13;
<br/>
MapLayer0[ROW*32 + 14] = LETTER14;
<br/>
MapLayer0[ROW*32 + 15] = LETTER15;
<br/>
MapLayer0[ROW*32 + 16] = LETTER16;
<br/>
MapLayer0[ROW*32 + 17] = LETTER17;
<br/>
MapLayer0[ROW*32 + 18] = LETTER18;
<br/>
MapLayer0[ROW*32 + 19] = LETTER19;
<br/>
MapLayer0[ROW*32 + 20] = LETTER20;
<br/>
MapLayer0[ROW*32 + 21] = LETTER21;
<br/>
MapLayer0[ROW*32 + 22] = LETTER22;
<br/>
MapLayer0[ROW*32 + 23] = LETTER23;
<br/>
MapLayer0[ROW*32 + 24] = LETTER24;
<br/>
MapLayer0[ROW*32 + 25] = LETTER25;
<br/>
MapLayer0[ROW*32 + 26] = LETTER26;
<br/>
MapLayer0[ROW*32 + 27] = LETTER27;
<br/>
MapLayer0[ROW*32 + 28] = LETTER28;
<br/>
MapLayer0[ROW*32 + 29] = LETTER29;
<br/>
MapLayer0[ROW*32 + 30] = LETTER30;
<br/>
MapLayer0[ROW*32 + 31] = LETTER31;
<br/>
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
Egad!  Why doesn't your code look like something like this?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define WIDTH   32
<br/>
#define HEIGHT   32
<br/>
<br/>
void write_cell(int p_x, int p_y, int p_letter)
<br/>
{
<br/>
   MapLayer0[p_y * WIDTH + p_x] = p_letter;
<br/>
}
<br/>
<br/>
void write_row_raw(int p_x, int p_y, int *p_data, int p_size)
<br/>
{
<br/>
   int i;
<br/>
<br/>
   for (i = 0; i &lt; p_size; i++)
<br/>
      write_cell(p_x + i, p_y, p_data[i]);
<br/>
}
<br/>
<br/>
void write_row(int p_row, int *p_data)
<br/>
{
<br/>
   write_row_raw(0, p_row, p_data, WIDTH);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
If you want to pass in a bunch of related values, you probably want to use an array.  This is especially so if your variables have names like LETTER4  (ie letter[4]).  The safe way to pass arrays around is to pass the size of the array along with it.  The write_row() function above assumes that the array you pass it is WIDTH (32) long.
<br/>
<br/>
I'm also not entirely sure why you are not using loops.  Unrolling loops is something the compiler can do for you, although these functions probably won't be your program's bottleneck.
<br/>
<br/>
In response to your original question, think of the display region as cache (ie one screen cell maps to more that one stage cell) and...
<br/>
If the player moves up, update the offscreen row at the top.
<br/>
If the player moves down, update the offscreen row at the bottom.
<br/>
If the player moves left, update the offscreen column to the left.
<br/>
If the player moves right, update the offscreen column to the right.
<br/>
<br/>
Here are some column update functions that work like the row funtions above:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void write_col_raw(int p_x, int p_y, int *p_data, int p_size)
<br/>
{
<br/>
   int i;
<br/>
<br/>
   for (i = 0; i &lt; p_size; i++)
<br/>
      write_cell(p_x, p_y + i, p_data[i]);
<br/>
}
<br/>
<br/>
void write_col(int p_row, int *p_data)
<br/>
{
<br/>
   write_col_raw(0, p_row, p_data, HEIGHT);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#41188 - LOst? - Tue Apr 26, 2005 4:37 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ImInABand wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void Write(int ROW, int LETTER0, int LETTER1, int LETTER2, int LETTER3, int LETTER4, int LETTER5, int LETTER6, int LETTER7, int LETTER8, int LETTER9, int LETTER10, int LETTER11, int LETTER12, int LETTER13, int LETTER14, int LETTER15, int LETTER16, int LETTER17, int LETTER18, int LETTER19, int LETTER20, int LETTER21, int LETTER22, int LETTER23, int LETTER24, int LETTER25, int LETTER26, int LETTER27, int LETTER28, int LETTER29, int LETTER30, int LETTER31) {
<br/>
<br/>
MapLayer0[ROW*32 + 0] = LETTER0;
<br/>
MapLayer0[ROW*32 + 1] = LETTER1;
<br/>
MapLayer0[ROW*32 + 2] = LETTER2;
<br/>
MapLayer0[ROW*32 + 3] = LETTER3;
<br/>
MapLayer0[ROW*32 + 4] = LETTER4;
<br/>
MapLayer0[ROW*32 + 5] = LETTER5;
<br/>
MapLayer0[ROW*32 + 6] = LETTER6;
<br/>
MapLayer0[ROW*32 + 7] = LETTER7;
<br/>
MapLayer0[ROW*32 + 8] = LETTER8;
<br/>
MapLayer0[ROW*32 + 9] = LETTER9;
<br/>
MapLayer0[ROW*32 + 10] = LETTER10;
<br/>
MapLayer0[ROW*32 + 11] = LETTER11;
<br/>
MapLayer0[ROW*32 + 12] = LETTER12;
<br/>
MapLayer0[ROW*32 + 13] = LETTER13;
<br/>
MapLayer0[ROW*32 + 14] = LETTER14;
<br/>
MapLayer0[ROW*32 + 15] = LETTER15;
<br/>
MapLayer0[ROW*32 + 16] = LETTER16;
<br/>
MapLayer0[ROW*32 + 17] = LETTER17;
<br/>
MapLayer0[ROW*32 + 18] = LETTER18;
<br/>
MapLayer0[ROW*32 + 19] = LETTER19;
<br/>
MapLayer0[ROW*32 + 20] = LETTER20;
<br/>
MapLayer0[ROW*32 + 21] = LETTER21;
<br/>
MapLayer0[ROW*32 + 22] = LETTER22;
<br/>
MapLayer0[ROW*32 + 23] = LETTER23;
<br/>
MapLayer0[ROW*32 + 24] = LETTER24;
<br/>
MapLayer0[ROW*32 + 25] = LETTER25;
<br/>
MapLayer0[ROW*32 + 26] = LETTER26;
<br/>
MapLayer0[ROW*32 + 27] = LETTER27;
<br/>
MapLayer0[ROW*32 + 28] = LETTER28;
<br/>
MapLayer0[ROW*32 + 29] = LETTER29;
<br/>
MapLayer0[ROW*32 + 30] = LETTER30;
<br/>
MapLayer0[ROW*32 + 31] = LETTER31;
<br/>
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
XD
<br/>
<br/>
Really, that function call takes 128 bytes on the stack. I've never seen anything like it before hehe.
<br/>
<br/>
I wonder how many times you can call this function from within this function before you will get stack overflow?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#41191 - Dwedit - Tue Apr 26, 2005 5:59 am</h4>
    <div class="postbody"><span class="postbody">I'd guess about 248 if IWRAM is free, or if the stack sits in EWRAM, 1985.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#41196 - ImInABand - Tue Apr 26, 2005 8:12 am</h4>
    <div class="postbody"><span class="postbody">ive devised several other methods of doing this outside of that horrendous abomination, that thing was the braindchild of insomnia and a quick ay through the problem.  using an array method i came up with a much better idea, at first it hadnt occurred to me about teh stack overflow thing [hee hee]
<br/>
<br/>
i originally used that function to write rows and display text in a low-memory intensive text editor that im working on, so the stack overflow wouldnt be a problem, since the function would only have been called a max of 30 times, if that.
<br/>
<br/>
reminder: I've pretty much taught myself everything i know, so for "feeling through the dark"  i think it wasnt too harsh of an idea for what it was being used for.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
