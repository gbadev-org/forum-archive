<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>THUMB instructions - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > THUMB instructions</h2>
<div id="posts">
<div class="post">
    <h4>#16080 - DarkPhantom - Sat Feb 07, 2004 8:05 pm</h4>
    <div class="postbody"><span class="postbody">The C compiler seems to generate ARM instructions by default. I know that ARM instructions execute faster than THUMB instructions however, I know that the GamePak ROM is connected to the mainboard by a bus with a width of only 16-bits. Therefore, I assume that if you want execute your program directly from the ROM it would be faster to use THUMB instructions because each thumb is 16 bits so one instruction won't require that the mainboard pull two requests from the ROM pack and then combine them to feed to the processor, right? In that spirit, anybody know how to get GCC to generate THUMB instructions instead of ARM?
<br/>
<br/>
(Tell me anyway, even if I am incorrect on the speed issue)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16085 - torne - Sat Feb 07, 2004 9:03 pm</h4>
    <div class="postbody"><span class="postbody">It's faster to use Thumb from ROM/EWRAM and ARM from IWRAM, yes, because of the bus widths. In practise the difference varies; with prefetching enabled, it's sometimes faster to use ARM code even from ROM purely because the ARM version is more efficient; the Thumb instruction set is rather limited. You might want to try both if you have a piece of performance critical code but no more space in IWRAM for it. Most of the problems come from GCC's pretty miserable Thumb code generation; ARM's own compiler seems to perform better at 16-bit code. I write most things in assembler so I prefer to use Thumb; my brain is a better optimiser in most cases than GCC. =)
<br/>
<br/>
To get GCC to generate Thumb code, add the argument -mthumb to the command line. However, if you want to be able to call Thumb code from ARM, and vice versa, then *all* modules involved, both ARM and Thumb, need to be compiled and linked with interworking support by adding -mthumb-interwork. You need both -mthumb-interwork and -mthumb to generate Thumb code with interworking. Also, any assembly code which you have written by hand (not inline, only standalone) needs to use interworking return sequences; read the ARM/Thumb procedure call standard for details, or search the assembly forum here for my previous explanations of the procedure calling standard.
<br/>
<br/>
Hope that's all the info you wanted.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16355 - x86asm - Fri Feb 13, 2004 3:37 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>torne wrote:</b></span></td> </tr> <tr> <td class="quote">It's faster to use Thumb from ROM/EWRAM and ARM from IWRAM, yes, because of the bus widths. In practise the difference varies; with prefetching enabled, it's sometimes faster to use ARM code even from ROM purely because the ARM version is more efficient; the Thumb instruction set is rather limited. You might want to try both if you have a piece of performance critical code but no more space in IWRAM for it. Most of the problems come from GCC's pretty miserable Thumb code generation; ARM's own compiler seems to perform better at 16-bit code. I write most things in assembler so I prefer to use Thumb; my brain is a better optimiser in most cases than GCC. =)
<br/>
<br/>
To get GCC to generate Thumb code, add the argument -mthumb to the command line. However, if you want to be able to call Thumb code from ARM, and vice versa, then *all* modules involved, both ARM and Thumb, need to be compiled and linked with interworking support by adding -mthumb-interwork. You need both -mthumb-interwork and -mthumb to generate Thumb code with interworking. Also, any assembly code which you have written by hand (not inline, only standalone) needs to use interworking return sequences; read the ARM/Thumb procedure call standard for details, or search the assembly forum here for my previous explanations of the procedure calling standard.
<br/>
<br/>
Hope that's all the info you wanted.</td> </tr></table><span class="postbody">
<br/>
<br/>
That step seems to be done by default in Visual HAM, maybe you can show the keyword (if there is one) that makes the compiler, compile a function in THUMB code instead of ARM code?
<br/>
<br/>
Thanks<br/>_________________<br/>Hello Everyone :D</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#16361 - tom - Fri Feb 13, 2004 8:01 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>x86asm wrote:</b></span></td> </tr> <tr> <td class="quote">maybe you can show the keyword (if there is one) that makes the compiler, compile a function in THUMB code instead of ARM code?
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
you can't switch between arm/thumb in a source file, you can only compile whole files as thumb, using the -mthumb switch, as torne said.
<br/>
<br/>
(if you're writing asm code with as you can switch between arm/thumb code generation using the .arm/.thumb or .code 32/.code 16 directives)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
