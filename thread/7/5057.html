<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>I'm trapped in a class! - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > I'm trapped in a class!</h2>
<div id="posts">
<div class="post">
    <h4>#36250 - LOst? - Wed Feb 16, 2005 2:23 pm</h4>
    <div class="postbody"><span class="postbody">It all started out in 2001. I was kinda competing with a friend about knowing most C++. however, I only programmed C, and he was way ahead coding C++ things.
<br/>
<br/>
Now, 2005, everything I do seem to be a class. For example, I'm coding a plane (background for storing tile numbers) manager, and I feel so dirty making it a class with constructor to set the size, having the size stored as private, deleting the plane buffer with the destructor.
<br/>
<br/>
Why do I feel dirty about it? Because last summer I used an old compiler for DOS called WATCOM C (used to create ID Software's DOOM), but I thought it being Open source now called Open Watcom maybe would make it more modern? DOOM was written in C btw.
<br/>
I made a whole software engine in WATCOM C++, and it was so slow I vomited all over it. I mean I tried every possible optimazion, but I couldn't speed up the things. Then I noticed, moving private variables to public and accessing them directly changed the speed noticable. So why having the variables in private anyway, I thought?
<br/>
But it didn't stop there... God, writing all these classes for nothing, when I could have the methods as C functions to get the speed the way it was supposed to.
<br/>
<br/>
So, I moved the whole software engine project into Visual C++ 6, and added some DirectX for screen access.... With all the classes and everything, and wow the speed was increadible!
<br/>
<br/>
But still, I'm hurt by knowing everything that really needs speed were written in C. Such as Microsoft Windows, Visualboy Advance, Gens (Sega EMU).
<br/>
<br/>
My software engine is really good, but it can't run at full speed on a 450 MHz, like Gens... And still Gens is an emulator! For gods sake, why did I get into C++ when all it did was getting me in trouble?
<br/>
<br/>
I'm stuck. Wherever I need something, I feel I need a constructor, a place where all my code for this object can have its own life, being private for everything else. That's why I can't leave C++. I'm doomed to be slow for the rest of my life I guess.
<br/>
<br/>
A typical class by me:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
class Plane
<br/>
{
<br/>
private:
<br/>
   int m_width;
<br/>
   int m_height;
<br/>
   int m_size;
<br/>
<br/>
   unsigned short* data;
<br/>
<br/>
public:
<br/>
   Plane (int width, int height)
<br/>
   {
<br/>
      m_size = (width * height);
<br/>
<br/>
      data = new unsigned short [m_size];
<br/>
      
<br/>
      m_width = width;
<br/>
      m_height = height;
<br/>
   }
<br/>
<br/>
   ~Plane ()
<br/>
   {
<br/>
      delete [] data;
<br/>
   }
<br/>
<br/>
   int ReturnWidth ()
<br/>
   {
<br/>
      return m_width;
<br/>
   }
<br/>
<br/>
   int ReturnHeight ()
<br/>
   {
<br/>
      return m_height;
<br/>
   }
<br/>
<br/>
   void SetData (int where, unsigned short entry)
<br/>
   {
<br/>
      if (where &lt; 0 || where &gt;= m_size)
<br/>
         return;
<br/>
<br/>
      data [where] = entry;
<br/>
   }
<br/>
<br/>
   unsigned short GetData (int where)
<br/>
   {
<br/>
      if (where &lt; 0 || where &gt;= m_size)
<br/>
         return 0;
<br/>
<br/>
      return data [where];
<br/>
   }
<br/>
};
<br/>
</td> </tr></table><span class="postbody">
<br/>
Should this be slow? So if it is, what's C++ good for? Writing this in C would require me to do functions and keep track of them like crazy.
<br/>
And of course I will not have the methods inside the class in the end. This is just when I test the code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36258 - sasq - Wed Feb 16, 2005 5:27 pm</h4>
    <div class="postbody"><span class="postbody">If you design carefully you should almost always be able to reach the same speeds with C++ as C.
<br/>
<br/>
In the example given I think you should:
<br/>
<br/>
Define the  Return-functions as inline and const
<br/>
<br/>
In SetData(), only check indata if you need to debug:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline void SetData (int where, unsigned short entry)
<br/>
{
<br/>
#ifdef DEBUG
<br/>
      if (where &lt; 0 || where &gt;= m_size)
<br/>
         return;
<br/>
#endif
<br/>
      data [where] = entry;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This should be as fast as just using a array in C (with a descent compiler at least).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36259 - poslundc - Wed Feb 16, 2005 5:55 pm</h4>
    <div class="postbody"><span class="postbody">Functions defined within the scope of a class definition are automatically inlined, if they can be.
<br/>
<br/>
There's a good chance that your compiler didn't have function-inlining turned on. With GCC, you need to be using at least -O1 for class member functions to be inlined (-O3 for general inline functions).
<br/>
<br/>
If the accessor methods are being inlined into your code, they should be just as fast as accessing the member values directly.
<br/>
<br/>
(sasq's debug-tip is also a good way to improve performance by removing the bounds checking in your release; an ASSERT function is another good, clean way of handling this.)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36270 - sajiimori - Wed Feb 16, 2005 7:34 pm</h4>
    <div class="postbody"><span class="postbody">Careful with that #ifdef back there.  You run the risk of having a perfectly working debug build that becomes a release build with random memory corruption.  If it's a failure condition, then assert.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36271 - Miked0801 - Wed Feb 16, 2005 7:36 pm</h4>
    <div class="postbody"><span class="postbody">Older compilers will also not handle C++ as well.  I prefer C, but that's because it was what I grew up in.  No matter the language, general optimizing principals apply.  1 or 2 loops will usually eat 80-90% of your overhead and those are where you need to concentrate your efforts.  Even consider hand assembling some of the lowest level, highest called routines.  As an example, consider the code in a 3D engine which maps textures onto polys (or any other rendering.)  This in beginner engines is your biggest bottleneck and should be hand assembled or coded in C (or C++) in such a way that the code emulates the hardware as well as possible.  Later on, advanced culling techniques and such spread the load out a bit more (and are also canidates for optimization as well.)
<br/>
<br/>
What does matching C code to hardware mean?  It means knowing how many registers the CPU has so you know how many local vars it can keep without pushing.  It means using 32-bit values on a 32-bit system even if the value may fit into a u16 or u8.  It means looking at the assembler output of the C/C++ function to gauge how well the compiler is translating your code and trying different tricks to save instructions (true story here, I had a count down loop that my compiler wouldn't assemble efficiently.  I tried for loops, do while, while, etc.  The only way that finally worked 100% efficiently was to make it a while(1) loop with an if() break statement in it instead of counting down traditionally.)  It means understanding alignment issues such that you can do the following to save space (use with caution!)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// Normal box code
<br/>
typedef struct _BOX
<br/>
{
<br/>
    u8 tlx, brx, tly, bry;
<br/>
    u32 flags
<br/>
} BOX;
<br/>
<br/>
BOX box1 = {0, 0, 10, 10, FLAG_ENABLED);
<br/>
BOX box2 = {5, 5, 12, 12, FLAG_ENABLED);
<br/>
<br/>
void collideCheck(void)
<br/>
{
<br/>
    if((box1.brx &gt;= box2.tlx) &amp;&amp; (box2.brx &gt;= box1.tlx) &amp;&amp;
<br/>
       (box1.bry &gt;= box1.tly) &amp;&amp; (box2.bry &gt;= box1.tly) &amp;&amp;
<br/>
    {
<br/>
        if((box1.flags &amp; FLAG_ENABLED) &amp;&amp;
<br/>
           (box2.flags &amp; FLAG_ENABLED))
<br/>
        {
<br/>
            // Collision occured
<br/>
        }
<br/>
    }
<br/>
}
<br/>
<br/>
// Designed to compile for ARM (not thumb)
<br/>
void collideCheckFast(void)
<br/>
{
<br/>
    // Read as a s32 the 1st 4 bytes of each struct into 2 registers
<br/>
    s32 aBox = *(s32 *)(&amp;box1);
<br/>
    s32 dBox = *(s32 *)(&amp;box2);
<br/>
<br/>
    {
<br/>
        s32 aTop, aBottom, dTop, dBottom;
<br/>
<br/>
        // Use shifts to get at values as ARM does this for free
<br/>
        aTop = aBox &gt;&gt; 24;
<br/>
        aBox &lt;&lt;= 8;
<br/>
<br/>
        aBottom = aBox &gt;&gt; 24;
<br/>
        aBottom &lt;&lt;= 8;
<br/>
<br/>
        dTop = dBox &gt;&gt; 24;
<br/>
        dBox &lt;&lt;= 8;
<br/>
<br/>
        dBottom = dBox &gt;&gt; 24;
<br/>
        dBottom &lt;&lt;= 8;
<br/>
<br/>
       // Above tempvars go out of scope so vars below will still be in register space
<br/>
        if ( (aBottom &gt;= dTop &amp;&amp; dBottom &gt;= aTop))
<br/>
       {
<br/>
            s32 aLeft, aRight, dLeft, dRight;
<br/>
<br/>
            aLeft = aBox &gt;&gt; 24;
<br/>
            aBox &lt;&lt;= 8;
<br/>
<br/>
            aRight = aBox &gt;&gt; 24;
<br/>
            // no need for last box shift
<br/>
<br/>
            dleft = dBox &gt;&gt; 24;
<br/>
            dBox &lt;&lt;= 8;
<br/>
<br/>
            dRight = dBox &gt;&gt; 24;
<br/>
<br/>
            if(aRight &gt;= dLeft &amp;&amp; dRight &gt;= aLeft )
<br/>
            {
<br/>
                // Check enable flag for both at same time
<br/>
                if((box1.flags &amp; box2.flags &amp; FLAG_ENABLED)
<br/>
                {
<br/>
                     // Collision occured
<br/>
                }
<br/>
            }
<br/>
       }
<br/>
    }
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The first example would be compiled (even optimized) as a jumble of 8-bit ROM reads then compares and not very efficient.  The 2nd, while nearly 3x as long in source, will run much, much faster as it minimizes ROM accesses and uses the ARMs built it capacity to does shifts for free.  The above code may bugs, so use at your own risk (coded on fly), but it shows what knowing the hardware can do for optimizing.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36319 - sandymac - Thu Feb 17, 2005 7:48 am</h4>
    <div class="postbody"><span class="postbody">I think the following is the "corrected" form of what Miked0801 typed from memory.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// These cords make more sense to me
<br/>
BOX box1 = {0, 10, 0, 10, FLAG_ENABLED}; 
<br/>
BOX box2 = {5, 12, 5, 12, FLAG_ENABLED};
<br/>
<br/>
// Designed to compile for ARM (not thumb) 
<br/>
void collideCheckFast(void) 
<br/>
{ 
<br/>
   // Read as a s32 the 1st 4 bytes of each struct into 2 registers 
<br/>
   s32 aBox = *(s32 *)(&amp;box1); 
<br/>
   s32 dBox = *(s32 *)(&amp;box2); 
<br/>
   
<br/>
   { 
<br/>
      s32 aTop, aBottom, dTop, dBottom; 
<br/>
      
<br/>
      // Use shifts to get at values as ARM does this for free 
<br/>
      aBottom = aBox &gt;&gt; 24; 
<br/>
      aBox &lt;&lt;= 8; 
<br/>
      
<br/>
      aTop = aBox &gt;&gt; 24; 
<br/>
      aBox &lt;&lt;= 8;
<br/>
      
<br/>
      dBottom = dBox &gt;&gt; 24;
<br/>
      dBox &lt;&lt;= 8;
<br/>
      
<br/>
      dTop = dBox &gt;&gt; 24;
<br/>
      dBox &lt;&lt;= 8;
<br/>
      
<br/>
      // Above tempvars go out of scope so vars below will still be in register space 
<br/>
      if ( (aBottom &gt;= dTop &amp;&amp; dBottom &gt;= aTop)) 
<br/>
      {
<br/>
         s32 aLeft, aRight, dLeft, dRight;
<br/>
<br/>
         aRight = aBox &gt;&gt; 24;
<br/>
         aBox &lt;&lt;= 8;
<br/>
<br/>
         aLeft = aBox &gt;&gt; 24;
<br/>
         // no need for last box shift
<br/>
<br/>
         dRight = dBox &gt;&gt; 24;
<br/>
         dBox &lt;&lt;= 8;
<br/>
<br/>
         dLeft = dBox &gt;&gt; 24;
<br/>
<br/>
         if(aRight &gt;= dLeft &amp;&amp; dRight &gt;= aLeft )
<br/>
         {
<br/>
            // Check enable flag for both at same time
<br/>
            if((box1.flags &amp; box2.flags &amp; FLAG_ENABLED))
<br/>
            {
<br/>
               // Collision occured
<br/>
            }
<br/>
         }
<br/>
      }
<br/>
   }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
Corrections of my correction are welcomed. :-)<br/>_________________<br/>"He who dares not offend cannot be honest." -- Thomas Paine</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36378 - col - Fri Feb 18, 2005 11:13 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
...
<br/>
I'm stuck. Wherever I need something, I feel I need a constructor, a place where all my code for this object can have its own life, being private for everything else. That's why I can't leave C++. I'm doomed to be slow for the rest of my life I guess....
<br/>
<br/>
A typical class by me:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
...
<br/>
   Plane (int width, int height)
<br/>
   {
<br/>
      m_size = (width * height);
<br/>
<br/>
      data = new unsigned short [m_size];
<br/>
      
<br/>
      m_width = width;
<br/>
      m_height = height;
<br/>
   }
<br/>
...
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
If you are using constructors in this way wherever you need something, you will potentially be losing a lot of cycles and memory !
<br/>
<br/>
The problem is that you are initialising all the members in the constructor body - which means they will be initialised twice !
<br/>
iirc, this is because all members must be initialised before the constructor body starts, so if you don't specify values in an 'initialiser list', they will be default initialised before the constructor body is run.
<br/>
To avoid this, you should be using an initialiser list:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Plane (int width, int height)
<br/>
:   m_width (width),
<br/>
    m_height (height),
<br/>
    m_size (width * height),
<br/>
    data ( new unsigned short [m_size] )
<br/>
{
<br/>
   //ctor body
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
(remember to keep the order of items in the list the same as the order they were declared in.)
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36393 - sajiimori - Fri Feb 18, 2005 7:46 pm</h4>
    <div class="postbody"><span class="postbody">Primitives are uninitialized by default, so there is no inefficiency here.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36400 - col - Sat Feb 19, 2005 12:45 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Primitives are uninitialized by default, so there is no inefficiency here.</td> </tr></table><span class="postbody">
<br/>
<br/>
mmm, nice nit ;)
<br/>
<br/>
My intent was to suggest that if this style of constuctor without init list is used "Wherever I need something", then it has the potential to cause efficiency problems....
<br/>
<br/>
You're right about the PODs not being default initialized, however, using an initializer list - at least in this case - allows gcc to optimize the code better. I compiled both the above examples using the lates DevkitARM with -O3 and found the version with the initializer list produced smaller, faster ASM output.
<br/>
<br/>
cheers
<br/>
<br/>
Col</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36402 - sajiimori - Sat Feb 19, 2005 1:12 am</h4>
    <div class="postbody"><span class="postbody">Conclusion: compilers are stupid. ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#36413 - LOst? - Sat Feb 19, 2005 5:45 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Primitives are uninitialized by default, so there is no inefficiency here.</td> </tr></table><span class="postbody">
<br/>
<br/>
More info please!
<br/>
<br/>
I don't like initializing things twice.
<br/>
<br/>
Remember that I always call constructors with new like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
Plane* plane_a = new Plane (64, 32);
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38120 - Deanonious - Tue Mar 22, 2005 7:20 am</h4>
    <div class="postbody"><span class="postbody">Yes I have to admit that I a really bad habit of not using Init. Lists in my constructors which is a major no no.  
<br/>
<br/>
Another major bottleneck in C++ coding that you have to majorly avoid is Run Time Type Definition, it's a fairly cool feature of C++, but it kills run-time performance.  I can't think of many others at the top of my head, but I did see a book at Barnes &amp; Noble a little while back (I can't remember the title atm) but it was all about C++ Optimizations for time critical applications (particularly games) it looked like a very useful read and reference to keep around.  Let me know if you would like me to try to look it up for you.
<br/>
<br/>
Dean</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38121 - sajiimori - Tue Mar 22, 2005 8:00 am</h4>
    <div class="postbody"><span class="postbody">That would be Run Time Type Identification, RTTI.  C++ doesn't have any faculties for defining new types at runtime.
<br/>
<br/>
I haven't seen an appropriate use for RTTI yet.  I guess it could be useful for debugging.
<br/>
<br/>
Sorry LOst, I didn't see that post from way-back-when.  Still, I don't know what more information you want.  You declared some primitives in your class, and they are not automatically initialized, so you are not initalizing them twice.
<br/>
<br/>
In any case, it's way too early to think about optimization here.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38131 - Deanonious - Tue Mar 22, 2005 6:15 pm</h4>
    <div class="postbody"><span class="postbody">That's right I remembered RTTI, I just couldn't remember what the I stood for *slaps himself*
<br/>
<br/>
I have only used it a few times myself because some of the CS professors at my University think that it is important, the way they had us use it was cool in a way, but for the most part it was just the "Lazy" way of doing it.
<br/>
<br/>
Dean</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38148 - Abscissa - Wed Mar 23, 2005 12:35 am</h4>
    <div class="postbody"><span class="postbody">I recommend the book "<a class="postlink" href="http://www.amazon.com/exec/obidos/ASIN/1584502274/qid=1111534481/sr=2-1/ref=pd_bbs_b_2_1/104-5725415-4958363" target="_blank">C++ for Game Programmers</a>". It has tons of info about all sorts of speed issues with C++.  Although I perfer <a class="postlink" href="http://www.digitalmars.com/d" target="_blank">D</a> myself.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38152 - Dwedit - Wed Mar 23, 2005 2:05 am</h4>
    <div class="postbody"><span class="postbody">Isn't division or muliplication by powers of 2 automatically converted to shifts by compilers?<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#38153 - jma - Wed Mar 23, 2005 2:43 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">Isn't division or muliplication by powers of 2 automatically converted to shifts by compilers?</td> </tr></table><span class="postbody">
<br/>
<br/>
This can be a common misconception. The standard answer is "yes", but there are factors to consider.
<br/>
<br/>
o Not all compilers do this (and they don't <span style="font-style: italic">have</span> to).
<br/>
o Are you dealing with signed or unsigned values?
<br/>
<br/>
For the second point, consider the following:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int x = -1;
<br/>
<br/>
int a = x / 2;
<br/>
int b = x &gt;&gt; 1;
<br/>
<br/>
assert(a != b);</td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-weight: bold">a</span> and <span style="font-weight: bold">b</span> are two totally different values. Did you want the compiler to actually turn the divide operation into a shift in this case? 
<br/>
<br/>
Processors have methods of getting around this. For example, on the x86, <span style="font-weight: bold">a</span> would be calculated like so:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">cdq
<br/>
sub eax,edx
<br/>
sar eax,1</td> </tr></table><span class="postbody">
<br/>
<br/>
This is (simply put) a little sign extend trick that could get simulated on the ARM like so:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">mov   r1,#0
<br/>
movs  r0,r0 ; test sign bit
<br/>
mvnmi r1,r1 ; simulate sign extend
<br/>
sub   r0,r0,r1
<br/>
mov   r0,r0 asr #1</td> </tr></table><span class="postbody">
<br/>
<br/>
The same effect, but still more work than a simple shift operation, with a conditional involved, which is much slower than just using the shift operator.  So... use shift when you can, and don't just expect a compiler to write good code for you.
<br/>
<br/>
Jeff M.<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
