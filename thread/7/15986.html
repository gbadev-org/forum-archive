<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>enum question - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > enum question</h2>
<div id="posts">
<div class="post">
    <h4>#162237 - gauauu - Thu Aug 28, 2008 4:42 pm</h4>
    <div class="postbody"><span class="postbody">I recently switched over from using my own bool (typedef'd from an int) to the bool defined by libnds (enum'd as true/fase).  Some oddities came up in my code that made me wonder what happens under the covers with enums in C.
<br/>
<br/>
Say I have a function like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
bool checkForMagicBits(uint32 value, uint32 bitflag)
<br/>
{
<br/>
    return (value &amp; bitflag);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
When I declared bool to just be an int, this would work great, I could do:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if (checkForMagicBits(512, 512)) .... do something</td> </tr></table><span class="postbody">
<br/>
<br/>
But now, if instead, I use the bool from libnds:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef enum { false, true } bool;</td> </tr></table><span class="postbody">
<br/>
<br/>
Then it really gets interesting.  Passing in 32, 32 works the same way as before (returns a non-zero, thus true, value), but passing in 512, 512 actually seems to return a 0 (which C thinks is false).  
<br/>
<br/>
Obviously this has to do with assigning "wrong" int values to an enum, but does anybody know what's really happening under the covers here?
<br/>
<br/>
It's easy enough to fix by doing something like
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
bool checkForMagicBits(uint32 value, uint32 bitflag)
<br/>
{
<br/>
    return ((value &amp; bitflag) != 0);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
But I'm rather curious about what's really happening.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162238 - Miked0801 - Thu Aug 28, 2008 4:48 pm</h4>
    <div class="postbody"><span class="postbody">My guess is the 'bool' is being defined as a u8.  512 = 0 when assigned to a u8.  If you are returning a bool, you should return a bool
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
return (value &amp; bitflag) != 0;
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162239 - sgeos - Thu Aug 28, 2008 4:49 pm</h4>
    <div class="postbody"><span class="postbody">IIRC, you can assign values to enumarated names like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef enum { false=0, true=1 } bool;</td> </tr></table><span class="postbody">
<br/>
I could not figure out how GCC automatically assigned enums,
<br/>
so I explicitly set the values last time I worked with them.
<br/>
<br/>
I pulled this of the <a class="postlink" href="http://msdn.microsoft.com/en-us/library/whbyts4t.aspx" target="_blank">net</a>:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">enum DAY            /* Defines an enumeration type    */
<br/>
{
<br/>
    saturday,       /* Names day and declares a       */
<br/>
    sunday = 0,     /* variable named workday with    */ 
<br/>
    monday,         /* that type                      */
<br/>
    tuesday,
<br/>
    wednesday,      /* wednesday is associated with 3 */
<br/>
    thursday,
<br/>
    friday
<br/>
} workday;</td> </tr></table><span class="postbody">
<br/>
Does the standard guarantee wednesday to be 3?
<br/>
I recall actual enum values not working as expected.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162247 - gauauu - Thu Aug 28, 2008 5:15 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">My guess is the 'bool' is being defined as a u8.  512 = 0 when assigned to a u8.  If you are returning a bool, you should return a bool</td> </tr></table><span class="postbody">
<br/>
<br/>
My guess as well, which is why my solution matched yours ;-)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">IIRC, you can assign values to enumarated names</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, that's what I've found to be the easiest way of dealing with things at other times.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162253 - keldon - Thu Aug 28, 2008 7:01 pm</h4>
    <div class="postbody"><span class="postbody">Bearing in mind that bool is an enumeration; consider the following:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">enum Day
<br/>
{
<br/>
   MONDAY,
<br/>
   TUESDAY,
<br/>
   WEDNESDAY,
<br/>
   THURSDAY,
<br/>
   FRIDAY,
<br/>
   SATURDAY,
<br/>
   SUNDAY
<br/>
};
<br/>
<br/>
void function (void)
<br/>
{
<br/>
   Day day = 0;
<br/>
   Day another_day = (5 &amp; 4) != 0;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
That is effectively what you are asking your code to do. In the context of days, it is obvious why the compiler would not like this without - at least - an explicit cast. Of course, you will want to be sure that you are casting a value that is one of your enumerations, especially since anything non-zero is treated as false in C/C++.
<br/>
<br/>
Of course, for the type safe nut, there is always (not completely tested, but compiles)  ...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class Bool
<br/>
{
<br/>
   public:
<br/>
      Bool (int i = 0)                  { value = char (i ? 1 : 0); }
<br/>
      
<br/>
      Bool (unsigned int i)               { value = char (i ? 1 : 0); }
<br/>
      
<br/>
      Bool&amp; operator= (const Bool&amp; b)         { value = b.value; return *this; }
<br/>
      
<br/>
      operator int (void) const            { return int (value ? 1 : 0); };
<br/>
      
<br/>
      
<br/>
      Bool operator== (const Bool &amp;b) const   { return value == b.value; };
<br/>
      Bool operator!= (const Bool &amp;b) const   { return value != b.value; };
<br/>
      Bool operator! (void) const            { return Bool ( value ? 0 : 1 ); };
<br/>
      Bool operator&amp; (const Bool &amp;b) const   { return Bool (value &amp; b.value); };
<br/>
      Bool operator| (const Bool &amp;b) const   { return Bool (value | b.value); };
<br/>
      
<br/>
   private:
<br/>
      char value;               //!&lt; Value must always be 1 or 0.
<br/>
}; // Bool
<br/>
<br/>
Bool&amp; false_bool (void);
<br/>
Bool&amp; true_bool (void);
<br/>
#define True (true_bool())
<br/>
#define False (false_bool())
<br/>
<br/>
Bool&amp; true_bool (void)
<br/>
{
<br/>
   static Bool bool_(1);
<br/>
   return bool_;
<br/>
}
<br/>
<br/>
Bool&amp; false_bool (void)
<br/>
{
<br/>
   static Bool bool_ (0);
<br/>
   return bool_;
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162269 - sajiimori - Fri Aug 29, 2008 2:06 am</h4>
    <div class="postbody"><span class="postbody">Some bizzarre posts in this thread.  The only issue was that GCC chose to represent your enum as a byte -- nothing to do with initializers or casts.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162271 - elwing - Fri Aug 29, 2008 6:07 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Some bizzarre posts in this thread.  The only issue was that GCC chose to represent your enum as a byte -- nothing to do with initializers or casts.</td> </tr></table><span class="postbody">
<br/>
<br/>
that is really strange infact, aren't enum suposed to use machine base data type (int?)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162272 - sgeos - Fri Aug 29, 2008 6:52 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elwing wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Some bizzarre posts in this thread.  The only issue was that GCC chose to represent your enum as a byte -- nothing to do with initializers or casts.</td> </tr></table><span class="postbody">
<br/>
that is really strange infact, aren't enum suposed to use machine base data type (int?)</span></td> </tr></table><span class="postbody">
<br/>
I expected it used int too.  I can see the logic behind behind using the smallest type that will be able to enumerate all of your options.  Is this choice left up to the implementation, or does the standard have something to say about it?
<br/>
<br/>
For what it is worth, I compiled and ran an enum sizeof test:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;stdio.h&gt;
<br/>
<br/>
#define PRINT_SIZEOF(t) printf("sizeof(%s)\t= %d;\n",#t,sizeof(t));
<br/>
<br/>
typedef enum {TRUE0              , FALSE0    } bool0;
<br/>
typedef enum {TRUE1 = 0x000000001, FALSE1 = 0} bool1;
<br/>
typedef enum {TRUE2 = 0x000000100, FALSE2 = 0} bool2;
<br/>
typedef enum {TRUE3 = 0x000010000, FALSE3 = 0} bool3;
<br/>
typedef enum {TRUE4 = 0x100000000, FALSE4 = 0} bool4;
<br/>
<br/>
int main(void)
<br/>
{
<br/>
        PRINT_SIZEOF(bool0);
<br/>
        PRINT_SIZEOF(bool1);
<br/>
        PRINT_SIZEOF(bool2);
<br/>
        PRINT_SIZEOF(bool3);
<br/>
        PRINT_SIZEOF(bool4);
<br/>
        printf("---\n");
<br/>
        PRINT_SIZEOF(TRUE0);
<br/>
        PRINT_SIZEOF(TRUE1);
<br/>
        PRINT_SIZEOF(TRUE2);
<br/>
        PRINT_SIZEOF(TRUE3);
<br/>
        PRINT_SIZEOF(TRUE4);
<br/>
        printf("---\n");
<br/>
        PRINT_SIZEOF(char);
<br/>
        PRINT_SIZEOF(int);
<br/>
        PRINT_SIZEOF(short);
<br/>
        PRINT_SIZEOF(long);
<br/>
        PRINT_SIZEOF(float);
<br/>
        PRINT_SIZEOF(double);
<br/>
        PRINT_SIZEOF(long long);
<br/>
        PRINT_SIZEOF(long double);
<br/>
        return 0;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
It is interesting to note the warning I got when I compiled this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">$ cc     sizetest.c   -o sizetest
<br/>
sizetest.c:9: warning: integer constant is too large for "long" type</td> </tr></table><span class="postbody">
<br/>
<br/>
It is also interesting to note that the compiler will use a size that can enumerate your values:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">$ ./sizetest.exe
<br/>
sizeof(bool0)   = 4;
<br/>
sizeof(bool1)   = 4;
<br/>
sizeof(bool2)   = 4;
<br/>
sizeof(bool3)   = 4;
<br/>
sizeof(bool4)   = 8;
<br/>
---
<br/>
sizeof(TRUE0)   = 4;
<br/>
sizeof(TRUE1)   = 4;
<br/>
sizeof(TRUE2)   = 4;
<br/>
sizeof(TRUE3)   = 4;
<br/>
sizeof(TRUE4)   = 8;
<br/>
---
<br/>
sizeof(char)    = 1;
<br/>
sizeof(int)     = 4;
<br/>
sizeof(short)   = 2;
<br/>
sizeof(long)    = 4;
<br/>
sizeof(float)   = 4;
<br/>
sizeof(double)  = 8;
<br/>
sizeof(long long)       = 8;
<br/>
sizeof(long double)     = 12;</td> </tr></table><span class="postbody">Also interesting, is that the standard size for enum is the size of int... or, more precisely long in this case, although they are the same size.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162277 - keldon - Fri Aug 29, 2008 8:48 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Some bizzarre posts in this thread.  The only issue was that GCC chose to represent your enum as a byte -- nothing to do with initializers or casts.</td> </tr></table><span class="postbody">
<br/>
Oops, wasn't thinking about GCC. I have a compiler I use very often that will moan at that, forcing you to write <span style="font-style: italic">return bool((value &amp; bitflag) != 0)</span>.
<br/>
<br/>
<span style="font-weight: bold">Edit:</span> Visual C++ is one of them; which moans about converting from bool to Bool (after I renamed the enum), but also when I converted it to an int and tried to return it.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elwing wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Some bizzarre posts in this thread.  The only issue was that GCC chose to represent your enum as a byte -- nothing to do with initializers or casts.</td> </tr></table><span class="postbody">
<br/>
<br/>
that is really strange infact, aren't enum suposed to use machine base data type (int?)</span></td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b><a class="postlink" href="http://www.kuzbass.ru:8086/docs/isocpp/dcl.html" target="_blank">C++ Standard 7.2.5</a> wrote:</b></span></td> </tr> <tr> <td class="quote">The underlying type of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. It is implementation-defined which integral type is used as the underlying type for an enumeration except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0. The value of sizeof() applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of sizeof() applied to the underlying type. </td> </tr></table><span class="postbody"></span><span class="gensmall"><br/><br/>Last edited by keldon on Fri Aug 29, 2008 11:23 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#162278 - elwing - Fri Aug 29, 2008 9:20 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Some bizzarre posts in this thread.  The only issue was that GCC chose to represent your enum as a byte -- nothing to do with initializers or casts.</td> </tr></table><span class="postbody">
<br/>
Oops, wasn't thinking about GCC. I have a compiler I use very often that will moan at that, forcing you to write <span style="font-style: italic">return bool((value &amp; bitflag) != 0)</span>.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elwing wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Some bizzarre posts in this thread.  The only issue was that GCC chose to represent your enum as a byte -- nothing to do with initializers or casts.</td> </tr></table><span class="postbody">
<br/>
<br/>
that is really strange infact, aren't enum suposed to use machine base data type (int?)</span></td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b><a class="postlink" href="http://www.kuzbass.ru:8086/docs/isocpp/dcl.html" target="_blank">C++ Standard 7.2.5</a> wrote:</b></span></td> </tr> <tr> <td class="quote">The underlying type of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. It is implementation-defined which integral type is used as the underlying type for an enumeration except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0. The value of sizeof() applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of sizeof() applied to the underlying type. </td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
<br/>
okay, so that mean that the implementation of enum use an underlying type of 8bit int and that is a correct implementation, the question that I have now is: can you still use enum if you want to program for a ds/gba knowing that it will reduce performance without any needs?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162284 - sgeos - Fri Aug 29, 2008 4:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elwing wrote:</b></span></td> </tr> <tr> <td class="quote">okay, so that mean that the implementation of enum use an underlying type of 8bit int and that is a correct implementation,</td> </tr></table><span class="postbody">
<br/>
In C++, yes.  I'm not sure what the C standard says about the issue.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>elwing wrote:</b></span></td> </tr> <tr> <td class="quote">the question that I have now is: can you still use enum if you want to program for a ds/gba knowing that it will reduce performance without any needs?</td> </tr></table><span class="postbody">
<br/>
You ought to be able to bump the size up by doing something like either one of these:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef enum { false=0, true=0x10000000 } bool;
<br/>
typedef enum { false=0, true=1, bool_size_dummy_value=0x10000000 } bool;</td> </tr></table><span class="postbody">
<br/>
That should take care of performance issues.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162288 - sajiimori - Fri Aug 29, 2008 6:22 pm</h4>
    <div class="postbody"><span class="postbody">I think there's a GCC flag to force it to use int for all enums.  It's probably a good idea to enable that flag.  (Is it something like -fno-short-enums?)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162301 - Miked0801 - Sat Aug 30, 2008 6:49 pm</h4>
    <div class="postbody"><span class="postbody">Or lame out and
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef BOOL int;
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162305 - gauauu - Sat Aug 30, 2008 8:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Or lame out and
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef BOOL int;
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
<br/>
Really, though, is there any reason that it would be less preferable to do this?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162306 - elwing - Sat Aug 30, 2008 9:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gauauu wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Or lame out and
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef BOOL int;
<br/>
</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
<br/>
Really, though, is there any reason that it would be less preferable to do this?</span></td> </tr></table><span class="postbody">
<br/>
<br/>
not sure, but using an enum typedef instead of your bool typedef doesn't allow more type checks at compile time? at run time it is pretty equal (as long as the typedef enum compile as an int...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162325 - Miked0801 - Sun Aug 31, 2008 5:29 pm</h4>
    <div class="postbody"><span class="postbody">The typedef takes away some of the compiler's ability to complain about when you use numeric expresions directly as bools.  The compiler usually complains for a good reason - as the beginning of this thread showed :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162330 - gauauu - Sun Aug 31, 2008 8:08 pm</h4>
    <div class="postbody"><span class="postbody">Except that using the enum, the compiler doesn't complain either.
<br/>
<br/>
This code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef enum
<br/>
{
<br/>
    true,
<br/>
    false
<br/>
}bool;
<br/>
<br/>
bool check(int x)
<br/>
{
<br/>
    return 512 &amp; x;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
and
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
enum bool
<br/>
{
<br/>
    true,
<br/>
    false
<br/>
};
<br/>
<br/>
enum bool check(int x)
<br/>
{
<br/>
    return 47;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Compiled with no warnings in GCC 4.2.3 using -Wall or -Wextra</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162338 - sajiimori - Sun Aug 31, 2008 10:19 pm</h4>
    <div class="postbody"><span class="postbody">In C, integer types will implicitly convert to enum types.  C++ requires a cast.
<br/>
<br/>
Then again, bool <span style="font-style: italic">is</span> an integer type in C++.  =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162468 - sniper - Wed Sep 03, 2008 6:10 pm</h4>
    <div class="postbody"><span class="postbody">Maybe it helps ... this I'm using since years using C.
<br/>
Also works well with static code checker.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef enum
<br/>
{
<br/>
    false = 0
<br/>
  , true = 1
<br/>
} bool_t;
<br/>
<br/>
#define BOOL_CAST(a) ((a) ? true : false)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
bool_t check(int x)
<br/>
{
<br/>
    return BOOL_CAST(512 &amp; x);
<br/>
} 
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162469 - tepples - Wed Sep 03, 2008 7:28 pm</h4>
    <div class="postbody"><span class="postbody">Or just #define BOOL_CAST(a) (!!(a))<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#162472 - gauauu - Wed Sep 03, 2008 7:46 pm</h4>
    <div class="postbody"><span class="postbody">Well, the problem isn't WHAT to do about it, which I answered in the original post.  ;-)
<br/>
<br/>
The question was, what is really going on, according to the spec.  The answer so far seems to be that the compiler can pick any size it wants to represent the enum, and was probably picking a u8.  And the C compiler doesn't do any type checking against the enums to make sure you assign the right thing.
<br/>
<br/>
Feel free to keep discussing, but it seems to me that the question has been pretty well answered.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
