<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Interrupts not working on real hardware - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > Interrupts not working on real hardware</h2>
<div id="posts">
<div class="post">
    <h4>#46806 - paladine - Fri Jul 01, 2005 12:42 am</h4>
    <div class="postbody"><span class="postbody">My interrupts are working just fine and dandy in VBA but when I load my image to the real hardware it never gets called at all!  I'm using a plain makefile setup with Jeff's crtls, crt0.s 1.28 and lnkscript 1.3.  
<br/>
Here's some sample code
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
CODE_IN_IWRAM void InterruptProcess()
<br/>
{
<br/>
  u16 intFlag = REG_IF;
<br/>
  /* turn off interrupts */
<br/>
  REG_IME = 0;
<br/>
  
<br/>
  static int i=0;
<br/>
  if ((i++) &amp; 1)
<br/>
  {
<br/>
    static u16 full = 0x7FFF;
<br/>
    DMACopy(&amp;full,VIDEO_BUFFER,38400,DMA_16NOW | DMA_SOURCE_FIXED);
<br/>
  }
<br/>
  else
<br/>
  {
<br/>
    static u16 empty = 0;
<br/>
    DMACopy(&amp;empty,VIDEO_BUFFER,38400,DMA_16NOW | DMA_SOURCE_FIXED);
<br/>
  } 
<br/>
  
<br/>
  /* service interrupt */
<br/>
  if ((intFlag &amp; INT_VBLANK))
<br/>
  {
<br/>
    /* perform the DMA transfers */
<br/>
    /*while (!list_empty(&amp;dmaList))
<br/>
    {
<br/>
      LPDMATRANSFER pDMA = (LPDMATRANSFER)list_pop(&amp;dmaList);
<br/>
      // perform transfer
<br/>
      REG_DMA0SAD = (u32)(pDMA-&gt;src);
<br/>
      REG_DMA0DAD = (u32)(pDMA-&gt;dest);
<br/>
      REG_DMA0CNT = pDMA-&gt;flags;
<br/>
      // remove from list
<br/>
      list_del(&amp;pDMA-&gt;list);
<br/>
    } */
<br/>
    /* update sprites */
<br/>
    SpriteCopyToOAM();
<br/>
  }
<br/>
  REG_IF |= intFlag;
<br/>
  SWI_ACKNOWLEDGE |= intFlag;
<br/>
  /* turn them back on */
<br/>
  REG_IME = 1;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
and the setup code
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
/* no interrupts quite yet */
<br/>
  REG_IME = 0;
<br/>
<br/>
  REG_DISPCNT = (3 | BG2_ENABLE | OBJ_ENABLE | OBJ_MAP_1D);
<br/>
  /* turn on vblank interrupts */
<br/>
  REG_IE |= INT_VBLANK | INT_HBLANK;
<br/>
  REG_DISPSTAT |= REG_DISPSTAT_ENABLE_VBLANK | REG_DISPSTAT_ENABLE_HBLANK;
<br/>
  /* turn on timers */
<br/>
  REG_TM0CNT = TIMER_FREQUENCY_1024 | TIMER_ENABLE;
<br/>
  REG_TM1CNT = TIMER_OVERFLOW | TIMER_ENABLE;
<br/>
  /* turn off backgrounds */
<br/>
  REG_BG0CNT = 0;
<br/>
  REG_BG1CNT = 0;
<br/>
  REG_BG2CNT = 0;
<br/>
  REG_BG3CNT = 0;
<br/>
  // turn off blending
<br/>
  REG_BLDMOD = 0;
<br/>
  /* turn interrupts on */
<br/>
  REG_IME = 1;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Judging from the code it should make the screen quickly go from white to black.  But no interrupts fire so nothing happens, just stays frozen.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46855 - FluBBa - Fri Jul 01, 2005 9:40 am</h4>
    <div class="postbody"><span class="postbody">Judging from the code you're trying to fill the entire screen every <span style="text-decoration: underline">HBLANK</span> is that what you want?<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46857 - NoMis - Fri Jul 01, 2005 10:26 am</h4>
    <div class="postbody"><span class="postbody">You have to make sure your interrupt handler is compiled as ARM. 
<br/>
<br/>
NoMis<br/>_________________<br/><span style="font-style: italic"><a class="postlink" href="http://www.gamedev.at/" target="_blank">www.gamedev.at</a></span> - The austrian gamedev site
<br/>
<span style="font-style: italic"><a class="postlink" href="http://hde.gamedev.at/" target="_blank">hde.gamedev.at</a></span> - The Handheld Dev Env plugins for Eclipse</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46866 - paladine - Fri Jul 01, 2005 2:26 pm</h4>
    <div class="postbody"><span class="postbody">Yes I'm aware I'm changing the entire screen on every hblank.  The purpose is to prove that I'm getting interrupts on the real hardware - which I believe I am not.  If the screen goes whacky wild, then I know I am succeeding and can code what I really want ;-)
<br/>
<br/>
And yes, the code is compiled as arm.  Here is the output from gcc
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
  1                    .file "interrupts.c"
<br/>
   2                    .global dmaList
<br/>
   3                    .data
<br/>
   4                    .align 2
<br/>
   5                    .type dmaList,%object
<br/>
   6                    .size dmaList,8
<br/>
   7                    dmaList:
<br/>
   8 0000 00000000      .word dmaList
<br/>
   9 0004 00000000      .word dmaList
<br/>
  10                    .section .iwram,"ax",%progbits
<br/>
  11                    .align 2
<br/>
  12                    .global InterruptProcess
<br/>
  13                    .type InterruptProcess,%function
<br/>
  14                    InterruptProcess:
<br/>
  15
<br/>
  16
<br/>
  17
<br/>
  18 0000 0DC0A0E1      mov ip,sp
<br/>
  19 0004 70D82DE9      stmfd sp!,{r4,r5,r6,fp,ip,lr,pc}
<br/>
  20 0008 023CA0E3      mov r3,#512
<br/>
  21 000c 813383E2      add r3,r3,#67108866
<br/>
  22 0010 B020D3E1      ldrh r2,[r3,#0]
<br/>
  23 0014 0133A0E3      mov r3,#67108864
<br/>
  24 0018 0260A0E1      mov r6,r2
<br/>
  25 001c 823F83E2      add r3,r3,#520
<br/>
  26 0020 010012E3      tst r2,#1
<br/>
  27 0024 0020A0E3      mov r2,#0
<br/>
  28 0028 04B04CE2      sub fp,ip,#-4294967292
<br/>
  29 002c B020C3E1      strh r2,[r3,#0]
<br/>
  30 0030 2500000A      beq .L2
<br/>
  31 0034 A0409FE5      ldr r4,.L15
<br/>
  32 0038 003094E5      ldr r3,[r4,#0]
<br/>
  33 003c 040053E1      cmp r3,r4
<br/>
  34 0040 2200000A      beq .L13
<br/>
  35 0044 0450A0E1      mov r5,r4
<br/>
  36 0048 01E3A0E3      mov lr,#67108864
<br/>
  37                    .L11:
<br/>
  38 004c 003094E5      ldr r3,[r4,#0]
<br/>
  39 0050 041093E5      ldr r1,[r3,#4]
<br/>
  40 0054 002093E5      ldr r2,[r3,#0]
<br/>
  41 0058 002081E5      str r2,[r1,#0]
<br/>
  42 005c 041082E5      str r1,[r2,#4]
<br/>
  43 0060 00C093E5      ldr ip,[r3,#0]
<br/>
  44 0064 050093E9      ldmib r3,{r0,r2}
<br/>
  45 0068 0C1093E5      ldr r1,[r3,#12]
<br/>
  46 006c 00C080E5      str ip,[r0,#0]
<br/>
  47 0070 B0208EE5      str r2,[lr,#176]
<br/>
  48 0074 B4108EE5      str r1,[lr,#180]
<br/>
  49 0078 002095E5      ldr r2,[r5,#0]
<br/>
  50 007c 101093E5      ldr r1,[r3,#16]
<br/>
  51 0080 050052E1      cmp r2,r5
<br/>
  52 0084 B8108EE5      str r1,[lr,#184]
<br/>
  53 0088 04008CE5      str r0,[ip,#4]
<br/>
  54 008c 1100001A      bne .L11
<br/>
  55                    .L13:
<br/>
  56 0090 48309FE5      ldr r3,.L15+4
<br/>
  57 0094 0FE0A0E1      mov lr,pc
<br/>
^LARM GAS                       page 2
<br/>
<br/>
<br/>
  58 0098 13FF2FE1      bx r3
<br/>
  59                    .L2:
<br/>
  60 009c 022CA0E3      mov r2,#512
<br/>
  61 00a0 812382E2      add r2,r2,#67108866
<br/>
  62 00a4 B030D2E1      ldrh r3,[r2,#0]
<br/>
  63 00a8 033086E1      orr r3,r6,r3
<br/>
  64 00ac B030C2E1      strh r3,[r2,#0]
<br/>
  65 00b0 0314A0E3      mov r1,#50331648
<br/>
  66 00b4 7F1C81E2      add r1,r1,#32512
<br/>
  67 00b8 B83FD1E1      ldrh r3,[r1,#248]
<br/>
  68 00bc 0123A0E3      mov r2,#67108864
<br/>
  69 00c0 033086E1      orr r3,r6,r3
<br/>
  70 00c4 B83FC1E1      strh r3,[r1,#248]
<br/>
  71 00c8 822F82E2      add r2,r2,#520
<br/>
  72 00cc 0130A0E3      mov r3,#1
<br/>
  73 00d0 B030C2E1      strh r3,[r2,#0]
<br/>
  74 00d4 70689DE8      ldmfd sp,{r4,r5,r6,fp,sp,lr}
<br/>
  75 00d8 1EFF2FE1      bx lr
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46867 - FluBBa - Fri Jul 01, 2005 2:31 pm</h4>
    <div class="postbody"><span class="postbody">DMA stops the cpu while it is running, filling the entire screen takes a lot of time, well at least a lot more then one raster row so you will end up with very unpredictable code in this case.<br/>_________________<br/>I probably suck, my not is a programmer.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46869 - paladine - Fri Jul 01, 2005 2:45 pm</h4>
    <div class="postbody"><span class="postbody">Yes that is true, the DMA probably takes longer than the entire HBLANK cycle.  I took your advice, disasble HBLANK processing and wrote code to update the first 8 pixels only so as not to abuse the CPU.  Still nothing on the real hardware :( 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
CODE_IN_IWRAM void InterruptProcess()
<br/>
{
<br/>
  u16 intFlag = REG_IF;
<br/>
  /* turn off interrupts */
<br/>
  REG_IME = 0;
<br/>
  
<br/>
  static int i=0;
<br/>
  int j;
<br/>
  if ((i++) &amp; 1)
<br/>
  {
<br/>
    static const u16 full = 0x7FFF;
<br/>
    for (j=0;j&lt;8;++j)
<br/>
      VIDEO_BUFFER[j] = full;
<br/>
  }
<br/>
  else
<br/>
  {
<br/>
    static u16 empty = 0;
<br/>
    for (j=0;j&lt;8;++j)
<br/>
      VIDEO_BUFFER[j] = empty;
<br/>
  }
<br/>
  
<br/>
  /* service interrupt */
<br/>
  if ((intFlag &amp; INT_VBLANK))
<br/>
  {
<br/>
    /* perform the DMA transfers */
<br/>
    while (!list_empty(&amp;dmaList))
<br/>
    {
<br/>
      LPDMATRANSFER pDMA = (LPDMATRANSFER)list_pop(&amp;dmaList);
<br/>
      // perform transfer
<br/>
      REG_DMA0SAD = (u32)(pDMA-&gt;src);
<br/>
      REG_DMA0DAD = (u32)(pDMA-&gt;dest);
<br/>
      REG_DMA0CNT = pDMA-&gt;flags;
<br/>
      // remove from list
<br/>
      list_del(&amp;pDMA-&gt;list);
<br/>
    }
<br/>
    /* update sprites */
<br/>
    SpriteCopyToOAM();
<br/>
  }
<br/>
  REG_IF |= intFlag;
<br/>
  SWI_ACKNOWLEDGE |= intFlag;
<br/>
  /* turn them back on */
<br/>
  REG_IME = 1;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46870 - poslundc - Fri Jul 01, 2005 3:51 pm</h4>
    <div class="postbody"><span class="postbody">1. All you want to do - at the moment, anyway - is get the interrupts working on hardware, right? Then stop trying to process multiple DMA transfers, update your shadow OAM, etc. First of all, you don't have time for <span style="font-style: italic">any</span> of that. Especially not in a C-coded ISR. If you're only updating the first 8 pixels it's very likely you won't see anything because you'll be halfway through the scanline before your ISR is complete. Get the interrupt working doing <span style="font-style: italic">absolutely nothing</span> other than setting a single value, like the backdrop colour (0x05000000), based on VCount, so you can see that you've got the basic code working and in action. Then you can build your other crap onto it and when stuff starts dropping out you'll know it's too much.
<br/>
<br/>
2. You are setting two acknowledgement bits, it seems: REG_IF and SWI_ACKNOWLEDGE. I don't know what SWI_ACKNOWLEDGE is, but all you need to do is set REG_IF.
<br/>
<br/>
3. Try assigning REG_IF directly (ie. REG_IF = ...) instead of using bitwise-or. I found that this made the difference when I wrote interrupt code.
<br/>
<br/>
4. Don't assign REG_IF its contents, since you might be getting other interrupts registering in it (and in fact you should be checking for these at the beginning of your routine). Assign to it the specific flag for the ISR that you've just completed, in this case 0x0002 for HBlank.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46880 - paladine - Fri Jul 01, 2005 6:45 pm</h4>
    <div class="postbody"><span class="postbody">I made an empty routine that just returns immediately after acking the int.  Still does not execute the interrupt code :(  Maybe it's my compiler, i'm not sure.  Funny thing is it works just fine on the emulator.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46881 - paladine - Fri Jul 01, 2005 6:58 pm</h4>
    <div class="postbody"><span class="postbody">OK well here's something strange - I recompiled it in ROM mode and it runs just fine.  Apparently when I compile it for multiboot loading, it doesn't work.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46907 - tepples - Fri Jul 01, 2005 11:02 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">2. You are setting two acknowledgement bits, it seems: REG_IF and SWI_ACKNOWLEDGE. I don't know what SWI_ACKNOWLEDGE is, but all you need to do is set REG_IF.</td> </tr></table><span class="postbody">
<br/>
SWI_ACKNOWLEDGE might be what I've been calling BIOS_IF (0x03007ff8, mirrored at 32 KiB intervals up to 0x03fffff8). In order to use BIOS IntrWait() or VBlankIntrWait(), you need to let IntrWait() know which interrupts were just handled. This involves ORing the interrupts that you handled into BIOS_IF.  Here's what a typical interrupt service routine looks like:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void isr(void)
<br/>
{
<br/>
  unsigned int interrupts = REG_IF;
<br/>
<br/>
  /* omit: handle each interrupt */
<br/>
<br/>
  BIOS_IF |= interrupts;  /* do not use = */
<br/>
  REG_IF = interrupts;  /* do not use |= */
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46919 - paladine - Sat Jul 02, 2005 2:24 am</h4>
    <div class="postbody"><span class="postbody">My handler routine works great.  My problem is that the interrupt handler is not being called by the hardware when launched via multiboot.  If I burn the image as a ROM to my flash card it plays fine.  I just can't multiboot launch it on the real hardware.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46921 - tepples - Sat Jul 02, 2005 2:33 am</h4>
    <div class="postbody"><span class="postbody">Hmm... Your code seems to follow my example with one exception. Does it work if you change this line
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  REG_IF |= intFlag;</td> </tr></table><span class="postbody">
<br/>
to the following?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">  REG_IF = intFlag;</td> </tr></table><span class="postbody">
<br/>
If you're using more than one different interrupt, there might be a difference in behavior that only shows up when the serial is turned on or when the game's code starts on a different scanline.
<br/>
<br/>
Another thing that might help (in any mode <span style="font-style: italic">except</span> 3) is to put writes to the backdrop color (entry 0 of palette memory) at strategic points in the setup code, so that if it crashes, at least you know how far it got.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46922 - LOst? - Sat Jul 02, 2005 2:52 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>paladine wrote:</b></span></td> </tr> <tr> <td class="quote">My handler routine works great.  My problem is that the interrupt handler is not being called by the hardware when launched via multiboot.  If I burn the image as a ROM to my flash card it plays fine.  I just can't multiboot launch it on the real hardware.</td> </tr></table><span class="postbody">
<br/>
Have you checked the right options in the CRT0 file? Suck as multiple interrupts being ON? It may be some other options that might be turned ON or OFF.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46929 - headspin - Sat Jul 02, 2005 5:50 am</h4>
    <div class="postbody"><span class="postbody">Edit crt.s and make sure you have the following:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">.equ __FastInterrupts, 1
<br/>
@.equ __SingleInterrupts, 1
<br/>
@.equ __MultipleInterrupts, 1</td> </tr></table><span class="postbody">
<br/>
<br/>
_Otherwise_ you need an interrupt table for your interrupts... example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void HBlankInterrupt(void)
<br/>
{
<br/>
   unsigned long int regs = REG_IE;
<br/>
<br/>
   REG_IF |= INT_HBLANK;
<br/>
<br/>
   // do stuff;
<br/>
<br/>
   REG_IE = regs;
<br/>
<br/>
}
<br/>
<br/>
void (*IntrTable[])() =
<br/>
{
<br/>
   0, // v-blank
<br/>
   &amp;HBlankInterrupt(), // h-blank
<br/>
   0, // vcount
<br/>
   0, // timer0
<br/>
   0, // timer1
<br/>
   0, // timer2
<br/>
   0, // timer3
<br/>
   0, // serial
<br/>
   0, // dma0
<br/>
   0, // dma1
<br/>
   0, // dma2
<br/>
   0, // dma3
<br/>
   0, // key
<br/>
   0  // cart
<br/>
};
<br/>
<br/>
void initInterrupt()
<br/>
{
<br/>
   REG_IME=0;
<br/>
   REG_IE = INT_HBLANK | INT_VBLANK;
<br/>
   REG_DISPSTAT = BIT04 | BIT03;
<br/>
   REG_IME=1;            //enable interrupt
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://headsoft.com.au/index.php?category=warhawk" target="_blank">Warhawk DS</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=mmll" target="_blank">Manic Miner: The Lost Levels</a> | <a class="postlink" href="http://headsoft.com.au/index.php?category=tdg" target="_blank">The Detective Game</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46949 - wintermute - Sat Jul 02, 2005 2:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>paladine wrote:</b></span></td> </tr> <tr> <td class="quote">My handler routine works great.  My problem is that the interrupt handler is not being called by the hardware when launched via multiboot.  If I burn the image as a ROM to my flash card it plays fine.  I just can't multiboot launch it on the real hardware.</td> </tr></table><span class="postbody">
<br/>
<br/>
How are you launching the multiboot app?
<br/>
<br/>
There are problems with some of the multiboot loaders around (f2a, xg2turbo &amp; efa) which seem to stop interrupts working. xboo.com, Xboo Communicator &amp; the mbv2 client don't suffer from this.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#46951 - paladine - Sat Jul 02, 2005 3:00 pm</h4>
    <div class="postbody"><span class="postbody">I have a F2A and I launch it via the if2a utility that runs under Linux.  That is somewhat comforting to hear that the multiboot loader can be buggy.  At least I know my code is working as expected ;-)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
