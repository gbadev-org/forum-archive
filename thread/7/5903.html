<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Function-like Macros vs. Inline Functions - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Function-like Macros vs. Inline Functions</h2>
<div id="posts">
<div class="post">
    <h4>#44353 - staticboy - Tue May 31, 2005 10:52 pm</h4>
    <div class="postbody"><span class="postbody">I'm certainly no C/C++ guru, but have reached the level where I'm thinking about what makes the best/fastest code for a GBA game.
<br/>
<br/>
My thoughts are concerning the pros and cons of using either function-like macros vs. inline functions (or normal functions for that matter). Traditionally most C/C++ developers would go for functions over macros because they can be debugged and made type safe. However, function calls increase complexity in the final compilation leading to (slightly) slower code. For desktop applications this is probably of no consequence. For the GBA it could be totally different! I have read that standard C header files can contain functions with macro alternatives (<a class="postlink" href="http://www-ccs.ucsd.edu/c/lib_over.html" target="_blank">masking macros</a>) that execute faster than the functions of the same name, but these should be reserved for use in release code.
<br/>
<br/>
All of this was triggered when I looked at my function to perform a DMA fast copy:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//defines needed by DMAFastCopy
<br/>
#define REG_DMA3SAD *(volatile unsigned int*)0x40000D4
<br/>
#define REG_DMA3DAD *(volatile unsigned int*)0x40000D8
<br/>
#define REG_DMA3CNT *(volatile unsigned int*)0x40000DC
<br/>
#define DMA_ENABLE 0x80000000
<br/>
#define DMA_TIMING_IMMEDIATE 0x00000000
<br/>
#define DMA_16 0x00000000
<br/>
#define DMA_32 0x04000000
<br/>
#define DMA_32NOW (DMA_ENABLE | DMA_TIMING_IMMEDIATE | DMA_32)
<br/>
#define DMA_16NOW (DMA_ENABLE | DMA_TIMING_IMMEDIATE | DMA_16)
<br/>
<br/>
// DMAFastCopy only for 16/32-bit immediate transfers
<br/>
void DMAFastCopy(void* source, void* dest, unsigned int count, unsigned int mode)
<br/>
{
<br/>
   if (mode == DMA_16NOW || mode == DMA_32NOW)
<br/>
   {
<br/>
      REG_DMA3SAD = (unsigned int)source;
<br/>
      REG_DMA3DAD = (unsigned int)dest;
<br/>
      REG_DMA3CNT = count | mode;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
So, I got to thinking that this could easily be re-written as a function-like macro. Definitely not so easy to read and would be almost impossible to debug, but acceptable risks for such a well-defined action if it proved to make for faster execution:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// DMA Fast Copy MACRO
<br/>
#define DMAFASTCOPY(source, dest, count, mode) if((mode)==DMA_16NOW||(mode)==DMA_32NOW){REG_DMA3SAD=(unsigned int)(source);REG_DMA3DAD=(unsigned int)(dest);REG_DMA3CNT = (count)|(mode);}</td> </tr></table><span class="postbody">
<br/>
<br/>
During my research in the deeper depths of various online C references I discovered "inlining" functions. So, my DMAFastCopy could be transformed into an inline function by the simple addition of the inline directive:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">inline void DMAFastCopy(void* source, void* dest, unsigned int count, unsigned int mode)
<br/>
{
<br/>
   if (mode == DMA_16NOW || mode == DMA_32NOW)
<br/>
   {
<br/>
      REG_DMA3SAD = (unsigned int)source;
<br/>
      REG_DMA3DAD = (unsigned int)dest;
<br/>
      REG_DMA3CNT = count | mode;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
As the inline directive is only a "hint", how do I find out what optimisation choice the compiler actually made? Did it perform an inline replacement each time I used the function or did it decide that going for a proper function call was the best way forward?
<br/>
<br/>
I see no difference in finally binary sizes using any of these methods or any noticable increase/decrease in performance. Maybe my game just doesn't have enough bells and whistles running yet to really tax the CPU for this sort of fine tuning to make any difference?
<br/>
<br/>
Any thoughts or experiences on this subject will be received with great interest!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44358 - strager - Tue May 31, 2005 11:43 pm</h4>
    <div class="postbody"><span class="postbody">When compiling your file, add a little -save-temps to the command line.  It will make a file <span style="font-style: italic">name</span>.s, and you can look in there for your answer.
<br/>
<br/>
Me, I would prefer the use of standard functions.  Why?  It takes up less space in ROM, and it is readable (for the most part).
<br/>
<br/>
I don't know about inline, but it looks like C++ syntax to me, and that means it is un-trustable (IMO).  Be warned.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44362 - Dwedit - Wed Jun 01, 2005 12:02 am</h4>
    <div class="postbody"><span class="postbody">You know, backslash + newline is the same as nothing, so to continue a line over multiple lines, just stick a backslash as the last character.
<br/>
#define something \
<br/>
line 1 \
<br/>
line 2 \
<br/>
line 3...<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44365 - sajiimori - Wed Jun 01, 2005 12:11 am</h4>
    <div class="postbody"><span class="postbody">Compile in C99 or C++ mode and use inline functions.  They are 100% as fast as macros.
<br/>
<br/>
Far from being untrustworthy, C++ features can let you write code that is fast <span style="font-style: italic">and</span> good.
<br/>
<br/>
All that aside, forget about optimizing until you have a bottleneck.  In the case of large DMA copies, the copying itself will be the majority of the work, not the setup, so inlining is not likely to be very important.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44366 - poslundc - Wed Jun 01, 2005 12:14 am</h4>
    <div class="postbody"><span class="postbody">I googled up <a class="postlink" href="http://gcc.gnu.org/onlinedocs/gcc/Inline.html" target="_blank">this entry</a> from the GCC documentation.
<br/>
<br/>
According to it, you must be building at least -O1 in order for functions to inline. <a class="postlink" href="http://developer.apple.com/documentation/DeveloperTools/gcc-3.3/gcc/Optimize-Options.html" target="_blank">This page</a> suggests that it must be -O3 (unless you specify -finline-functions), although it may be that this is only for GCC to automatically inline function that it feels are worth inlining, without you providing the keyword.
<br/>
<br/>
From the first article, as to when functions can't be inlined:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Note that certain usages in a function definition can make it unsuitable for inline substitution. Among these usages are: use of varargs, use of alloca, use of variable sized data types (see Variable Length), use of computed goto (see Labels as Values), use of nonlocal goto, and nested functions (see Nested Functions). Using -Winline will warn when a function marked inline could not be substituted, and will give the reason for the failure. </td> </tr></table><span class="postbody">
<br/>
<br/>
None of those are frequently-used features in GBA programming.
<br/>
<br/>
Inlined functions are generally preferable to macros, as they are less error-prone, provide features like type-checking, and are easy to switch to actual functions should you need to down the road.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44396 - Cearn - Wed Jun 01, 2005 9:08 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">They are 100% as fast as macros.</td> </tr></table><span class="postbody">
<br/>
This isn't *quite* true. In pretty much all cases I've checked there is no difference in output between macros and inline functions, but not all. In particular, it doesn't seem to do all that is possible when you're using constants, even if the arguments have the const qualifier. This could cause ugly code when you try to piece together all the constants for a register: instead of folding all of them into a single value, you could end up with a bunch of loads, ORs and shifts. So that'd probably make them ~95% as fast as macros :). Note: I've only tested this with just C, not C++ or a proper C99 option, so that may be my problem.
<br/>
Aside from that, I agree that inline functions are much friendlier than macros in use. And they can be a <span style="font-style: italic">lot</span> faster than normal functions if the body is short; and sometimes even produce smaller code because it can be optimised with the rest of the caller.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44412 - Suboptimal - Wed Jun 01, 2005 3:22 pm</h4>
    <div class="postbody"><span class="postbody">Note that there is a rather nasty potential land mine in this macro:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// DMA Fast Copy MACRO
<br/>
#define DMAFASTCOPY(source, dest, count, mode) if((mode)==DMA_16NOW||(mode)==DMA_32NOW){REG_DMA3SAD=(unsigned int)(source);REG_DMA3DAD=(unsigned int)(dest);REG_DMA3CNT = (count)|(mode);}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Let's say you tried to do something like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if ( bFoo )
<br/>
  DMAFASTCOPY( ... );
<br/>
else
<br/>
  DMAFASTCOPY( ... );
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Seems trivial enough, right? Unfortunately, the second statement will NEVER get called.  It will expand to this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if ( bFoo )
<br/>
  if((mode)==DMA_16NOW||(mode)==DMA_32NOW)
<br/>
    { .... }
<br/>
  else
<br/>
    if((mode)==DMA_16NOW||(mode)==DMA_32NOW)
<br/>
    {  .... }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
The macro couild be re-written to avoid this, but I tend to steer away from macros just because I always end up shooting myself in the foot with errors like this, usually long after I have forgotten I bought a gun.  I guess problems like that are rarer when you're doing the last wee bit of optimizing, since you're probably being more meticulous. 
<br/>
<br/>
Incindentally, does anyone know if the code in inlined functions is run in the same scope as the calling function, or does it follow the traditional scoping rules of a called function. I would assume it scopes properly, otherwise it would behave differently when the compiler can actually inline it and when it can't, which would be evil.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44415 - poslundc - Wed Jun 01, 2005 4:02 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Suboptimal wrote:</b></span></td> </tr> <tr> <td class="quote">Incindentally, does anyone know if the code in inlined functions is run in the same scope as the calling function, or does it follow the traditional scoping rules of a called function. I would assume it scopes properly, otherwise it would behave differently when the compiler can actually inline it and when it can't, which would be evil.</td> </tr></table><span class="postbody">
<br/>
<br/>
Inlined functions follow the conventional scoping rules for functions.
<br/>
<br/>
With all the pro-inlined-functions talk in this thread, I want to add to my previous post to mention that macros have their time and place as well. The difference between the two is that macros were designed to provide a feature that <span style="font-style: italic">can be used to solve a specific problem</span>, whereas inlined functions were designed to <span style="font-style: italic">solve a specific problem</span>.
<br/>
<br/>
So, since inlined functions were designed for the specific problem of letting you create small functions without causing performance to degrade, use them for that. Use macros when you don't specifically want to do that, but need to represent some piece of code or value with a different, global token.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44427 - sajiimori - Wed Jun 01, 2005 6:45 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">In pretty much all cases I've checked there is no difference in output between macros and inline functions, but not all.</td> </tr></table><span class="postbody">You caught me being idealistic again. ;)  Inline functions <span style="font-style: italic">should</span> be 100% as fast as macros, but the reality of imperfect compilers messes that up a bit.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44547 - staticboy - Thu Jun 02, 2005 8:12 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for all your replies, very informative and plenty of food for thought. I guess I'll just have to take it on a case by case basis, trying different methods and measure the effect on final performance.
<br/>
<br/>
This is probably a silly question: Is there any way to benchmark ROMS?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#44561 - tepples - Thu Jun 02, 2005 9:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>staticboy wrote:</b></span></td> </tr> <tr> <td class="quote">This is probably a silly question: Is there any way to benchmark ROMS?</td> </tr></table><span class="postbody">
<br/>
No$gba has a profiler, but most hobbyists can't afford it. Another technique, which works on No$gba freeware, VBA, and hardware is to execute something repeatedly in a loop and use either timers or vcount to see how long it takes.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45085 - Mollusk - Tue Jun 07, 2005 4:24 pm</h4>
    <div class="postbody"><span class="postbody">I actually tested some small bits of codes with both macros and inline functions, with timers, on gba. It looked like macros were a little bit faster than inline functions, not sure why.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45086 - strager - Tue Jun 07, 2005 4:28 pm</h4>
    <div class="postbody"><span class="postbody">I believe it is because inline functions take the time to push/pop registers that don't need pushing/popping.  I've been in favor of macros throughout this discussion, and I guess I am on the winning team. :-)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45100 - sajiimori - Tue Jun 07, 2005 6:10 pm</h4>
    <div class="postbody"><span class="postbody">If the inline version is slower, you are either building in a way that prevents the compiler from optimizing properly, or it is a compiler issue.
<br/>
<br/>
There is no single reason that an inline version would produce slower code.  It's not so much the "winning team" as the "placate the broken compiler" team, though that's occasionally necessary in real life.
<br/>
<br/>
Again, when it matters, always check the output.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45115 - tepples - Tue Jun 07, 2005 7:41 pm</h4>
    <div class="postbody"><span class="postbody">Have you tried compiling each version (with macros and with inline functions) with -S instead of -c, sending output to a .s file, and comparing the assembly language files that GCC generates?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45296 - Cearn - Thu Jun 09, 2005 9:27 am</h4>
    <div class="postbody"><span class="postbody">For some reason inline functions consistently put things inside a loop that should be there. For example
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
static inline void m3_plot(int x, int y, u16 clr)
<br/>
{   vid_mem[y*240+x]= clr]   }
<br/>
<br/>
// draw a rectangle
<br/>
for(iy=8; iy&lt;64; iy++)
<br/>
    for(ix=8; ix&lt;64; ix++)
<br/>
        m3_plot(ix, iy, 0xdead);
<br/>
</td> </tr></table><span class="postbody">
<br/>
Because 0x06000000 is too large a number for thumb code to do in one go, it has to be constructed in two instructions. For some reason, this happens inside the loop(s), rather than outside. The same thing happens to macros once the loops get a little more complicated. Mind you, this is still 3x faster than in m3_plot was a real function.
<br/>
Another reason for slower code is if you use non-word types for parameters, as they will probably have code for sign-extension. 
<br/>
Not using the const qualifier is also a possible slow-down, especially if you intend to combine them with arithmetic/logic operators: instead of all the constants folding together, you might actually get all the adds, ors, shifts etc that make up the code.
<br/>
The optimiser can be a little fickle at times, especially when it comes to inline functions. Just changing the order of statements can sometimes make some difference. Macros may require a little more caution in use, but at least you know what you get.
<br/>
Oh, and pushing/popping only happens for real functions, not inline. Perhaps when inline functions' code gets real hairy there may be stack handling too, but if that happens the code shouldn't be inlined anyway.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45337 - Miked0801 - Thu Jun 09, 2005 7:35 pm</h4>
    <div class="postbody"><span class="postbody">This of course being a perfect place for an assembly function.
<br/>
<br/>
Of course, I took it to too far of an extreme, but it was fun and I haven't had practice in a long while.  Thumb is not nearly as fun as ARM :)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
 @untested! - just spewed into the box for fun :)
<br/>
<br/>
 @ preserve
<br/>
 push r4,r5,r6
<br/>
<br/>
 @ Get start of video mem + 8 halfwords (r3 temp for now).
<br/>
 mov r3,#6
<br/>
 lsl r3,r3,#24
<br/>
 add r3,r3,#16
<br/>
<br/>
 @ Load r2 with 480 for later increments
<br/>
 mov r2,#240
<br/>
 lsl r2,r2,#1
<br/>
<br/>
 @ Get end y into r1 = vid_mem + 240 * 64 (*2 halfwords)
<br/>
 lsl r1,r2,#6
<br/>
 add r1,r1,r3
<br/>
<br/>
 @ Get start y int r0 = vid_mem + 240 * 8  (*2 halfwords)
<br/>
 lsl r0,r2,#3
<br/>
 add r0,r0,r3
<br/>
<br/>
 @r3 holds 32-bit 0xdeaddead
<br/>
 mov r3,$de
<br/>
 lsl r3,r3,#8
<br/>
 add r3,r3,$ad
<br/>
<br/>
 @ do last 16-bits at once
<br/>
 lsl r1,r3,#16
<br/>
 add r3,r3,r1
<br/>
<br/>
 @ copy into r4,r5,r6 to eliminate inner loop
<br/>
 mov r4,r3
<br/>
 mov r5,r3
<br/>
 mov r6,r3
<br/>
<br/>
lp:
<br/>
 @ blast - works because x is even
<br/>
 stmia r0,[r3,r4,r5,r6]
<br/>
<br/>
 @ increment loop (by 240*2) and check against end
<br/>
 add r0,r0,r2
<br/>
 cmp r0,r1
<br/>
 bne lp
<br/>
 
<br/>
 @ cleanup
<br/>
 pop r4,r5,r6
<br/>
 bx lr
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45418 - jma - Fri Jun 10, 2005 3:11 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Have you tried compiling each version (with macros and with inline functions) with -S instead of -c, sending output to a .s file, and comparing the assembly language files that GCC generates?</td> </tr></table><span class="postbody">
<br/>
<br/>
They will almost never be the same. In very simple situations they can be, but consider the following:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define RAND(min, max) \
<br/>
  ((min) + (rand() * ((max) - (min)) / RAND_MAX))
<br/>
<br/>
inline int my_rand(int min, int max) {
<br/>
  return min + rand() * (max - min) / RAND_MAX;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Now let's actually use each:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int x1 = RAND(y * 100, y * 100 + 5);
<br/>
int x2 = my_rand(y * 100, y * 100 + 5);</td> </tr></table><span class="postbody">
<br/>
<br/>
The code generation for these will be terrible for the macro and much better for the inline function.
<br/>
<br/>
Jeff M.<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45496 - tepples - Sat Jun 11, 2005 5:55 am</h4>
    <div class="postbody"><span class="postbody">If you're referring to recalculation of reused temporary values in a macro, then what about a macro using a compound statement within an expression (a [url=http://www-2.cs.cmu.edu/cgi-bin/info2www?(gcc.info)Statement%20Exprs]GCC extension to C[/url])? How does that perform?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define RAND(min, max) \
<br/>
  ({int _min = (min); \
<br/>
    (_min) + (rand() * ((max) - (_min)) / RAND_MAX)})
<br/>
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#45552 - jma - Sat Jun 11, 2005 11:19 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">If you're referring to recalculation of reused temporary values in a macro, then what about a macro using a compound statement within an expression... ?</td> </tr></table><span class="postbody">
<br/>
As I don't use GCC (and never have), I wouldn't know. However, I do find that terribly unreadable. Does it actually return a value (no sarcasm, just an honest question as to whether or not it works)? Why not just use the inline function which is portable across compilers? :)
<br/>
<br/>
Jeff M.<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#51513 - ribrdb2 - Sat Aug 20, 2005 9:47 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>staticboy wrote:</b></span></td> </tr> <tr> <td class="quote">This is probably a silly question: Is there any way to benchmark ROMS?</td> </tr></table><span class="postbody">
<br/>
No$gba has a profiler, but most hobbyists can't afford it.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
VBA also supports profiling with gprof. It's kind of tricky and somewhat limited, but very useful when you want to know where your time is being spent.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
