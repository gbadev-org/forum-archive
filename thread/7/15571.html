<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>const MyClass& obj = MyClass (...) and lifetimes - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > const MyClass& obj = MyClass (...) and lifetimes</h2>
<div id="posts">
<div class="post">
    <h4>#157388 - keldon - Fri May 23, 2008 9:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">const MyClass&amp; obj = MyClass (1,2,3);
<br/>
int m = obj.get_product() + obj.get_sum();</td> </tr></table><span class="postbody">
<br/>
<br/>
Not that I'm using this; but with optimisations and all, what is the worst that could/should happen? Apparently a const reference will extend the lifetime of the reference object to the lifetime of the const reference. I'm not too sure about that though and wanted some clarification on what the standards say.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#157411 - sajiimori - Fri May 23, 2008 9:43 pm</h4>
    <div class="postbody"><span class="postbody">I found the standard a bit vague in that regard.  These always worked for me:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">MyClass returnsByValue();
<br/>
<br/>
const MyClass&amp; ok1 = returnsByValue();
<br/>
const MyClass&amp; ok2 = MyClass(1, 2, 3);
<br/>
</td> </tr></table><span class="postbody">
<br/>
This one gave me trouble on the compiler I use at work, though I'm not clear on whether it's supposed to work (edit: This actually works -- see below):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">MyClass fn1();
<br/>
MyClass fn2();
<br/>
const MyClass&amp; maybeNotOk = condition() ? fn1() : fn2();
<br/>
</td> </tr></table><span class="postbody">
<br/>
And I'm also nervous about this one (edit: actually, this should really work):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">ConvertibleToMyClass returnsConvertible();
<br/>
const MyClass&amp; dunno = returnsConvertible();
<br/>
</td> </tr></table><span class="postbody">
<br/>
As far as performance, using this idiom is pretty much the strongest guarantee you can get that the number of copies will be minimized.  In theory, using a value should work just as well, if the compiler is smart about return value optimizations.
<br/>
<br/>
Edit: The conditional operator example above caused a copy when I just tested it, but the copy was eliminated easily:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">inline MyClass fn(bool b) { if(b) return fn1(); else return fn2(); }
<br/>
const MyClass&amp; noCopyHere = fn(condition());
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
