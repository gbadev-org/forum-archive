<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Slow member function pointers - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Slow member function pointers</h2>
<div id="posts">
<div class="post">
    <h4>#139625 - dushan42 - Sat Sep 08, 2007 10:27 am</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I've noticed that the code generated for my member function pointer calls is quite hairy. It seems that gcc fails to optimise calls even when it knows that the function's class doesn't use multiple / virtual inheritance (at least not for Thumb).
<br/>
<br/>
For example:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class SomeClass;
<br/>
<br/>
typedef void (SomeClass::*MemberFunc)();
<br/>
<br/>
void callMemberFunc(SomeClass *object, MemberFunc func)
<br/>
{
<br/>
   (object-&gt;*func)();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
In this case you'd expect the call to be pretty complicated as the compiler doesn't know anything about SomeClass. Both gcc and Visual Studio understandably generate equally horrid code. However if I change the first line to:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class SomeClass {};</td> </tr></table><span class="postbody">
<br/>
<br/>
I'd expect the compiler to get smart about the call as it knows multiple inheritance definitely isn't involved. Visual Studio does - the resulting code is exactly what I want:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   (object-&gt;*func)();
<br/>
00424D40  mov         ecx,dword ptr [esp+4] 
<br/>
00424D44  jmp         dword ptr [esp+8] 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Unfortunately the Thumb code generated by gcc is identical in both cases:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">00000000 &lt;_Z14callMemberFuncP9SomeClassMS_FvvE&gt;:
<br/>
   0:   b510         push   {r4, lr}
<br/>
   2:   1c04         mov   r4, r0      (add r4, r0, #0)
<br/>
   4:   07d3         lsl   r3, r2, #31
<br/>
   6:   d407         bmi   18 &lt;_Z14callMemberFuncP9SomeClassMS_FvvE+0x18&gt;
<br/>
   8:   1c0b         mov   r3, r1      (add r3, r1, #0)
<br/>
   a:   1050         asr   r0, r2, #1
<br/>
   c:   1820         add   r0, r4, r0
<br/>
   e:   fffef7ff    bl   0 &lt;_call_via_r3&gt;
<br/>
  12:   bc10         pop   {r4}
<br/>
  14:   bc01         pop   {r0}
<br/>
  16:   4700         bx   r0
<br/>
  18:   1050         asr   r0, r2, #1
<br/>
  1a:   5903         ldr   r3, [r0, r4]
<br/>
  1c:   185b         add   r3, r3, r1
<br/>
  1e:   681b         ldr   r3, [r3, #0]
<br/>
  20:   e7f4         b   c &lt;_call_via_r3+0xc&gt;
<br/>
  22:   46c0         nop         (mov r8, r8)
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Ouch!
<br/>
<br/>
I've tried this with a bunch of different versions of gcc (4.1.1, 4.1.0, 4.0.1, 3.4.4) and none of them generated optimised code when SomeClass was defined at the time of the call.
<br/>
<br/>
Any ideas why gcc does this? Is there a way to get more optimal code out of it through magic command line args or massaging the code?
<br/>
<br/>
Thanks,
<br/>
<br/>
Dushan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#139649 - col - Sat Sep 08, 2007 4:09 pm</h4>
    <div class="postbody"><span class="postbody">Read this article <a class="postlink" href="http://www.codeproject.com/cpp/FastDelegate.asp" target="_blank">http://www.codeproject.com/cpp/FastDelegate.asp</a>, it has everything you wanted to know about pointer to member functions. Info about why there are so many issues with them, and details about how different compilers implement them....
<br/>
<br/>
It's a good read, highly recommended ! :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#139652 - keldon - Sat Sep 08, 2007 4:38 pm</h4>
    <div class="postbody"><span class="postbody">Good link; added to the <a class="postlink" href="http://forum.gbadev.org/viewtopic.php?t=13662" target="_blank">MUL</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#139674 - dushan42 - Sat Sep 08, 2007 8:16 pm</h4>
    <div class="postbody"><span class="postbody">The article on FastDelegates is a very good read indeed - thanks for the link.
<br/>
<br/>
Unfortunately it doesn't mention any problems with gcc optimization. It's interesting that FastDelegates work without knowing anything about the class at call time:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "FastDelegate.h"
<br/>
<br/>
using namespace fastdelegate;
<br/>
<br/>
typedef FastDelegate&lt;void(void)&gt; SomeDelegate;
<br/>
<br/>
void callDelegate(SomeDelegate &amp;delegate)
<br/>
{
<br/>
   delegate();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
compiled with Visual Studio this yields really efficient code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void callDelegate(SomeDelegate &amp;delegate)
<br/>
{
<br/>
   delegate();
<br/>
00424D70  mov         eax,dword ptr [esp+4] 
<br/>
00424D74  mov         ecx,dword ptr [eax] 
<br/>
00424D76  mov         eax,dword ptr [eax+4] 
<br/>
00424D79  jmp         eax  
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Classes with multiple / virtual inheritance are detected at bind time &amp; stub function is generated for those - it's all very clever :). It does all come down to a MFP call however so with gcc I still end up with inefficient code:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">00000000 &lt;_Z12callDelegateRN12fastdelegate12FastDelegateIFvvEEE&gt;:
<br/>
   0:   b500         push   {lr}
<br/>
   2:   6883         ldr   r3, [r0, #8]
<br/>
   4:   b081         sub   sp, #4
<br/>
   6:   6801         ldr   r1, [r0, #0]
<br/>
   8:   6842         ldr   r2, [r0, #4]
<br/>
   a:   07d8         lsls   r0, r3, #31
<br/>
   c:   d406         bmi.n   1c &lt;_Z12callDelegateRN12fastdelegate12FastDelegateIFvvEEE+0x1c&gt;
<br/>
   e:   105b         asrs   r3, r3, #1
<br/>
  10:   18c8         adds   r0, r1, r3
<br/>
  12:   f000 f808    bl   26 &lt;_Z12callDelegateRN12fastdelegate12FastDelegateIFvvEEE+0x26&gt;
<br/>
  16:   b001         add   sp, #4
<br/>
  18:   bc01         pop   {r0}
<br/>
  1a:   4700         bx   r0
<br/>
  1c:   105b         asrs   r3, r3, #1
<br/>
  1e:   18c8         adds   r0, r1, r3
<br/>
  20:   6803         ldr   r3, [r0, #0]
<br/>
  22:   589a         ldr   r2, [r3, r2]
<br/>
  24:   e7f5         b.n   12 &lt;_Z12callDelegateRN12fastdelegate12FastDelegateIFvvEEE+0x12&gt;
<br/>
  26:   4710         bx   r2
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Interestingly enough, this isn't an ARM/Thumb problem as I assumed - MinGW (gcc version 3.4.2) generates similarly inefficient code for x86. I did a whole bunch of googling for the problem but so far with no luck. I refuse to believe this is a gcc limitation - epecially now that you got me hooked on delegates! :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#139686 - keldon - Sat Sep 08, 2007 9:33 pm</h4>
    <div class="postbody"><span class="postbody">Just one question, what is it jumping to? Could it be jumping to specific controller code or something?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#139717 - dushan42 - Sun Sep 09, 2007 7:57 am</h4>
    <div class="postbody"><span class="postbody">Do you mean the Visual Studio generated code? I did some tests and it depends on what function assigned to the member function pointer.
<br/>
<br/>
If you assign a virtual function, VS generates a tiny stub that looks it up in the vtable and then calls the correct function. The jmp instruction goes into the stub - so in terms of speed it's probably comparable to gcc code.
<br/>
<br/>
The beauty of the VS optimisation is that for non-virtual function the jmp is direct - it's as fast as good old fashioned C function pointer.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
