<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Why is this considered faster? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > Why is this considered faster?</h2>
<div id="posts">
<div class="post">
    <h4>#164982 - brave_orakio - Fri Dec 05, 2008 3:13 am</h4>
    <div class="postbody"><span class="postbody">I was troling these forums and a lot of times people would suggest doing
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
int* ptr;
<br/>
int i = 6;//Or what ever number
<br/>
<br/>
(ptr + i);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
instead of 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
ptr[i];
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
because it is faster. How is this different when it is converted to assembly?<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164984 - nanou - Fri Dec 05, 2008 4:30 am</h4>
    <div class="postbody"><span class="postbody">Is it faster? I'm not so sure, but I'm not one of the people who checks the ASM output...
<br/>
<br/>
If it is faster, it's probably ptr[i] being computed to the size of ptr's type, where ptr + i is straight addition. Why a compiler wouldn't optimize that out is beyond me.<br/>_________________<br/>- nanou</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164985 - sajiimori - Fri Dec 05, 2008 4:35 am</h4>
    <div class="postbody"><span class="postbody">ptr[i] is purely syntax sugar for *(ptr+i).  There is absolutely no performance difference.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164988 - brave_orakio - Fri Dec 05, 2008 5:39 am</h4>
    <div class="postbody"><span class="postbody">I thought just as well too. 
<br/>
<br/>
Just curious about it because I remember seeing in different threads with some people suggesting to do it as I stated previously because it was faster.
<br/>
<br/>
I thought maybe there's something I don't know about there<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164990 - Dwedit - Fri Dec 05, 2008 8:49 am</h4>
    <div class="postbody"><span class="postbody">protip: Run GCC with the -S and -o somefile.s switches to see the ASM code.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164992 - brave_orakio - Fri Dec 05, 2008 10:06 am</h4>
    <div class="postbody"><span class="postbody">Going back, I think I misunderstood something.
<br/>
<br/>
This is what I meant:
<br/>
<br/>
Why is pointer indexing faster than array indexing?
<br/>
<br/>
I read this in the Graphics section of the forums about 2D bitmap drawing optimization.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#164993 - Ludo6431 - Fri Dec 05, 2008 1:03 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">ptr[i] is purely syntax sugar for *(ptr+i).  There is absolutely no performance difference.</td> </tr></table><span class="postbody">
<br/>
I'm not sure, i think :
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int ptr[10];
<br/>
<br/>
<br/>
int j=ptr[4];
<br/>
&lt;=&gt;
<br/>
int j=*(ptr+sizeof(int)*4);
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165001 - Miked0801 - Fri Dec 05, 2008 6:19 pm</h4>
    <div class="postbody"><span class="postbody">I'll take a shot at your second question:
<br/>
<br/>
Pointer indexing 'can' be faster than array indexing, depending on what you are doing.  Our ARM compilers tend to make pointer indexing use stm/ldm combos more often and more efficient than array indexing.  Tend to, not always, not even usually.  As such, the following should not supersede readability of code.  If you really, really need something to go faster, then you comment like crazy and/or use asm.
<br/>
<br/>
Here's 4 ways to copy an int foo[10] array to int newFoo[10]:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
1.
<br/>
for(int i=0;i&lt;10;i++)
<br/>
{
<br/>
    newFoo[i] = foo[i];
<br/>
}
<br/>
<br/>
2.
<br/>
for(int i=0;i&lt;10;i++)
<br/>
{
<br/>
    *newFoo++ = *foo++;
<br/>
}
<br/>
<br/>
3.
<br/>
memCopy(newFoo, foo, sizeof(foo));
<br/>
<br/>
4.
<br/>
typedef struct
<br/>
{
<br/>
    int pad[10];
<br/>
} Generic40Bytes;
<br/>
<br/>
*((Generic40Bytes *)newFoo) = *((Generic40Bytes *)foo);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm willing to bet that way 4 would compile to the fastest code, most of the time, followed by a tie between 1 &amp; 2, with 3 coming in last - for this very small amount of data to be copied.
<br/>
<br/>
If the same type of copy was done with 4000 bytes, memCopy would probably move up to first or second depending on just how bloated way 4 becomes (and the cache missing that causes.)
<br/>
<br/>
or use DMA for sizes in that range and larger :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165004 - Cearn - Fri Dec 05, 2008 7:46 pm</h4>
    <div class="postbody"><span class="postbody">I would have expected someone to mention that <span style="font-weight: bold">[EDIT: premature]</span> optimization is the root of all evil by now &gt;_&gt;. 
<br/>
Anyway ...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>brave_orakio wrote:</b></span></td> </tr> <tr> <td class="quote">Why is pointer indexing faster than array indexing?
<br/>
<br/>
I read this in the Graphics section of the forums about 2D bitmap drawing optimization.</td> </tr></table><span class="postbody">
<br/>
What they may have been referring to is not just pointers vs arrays, but loop-reversal as well: 
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// incrementing for loop
<br/>
for(i=0; i&lt;size; i++)
<br/>
    dst[i] = src[i];
<br/>
<br/>
// decrementing while loop
<br/>
while(size--)
<br/>
    *dst++ = *src++;
<br/>
</td> </tr></table><span class="postbody">If this were converted directly into assembly, the second version would be faster because subtracting and comparing to zero can be done in one instruction rather than two. However, whether it actually compile to faster assembly will depend instruction set (ARM vs Thumb), data type and the <span style="font-style: italic">exact</span> formulation of your statements. 
<br/>
<br/>
It also depends on what mood the compiler is in today. Sometimes it will convert the for,++ loop into the functional equivalent of the while,-- ; and sometimes it will do the reverse. It's nearly impossible to predict when it does what. In Miked0801's cases, for example, cases 1 and 2 may produce the same code, so may 3 and 4. Then again, maybe not. 
<br/>
<br/>
Bottom line, don't worry about it too much.
<br/>
<br/>
<br/>
What will make a difference, however, is how you handle memory data (global variables or member variables): whether your code uses that data directly or if you load them up into local variables first. For example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct Surface
<br/>
{
<br/>
   u16 *data;
<br/>
   u16 width;
<br/>
   u16 height;
<br/>
} Surface;
<br/>
<br/>
// Two 16bit blits from src to dst.
<br/>
<br/>
// Dereference members in loops 
<br/>
void blitA(Surface *dst, int x, int y, Surface *src)
<br/>
{
<br/>
   int ix, iy;
<br/>
<br/>
   for(iy=0; iy&lt;src-&gt;height; iy++)
<br/>
   {
<br/>
      for(ix=0; ix&lt;src-&gt;width; ix++)
<br/>
         dst-&gt;data[(y+iy)*dst-&gt;width+(x+ix)]= src-&gt;data[iy*src-&gt;width+x];         
<br/>
   }
<br/>
}
<br/>
<br/>
// Load into locals first
<br/>
void blitB(Surface *dst, int x, int y, Surface *src)
<br/>
{
<br/>
   int ix, iy;
<br/>
   int srcWidth= src-&gt;width, srcHeight= src-&gt;height;
<br/>
   int dstWidth= dst-&gt;width;
<br/>
   u16 *srcData= src-&gt;data, *dstData= &amp;dst-&gt;data[y*dstWidth+x];
<br/>
<br/>
   for(iy=0; iy&lt;srcHeight; iy++)
<br/>
      for(ix=0; ix&lt;srcWidth; ix++)
<br/>
         dstData[iy*dstWidth+ix]= srcData[iy*srcWidth+ix];
<br/>
}</td> </tr></table><span class="postbody">
<br/>
In blitA(), all the members of <span style="font-style: italic">src</span> and <span style="font-style: italic">dst</span> are read inside the main loop, and y*width+x is calculated there too. In blitB(), that's all taken care of beforehand and the multiplies are even converted to increments that are only applied in the outer loop. As a result, blitB is roughly twice as fast as blitA. (Of course, for large transfers of contingent memory, you should be using a dedicated copier anyway (DMA or assembly routine)).
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Ludo6431 wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">ptr[i] is purely syntax sugar for *(ptr+i). There is absolutely no performance difference.</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not sure, i think :
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int ptr[10];
<br/>
<br/>
int j=ptr[4];
<br/>
&lt;=&gt;
<br/>
int j=*(ptr+sizeof(int)*4);</td> </tr></table><span class="postbody"> </span></td> </tr></table><span class="postbody">In pointer arithmetic, the unit for additions and subtractions is already the element-size. The sizeof(int) is not necessary.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">If the same type of copy was done with 4000 bytes, memCopy would probably move up to first or second depending on just how bloated way 4 becomes (and the cache missing that causes.) </td> </tr></table><span class="postbody"> It will probably depend on the compiler, but GCC will convert struct-copies larger than 13*4 bytes into memcpy calls.</span><span class="gensmall"><br/><br/>Last edited by Cearn on Sat Dec 06, 2008 10:12 am; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#165006 - silent_code - Fri Dec 05, 2008 10:07 pm</h4>
    <div class="postbody"><span class="postbody">If "pSomeStruct++" is setting the pointer to the next instance (or overflowing ;^p ) inside an array of the type of some structure or even a basic type, it doesn't really matter, with respect to the structure's size, then "pSomeStruct += 4" is doing the same, only skipping a few instances inbetween.
<br/>
<br/>
So, "pSomeData + 4" is equivalent to "pSomeData[4]".
<br/>
<br/>
If you cast your data to, let's say char, then those statements will skip the amount of bytes (4 in this example).<br/>_________________<br/><span style="font-size: 9px; line-height: normal"><span style="text-decoration: underline"><span style="font-weight: bold"></span></span> July 5th 08: "<span style="font-weight: bold">Volumetric Shadow Demo</span>" 1.6.0 (final) source released
<br/>
June 5th 08: "<span style="font-weight: bold">Zombie NDS</span>" WIP released!
<br/>
It's all on my page, just click <span style="font-weight: bold">WWW</span> below.</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165012 - sajiimori - Sat Dec 06, 2008 1:17 am</h4>
    <div class="postbody"><span class="postbody">Ludo6431, you're right that your examples aren't equivalent, but not for the reasons you think.
<br/>
<br/>
*(ptr+sizeof(int)*4) == *(ptr+16) == ptr[16].
<br/>
<br/>
Cearn, optimization isn't the root of all evil... but maybe we already agree about that.
<br/>
<br/>
silent_code, "pSomeData + 4" isn't equivalent to "pSomeData[4]".  It's equivalent to "&amp;pSomeData[4]".</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165018 - Cearn - Sat Dec 06, 2008 10:11 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Cearn, optimization isn't the root of all evil... but maybe we already agree about that.</td> </tr></table><span class="postbody">
<br/>
Gah. <span style="font-style: italic">Premature</span> optimization. What I meant to say was "premature optimization is the root of all evil". And turning array-indexing into pointer-indexing is probably a example of that.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165034 - brave_orakio - Sun Dec 07, 2008 1:51 am</h4>
    <div class="postbody"><span class="postbody">Wow a lot of replies! Thank you very much, as usual you guys are very helpful! 
<br/>
I guess the bottom line is, the compiler can be very moody and may mess with any c code optimization I do!
<br/>
For large data copying, yes I do use a dedicated copier(DMA). I guess it is more useful for small data copying when DMA or any other dedicated copier would have too large an overhead.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165038 - Dwedit - Sun Dec 07, 2008 10:22 am</h4>
    <div class="postbody"><span class="postbody">People generally don't like to use DMA as much on the NDS because DMA can not access the cache, preferring memcpy.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165050 - sajiimori - Sun Dec 07, 2008 9:46 pm</h4>
    <div class="postbody"><span class="postbody">That can actually be a good thing: a block transfer (like a memcpy) reads a range of memory only once, so caching generally doesn't help much... but large CPU transfers <span style="font-style: italic">do</span> end up kicking <span style="font-style: italic">everything else</span> out of the cache, which leads to additional cache misses after the transfer finishes.
<br/>
<br/>
A good strategy for substantial copies is to call DC_StoreAll (or the homebrew equivalent, whatever it's called) and use DMA.  Then the existing cache contents won't be kicked out for nothing.  The stores were probably going to happen anyway, eventually, so there's usually not much loss there.
<br/>
<br/>
(Oh, and you have to invalidate the destination range, if it's in main RAM.  If you're doing a large DMA to main RAM, you may as well flush the whole cache anyway, since invalidating large ranges is slow, so the benefits of DMA are partially lost.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165069 - Miked0801 - Mon Dec 08, 2008 8:24 pm</h4>
    <div class="postbody"><span class="postbody">Bah, stupid DMA.  #1 source of funky, what the hell bugs
<br/>
1. I changed to DMA, why is it slower?  (Cache invalidating was painful.)
<br/>
2. Every blue moon, my DMA goes crazy and copies stuff to our OAM buffer and beyond?  (Same DMA channel was being used in regular and interrupt code.)
<br/>
3. Multiplayer code is dropping packets like mad? (DMAs too long)
<br/>
<br/>
Bleh.  Stupid, broken crap.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165073 - sajiimori - Mon Dec 08, 2008 11:02 pm</h4>
    <div class="postbody"><span class="postbody">Oh yeah, here's another fun WTFDMA:
<br/>
<br/>
Step 1: Use DMA to upload a really long display list to the FIFO.  (Perhaps you happen to be right around VCount=190...)
<br/>
<br/>
Step 2: In VBlank, use DMA to upload textures to VRAM.  (Must wait for the existing DMA to finish...)
<br/>
<br/>
Step 3: Check out awesome black lines at the top of the screen from where the video mode is still in LCDC, because your display list stole a bunch of VBlank time away from your texture transfers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165074 - elhobbs - Tue Dec 09, 2008 1:47 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Multiplayer code is dropping packets like mad? (DMAs too long)</td> </tr></table><span class="postbody">are you sure that DMA is the problem with dropping packets? Are you using FIFO for the wifi sync functions or are you using a shared memory mailslot?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165075 - wintermute - Tue Dec 09, 2008 4:53 am</h4>
    <div class="postbody"><span class="postbody">1. He's an official dev so he uses what he's given.
<br/>
2. In any case DMA stalls the CPU so it increases the chance of missing interrupts.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165083 - brave_orakio - Tue Dec 09, 2008 9:14 am</h4>
    <div class="postbody"><span class="postbody">From your comments, it seems that DMA is not the preferred method for copying in the NDS.
<br/>
I thought that interrupts have priority over DMA in the GBA though? or only for the lesser DMA channels?<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165089 - wintermute - Tue Dec 09, 2008 5:24 pm</h4>
    <div class="postbody"><span class="postbody">Nope, active DMA stalls the CPU on both GBA and DS.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165106 - sajiimori - Tue Dec 09, 2008 10:54 pm</h4>
    <div class="postbody"><span class="postbody">I wouldn't say it stalls the CPU outright, but DMA can certainly block the CPU if it's constantly accessing main RAM and there's a cache miss.
<br/>
<br/>
If the DMA isn't constantly accessing main RAM (e.g. when uploading a display list, where it spends a lot of time waiting for the geometry hardware), or if there are no cache misses (e.g. if the surrounding code is all cached or in ITCM), the CPU can continue executing.
<br/>
<br/>
Anyway, there's no simple answer as far as which way is faster/better, but CPU copies are absolutely easier to get right.
<br/>
<br/>
Beginners should just use the CPU, no doubt.  As for experts... well, they'll just eliminate the need for the copy entirely, won't they?  ;)
<br/>
<br/>
(I'm only half-joking; we have very few substantial copy operations in our engine.)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165121 - brave_orakio - Wed Dec 10, 2008 8:59 am</h4>
    <div class="postbody"><span class="postbody">But for GBA it stalls it outright because there is no cache on the GBA right?
<br/>
Just curious though, for GBA development, professionals do use the DMA right? I remember mike saying that they used it for large sprite copying in Spyro. 
<br/>
For NDS, do you make your own copier? hand coded assembly probably?<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165123 - eKid - Wed Dec 10, 2008 9:25 am</h4>
    <div class="postbody"><span class="postbody">DMA is very useful if you're copying data that you aren't working on with the CPU, or when you need to copy at a certain timing, like at the start of HBlank.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165131 - Miked0801 - Wed Dec 10, 2008 5:58 pm</h4>
    <div class="postbody"><span class="postbody">On the GBA, you used DMA when:
<br/>
1. You needed automated, short burst copies (ala HDMA) for scanline tricks.
<br/>
2. You weren't doing multiplayer code and needed large copies as fast as possible.
<br/>
3. Copying OAMs in VBlank.
<br/>
<br/>
We pretty much ignored general purpose DMAs on games with multiplayer due to late interrupt packet loss.  Heck, even Digimon Racing, a Mode 7 game with 4-player multiplayer, experienced noticable slowdown due to packet loss from short HDMAs.
<br/>
<br/>
On DS (so far)
<br/>
In theory, DMAs can help loading from the cart.  In reality, it stalls nearly immediately unless you have it set up absolultely perfectly.  OAMs still use it, and I used it to copy large movie BGs another recent game - with some small issues...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165156 - brave_orakio - Thu Dec 11, 2008 2:45 am</h4>
    <div class="postbody"><span class="postbody">I guess I'm ok to use DMA since I wont be running multiplayer code and my primary development is for GBA. 
<br/>
I use it for copying images to VRAM and of course OAM copy in Vblank.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165163 - sajiimori - Thu Dec 11, 2008 7:33 am</h4>
    <div class="postbody"><span class="postbody">To answer your other questions, brave_orakio:
<br/>
<br/>
DMA stalls the GBA unless you're running code from IWRAM.
<br/>
<br/>
For NDS, like I said, we mostly try to eliminate the need to copy anything in the first place, but we use DMA for uploading geometry to the FIFO, for OAMs, and for VRAM transfers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165320 - tepples - Wed Dec 17, 2008 5:52 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">On DS (so far)
<br/>
In theory, DMAs can help loading from the cart.</td> </tr></table><span class="postbody">
<br/>
Only in official games. In homebrew, the DLDI spec requires drivers to use PIO, not DMA.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165324 - Miked0801 - Wed Dec 17, 2008 6:10 am</h4>
    <div class="postbody"><span class="postbody">And DMA in official land does next to no good on cartloads anyways.  Bleh.  Stupid slow interface.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165328 - tepples - Wed Dec 17, 2008 6:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Bleh.  Stupid slow interface.</td> </tr></table><span class="postbody">
<br/>
Just be glad it's roughly an order of magnitude faster than the 300 KiB per second typical of a PlayStation 1 CD drive or a Games n' Music microSD interface.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165352 - Miked0801 - Wed Dec 17, 2008 9:00 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, I worked on PS1 titles as well back in the day.  Stupid dev units were so poor, you had to turn them in their side's just so they wouldn't overheat.  I expect slow loads from discs, not from 'cart' based systems.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165361 - sajiimori - Thu Dec 18, 2008 1:25 am</h4>
    <div class="postbody"><span class="postbody">We're still living a life of comparative luxury: we get to load models and sfx on the frame that we need them, and we get to continuously stream all character animations.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165362 - Miked0801 - Thu Dec 18, 2008 2:38 am</h4>
    <div class="postbody"><span class="postbody">I know, but I sure enjoyed the relative firehose of a pipeline we got on the GBA.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165368 - brave_orakio - Thu Dec 18, 2008 7:48 am</h4>
    <div class="postbody"><span class="postbody">But the memory on PS1 is much greater than on the GBA, so you could load plenty of frames. 
<br/>
Of course, maybe the images are 32-bits per pixel, so that eats a lot more memory?<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165369 - DiscoStew - Thu Dec 18, 2008 8:17 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>brave_orakio wrote:</b></span></td> </tr> <tr> <td class="quote">But the memory on PS1 is much greater than on the GBA, so you could load plenty of frames. 
<br/>
Of course, maybe the images are 32-bits per pixel, so that eats a lot more memory?</td> </tr></table><span class="postbody">
<br/>
<br/>
True that the PS1 has more memory on the unit itself vs the GBA's memory on unit, but the cartridges practically act like memory themselves when comparing read speeds of the 2 pieces of hardware, so 32MBs?
<br/>
<br/>
Love the way off-topics come about.   :P<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165371 - sajiimori - Thu Dec 18, 2008 9:40 am</h4>
    <div class="postbody"><span class="postbody">About loading "plenty of frames" given larger memory:
<br/>
<br/>
Taking my latest DS project as an example, the amount of crap we load during the course of a typical level <span style="font-style: italic">greatly</span> exceeds RAM capacity.
<br/>
<br/>
If we had to deal with slow media (i.e. anything that spins), we would've had to choose between either cutting down the quantity of assets to a small fraction of what they are, or predicting when assets will be needed so we could start loading them well ahead of time (but not before we're able to unload something else).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#165373 - brave_orakio - Thu Dec 18, 2008 10:15 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DiscoStew wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<br/>
Love the way off-topics come about.   :P</td> </tr></table><span class="postbody">
<br/>
<br/>
hahaha! indeed, I started the topic asking about array and pointer indexing, and it slowly evolved into data copies! I'm not complaining though, the insight that I get from each post is great!
<br/>
<br/>
Yikes! I'm pretty thankful that I don't have to think about things like that when developing for GBA.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
