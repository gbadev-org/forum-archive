<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How to spawn enemies? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > How to spawn enemies?</h2>
<div id="posts">
<div class="post">
    <h4>#78846 - LOst? - Mon Apr 10, 2006 4:13 am</h4>
    <div class="postbody"><span class="postbody">I have programmed a C++ class that is used to handle enemies in my game. The class is being inherited from a standard object class, with a few overloadable virtals and some extended variables and methods.
<br/>
<br/>
Now, it would be really easy to spawn an enemy using the operator new.
<br/>
<br/>
So here comes my question. If I want to use static memory instead of dynamic memory. How do I do?
<br/>
<br/>
I want to create multiple instances of an enemy, or other objects. I don't really know the size of the class. But what about making a static memory area and by force casting a class to it? Is it possible?
<br/>
<br/>
What options do I have? Can I overload the operator new in some way? Can I cast classes to a memory area?<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#78848 - DekuTree64 - Mon Apr 10, 2006 5:00 am</h4>
    <div class="postbody"><span class="postbody">You could use placement new
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;new&gt;
<br/>
u8 enemyMem[MAX_ENEMIES * sizeof(Enemy)];
<br/>
...
<br/>
Enemy *dude = new(enemyMem + index * sizeof(Enemy)) Enemy;</td> </tr></table><span class="postbody">
<br/>
That will basically just call Enemy's constructor on that address, which sounds like what you want. I don't think you can call delete on objects created that way though, so if it has a destructor you'll have to call it manually.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#78849 - LOst? - Mon Apr 10, 2006 5:08 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>DekuTree64 wrote:</b></span></td> </tr> <tr> <td class="quote">You could use placement new
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;new&gt;
<br/>
u8 enemyMem[MAX_ENEMIES * sizeof(Enemy)];
<br/>
...
<br/>
Enemy *dude = new(enemyMem + index * sizeof(Enemy)) Enemy;</td> </tr></table><span class="postbody">
<br/>
That will basically just call Enemy's constructor on that address, which sounds like what you want. I don't think you can call delete on objects created that way though, so if it has a destructor you'll have to call it manually.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Oh interresting. Thank you! I didn't know about this. Does this work for inherited classes?
<br/>
<br/>
The main problem is that new takes too long time to dynamically allocate memory. Longer than a frame of 60fps.
<br/>
<br/>
So this "new" you are using, how does it create the class in memory?
<br/>
<br/>
I want like an array of enemies. And I want to assign an enemy class when it needs to be spawned. But without a delay. It should be like immediate action.
<br/>
<br/>
<br/>
EDIT: DekuTree64, your example makes sence! Thank you so much!<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#78863 - poslundc - Mon Apr 10, 2006 7:50 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">So here comes my question. If I want to use static memory instead of dynamic memory. How do I do?</td> </tr></table><span class="postbody">
<br/>
<br/>
The simplest answer is to not use class features like inheritance and polymorphism. Use another paradigm, such as unions and function tables wherever you need them to provide polymorphism.
<br/>
<br/>
There are more complicated answers, such as creating a static pool of enough objects of different types so that you can have the correct kind available (which results in wasted objects), or using placement new (as DT64 shows) and keeping your memory blocks the size of the largest descendant of your class (which results in wasted memory for smaller subclasses).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I want to create multiple instances of an enemy, or other objects. I don't really know the size of the class. But what about making a static memory area and by force casting a class to it? Is it possible?</td> </tr></table><span class="postbody">
<br/>
<br/>
Possible, yes. But very, very dangerous if you don't know how your compiler is implementing its classes. This is part of the reason why C++ provides you with your different cast operators.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">What options do I have? Can I overload the operator new in some way? Can I cast classes to a memory area?</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, you can overload operator new; have a look at a C++ FAQ for precise notation (I don't have it on me).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">The main problem is that new takes too long time to dynamically allocate memory. Longer than a frame of 60fps. </td> </tr></table><span class="postbody">
<br/>
<br/>
<span style="font-style: italic">Then you are doing something wrong.</span>
<br/>
<br/>
Your heap allocator should NOT be such a drain on resources. If I were you, I would profile your code and make sure this is the case.
<br/>
<br/>
The far greater danger on a system like the GBA is from heap fragmentation due to the limited memory size. For this reason, I'm disinclined to use dynamic allocation pretty much at all, or only with the greatest of care. But speed should not be the issue.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#78869 - LOst? - Mon Apr 10, 2006 9:05 am</h4>
    <div class="postbody"><span class="postbody">This was my idea when I created this system:
<br/>
<br/>
Have a base class called Object, with a virtual function for the AI.
<br/>
<br/>
Then create objects and enemies using the Object class as a template. E. g.:
<br/>
class Rock : public Object
<br/>
class Boss : public Object
<br/>
class Player : public Object
<br/>
<br/>
<br/>
Then have a list of pointers to Object classes:
<br/>
<br/>
Object* objs [128];
<br/>
<br/>
objs [0] = (Object*) new Player ();
<br/>
objs [1] = (Object*) new Rock ();
<br/>
<br/>
<br/>
And so on...<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#78885 - sgeos - Mon Apr 10, 2006 11:56 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">enemy_t enemyTable[MAX_ENEMIES];</td> </tr></table><span class="postbody">
<br/>
I'd write a class constructor that finds the first open slot in the array, reinitializes it and returns a reference to the newly created critter.  The enemy table and max size probably want to be class variables.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
