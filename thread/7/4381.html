<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Bounds-checked arrays - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Bounds-checked arrays</h2>
<div id="posts">
<div class="post">
    <h4>#29088 - sajiimori - Thu Nov 11, 2004 6:59 am</h4>
    <div class="postbody"><span class="postbody">I've been trying to figure out how to implement generic bounds-checked arrays that are as efficient as C arrays (when bounds checking is disabled) and can be initialized during declaration.  Here's a naive attempt at such a class:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">template&lt;class T, int SIZE&gt;
<br/>
class Array
<br/>
{
<br/>
    public:
<br/>
        Array(T data[SIZE]) : mData(data) {}
<br/>
<br/>
        T&amp; operator[](int i)
<br/>
        {
<br/>
            assert(i &gt;= 0 &amp;&amp; i &lt; SIZE);
<br/>
            return mData[i];
<br/>
        }
<br/>
<br/>
    private:
<br/>
        T* const mData;
<br/>
};</td> </tr></table><span class="postbody">At least with GCC, using it involves an extra dereference in comparison to regular arrays.  Even if everything is declared const, GCC can't figure out that mData is equivalent to the initializer.  So, it seems necessary for the object to actually contain the array, like this:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">template&lt;class T, int SIZE&gt;
<br/>
class Array
<br/>
{
<br/>
    public:
<br/>
        T&amp; operator[](int i)
<br/>
        {
<br/>
            assert(i &gt;= 0 &amp;&amp; i &lt; SIZE);
<br/>
            return mData[i];
<br/>
        }
<br/>
<br/>
    private:
<br/>
        T mData[SIZE];
<br/>
};</td> </tr></table><span class="postbody">But how could such an object be initialized during declaration?
<br/>
<br/>
Edit: On second thought, the inefficiency of the first version is inconsequential.  Since the difference between regular arrays and bounds-checked arrays is only relevant for debug builds, I can simply switch to regular arrays for release builds.
<br/>
<br/>
The new questions are:  How do I declare the first version gracefully, without having to declare the C array and the wrapper seperately?  And then how do I change to standard arrays transparently?
<br/>
<br/>
I just know the answer is gonna be "macros", but if there's another way, I'd definitely like to find it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29101 - poslundc - Thu Nov 11, 2004 3:15 pm</h4>
    <div class="postbody"><span class="postbody">...
<br/>
<br/>
I'd use macros.
<br/>
<br/>
I don't know of any other way to toggle invisibly between a native C and foreign C++ construct.
<br/>
<br/>
Does it make any difference if you inline the operator method?
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29115 - sajiimori - Thu Nov 11, 2004 7:33 pm</h4>
    <div class="postbody"><span class="postbody">It's already inlined in the example.
<br/>
<br/>
Here's what I came up with:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define DECL_ARRAY(TYPE, NAME, SIZE, ...) \
<br/>
  TYPE NAME##__c_array[SIZE] = \
<br/>
  { \
<br/>
    __VA_ARGS__ \
<br/>
  }; \
<br/>
  Array&lt;TYPE, SIZE&gt; NAME(NAME##__c_array)
<br/>
<br/>
DECL_ARRAY(int, five_numbers, 5,
<br/>
  10, 20, 30, 40, 50);</td> </tr></table><span class="postbody">Which expands to:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int five_numbers__c_array[5] =
<br/>
{
<br/>
  10, 20, 30, 40, 50
<br/>
};
<br/>
Array&lt;int, 5&gt; five_numbers(five_numbers__c_array);</td> </tr></table><span class="postbody">Improvements?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29124 - ScottLininger - Thu Nov 11, 2004 10:11 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">I just know the answer is gonna be "macros", but if there's another way, I'd definitely like to find it.</td> </tr></table><span class="postbody">
<br/>
<br/>
What's wrong with macros? I'm a macro junkie. So long as you keep them nicely defined in one spot, they make code much cleaner.
<br/>
<br/>
I've often toyed with the idea of making a monstrous macro library that seamlessly allows PHP to become compiled C. ;)
<br/>
<br/>
Or are you just doing this as a language exercise and not a practical implementation?
<br/>
<br/>
-Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#29127 - sajiimori - Thu Nov 11, 2004 11:32 pm</h4>
    <div class="postbody"><span class="postbody">This is for real use.
<br/>
<br/>
C macros offend my aesthetic sensibilities, but I don't have time to debate right now.
<br/>
<br/>
If you want to turn PHP into C, then write a compiler.  If you want to embed PHP into C, then write a preprocessor that invokes your compiler and pastes in the output.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
