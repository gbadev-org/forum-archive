<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Using unary operators on unsigned short integer with G++ - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Using unary operators on unsigned short integer with G++</h2>
<div id="posts">
<div class="post">
    <h4>#386 - notron - Tue Jan 07, 2003 4:15 am</h4>
    <div class="postbody"><span class="postbody">Okay, I know I am a Newbie and this may be stupid, but..... it appears to me that G++ (devkitadv) is expanding 16 bits to 32 bits when it evaluates unary expressions.  For example, I tested the following:
<br/>
<br/>
unsigned short mask = 0xffff;
<br/>
if ((~mask) == 0)
<br/>
{  (code turns screen blue) }
<br/>
else
<br/>
{ (code turns screen red)}
<br/>
<br/>
Now, the bitwise complement of mask should be 0x0000, but the above code will turn the screen red every time.  If I embed an explicit typedef override in the code like this:
<br/>
if ( ( (u16)~mask) == 0)
<br/>
<br/>
Then it properly evaluates to TRUE !
<br/>
<br/>
Okay, so tell me if me what gives here?<br/>_________________<br/>MysticX is The Defender</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#391 - anli - Tue Jan 07, 2003 9:47 am</h4>
    <div class="postbody"><span class="postbody">As far as I see, you cannot avoid this promotion to take place.
<br/>
The typecasting is necessary, I think.
<br/>
<br/>
best regards
<br/>
/anli</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#415 - Burre - Tue Jan 07, 2003 4:39 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>anli wrote:</b></span></td> </tr> <tr> <td class="quote">As far as I see, you cannot avoid this promotion to take place.
<br/>
The typecasting is necessary, I think.
<br/>
<br/>
best regards
<br/>
/anli</td> </tr></table><span class="postbody">
<br/>
<br/>
Yeah, I have to do a lot of typecasting (that shouldn't be necessary) in HAM using C++ as well. Especially when using pointers and adresses.
<br/>
<br/>
When using C lines like this works perfectly:
<br/>
ham_StartIntHandler(INT_TYPE_VBL, &amp;start_vblFunc);
<br/>
<br/>
But when using C++ it requires typecasting to (void*):
<br/>
ham_StartIntHandler(INT_TYPE_VBL, (void*)&amp;start_vblFunc);
<br/>
<br/>
Or else it will report an error (something like: cannot convert void (*)() to void*). Is it supposed to be that way?<br/>_________________<br/>"The best optimizer is between your ears..."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#448 - tom - Tue Jan 07, 2003 7:58 pm</h4>
    <div class="postbody"><span class="postbody">[quote="Burre"]Or else it will report an error (something like: cannot convert void (*)() to void*). Is it supposed to be that way?[/quote]
<br/>
<br/>
C++ has much stronger typechecking than C, and void(*)(), a pointer to a function with no parameters and returning void is definitely not the same
<br/>
as void*, so you need a typecast here.
<br/>
<br/>
So yes, this is supposed to be that way. Wether you regard this as a good or a bad thing is up to you =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#456 - Burre - Tue Jan 07, 2003 8:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tom wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Burre wrote:</b></span></td> </tr> <tr> <td class="quote">Or else it will report an error (something like: cannot convert void (*)() to void*). Is it supposed to be that way?</td> </tr></table><span class="postbody">
<br/>
<br/>
C++ has much stronger typechecking than C, and void(*)(), a pointer to a function with no parameters and returning void is definitely not the same
<br/>
as void*, so you need a typecast here.
<br/>
<br/>
So yes, this is supposed to be that way. Wether you regard this as a good or a bad thing is up to you =)</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Well I don't mind really. Thanks for pointing out the difference. I'm used to C and have only coded in C++ a couple of months, so I'm not entirely used to all the differences yet. But yes I've noticed some differences in the use of explicit and implicit typeconversions.<br/>_________________<br/>"The best optimizer is between your ears..."</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
