<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>IMAGE class design for flexibility & speed - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > IMAGE class design for flexibility & speed</h2>
<div id="posts">
<div class="post">
    <h4>#161552 - keldon - Wed Aug 06, 2008 7:31 am</h4>
    <div class="postbody"><span class="postbody">I had initially created an image class (call it <span style="font-weight: bold">Mark I</span>) that was a final class and worked directly with its pixel data (although the images were composed of PIXEL_BUFFER objects for each line). This allowed me to make one image refer to a subsection of another image with the same [fast] access speed and also join images together so that one image could represent both screens.
<br/>
<br/>
The image was overly bloated, doing far too much, such as filling (opaque and translucent), line drawing and text drawing:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class DS_BITMAP
<br/>
{
<br/>
   public:
<br/>
      enum DATA_MODE
<br/>
      {
<br/>
         RGB, ARGB, ARGB_SEMI
<br/>
      };
<br/>
      
<br/>
      DS_BITMAP (void);
<br/>
      
<br/>
      DS_BITMAP ( BITMAP_BUFFER_ALLOCATION&lt;&gt;&amp; bitmap_allocation );
<br/>
      
<br/>
      DS_BITMAP ( int _width, int _height, COLOUR *_bitmap_buffer = NULL );
<br/>
      DS_BITMAP ( DS_BITMAP&amp; bitmap, int x, int y, int width, int height );
<br/>
      DS_BITMAP ( int _height, PIXEL_BUFFER* pixel_buffer_array );
<br/>
      ~DS_BITMAP (void);
<br/>
      
<br/>
      // methods
<br/>
      void clear_bitmap ( COLOUR clear_colour = RGBA (0,0,0,0) );
<br/>
      
<br/>
      const BOOL contains ( int x, int y ) const;
<br/>
      
<br/>
      void draw_bitmap ( int x, int y, const DS_BITMAP &amp;ds_bitmap, BOOL is_only_drawing_updated_pixels = FALSE );
<br/>
      void draw_bitmap ( int dx, int dy, int sx1, int sy1, int sx2, int sy2, const DS_BITMAP &amp;ds_bitmap, BOOL is_only_drawing_updated_pixels = FALSE );
<br/>
      
<br/>
      void draw_line ( int x1, int y1, int x2, int y2, COLOUR colour, LINE_STYLE line_style );
<br/>
      void draw_line ( int x1, int y1, int x2, int y2, COLOUR colour );
<br/>
      
<br/>
      void draw_text_background ( int x, int y, FONT_ID font_id, COLOUR bg_colour, const char* const text );
<br/>
      
<br/>
      void draw_text ( int x, int y, FONT_ID font_id, COLOUR colour, const char* const text, int cursor_pos = -1 );
<br/>
      void draw_clip_text ( int x, int y, int width, FONT_ID font_id, COLOUR colour, const char* const text );
<br/>
      void draw_formatted_text ( int positioning, FONT_ID font_id, COLOUR text_colour, const char* const text, int cursor_pos = -1 );
<br/>
      void draw_formatted_text( int x1, int y1, int x2, int y2, int positioning, FONT_ID id, COLOUR text_colour, const char* const text, int cursor_pos = -1);
<br/>
      
<br/>
      void draw_rect ( int x, int y, int width, int height, COLOUR colour );
<br/>
      void fill_rect ( int x, int y, int width, int height, COLOUR colour );
<br/>
      void fill_semi_transparent_rect ( int x, int y, int width, int height, COLOUR colour );
<br/>
      
<br/>
      void draw_border ( COLOUR colour, int size = 1 );
<br/>
      
<br/>
      void clear_edited_region (void);
<br/>
      
<br/>
      void invalidate_pixel (int x, int y);
<br/>
      
<br/>
      
<br/>
      void set_data_mode ( DATA_MODE mode )               { data_mode = mode; };
<br/>
      const DATA_MODE get_data_mode (void) const            { return data_mode; };
<br/>
      
<br/>
      const COLOUR get_pixel ( int x, int y ) const;
<br/>
      void set_pixel ( int x, int y, COLOUR colour );
<br/>
      void set_pixel_without_invalidation ( int x, int y, COLOUR colour );
<br/>
      const int get_height (void) const                  { return height; };
<br/>
      const int get_width (void) const                  { return width; };
<br/>
      
<br/>
      const DIMENSION get_dimension (void) const            { return DIMENSION (get_width(), get_height()); };
<br/>
      
<br/>
      
<br/>
      
<br/>
      const PIXEL_BUFFER&amp; get_pixel_buffer ( int y ) const;
<br/>
      PIXEL_BUFFER&amp; get_pixel_buffer ( int y );
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I created a second class design using an abstract base class (call it <span style="font-weight: bold">Mark II</span>). It makes no assumptions on whether the image is able to store graphics or not, allowing for some interesting compositions, such as an image that streams from file, containing [say] a section stored in VRAM (that waits for VBL when written to), while also holding a window view of another image. This image class has the following interface:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class IMAGE
<br/>
{
<br/>
   public:
<br/>
      IMAGE (void);
<br/>
      virtual ~IMAGE (void)                           {;};
<br/>
      
<br/>
      virtual const DIMENSION2D get_size (void) const =0;
<br/>
      
<br/>
      const int get_width (void) const;
<br/>
      const int get_height (void) const;
<br/>
      
<br/>
      virtual const COLOUR get_pixel (int x, int y) const =0;
<br/>
      virtual void set_pixel (int x, int y, COLOUR colour) =0;
<br/>
      
<br/>
      virtual void draw_image (const IMAGE&amp;, int dx, int dy, int sx, int sy, int width, int height) =0;
<br/>
      void draw_image (const IMAGE&amp;, int dx, int dy);
<br/>
      
<br/>
      
<br/>
      virtual void blit_line (COLOUR *data, int x, int y, int width) const =0;
<br/>
      
<br/>
      virtual const bool contains (int x, int y) const;
<br/>
      
<br/>
      virtual const DRAW_MODE get_draw_mode (void) const;
<br/>
      virtual void set_draw_mode (DRAW_MODE draw_mode);
<br/>
      
<br/>
   private:
<br/>
      DRAW_MODE draw_mode_;
<br/>
      
<br/>
}; // IMAGE
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
For further operations I created a GRAPHICS class for handling more complex drawing tasks. Functionally it couldn't be better (so to speak), but images that are composed of other images provides slow fill rates (due to the composition), although image blitting is fine. For example, I can load an image and copy it to screen quicker than I can paint a filled rectangle (with an image hidden behind 1-3 layers). In this system the GRAPHICS class is created independently of the IMAGE (taking the IMAGE as a parameter). The composition is necessary
<br/>
<br/>
Despite the lacking design of <span style="font-weight: bold">Mark I</span>, it has proved useful for mapping both screens to a single image and creating window views of other images with fast draw speeds (due to its PIXEL_BUFFER approach, which allows the composed image to directly access the data).
<br/>
<br/>
For <span style="font-weight: bold">Mark III</span> I would like to improve the performance for lower level operations (if possible) without sacrificing the freedom of the design. I could move rect-filling over to the IMAGE class (or at least as a method that only draws on one line). If anything, does anyone have any good experiences to add with these needs in mind.
<br/>
<br/>
p.s. purpose: bitmap mode GUI implementation (hence the benefit of being able to create IMAGE view ports).</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
