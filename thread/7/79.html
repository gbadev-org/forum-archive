<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Using memset/memcpy in Mode 3 - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Using memset/memcpy in Mode 3</h2>
<div id="posts">
<div class="post">
    <h4>#443 - Vortex - Tue Jan 07, 2003 7:35 pm</h4>
    <div class="postbody"><span class="postbody">Hello !
<br/>
<br/>
All of the tutorials recommend using the following code to display an image in mode 3:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void ShowImage( u8* image )
<br/>
{
<br/>
   u16* img = (u16*) image;
<br/>
<br/>
   for( u16 y = 0; y &lt; ScreenHeight; y ++ )
<br/>
      for( u16 x = 0; x &lt; ScreenWidth; x ++ )
<br/>
         VideoBuffer[ x + y * ScreenWidth ] = *img++; 
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I am wondering are any benefits using memcpy() instead:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void ShowImage( u8* image )
<br/>
{
<br/>
   memcpy( VideoBuffer, image, ScreenWidth * ScreenHeight * 2 );   // memcpy works with bytes
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The same question applies for using memset() in ClearScreen.
<br/>
<br/>
Thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#445 - Touchstone - Tue Jan 07, 2003 7:45 pm</h4>
    <div class="postbody"><span class="postbody">Defenitely a speed increase if you use memcpy becuase you'll get rid of the horrible [x + y * ScreenWidth] thing. You'll get some increase in having just one loop instead of two aswell. But what you really would want to do is DMA copy the whole thing instead of doing it with CPU. DMA is syncronus with the CPU so don't plan to use the CPU while copying but at least you will get sequential accesses instead of a lot of random accesses. I think. :)<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#505 - jaymzjulian - Wed Jan 08, 2003 5:36 am</h4>
    <div class="postbody"><span class="postbody">but you should be aware that memcpy() is still *horrendously slow* on the GBA - better to use DMA or an asm funciton with a list of LDM/STM pairs
<br/>
<br/>
	- jj</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#697 - Nessie - Thu Jan 09, 2003 8:47 pm</h4>
    <div class="postbody"><span class="postbody">There is another way it could be coded that would offer a performance boost over your code...but probably wouldn't be quite as fast as a DMA or optimized memcpy.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void ShowImage( u8* image ) 
<br/>
{ 
<br/>
   u16* img = (u16*) image; 
<br/>
   u16* dest = VideoBuffer;
<br/>
<br/>
   for ( u16 i = 0; i &lt; ScreenHeight * ScreenWidth; i++ )
<br/>
  {
<br/>
         *dest++ = *img++; 
<br/>
  }
<br/>
} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
...anyway, hopefully you get the idea even if the code isn't quite right.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#698 - Lord Graga - Thu Jan 09, 2003 8:55 pm</h4>
    <div class="postbody"><span class="postbody">Even more optimized it is:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void ShowImage( u8* image ) 
<br/>
{ 
<br/>
   u16* img = (u16*) image; 
<br/>
   for ( u16 i = 0; i &lt; 38400; i++ ) VideoBuffer = *img++; 
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#702 - Nessie - Thu Jan 09, 2003 9:12 pm</h4>
    <div class="postbody"><span class="postbody">I think I know what you're getting at, but you still have to increment your videoBuffer pointer.
<br/>
<br/>
Also, any decent compiler will automatically compute the result of any constants......eg.:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if ( dumbVariable &gt; (4 * 2 * 3 * 2 + 5 * 2 * 4 * 2))
<br/>
{
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
...should be compiled as:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
if ( dumbVariable &gt;  128 ) //(8 * 6 + 10 * 8 == 48 + 80 == 128 )
<br/>
{
<br/>
} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
...I usually tend to leave arithmetic with constants intact since it makes the code easier to read and maintain..and it in no way affects performance unless your compiler is crap.  
<br/>
<br/>
You can verify how you compiler handles this by checking out the disassembly.[/code]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#704 - Touchstone - Thu Jan 09, 2003 9:27 pm</h4>
    <div class="postbody"><span class="postbody">Hey Graga, your code is broken. VideoBuffer is a pointer.
<br/>
<br/>
I don't think you'll get it significantly much faster code than Nessie without unrolling the loop. You could of course do it like this</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void ShowImage(u8* _pImage)
<br/>
{
<br/>
   u16* pSrc = (u16*)_pImage;
<br/>
   u16* pDst = VideoBuffer;
<br/>
   int i = ScreenWidth * ScreenHeight;
<br/>
<br/>
   do
<br/>
   {
<br/>
      *pDst++ = *pSrc++;
<br/>
   } while( --i &gt; 0);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
This code doesn't require as many registers and variables for the asm code if compared to Nessies code since the expression <span style="font-weight: bold">while(--i &gt; 0);</span> can be evaluated to this asm code:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">subs r0, r0, #1   // r0 = i
<br/>
bne loopStart</td> </tr></table><span class="postbody">
<br/>
whereas Nessies <span style="font-weight: bold">for</span> statement typically evaluates to:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">add r0, r0, #1   // r0 = i
<br/>
cmp r0, r1      // r1 = ScreenWidth*ScreenHeight
<br/>
blt loopStart</td> </tr></table><span class="postbody"><br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#721 - Nessie - Thu Jan 09, 2003 11:41 pm</h4>
    <div class="postbody"><span class="postbody">Ah, the fine art of optimizations....  thanks for the tip Touchstone..</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#723 - Touchstone - Thu Jan 09, 2003 11:52 pm</h4>
    <div class="postbody"><span class="postbody">Happy I could be of some advice for anyone.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#740 - abstim - Fri Jan 10, 2003 2:50 am</h4>
    <div class="postbody"><span class="postbody">most good compilers will make that optimization too.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#803 - Splam - Fri Jan 10, 2003 7:28 pm</h4>
    <div class="postbody"><span class="postbody">If you're going to do it by hand instead of using dma then at least code it in asm in the 1st place, don't presume what the compiler will convert your C to, you'd be suprised if you looked at even the simplest function and the crap compilers can make of it.  I've found after converting the most optimised C routine I could possibly make (for converting a commodore 64 screen to gba screen) after converting to asm I got ~600% speed increse.
<br/>
<br/>
As jaymzjulian said, dma or ldm/stm (using as many free registers as you have) would be best (and use u32 as well, saves on loop and therefore instruction fetches) unravelled loop would be even faster.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#815 - Nessie - Fri Jan 10, 2003 8:34 pm</h4>
    <div class="postbody"><span class="postbody">Actually, I think everyone agreed that DMA or ASM would be the best solution. 
<br/>
<br/>
But for people who maybe aren't very far along in learning GBA programming, knowing some simple speed-up tricks using standard C is probably more than adequate.   Also, this question wasn't even asked in the ASM section, so perhaps people thought it more appropriate to explore faster C versions of the original code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#823 - Vortex - Fri Jan 10, 2003 10:34 pm</h4>
    <div class="postbody"><span class="postbody">Thank you for the answers. One more question: is it possible to use the suggested DMA approach in Mode 4 ? Does the video memory 16-bit per read/write limitation applies to the DMA access too ?
<br/>
<br/>
I guess the mode 4 DMA code should look like this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
REG_DMA3SAD = PaletteAndImageData;   
<br/>
REG_DMA3DAD = 0x6000000;
<br/>
REG_DMA3CNT = ScreenWidth * ScreenHeight / 2;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Thanks again</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#857 - Splam - Sat Jan 11, 2003 10:15 am</h4>
    <div class="postbody"><span class="postbody">There isn't a 16bit read/write limit on vram, you can write 32bit if you want.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#869 - Costis - Sat Jan 11, 2003 5:36 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
Yes, VRAM can be written in 16\32 bit bus-widths. However, you shouldn't use memcpy or memset to copy data or clear VRAM as it uses an 8-bit copy width. Copying over 32-bits at a time would be optimal. Actually, you could just have a fast ldmia\stmia loop if you don't want to use DMA. Here's an ARM code example of an ldmia\stmia loop implementation:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
CopyImageMode3
<br/>
      ; r0 holds the address of the image data to be copied
<br/>
      mov r1, #0x6000000 ; VRAM base area in Mode 3
<br/>
      stmfd sp!, {r4-r12, lr}
<br/>
      mov r2, #160 ; Y line counter
<br/>
ImageCopyLoop
<br/>
      
<br/>
      ; Copy one scanline per loop
<br/>
      ldmia r0!, {r3-r12, lr} ; Load 48 bytes into r3 through r12 and lr
<br/>
      stmia r1!, {r3-r12, lr} ; Store 48 bytes into the VRAM base in Mode 3
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
      ldmia r0!, {r3-r12, lr}
<br/>
      stmia r1!, {r3-r12, lr}
<br/>
<br/>
      subs r2, r2, #1
<br/>
      bne ImageCopyLoop
<br/>
<br/>
      ldmfd sp!, {r4-r12, pc}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I haven't tested this exact code out yet, but I've used that trick many times to clear small buffers, etc. I believe that someone discovered that DMA is still faster than using this method some time ago. Also, the above code can be rolled\unrolled as much as you would like to suit your needs.
<br/>
<br/>
Costis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#870 - Splam - Sat Jan 11, 2003 6:12 pm</h4>
    <div class="postbody"><span class="postbody">Yep, if I had to do it in code then thats the way I'd do it, and yes dma is still faster, doesn't matter how much you unroll the loop because once it's set up there is no overhead (instruction fetch etc).</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
