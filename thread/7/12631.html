<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>infinite_fgets() - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>C/C++ > infinite_fgets()</h2>
<div id="posts">
<div class="post">
    <h4>#120815 - Dracker - Tue Mar 06, 2007 6:48 am</h4>
    <div class="postbody"><span class="postbody">I've written a function called infinite_fgets() to make file input a lot easier.
<br/>
<br/>
It seems I've let a bug sneak in somewhere, because it seems that sometimes a program can hang in infinite_fgets()'s loop and never get out.  It also appears that this causes a memory leak, as when left in this state, the DS screens eventually blank.
<br/>
<br/>
I can't find any bugs in here - can you?  I'm fairly certain the bug is in infinite_fgets() but it is possible that it's elsewhere.
<br/>
<br/>
Code blocks seem to screw up indentation, not to mention lack of highlighting.  A much prettier version is available at <a href="http://pastebin.ca/383227" target="_blank">http://pastebin.ca/383227</a>
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;stdio.h&gt;
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include "infinite_fgets.h"
<br/>
<br/>
/*
<br/>
 * Basically, this function works like fgets except it handles
<br/>
 * an indefinite length input line.  Reads until it hits \n or EOF.
<br/>
 * Any line of text returned ends with \0.
<br/>
 *
<br/>
 * None of the lines returned contain/end with a newline!
<br/>
 *
<br/>
 * Returns NULL on error (malloc returns NULL, etc) and 0 if 
<br/>
 * EOF is reached before reading any input.  If end-of-line
<br/>
 * or some other non-EOF termination is reached before reading
<br/>
 * any input, returns NULL.
<br/>
 */
<br/>
char* infinite_fgets(FILE * stream) {
<br/>
   char *buffer;
<br/>
   short int i;
<br/>
   size_t size = sizeof(char);
<br/>
   i = fgetc(stream);           /* read in one character */
<br/>
   if ( i == EOF ) { /* EOF is -1, cannot store in char */
<br/>
      return 0; 
<br/>
      /* This retval must be handled by whatever called this */
<br/>
   } else if (   i == '\0'   || /* Null */
<br/>
         i == NULL   || /* Null */
<br/>
         i == '\255'   || /* Null */
<br/>
         i == '\r'       || /* carriage return */
<br/>
         i == '\n') return NULL;  /* Line Feed */
<br/>
<br/>
   buffer = malloc(size); /* size = sizeof(char) at this point */
<br/>
   if (buffer == NULL) { /* malloc error */ 
<br/>
      return NULL;
<br/>
   }
<br/>
   *buffer = (char)i; /* set first character */
<br/>
   for(;;) {
<br/>
      i = fgetc(stream);   /* read in one character */
<br/>
      if (   i == EOF   ||
<br/>
         i == '\0'   || /* Null */
<br/>
         i == NULL   || /* Null */
<br/>
         i == '\255'   || /* Null */
<br/>
         i == '\r'       || /* carriage return */
<br/>
         i == '\n') break;  /* Line Feed */
<br/>
<br/>
      buffer = realloc(buffer,size+sizeof(char));
<br/>
      /* Buffer is now 1 char longer than its contents */
<br/>
      if (buffer == NULL) { /* realloc error */
<br/>
         return NULL;
<br/>
      } /* END IF */
<br/>
      size+=sizeof(char);
<br/>
      buffer[size-1] = (char)i;
<br/>
      /* Add the character to the buffer 
<br/>
       * This assumes sizeof(char) == 1 
<br/>
       * Fortunately, this is true for all
<br/>
       * platforms I use this on */
<br/>
<br/>
   } /* END FOR */
<br/>
   buffer = realloc(buffer,size+sizeof(char));
<br/>
   /* Make room for null termination */
<br/>
   if (buffer == NULL) { /* realloc error */
<br/>
      return NULL; 
<br/>
   } /* END IF */
<br/>
   buffer[size] = '\0'; /* Null-terminate the string */
<br/>
   return buffer;
<br/>
} /* END INFINITE_FGETS */</td> </tr></table><span class="postbody">
<br/>
<br/>
The .h file only includes a prototype.<br/>_________________<br/><span style="font-weight: bold">--Drack</span>
<br/>
Onyx DS Lite, M3 Perfect Lite, Flashme V7, Flashed using SocketMe
<br/>
Gamecube DOL-001 with Qoob Pro
<br/>
Wii, not modded.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120830 - keldon - Tue Mar 06, 2007 11:08 am</h4>
    <div class="postbody"><span class="postbody">I would say to restart the code to read with a maximum value first. Once you have done that then modify it to then allocate more memory using the maximum length each time you have ran out of memory. Then create a final buffer (the one you will return) using the length that you have identified and deallocate chunks used to compute all of this.
<br/>
<br/>
Also try to rely less on having every line commented to understand the code; if correctly factored the code requires much less commenting.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120836 - KayH - Tue Mar 06, 2007 12:23 pm</h4>
    <div class="postbody"><span class="postbody">"realloc" has the potential for a lot of errors!
<br/>
<br/>
1) if realloc fails it returns NULL but the old buffer is still there! This can cause a mem leak if you not free them.
<br/>
2) if the size given is zero, than the mem is freed and the old pointer is still valid (this can also cause problems)
<br/>
<br/>
Please read the docu for realloc carefull! You may also rethink your design.
<br/>
I would suggest to malloc space in portions of e.g. 80 chars (depending on your environment). If your app try to exceed this you malloc new 80 chars. With additional method you can combine both or more strings later ...
<br/>
(as keldon alread suggest)
<br/>
<br/>
HTH
<br/>
KaY</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120840 - tepples - Tue Mar 06, 2007 1:33 pm</h4>
    <div class="postbody"><span class="postbody">The C standard states that sizeof(char) is always 1 by definition, even on word-addressed DSPs and the like where char == short == int == a 32-bit type. (Only Java makes char equivalent to unsigned short.)
<br/>
<br/>
And yes, it's best to realloc() in chunks larger than 1 byte. You could have it start at size = 64 bytes, and then do <span style="font-weight: bold">bufferSize += bufferSize / 2;</span> every time size threatens to exceed bufferSize.
<br/>
<br/>
And yes, it's best to hold the result of realloc() in a temporary variable and then copy it over buffer only once you know it has succeeded.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120850 - Dracker - Tue Mar 06, 2007 7:18 pm</h4>
    <div class="postbody"><span class="postbody">Ok, how about this as a revision, to address those flaws?
<br/>
<br/>
pastebin: <a href="http://paste.biz/paste-852.html" target="_blank">http://paste.biz/paste-852.html</a>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include &lt;stdio.h&gt;
<br/>
#include &lt;stdlib.h&gt;
<br/>
#include &lt;string.h&gt;
<br/>
#include "infinite_fgets.h"
<br/>
<br/>
/*
<br/>
 * Basically, this function works like fgets except it handles
<br/>
 * an indefinite length input line.  Reads until it hits \n or EOF.
<br/>
 * Any line of text returned ends with \0.
<br/>
 *
<br/>
 * None of the lines returned contain/end with a newline!
<br/>
 *
<br/>
 * Returns NULL on error (malloc returns NULL, etc) or if
<br/>
 * no input is read before end of line/file
<br/>
 */
<br/>
<br/>
char * infinite_fgets(FILE * stream) {
<br/>
   char *buffer;
<br/>
   size_t strsize = 1;
<br/>
   short int i;
<br/>
   size_t bufsize = 10;
<br/>
   i = fgetc(stream);
<br/>
   if (   i == EOF        || /* no meaningful data before end of string */
<br/>
      i == '\0'   || 
<br/>
      i == '\255'   || 
<br/>
      i == '\r'       ||
<br/>
      i == '\n') return NULL; 
<br/>
   
<br/>
   buffer = malloc(bufsize);
<br/>
   if (buffer == NULL) { /* malloc error */ 
<br/>
      return NULL;
<br/>
   }
<br/>
   buffer[strsize-1] = (char)i;
<br/>
   buffer[strsize] = '\0';
<br/>
   strsize++;
<br/>
   for(;;) {
<br/>
      i = fgetc(stream);
<br/>
      if (   i == EOF   || /* end of string */
<br/>
         i == '\0'   ||
<br/>
         i == '\255'   ||
<br/>
         i == '\r'       ||
<br/>
         i == '\n') {
<br/>
         break;
<br/>
      }
<br/>
      
<br/>
      if (strsize == bufsize - 1) { /* buffer is exactly full */
<br/>
         char * tempbuffer = malloc(bufsize * 2);
<br/>
         if (tempbuffer == NULL) {
<br/>
            free(buffer);
<br/>
            return NULL;
<br/>
         }
<br/>
         strncpy(tempbuffer,buffer,bufsize);
<br/>
         free(buffer);
<br/>
         buffer = tempbuffer;
<br/>
         bufsize*=2;
<br/>
      }
<br/>
      buffer[strsize-1] = (char)i;
<br/>
      buffer[strsize] = '\0';
<br/>
      strsize++;
<br/>
   } /* END FOR */
<br/>
<br/>
   char * retval = malloc(strlen(buffer)+1);
<br/>
   /* strlen does not include space for the '\0' */
<br/>
   if (retval == NULL) {
<br/>
      free(buffer);
<br/>
      return NULL;
<br/>
   }
<br/>
   strncpy(retval,buffer,strlen(buffer)+1);
<br/>
   /* strncpy will copy the '\0' */
<br/>
   free(buffer);
<br/>
   return retval;
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/><span style="font-weight: bold">--Drack</span>
<br/>
Onyx DS Lite, M3 Perfect Lite, Flashme V7, Flashed using SocketMe
<br/>
Gamecube DOL-001 with Qoob Pro
<br/>
Wii, not modded.</span><span class="gensmall"><br/><br/>Last edited by Dracker on Tue Mar 06, 2007 7:49 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#120851 - Dracker - Tue Mar 06, 2007 7:35 pm</h4>
    <div class="postbody"><span class="postbody">Oh, and I found the original bug I was looking for.
<br/>
<br/>
It seems "return 0" and "return NULL" are equivalent when return type is char * - so I could not distinguish between EOF and other things that would cause a NULL return.
<br/>
<br/>
The infinite loop was not the one in infinite_fgets() but the one reading the file.  Without knowing that it had hit EOF it kept on reading the EOF character and malloc'ing 1 byte over and over, hence the mem leak.
<br/>
<br/>
I should have just used feof(stream) instead of rolling my own retval.<br/>_________________<br/><span style="font-weight: bold">--Drack</span>
<br/>
Onyx DS Lite, M3 Perfect Lite, Flashme V7, Flashed using SocketMe
<br/>
Gamecube DOL-001 with Qoob Pro
<br/>
Wii, not modded.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120852 - sajiimori - Tue Mar 06, 2007 7:40 pm</h4>
    <div class="postbody"><span class="postbody">Um... ouch.
<br/>
<br/>
Factor out the pseudo-implementation of std::vector into its own module, then write infinite_fgets in terms of the container.
<br/>
<br/>
Or just use cin &gt;&gt; std::string, which already works.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120854 - KayH - Tue Mar 06, 2007 7:55 pm</h4>
    <div class="postbody"><span class="postbody">cin would require cpp, it seems it is only c yet
<br/>
<br/>
I have to agree sajiimori cin and vector would be better, but if you want to use your own method, than it seems ok so far (at least for me :-) ).
<br/>
An implementation of a vector is probably also nice for further reusage, good point sajiimori!
<br/>
<br/>
you do not need strlen(), as you already have the length: strsize</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120856 - tepples - Tue Mar 06, 2007 8:21 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Or just use cin &gt;&gt; std::string, which already works.</td> </tr></table><span class="postbody">
<br/>
But doesn't using iostream add 200 KB even to Hello World?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120858 - sajiimori - Tue Mar 06, 2007 9:07 pm</h4>
    <div class="postbody"><span class="postbody">Maybe in a sucky environment or with bad settings.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120861 - Dracker - Tue Mar 06, 2007 9:21 pm</h4>
    <div class="postbody"><span class="postbody">Nice catch on the strlen() - fixed in my sources now.
<br/>
<br/>
As for CPP stuff, I am keeping infinite_fgets() entirely in C.
<br/>
<br/>
Thanks for the help everyone.<br/>_________________<br/><span style="font-weight: bold">--Drack</span>
<br/>
Onyx DS Lite, M3 Perfect Lite, Flashme V7, Flashed using SocketMe
<br/>
Gamecube DOL-001 with Qoob Pro
<br/>
Wii, not modded.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120893 - tepples - Wed Mar 07, 2007 2:45 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Maybe in a sucky environment or with bad settings.</td> </tr></table><span class="postbody">
<br/>
Then both MinGW and devkitARM are sucky environments with bad default settings.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#120965 - sajiimori - Wed Mar 07, 2007 7:49 pm</h4>
    <div class="postbody"><span class="postbody">Well yeah, MinGW does make suckily large binaries, doesn't it?  Maybe there's a setting to make it behave well, but I haven't found it.
<br/>
<br/>
As for devkitARM, the default setting is -O0 with exceptions and RTTI, no?  I don't blame it for using generous defaults, but if you don't specify the settings you want, then you can't really complain.
<br/>
<br/>
Then again, I haven't really used devkitARM, so maybe it has the same problems as MinGW.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121009 - wintermute - Thu Mar 08, 2007 4:09 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Well yeah, MinGW does make suckily large binaries, doesn't it?  Maybe there's a setting to make it behave well, but I haven't found it.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
MinGW makes pretty large binaries for C++, C binaries are comparable to msvc in most cases.
<br/>
<br/>
iostream is pretty heavy everywhere afaik, you just don't notice because mostly you use it on a machine with an operating system and shared libraries.
<br/>
<br/>
MinGW can't make use of shared libraries for C++ code since the ABI and name mangling aren't compatible between different compilers.<br/>_________________<br/><a class="postlink" href="http://www.devkitpro.org/" target="_blank">devkitPro - professional toolchains at amateur prices</a>
<br/>
<a class="postlink" href="http://wiki.devkitpro.org/index.php/IRC" target="_blank">devkitPro IRC support</a>
<br/>
<a class="postlink" href="http://davejmurphy.com/" target="_blank">Personal Blog</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
