<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>bit variable type - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > bit variable type</h2>
<div id="posts">
<div class="post">
    <h4>#1329 - Psyk - Thu Jan 16, 2003 8:27 pm</h4>
    <div class="postbody"><span class="postbody">How do I explicilty define a variable as only a single bit? I'm doing object collision and i just want a simple true or false value. I could define it as an 8bit value but that would waste space.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1337 - Splam - Thu Jan 16, 2003 9:04 pm</h4>
    <div class="postbody"><span class="postbody">You can use a bitfield in C (a bool basically).
<br/>
<br/>
eg
<br/>
struct collision {
<br/>
unsigned a: 1;
<br/>
unsigned b: 1;
<br/>
unsigned c: 1;
<br/>
unsigned d: 1;
<br/>
unsigned e: 1;
<br/>
unsigned f: 1;
<br/>
unsigned g: 1;
<br/>
unsigned h: 1;
<br/>
} coll;
<br/>
<br/>
then to check a bit in that you just do coll.?  ? = the letter in the struct
<br/>
You would of course need to do some kind of typedef on this to access your whole map as that struct only works on 1 byte.   The 1; after each letter is the length (in bits) so you can even have a=4bits then b,c,d,e =1bit each.  Also if using more than 1 bit you can make them signed or unsigned (can't do that obviosuly with 1 bit hence the unsigned).
<br/>
<br/>
-edit-
<br/>
Of course it's probably a lot easier to do something like this...
<br/>
<br/>
Xpos = xpos of the thing you're checking for collisions.
<br/>
<br/>
if (collisionmap[Xpos&gt;&gt;3]&amp;(1&lt;&lt;(Xpos&amp;7)))
<br/>
might need to be (0x80&gt;&gt;(Xpso&amp;7)  brain is in a lull at the moment ;)
<br/>
that will divide your "coarse" postion by 8 to get you a byte from your collision map then mask out everything other than the bit you want to check inside that byte (based on the lower 3 bits of the xpos).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1351 - Psyk - Thu Jan 16, 2003 11:30 pm</h4>
    <div class="postbody"><span class="postbody">Thanks but i already have a working collision detection. I have an 2D array with each item corresponding to a tile on the bg map. I just wanted to know if there is a way to define it as an array of 1bit values.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1377 - Touchstone - Fri Jan 17, 2003 11:07 am</h4>
    <div class="postbody"><span class="postbody">If you just create a bitmask for your collision tiles and a bitmask for your objects then you could '&amp;' them together. For instance:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">TileMask (in binary) = 11100000
<br/>
ObjMask (in binary) = 00001111
<br/>
Collision = TileMask &amp; ObjMask
<br/>
</td> </tr></table><span class="postbody">To check collision if the object has moved one pixel to the left for instance the easiest way would be to create a new ObjMask that is aligned with TileMask.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1381 - imikeyi - Fri Jan 17, 2003 1:37 pm</h4>
    <div class="postbody"><span class="postbody">ANSI C has no 'bit' variable, the lowest is a byte (char) unfortunately. Usually I represent booleans as a char.<br/>_________________<br/>microkernel advance</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1435 - KoCMoHaBT - Sat Jan 18, 2003 7:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">You can use a bitfield in C (a bool basically). 
<br/>
<br/>
eg 
<br/>
struct collision { 
<br/>
unsigned a: 1; 
<br/>
unsigned b: 1; 
<br/>
unsigned c: 1; 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This syntax is don't work. GCC make a every bitfield a <span style="font-weight: bold">unsigned int</span>, with aligment.
<br/>
If you want this one worked you must use this one:
<br/>
<br/>
union {
<br/>
   struct {
<br/>
      unsigned int a : 1,b : 1,c : 1; // etc. only "","", don't "";""
<br/>
   }; // if anonymous structure don't work, give name to them
<br/>
   unsigned int data;
<br/>
} collision;
<br/>
<br/>
something like this.
<br/>
Another one thing -- you cant mix the datatypes in struct with bitfields.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1437 - ampz - Sat Jan 18, 2003 8:26 pm</h4>
    <div class="postbody"><span class="postbody">Easiest way is probably to use a few defines.
<br/>
For example, this would create a 256 x 256 bit-array:
<br/>
<br/>
unsigned char map[32*256];
<br/>
<br/>
#define col(x,y) (1&amp;(map[(y&lt;&lt;5)+(x&gt;&gt;3)]&gt;&gt;(x&amp;7)))
<br/>
<br/>
#define setcol(x,y,val) val?map[(y&lt;&lt;5)+(x&gt;&gt;3)]|=1&lt;&lt;(x&amp;7):map[(y&lt;&lt;5)+(x&gt;&gt;3)]&amp;=~(1&lt;&lt;(x&amp;7))
<br/>
<br/>
<br/>
In your code, col(5,14) will return the value (1 or 0) stored in x=5, y=14
<br/>
setcol(3,7,0) will set the bit at 3,7 to 0.
<br/>
<br/>
Note: Code is untested.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
