<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How can I save va_list arguments for later use? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > How can I save va_list arguments for later use?</h2>
<div id="posts">
<div class="post">
    <h4>#175260 - Polaris - Mon Oct 25, 2010 11:04 pm</h4>
    <div class="postbody"><span class="postbody">First and foremost, I don't even know if this will be half as useful as I think, so try not to be too harsh if you try to explain why this is a dumb thing to do :)
<br/>
<br/>
Ok, so this is what I'm trying to do.
<br/>
<br/>
1) I send some random amount of arguments to a function using ellipsis.
<br/>
2) Then I read the va_list and store each value into a void pointer that are in turn saved into a vector. 
<br/>
3) My problem comes when I try to use the data in those void pointers, casting them to the proper data type doesn't seem to work.
<br/>
<br/>
Here is some sample code, for simplicity sake I'm only using int as data type.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;vector&gt;
<br/>
#include &lt;iostream&gt;
<br/>
#include &lt;stdarg.h&gt;
<br/>
<br/>
struct Bla{
<br/>
   void* ble;
<br/>
};
<br/>
<br/>
std::vector&lt;Bla*&gt; va_function(int argAmount, ...){
<br/>
   va_list vl;
<br/>
   va_start(vl,argAmount);
<br/>
   
<br/>
   std::vector&lt;Bla*&gt; bli;
<br/>
<br/>
   for (int i=0;i&lt;argAmount;i++){
<br/>
      int val = va_arg(vl,int);
<br/>
      Bla* item = new Bla();
<br/>
      item-&gt;ble = &amp;val;
<br/>
      
<br/>
      std::cout &lt;&lt; *(static_cast&lt;int*&gt;(item-&gt;ble)) &lt;&lt; std::endl;
<br/>
<br/>
      bli.push_back(item);
<br/>
<br/>
      std::cout &lt;&lt; *(static_cast&lt;int*&gt;(bli[0]-&gt;ble)) &lt;&lt; std::endl;
<br/>
   }
<br/>
<br/>
   va_end(vl);
<br/>
<br/>
   std::cout &lt;&lt; "BLABLABALBALBALBAL" &lt;&lt; std::endl;
<br/>
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(bli[0]-&gt;ble)) &lt;&lt; std::endl;
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(bli[1]-&gt;ble)) &lt;&lt; std::endl;
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(bli[2]-&gt;ble)) &lt;&lt; std::endl;
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(bli[3]-&gt;ble)) &lt;&lt; std::endl;
<br/>
<br/>
   return bli;
<br/>
};
<br/>
<br/>
int _tmain(int argc, _TCHAR* argv[]){
<br/>
   std::vector&lt;Bla*&gt; blih;
<br/>
<br/>
   blih = va_function(4, 5, 6, 7, 8);
<br/>
<br/>
   std::cout &lt;&lt; "BLABLABALBALBALBAL" &lt;&lt; std::endl;
<br/>
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(blih[0]-&gt;ble)) &lt;&lt; std::endl;
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(blih[1]-&gt;ble)) &lt;&lt; std::endl;
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(blih[2]-&gt;ble)) &lt;&lt; std::endl;
<br/>
   std::cout &lt;&lt; *(static_cast&lt;int*&gt;(blih[3]-&gt;ble)) &lt;&lt; std::endl;
<br/>
  
<br/>
        return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The above prints the following
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
5
<br/>
5
<br/>
6
<br/>
6
<br/>
7
<br/>
7
<br/>
8
<br/>
8
<br/>
BLABLABALBALBALBAL
<br/>
8
<br/>
8
<br/>
8
<br/>
8
<br/>
BLABLABALBALBALBAL
<br/>
-858993460
<br/>
-858993460
<br/>
-858993460
<br/>
-858993460
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Any hints or help is appreciated.
<br/>
<br/>
Obviously there is something terribly wrong with accessing those values after calling va_end. I'll continue to look at it, if I stare it long enough  I'm sure the answer will come to me.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175261 - elhobbs - Tue Oct 26, 2010 1:14 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">      int val = va_arg(vl,int); 
<br/>
      Bla* item = new Bla(); 
<br/>
      item-&gt;ble = &amp;val; 
<br/>
</td> </tr></table><span class="postbody">
<br/>
&amp;val is the address of a stack variable. it is not permanent -  it is going out of scope.
<br/>
<br/>
why are you messing with vargs? just use the vector</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175264 - Polaris - Tue Oct 26, 2010 1:17 pm</h4>
    <div class="postbody"><span class="postbody">As you put it,  I'm just messing with C++, not really doing anything. Like poking a beast with a stick :)
<br/>
<br/>
I thought it would be pretty cool(as cool as coding can be) if I could hold a vector of void pointers with whatever data came in the va_list, and then do the proper cast later on when I needed it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175319 - kusma - Tue Oct 26, 2010 9:43 pm</h4>
    <div class="postbody"><span class="postbody">As elhobbs pointed out, you're taking an address from the stack frame. That address will also be the same for ever element in the list. This is just horribly broken code.
<br/>
<br/>
Perhaps you're looking for va_copy()? This was introduced in C99 to allow to iterate through the same va_list multiple time. You're not really giving enough background here...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175330 - sajiimori - Wed Oct 27, 2010 10:30 pm</h4>
    <div class="postbody"><span class="postbody">Poking a beast with a stick!  Hahah, well said.  :)
<br/>
<br/>
It's easy to explain why the code doesn't work, but it's meaningless for us to give "suggestions" if you're just messing around without any particular goal.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175339 - sgeos - Thu Oct 28, 2010 3:41 pm</h4>
    <div class="postbody"><span class="postbody">Storing the void pointers doesn't make any sense (because they will be invalid as soon as the function returns), so you will need to figure out what those pointers point to and copy the data to a permanent location.  You'll need to allocate space for the values you want to store, and then dereference the pointers to copy the parameters to a permanent memory location.  This may involve dropping the values into a statically allocated memory pool, or dynamically allocating memory for the values.
<br/>
<br/>
FWIW, if you are passing consts with global scope, I think storing the void pointers should work.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175341 - kusma - Thu Oct 28, 2010 6:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">FWIW, if you are passing consts with global scope, I think storing the void pointers should work.</td> </tr></table><span class="postbody">
<br/>
No, he's reading them all into the same variable "int val" and taking the address of that, so it would most certainly not work :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175342 - Polaris - Thu Oct 28, 2010 8:39 pm</h4>
    <div class="postbody"><span class="postbody">At last success!
<br/>
<br/>
I replaced this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int val = va_arg(vl,int);
<br/>
Bla* item = new Bla();
<br/>
item-&gt;ble = &amp;val;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
with this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int val = va_arg(vl,int);
<br/>
Bla* item = new Bla();
<br/>
item-&gt;ble = new int();
<br/>
*(static_cast&lt;int*&gt;(item-&gt;ble)) = val;</td> </tr></table><span class="postbody">
<br/>
<br/>
I figured it out from reading this bit.
<br/>
<br/>
<span style="font-weight: bold">You'll need to allocate space for the values you want to store, and then dereference the pointers to copy the parameters to a permanent memory location.
<br/>
</span>
<br/>
<br/>
Now with some not so crafty code I should be able to hold what ever values I send in through the ellipsis.
<br/>
<br/>
To put some background on this weird shit, I have done quite a bit of AS3 coding lately(hint!). Long story short, AS3 let's you do all sorts of strange crap with ease, and among that is it's implementation of something very similar to ellipsis, Adobe calls it the rest parameter. 
<br/>
<br/>
What it does is turn what ever you send in through the function into an array with all the values you sent in, in the order you sent them in. So I wanted to know how would something like that would work in C++;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175343 - sajiimori - Thu Oct 28, 2010 10:42 pm</h4>
    <div class="postbody"><span class="postbody">And now you're about to discover that va_function needs to take some kind of parameter that specifies the types of the arguments.  :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175344 - sgeos - Thu Oct 28, 2010 11:07 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">And now you're about to discover that va_function needs to take some kind of parameter that specifies the types of the arguments.  :)</td> </tr></table><span class="postbody">
<br/>
Or you could build an assumption into your function call.  Ie, I'm passing in indices for accessing values in my big lookup table of wonderful stuff.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175348 - elwing - Fri Oct 29, 2010 7:51 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">And now you're about to discover that va_function needs to take some kind of parameter that specifies the types of the arguments.  :)</td> </tr></table><span class="postbody">
<br/>
<br/>
that is only true if you want to use the vsprintf style of methods, otherwise you can make assumption on the type of the parameter in va_list (through if you know by advance the type passed that almost cancel all interest of using elipsis...)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175350 - keldon - Fri Oct 29, 2010 10:39 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Polaris wrote:</b></span></td> </tr> <tr> <td class="quote">At last success!
<br/>
<br/>
I replaced this:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int val = va_arg(vl,int);
<br/>
Bla* item = new Bla();
<br/>
item-&gt;ble = &amp;val;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
with this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int val = va_arg(vl,int);
<br/>
Bla* item = new Bla();
<br/>
item-&gt;ble = new int();
<br/>
*(static_cast&lt;int*&gt;(item-&gt;ble)) = val;</td> </tr></table><span class="postbody">
<br/>
<br/>
I figured it out from reading this bit.
<br/>
<br/>
<span style="font-weight: bold">You'll need to allocate space for the values you want to store, and then dereference the pointers to copy the parameters to a permanent memory location.
<br/>
</span>
<br/>
<br/>
Now with some not so crafty code I should be able to hold what ever values I send in through the ellipsis.
<br/>
<br/>
To put some background on this weird shit, I have done quite a bit of AS3 coding lately(hint!). Long story short, AS3 let's you do all sorts of strange crap with ease, and among that is it's implementation of something very similar to ellipsis, Adobe calls it the rest parameter. 
<br/>
<br/>
What it does is turn what ever you send in through the function into an array with all the values you sent in, in the order you sent them in. So I wanted to know how would something like that would work in C++;</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Hmm, food for thought ...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">cout &lt;&lt; 1 &lt;&lt; "text" &lt;&lt; myObject &lt;&lt; endl;</td> </tr></table><span class="postbody">
<br/>
<br/>
But do try to stick to c++ practices when coding in c++; not because c++ is better, but so that you can learn to think and work in c++.
<br/>
<br/>
Consider this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Derived a( 10 ), b( 20 ), c( 40 ), d( 50 );
<br/>
Base *list[] = { &amp;a, &amp;b, &amp;c, &amp;d, Base::end };
<br/>
someFunction( list );</td> </tr></table><span class="postbody">
<br/>
<br/>
Or:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">someFunction( Base::List( ).add( a ).add( b ).add( c ).add( d ) )</td> </tr></table><span class="postbody">
<br/>
<br/>
Keep your mind in AS3 and you'll feel limited when you migrate to a new language.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175353 - sajiimori - Fri Oct 29, 2010 6:39 pm</h4>
    <div class="postbody"><span class="postbody">sgeos and elwing, I was assuming that Polaris ultimately wanted to have a heterogeneous list, hence the void pointers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175354 - Polaris - Fri Oct 29, 2010 6:55 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">sgeos and elwing, I was assuming that Polaris ultimately wanted to have a heterogeneous list, hence the void pointers.</td> </tr></table><span class="postbody">
<br/>
<br/>
You got it right sajiimori, I wouldn't have bothered with void* otherwise.
<br/>
<br/>
Thanks for the input everyone.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175357 - elhobbs - Fri Oct 29, 2010 8:42 pm</h4>
    <div class="postbody"><span class="postbody">I almost never use ... style parameters - except when I want to mimic and/or override printf style printing. aside from that it is very limiting in that the parameter count can only change in the source code - it is not dynamic.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#175358 - sgeos - Sat Oct 30, 2010 4:23 am</h4>
    <div class="postbody"><span class="postbody">I think keldon made a very good point, and I also agree with elhobbs.
<br/>
<br/>
I suppose a person could have reasons for holding lists of void pointers, but it seems dangerous enough that the reason ought to be very good.  Proceed at your own risk.  =)
<br/>
<br/>
In general, I think you are probably better off passing some kind of generic list (like an array of pointers) or a struct/class custom tailored to your specific problem (or a combination of both).  Depending on what you are doing, dynamic behavior that can be data driven or scripted is good stuff.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
