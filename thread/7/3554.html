<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>gcc "undefined reference to" - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > gcc "undefined reference to"</h2>
<div id="posts">
<div class="post">
    <h4>#22075 - FPChris - Sat Jun 12, 2004 11:18 pm</h4>
    <div class="postbody"><span class="postbody">Hey All,
<br/>
<br/>
It's been several years since I've touched C. I've mainly done C++
<br/>
for the past 7-8 years. I'm now coding with devkitadv r5 with
<br/>
VisualC and my C is a little rusty...
<br/>
<br/>
The problem ...
<br/>
<br/>
I have a main.c file that includes a xfont.h file.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//----------------------------------------------------------------
<br/>
//xfont.h
<br/>
//----------------------------------------------------------------
<br/>
#ifndef XFONT_H
<br/>
#define XFONT_H
<br/>
<br/>
<br/>
#include "xgbatypes.h"
<br/>
<br/>
struct xGBAFont{
<br/>
<br/>
   u8 pali[4]; //color palettes indexes
<br/>
   u8 *pBmp[256];  //pointers to characters
<br/>
<br/>
};
<br/>
<br/>
<br/>
//----------------------------------------------------------------
<br/>
//xfont function prototypes
<br/>
//----------------------------------------------------------------
<br/>
extern void xPutCh(s16 x, s16 y, u16* buf, u8* pCh,struct xGBAFont* pF);
<br/>
<br/>
#endif
<br/>
//----------------------------------------------------------------
<br/>
//end of file
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
When compiled main can see the xGBAFont struct but not
<br/>
the xPutCh() function.
<br/>
<br/>
gcc error is:
<br/>
<br/>
main.o: In function `main':
<br/>
main.o(.text+0x188): undefined reference to `xPutCh(short, short, unsigned short*, unsigned char*, xGBAFont*)'
<br/>
collect2: ld returned 1 exit status
<br/>
NMAKE : fatal error U1077: 'gcc' : return code '0x1'
<br/>
<br/>
This is driving me batty. I even moved the function proto into
<br/>
main.c and it STILL generates this same error.
<br/>
<br/>
WTF?
<br/>
<br/>
Any advice would be greatly appreciated.
<br/>
Chris
<br/>
<br/>
<br/>
[/code]</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22077 - FPChris - Sat Jun 12, 2004 11:34 pm</h4>
    <div class="postbody"><span class="postbody">Ok I shuffled things around and gcc showed an error
<br/>
in an unrelated file that clear it up.
<br/>
<br/>
Looks like I'm in for some hair pulling if this is the norm for gcc errors.
<br/>
<br/>
Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22078 - dagamer34 - Sun Jun 13, 2004 12:23 am</h4>
    <div class="postbody"><span class="postbody">Did you add your .o file where xfont is defined to your makefile? It's not being linked into your binary.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22080 - Abscissa - Sun Jun 13, 2004 1:11 am</h4>
    <div class="postbody"><span class="postbody">Also, you might have messed up the parameters to the function: Missing params, extra params, using an int when it expects a float, etc.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22089 - FPChris - Sun Jun 13, 2004 3:36 am</h4>
    <div class="postbody"><span class="postbody">What happen was I'm so used to C++ that I declared a new font as...
<br/>
<br/>
xGBAFont xSysFont;
<br/>
<br/>
instead of...
<br/>
<br/>
struct xGBAFont xSysFont;
<br/>
<br/>
This was in my "xsysfont.h" and simply adding 'struct'
<br/>
resolved the error.
<br/>
<br/>
I've done this a couple times already and gcc never seems
<br/>
to generate a error than is in reference to the omission.
<br/>
Leaves me looking all over and screaming at the monitor :)
<br/>
<br/>
Thanks anyways...
<br/>
Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22095 - Abscissa - Sun Jun 13, 2004 5:09 am</h4>
    <div class="postbody"><span class="postbody">There's a little trick with typedef in C that's commonly used so that you don't have to worry about declaring using "struct":
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct t_xGBAFont{ 
<br/>
<br/>
   u8 pali[4]; //color palettes indexes 
<br/>
   u8 *pBmp[256];  //pointers to characters 
<br/>
<br/>
} xGBAFont; </td> </tr></table><span class="postbody">
<br/>
<br/>
With that, you can just say "xGBAFont xSysFont" even on very strict C compilers.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22098 - keldon - Sun Jun 13, 2004 9:38 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Abscissa wrote:</b></span></td> </tr> <tr> <td class="quote">There's a little trick with typedef in C that's commonly used so that you don't have to worry about declaring using "struct":
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef struct t_xGBAFont{ 
<br/>
<br/>
   u8 pali[4]; //color palettes indexes 
<br/>
   u8 *pBmp[256];  //pointers to characters 
<br/>
<br/>
} xGBAFont; </td> </tr></table><span class="postbody">
<br/>
<br/>
With that, you can just say "xGBAFont xSysFont" even on very strict C compilers.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
It's not a trick, it's a language feature :D lolol</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22100 - FPChris - Sun Jun 13, 2004 12:21 pm</h4>
    <div class="postbody"><span class="postbody">Excellent. That's what I was forgetting.
<br/>
<br/>
Its working as I'd like it too now.
<br/>
<br/>
Thanks guys.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22101 - sgeos - Sun Jun 13, 2004 1:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Abscissa wrote:</b></span></td> </tr> <tr> <td class="quote">There's a little trick with typedef in C that's commonly used so that you don't have to worry about declaring using "struct"</td> </tr></table><span class="postbody">
<br/>
If you always declare structs with the struct keyword people reading your code will know that the data type is a struct and not something else.  That can be useful:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef void (*big_magic_action)(int, int);
<br/>
typedef struct widget {
<br/>
   const char *name;
<br/>
   int cost;
<br/>
   big_magic_action please_do_big_magic;
<br/>
} widget;
<br/>
typedef int life_bar;</td> </tr></table><span class="postbody">
<br/>
Naming conventions are helpful.  I think that leaving struct in front of structs is a fine naming convention.
<br/>
<br/>
One of these would be a struct:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   const widget funny_thing_that_is_completely_useless_and_can_not_be_purchased_or_sold = MAGIC_BUTTON_PRESS_MACRO_TOKEN_MAKER_DEALIE_MA_JIG(last_funny_thing_you_get_for_pressing_, BUTTON_TRACKED_USING_HAPPY_SKILLS, _at_least_, BIG_UNREASONABLE_NUMBER, _times_total);
<br/>
   life_bar candys_bar_of_life = DEFAULT_GOLD_BAR;
<br/>
   big_magic_action super_hyper_super_neo_ultra_magic_radio_missle_death_wa
<br/>
ve = divine_beam_spray_deluxe_super_special_ten_billion_hit_combo_mk_viii_red_version;</td> </tr></table><span class="postbody">
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22103 - poslundc - Sun Jun 13, 2004 2:09 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">Naming conventions are helpful.  I think that leaving struct in front of structs is a fine naming convention.</td> </tr></table><span class="postbody">
<br/>
<br/>
In priciple I agree, but in practice I find the struct keyword is usually superfluous. Especially since I rarely find it practical to typedef either function pointers or primitive data types (beyond the u32, s16, etc. contractions).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22113 - Abscissa - Sun Jun 13, 2004 4:03 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">Naming conventions are helpful.  I think that leaving struct in front of structs is a fine naming convention.</td> </tr></table><span class="postbody">
<br/>
<br/>
In priciple I agree, but in practice I find the struct keyword is usually superfluous. Especially since I rarely find it practical to typedef either function pointers or primitive data types (beyond the u32, s16, etc. contractions).
<br/>
<br/>
Dan.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
My experience with this has been the same as Dan's.  However, I think that it *would* be very useful to typedef primitives (and to use enums more) *if* C had stronger type checking.  (I suppose this is getting a little off topic, but it's been bugging me for a while).  I'm actually very opposed to the way C automatically casts between a typedef or enum and it's underlying type - it makes those features more or less useless, since they're functionally identical to #define.  I would love it if the compiler were, for example, to generate errors on this:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
typedef enum t_shape {SQUARE, RECT, TRIANGLE} shape;
<br/>
typedef int shieldAmount;
<br/>
<br/>
void Foo(shape myShape, shieldAmount myShield)
<br/>
{
<br/>
  // Do something
<br/>
}
<br/>
<br/>
void Bar(void)
<br/>
{
<br/>
     int numEnemiesTotal = 7;
<br/>
     u16 color = 0xFFFF;
<br/>
<br/>
         // This should not be allowed,
<br/>
         // but C doesn't even issue a warning
<br/>
     Bar(color, numEnemiesTotal);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Since it doesn't, this can introduce a lot of bugs, AND defeats the purpose of typedef and enum.  Their purpose is to create a new type, but the only thing they really end up doing is create a name alias for existing types, so it's not particularly useful to use them. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22158 - FPChris - Mon Jun 14, 2004 12:21 am</h4>
    <div class="postbody"><span class="postbody">I'd say they are very useful in cases where you have:
<br/>
<br/>
typedef int shieldAmount;
<br/>
<br/>
Now say you have used shieldAmount in over 100 places in your code
<br/>
and have found out that it would be better if shieldAmount was a char.
<br/>
<br/>
typedef char shieldAmount;
<br/>
<br/>
Changing one line of code is far easier than changing 100 instances.
<br/>
And although were on GBA here, if the code was moved to
<br/>
another piece of hardware where 'int' sized data cause a conflict
<br/>
it could be easily fixed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22161 - Abscissa - Mon Jun 14, 2004 1:24 am</h4>
    <div class="postbody"><span class="postbody">True, but that still isn't any different than doing:
<br/>
<br/>
#define shieldAmount int</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22162 - sgeos - Mon Jun 14, 2004 1:27 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">I rarely find it practical to typedef either function pointers or primitive data types (beyond the u32, s16, etc. contractions).</td> </tr></table><span class="postbody">
<br/>
Contrary to what some may believe, u32, s16, etc are not typedef'd to save typing.  They are typedef'd because the underlying type might change.  An s16 is a signed integer that is at least 16 bits.  By using s16 you can port your code to another target or compiler and it will still work if the typedefs are set up correctly.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Abscissa wrote:</b></span></td> </tr> <tr> <td class="quote">However, I think that it *would* be very useful to typedef primitives (and to use enums more) *if* C had stronger type checking.</td> </tr></table><span class="postbody">
<br/>
Run time type checking is expensive.  I don't see any reason why a compiler couldn't issue warnings.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Abscissa wrote:</b></span></td> </tr> <tr> <td class="quote">this ... defeats the purpose of typedef and enum.  Their purpose is to create a new type, but the only thing they really end up doing is create a name alias for existing types, so it's not particularly useful to use them. :(</td> </tr></table><span class="postbody">
<br/>
One uses a typedef when the underlying type might change.  An enum is used when one wants to represent numerical values using names.  From what I understand, gcc's version of enum is not much different from a string of #define statements.
<br/>
<br/>
enum is compatable with int in C, so I can do something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef enum {HP_DEAD = 0xffff} hp_t;</td> </tr></table><span class="postbody">
<br/>
Then:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void take_damage_for_non_evil_vampire_type_creatures
<br/>
(
<br/>
   hp_t *hp_ptr,
<br/>
   u16 damage
<br/>
)
<br/>
{
<br/>
   if (damage &lt; *hp_ptr)
<br/>
      *hp_ptr -= damage;
<br/>
   else
<br/>
      *hp_ptr = HP_DEAD;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Sure, all of this could be done with #define statements.  I can even:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">int x = HP_DEAD;</td> </tr></table><span class="postbody">
<br/>
If I really want to.
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22166 - poslundc - Mon Jun 14, 2004 1:49 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">I rarely find it practical to typedef either function pointers or primitive data types (beyond the u32, s16, etc. contractions).</td> </tr></table><span class="postbody">
<br/>
Contrary to what some may believe, u32, s16, etc are not typedef'd to save typing.  They are typedef'd because the underlying type might change.  An s16 is a signed integer that is at least 16 bits.  By using s16 you can port your code to another target or compiler and it will still work if the typedefs are set up correctly.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
There was another thread I started some months back that discussed the philosophies behind naming conventions... I actually <span style="font-style: italic">prefer</span> the extra typing involved to define, for example, an "unsigned short int" but force myself to use u16 instead. Not so much for this reason - I do not expect or plan to be porting my GBA code any time soon to such a dramatically different architecture - but because if I explicitly state the variable size in its type then I know it's because I care about the size, whereas on the other hand I will always simply use "int" for generic counters, etc. where size is unimportant.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Abscissa wrote:</b></span></td> </tr> <tr> <td class="quote">However, I think that it *would* be very useful to typedef primitives (and to use enums more) *if* C had stronger type checking.</td> </tr></table><span class="postbody">
<br/>
Run time type checking is expensive.  I don't see any reason why a compiler couldn't issue warnings.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
The kind of type-checking Abscissa is describing could easily be done at compile time.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">One uses a typedef when the underlying type might change.</td> </tr></table><span class="postbody">
<br/>
<br/>
... Or as simply a way to shorthand a longer type.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">An enum is used when one wants to represent numerical values using names.  From what I understand, gcc's version of enum is not much different from a string of #define statements.</td> </tr></table><span class="postbody">
<br/>
<br/>
Other than #defines being handled by the pre-processor and enum generating symbols in the compiler. Two ways of skinning the same cat, I suppose.
<br/>
<br/>
Abscissa makes a point that C doesn't offer a simple way to have constants declared as a property of an exclusive type. That's more of a C++ thing. Whether or not you miss it depends on you, I suppose. I've never lost any sleep - or, more importantly, debugging time - over it, though.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
