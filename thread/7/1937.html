<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>noob - pern tutorial 3 issue - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > noob - pern tutorial 3 issue</h2>
<div id="posts">
<div class="post">
    <h4>#9969 - nazuraku - Sat Aug 23, 2003 7:57 pm</h4>
    <div class="postbody"><span class="postbody">I have gone through and downloaded pern's tutorial 3 and it seems to work fine except for one issue... whenever the sprite passes off the screen and returns on the other side and then crosses the point x coordinate at which it started... it suddenly becomes a blank green square.  I am at a loss how this could happen and am wondering if someone has any clues to why.  I origionally thought it could be a emulator issue, but I have tried multiple emulators and they all do the same thing.  It also appears that the sprite will get knocked a little to the right if you continually press down.  I will post the code below, but I am assuming many of you already have this code. 
<br/>
<br/>
#include&lt;math.h&gt;
<br/>
#include"gba.h"
<br/>
#include"screenmode.h"
<br/>
#include"keypad.h"
<br/>
#include"sprite.h"
<br/>
<br/>
#include"sprite1.h"
<br/>
<br/>
<br/>
<br/>
#define FIXED s32
<br/>
#define PI 3.14159
<br/>
#define RADIAN(n) 		(((float)n)/(float)180*PI)
<br/>
<br/>
///declare our functions so the c compiler knows what we are talking about
<br/>
<br/>
void InitializeSprites(void);
<br/>
void WaitForVsync(void);
<br/>
void CopyOAM(void);
<br/>
void GetInput(void);
<br/>
void MoveSprite(OAMEntry* sp, int x, int y);
<br/>
void RotateSprite(int rotDataIndex, int angle, FIXED x_scale,FIXED y_scale);
<br/>
<br/>
///these are global so i do not have to pass them to GetInput
<br/>
s16 x = 10;
<br/>
s16 y = 10;
<br/>
u16 char_number = 0;
<br/>
<br/>
FIXED angle = 0;
<br/>
FIXED zoom = 1&lt;&lt;8;
<br/>
<br/>
FIXED SIN[360];
<br/>
FIXED COS[360];
<br/>
<br/>
<br/>
<br/>
///main entry point from the boot.asm startup file
<br/>
int AgbMain(void)
<br/>
<br/>
{
<br/>
	int index = 0;  //some looping variables for loops :)
<br/>
	u16 loop;
<br/>
<br/>
	for(loop = 0; loop &lt; 360; loop++)
<br/>
	{
<br/>
		SIN[loop] = (FIXED)(sin(RADIAN(loop)) * 256);  //sin and cos are computed and cast to 							//fixed
<br/>
		COS[loop] = (FIXED)(cos(RADIAN(loop)) * 256);
<br/>
	}
<br/>
<br/>
	SetMode(MODE_2 | OBJ_ENABLE | OBJ_MAP_1D); //set mode 2 and enable sprites and 2d mapping
<br/>
<br/>
	for(loop = 0; loop &lt; 256; loop++)
<br/>
		OBJPaletteMem[loop] = sprite1Palette[loop];	//loop through and store the palette from your pict
<br/>
									//palette into obj palette mem OBJPaletteMem is
<br/>
									//defined in gba.h.  sprite1Palette is from
<br/>
									//pcx2gba tool sprite1.h.
<br/>
<br/>
	InitializeSprites();  //set all 128 sprites to offscreen
<br/>
<br/>
	//this is were we define our sprite atributes for the first sprite
<br/>
	//256 color 64x64 sprite that starts at character 0.  Character 0 is
<br/>
	//the first sprite data memory location.
<br/>
<br/>
	sprites[0].attribute0 = COLOR_256 | SQUARE| ROTATION_FLAG | y;
<br/>
	sprites[0].attribute1 = SIZE_64 |ROTDATA(0)|x;
<br/>
	sprites[0].attribute2 = char_number;
<br/>
<br/>
<br/>
//allright now to copy in the sprites bitmap.  The data in sprite1Data is allready striped
<br/>
//so we just copy it in one row of tiles at a time.  The only difference between this and a
<br/>
//2D sprite is that we would need to keep in mind the fact that the tiles are not all in a row.
<br/>
//We could just use one big for loop.  There are 8 rows (64x64 = 8x8 tiles) so we loop through
<br/>
//all 8.  There is 512 bytes per row (8 tiles * 8x8 = 512) but since we copy 2 bytes at a
<br/>
//time that equals 256.  The width of char memory is 32 * 8x8 = 1024 (512 double bytes).
<br/>
//	
<br/>
		for(index = 0; index &lt; 256*8; index++)
<br/>
		{
<br/>
			OAMData[index] = sprite1Data[index];
<br/>
<br/>
		}//end index loop
<br/>
<br/>
///Main Game loop	
<br/>
	while(1)
<br/>
	{
<br/>
		GetInput();    //get input changes the x and y based on input
<br/>
		MoveSprite(&amp;sprites[0],x,y); //changes sprite atributes based on new x,y
<br/>
<br/>
		RotateSprite(0,angle,zoom,zoom);
<br/>
<br/>
		WaitForVsync();			//waits for the screen to stop drawing
<br/>
		CopyOAM();				//Copies our sprite array into OAM.
<br/>
	}
<br/>
}
<br/>
<br/>
////Set sprites to off screen
<br/>
<br/>
void InitializeSprites(void)
<br/>
{
<br/>
	int loop;
<br/>
	for(loop = 0; loop &lt; 128; loop++)
<br/>
	{
<br/>
		sprites[loop].attribute0 = 160;  //y to &gt; 159
<br/>
		sprites[loop].attribute1 = 240;  //x to &gt; 239
<br/>
	}
<br/>
}
<br/>
<br/>
//wait for the screen to stop drawing
<br/>
void WaitForVsync(void)
<br/>
{
<br/>
<br/>
<br/>
//lets get rid of htat inline asm we used in arm
<br/>
<br/>
/*
<br/>
	__asm
<br/>
	{
<br/>
		mov 	r0, #0x4000006   //0x4000006 is vertical trace counter; when it hits 160					 //160 the vblanc starts
<br/>
		scanline_wait:	       	//the vertical blank period has begun. done in asm just
<br/>
								//because:)
<br/>
		ldrh	r1, [r0]
<br/>
		cmp	r1, #160
<br/>
		bne 	scanline_wait
<br/>
	}			
<br/>
*/
<br/>
<br/>
while(REG_VCOUNT&lt;160);
<br/>
<br/>
}
<br/>
<br/>
///Copy our sprite array to OAM
<br/>
void CopyOAM(void)
<br/>
{
<br/>
	u16 loop;
<br/>
	u16* temp;
<br/>
	temp = (u16*)sprites;
<br/>
	for(loop = 0; loop &lt; 128*4; loop++)
<br/>
	{
<br/>
		OAM[loop] = temp[loop];
<br/>
	}
<br/>
}
<br/>
<br/>
///Test for key presses
<br/>
void GetInput(void)
<br/>
{
<br/>
	if(!(*KEYS &amp; KEY_UP))
<br/>
	{
<br/>
 		y--;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_DOWN))
<br/>
	{
<br/>
 		y++;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_LEFT))
<br/>
	{
<br/>
 		x--;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_RIGHT))
<br/>
	{
<br/>
 		x++;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_L))
<br/>
	{
<br/>
 		angle--;
<br/>
		if(angle&lt;0)
<br/>
			angle = 359;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_R))
<br/>
	{
<br/>
 		angle++;
<br/>
		if(angle &gt; 359)
<br/>
			angle = 0;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_A))
<br/>
	{
<br/>
 		zoom--;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_B))
<br/>
	{
<br/>
 		zoom++;
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_START))
<br/>
	{
<br/>
 		if(!(sprites[0].attribute0 &amp; SIZE_DOUBLE))//set or clear size double
<br/>
		{											//needs if to keep from holding down the start
<br/>
			sprites[0].attribute0 |= SIZE_DOUBLE;
<br/>
			x-=32;								//size double shifts the sprite center by half the width and height this just
<br/>
			y-=32;								//adjusts for it.
<br/>
		}
<br/>
	}
<br/>
	if(!(*KEYS &amp; KEY_SELECT))
<br/>
	{
<br/>
 		if((sprites[0].attribute0 &amp; SIZE_DOUBLE))
<br/>
		{
<br/>
			sprites[0].attribute0 &amp;= ~SIZE_DOUBLE;
<br/>
			x+=32;
<br/>
			y+=32;
<br/>
		}
<br/>
	}
<br/>
}
<br/>
<br/>
//move the sprite
<br/>
void MoveSprite(OAMEntry* sp, int x, int y)
<br/>
{
<br/>
	if(x &lt; 0)			//if it is off the left corect
<br/>
		x = 512 + x;
<br/>
	if(y &lt; 0)			//if off the top corect
<br/>
		y = 256 + y;
<br/>
<br/>
	sp-&gt;attribute1 = sp-&gt;attribute1 &amp; 0xFE00;  //clear the old x value
<br/>
	sp-&gt;attribute1 = sp-&gt;attribute1 | x;
<br/>
<br/>
	sp-&gt;attribute0 = sp-&gt;attribute0 &amp; 0xFF00;  //clear the old y value
<br/>
	sp-&gt;attribute0 = sp-&gt;attribute0 | y;
<br/>
}	
<br/>
void RotateSprite(int rotDataIndex, int angle, FIXED x_scale,FIXED y_scale)
<br/>
{
<br/>
<br/>
	FIXED pa,pb,pc,pd;
<br/>
<br/>
	pa = ((x_scale) * COS[angle])&gt;&gt;8;    //(do my fixed point multiplies and shift back down)
<br/>
	pb = ((y_scale) * SIN[angle])&gt;&gt;8;
<br/>
	pc = ((x_scale) * -SIN[angle])&gt;&gt;8;
<br/>
	pd = ((y_scale) * COS[angle])&gt;&gt;8;
<br/>
<br/>
<br/>
	rotData[rotDataIndex].pa = pa;  //put them in my data struct
<br/>
	rotData[rotDataIndex].pb = pb;
<br/>
	rotData[rotDataIndex].pc = pc;
<br/>
	rotData[rotDataIndex].pd = pd;
<br/>
}
<br/>
<br/>
I would appreciate any ideas or comments you may have
<br/>
<br/>
thx</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9970 - sajiimori - Sat Aug 23, 2003 8:05 pm</h4>
    <div class="postbody"><span class="postbody">The x and y coordinates for the sprite are stored in 16 bit integers.  These are blindly or'ed into the sprite attributes, neglecting possible overflows (x should only use 9 bits, y only 8).  The overflow bits are overwriting other sprite flags.
<br/>
<br/>
Fix:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
sp-&gt;attribute1 = sp-&gt;attribute1 &amp; 0xFE00;  //clear the old x value
<br/>
sp-&gt;attribute1 = sp-&gt;attribute1 | (x &amp; 0x1FF);
<br/>
sp-&gt;attribute0 = sp-&gt;attribute0 &amp; 0xFF00;  //clear the old y value
<br/>
sp-&gt;attribute0 = sp-&gt;attribute0 | (y &amp; 0xFF);
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9974 - nazuraku - Sat Aug 23, 2003 8:40 pm</h4>
    <div class="postbody"><span class="postbody">That helped alot, it was driving me nuts.  
<br/>
<br/>
I ended up changing the move sprite function to another function I found on this forum, and that seemed to completely fix the issue
<br/>
<br/>
I changed the
<br/>
<br/>
	sp-&gt;attribute1 = sp-&gt;attribute1 &amp; 0xFE00;  //clear the old x value
<br/>
	sp-&gt;attribute1 = sp-&gt;attribute1 | x;
<br/>
<br/>
	sp-&gt;attribute0 = sp-&gt;attribute0 &amp; 0xFF00;  //clear the old y value
<br/>
	sp-&gt;attribute0 = sp-&gt;attribute0 | y;
<br/>
<br/>
to
<br/>
<br/>
  y &amp;= 0x00ff;  /* wrap y coordinate */ 
<br/>
  spr-&gt;attribute0 = (spr-&gt;attribute0 &amp; 0xff00) | y;  /* change only y bits */ 
<br/>
  x &amp;= 0x01ff;  /* wrap x coordinate */ 
<br/>
  spr-&gt;attribute1 = (spr-&gt;attribute1 &amp; 0xfe00) | x;  /* change only x bits */ 
<br/>
<br/>
to stop from overflow and it seems to work great.  Thanks for the advice again.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
