<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>String parsing bug I can't figure out - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > String parsing bug I can't figure out</h2>
<div id="posts">
<div class="post">
    <h4>#163374 - NovaYoshi - Tue Sep 30, 2008 11:29 pm</h4>
    <div class="postbody"><span class="postbody">I'm trying to write some code to let me split a string into sections, each section going into a new string, using a space to separate each. I'm trying to get this right so I can add argument support to my IRC bot's commands...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
<br/>
int main()
<br/>
{
<br/>
   system("cls"); //clear the screen
<br/>
   char buffer[1024];
<br/>
   char output[128][4]={"","","",""};   //where the split up text will go
<br/>
   int x=0;
<br/>
   int y=0;
<br/>
   int z=0;
<br/>
   char c=' ';
<br/>
<br/>
   fgets(buffer, 1024, stdin); //so spaces are read
<br/>
<br/>
<br/>
   while(c!='\0')//until we go and find a null byte in the input string
<br/>
   {
<br/>
      puts("------------------------------");
<br/>
      c=buffer[x];
<br/>
      printf("(C:\'%c\' X:%d Y:%d Z:%d)", c,x,y,z);
<br/>
<br/>
      if(c==' ')   //go and start filling the next buffer if we encounter a space
<br/>
      {
<br/>
         puts("Space encountered...");
<br/>
         output[z][y+1]='\0';   //finish the string with a null byte
<br/>
         y=0;   //We want to start filling from the beginning of the next buffer
<br/>
         z++;   //We want to start filling the next buffer
<br/>
      }
<br/>
      else
<br/>
         if(isalpha(c))   //so returns and crap are caught
<br/>
         {
<br/>
            output[z][y]=c;   //put the character in
<br/>
         }
<br/>
         else
<br/>
         {
<br/>
            puts("Was not alphanumeric... ignoring...");
<br/>
         }
<br/>
      x++;
<br/>
      y++;
<br/>
      putchar('\n');
<br/>
   printf("Out1: %s\n",output[0]);
<br/>
   printf("Out2: %s\n",output[1]);
<br/>
   printf("Out3: %s\n",output[2]);
<br/>
   printf("Out4: %s\n",output[3]);
<br/>
      putchar('\n');
<br/>
   }
<br/>
   output[z][y+1]='\0';   //add a null byte to that last buffer
<br/>
   //Show the final results
<br/>
   printf("Buffer: %s\n",buffer);
<br/>
   printf("Out1: %s\n",output[0]);
<br/>
   printf("Out2: %s\n",output[1]);
<br/>
   printf("Out3: %s\n",output[2]);
<br/>
   printf("Out4: %s\n",output[3]);
<br/>
<br/>
   return(1);
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
[edit] I asked on #C of Rizon, and Shahid helped me. He found what was wrong... and gave me the fixed source:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;ctype.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
 
<br/>
 
<br/>
int main()
<br/>
{
<br/>
   system("cls");
<br/>
   char buffer[1024];
<br/>
   char output[4][128] = {'\0' };   //where the split up text will go
<br/>
   int x=0;
<br/>
   int y=0;
<br/>
   int word=0;
<br/>
   char c=' ';
<br/>
 
<br/>
   fgets(buffer, 1024, stdin);
<br/>
 
<br/>
 
<br/>
   while(c != '\0')//until we go and find a null byte in the input string
<br/>
   {
<br/>
      c=buffer[x];
<br/>
      if(c==' ')   //go and start filling the next buffer if we encounter a space
<br/>
      {
<br/>
         puts("Space encountered...");
<br/>
         output[word][y+1]='\0';   //finish the string with a null byte
<br/>
         y=0;   //We want to start filling from the beginning of the next buffer
<br/>
         word++;   //We want to start filling the next buffer
<br/>
      }
<br/>
      else
<br/>
      {
<br/>
         if(isalpha(c))   //so returns and crap are caught
<br/>
         {
<br/>
            output[word][y]=c;   //put the character in
<br/>
         }
<br/>
         else
<br/>
         {
<br/>
            puts("Was not alphanumeric... ignoring...");
<br/>
         }
<br/>
         y++;
<br/>
      }
<br/>
      x++;
<br/>
   }
<br/>
   output[word][y+1]='\0';   //add a null byte to that last buffer
<br/>
 
<br/>
   printf("Buffer: %s\n",buffer);
<br/>
   printf("Out1: %s\n",output[0]);
<br/>
   printf("Out2: %s\n",output[1]);
<br/>
   printf("Out3: %s\n",output[2]);
<br/>
   printf("Out4: %s\n",output[3]);
<br/>
 
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163381 - nanou - Wed Oct 01, 2008 5:13 am</h4>
    <div class="postbody"><span class="postbody">... or you could use strtok().
<br/>
<br/>
It's frowned upon by some (but no more so than some of other things you're doing anyway.)<br/>_________________<br/>- nanou</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163387 - mml - Wed Oct 01, 2008 9:08 am</h4>
    <div class="postbody"><span class="postbody">Use strtok, or if you're worried about the frowning (and your C library has it), use strtok_r</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163394 - Miked0801 - Wed Oct 01, 2008 5:23 pm</h4>
    <div class="postbody"><span class="postbody">That there is some dangerous code.  You are likely to overwrite at least 2 arrays that I can see and probably more.  Why 1024 on input via fgets?  You could fgetc the buffer instead and step individually.  You have no word cout.  More than 4 words and boom.  You have no character count.  More than 128 letters and boom.  Everytime I see [z][y+1] I cringe as that is another case of memory corruption waitng to occur.  Single letter variable names will destroy you when you pick this code up later on and try to read it.  
<br/>
<br/>
But, you get the idea.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163405 - NovaYoshi - Wed Oct 01, 2008 8:28 pm</h4>
    <div class="postbody"><span class="postbody">Right, and I've been fixing up the code in implementing it into my bot, so that my bot won't crash with input like that... 
<br/>
[edit] Of course, I COULD be sloppy and have a second bot check to see if the first bot stops running, and restart it...
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Why 1024 on input via fgets?  You could fgetc the buffer instead and step individually.</td> </tr></table><span class="postbody">
<br/>
With the plugin system that XChat uses, the input string is already defined, and I don't know if fgetc works with strings and not just files...
<br/>
And I don't need that big buffer anymore, for the same reason. I just have it read from the command handler's arguments.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163485 - cheesethulhu - Fri Oct 03, 2008 6:30 am</h4>
    <div class="postbody"><span class="postbody">I have to second what other posters have said.  If you're allowed to modify the string passed to your code, then you should definitely use strtok_r().  If you aren't allowed to modify it, use strdup() and then strtok_r() (and of course eventually free()).
<br/>
<br/>
Regardless of what direction you decide to go with the code, here are some changes I would make to what you posted (the version edited by Shahid).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#include &lt;ctype.h&gt;
<br/>
#include &lt;stdio.h&gt;
<br/>
<br/>
// (note #6)
<br/>
#define MAX_ARGUMENTS         (4)
<br/>
#define MAX_ARGUMENT_LENGTH (128)
<br/>
<br/>
int main()
<br/>
{
<br/>
   system("cls");
<br/>
   char buffer[1024];
<br/>
   char output[MAX_ARGUMENTS][MAX_ARGUMENT_LENGTH] = {'\0' };   //where the split up text will go
<br/>
   int x=0;
<br/>
   int y=0;
<br/>
   int word=0;
<br/>
   char c=' ';
<br/>
   int i;
<br/>
 
<br/>
   fgets(buffer, 1024, stdin);
<br/>
 
<br/>
 
<br/>
   while((c != '\0') &amp;&amp; (word &lt; MAX_ARGUMENTS))//until we go and find a null byte in the input string (note #6)
<br/>
   {
<br/>
      c=buffer[x];
<br/>
      if(isspace(c) || ('\0' == c))   //go and start filling the next buffer if we encounter a space (note #1)
<br/>
      {
<br/>
         puts("Space encountered...");
<br/>
         if(y &gt; 0) // (note #2)
<br/>
         {
<br/>
            output[word][y]='\0';   //finish the string with a null byte (note #3)
<br/>
            y=0;   //We want to start filling from the beginning of the next buffer
<br/>
            word++;   //We want to start filling the next buffer
<br/>
         }
<br/>
      }
<br/>
      else
<br/>
      {
<br/>
         if(isprint(c))   //so returns and crap are caught (note #4)
<br/>
         {
<br/>
            if((y + 1) &lt; MAX_ARGUMENT_LENGTH)
<br/>
            {
<br/>
               output[word][y]=c;   //put the character in
<br/>
               y++; // (note #5)
<br/>
            }
<br/>
            else {
<br/>
               // (note #6)
<br/>
               // error handling for exceeding the maximum argument length
<br/>
            }
<br/>
         }
<br/>
         else
<br/>
         {
<br/>
            puts("Was not alphanumeric... ignoring...");
<br/>
         }
<br/>
      }
<br/>
      x++;
<br/>
   }
<br/>
   // (note #1)
<br/>
 
<br/>
   printf("Buffer: \"%s\"\n",buffer);
<br/>
   for(i = 0; i &lt; word; ++i) {
<br/>
      printf("Out%d: %s\n", i + 1, output[i]);
<br/>
   }
<br/>
 
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
1.  Using isspace() will catch tabs as well.  Checking for '\0' here will prevent you from having to duplicate code at the end of the while() loop.  Also <span style="font-style: italic">word</span> will be an accurate count of the number of arguments parsed.
<br/>
<br/>
2.  Multiple spaces in a row or leading/trailing spaces will result in extra empty output strings unless you only start the next word after finding at least one character of the current word.
<br/>
<br/>
3.  The index y is already one past the last character you have inserted into the string, so you don't need to add 1 when appending the null byte.  Masked by the string having been initialized to null bytes or else you would be encountering an extra byte of garbage at the end of each output string.
<br/>
<br/>
4.  Using isalpha() does not agree with your informational message.  You at least want isalnum() and most likely want isprint().  That way if the user passes an invalid argument like "bad^%$#@!argument", you won't tell them they passed "badargument".
<br/>
<br/>
5.  You should only increment the output string index when you put a character in the output string.  Otherwise, when you encounter an invalid character, your string will contain garbage or (in this case) get truncated (due to skipping over a null byte).
<br/>
<br/>
6.  Makes the code less vulnerable to buffer overflow.
<br/>
<br/>
I'm sure there are other things that can be improved, but those are the ones that jump out at me.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
