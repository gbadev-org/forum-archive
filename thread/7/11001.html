<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GCC 4.1.1 optimisations - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > GCC 4.1.1 optimisations</h2>
<div id="posts">
<div class="post">
    <h4>#100819 - dushan42 - Wed Aug 30, 2006 11:06 pm</h4>
    <div class="postbody"><span class="postbody">Hi,
<br/>
<br/>
I recompiled some of my old code with the latest devkit and discovered that my dma memset no longer worked if compiled with -O1 or higher:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">inline void dmaset16(int c, u32 word, volatile void *dst, u32 halfWords)
<br/>
{
<br/>
   volatile u32 *dma = &amp;REG_DM0SAD + 3*c;
<br/>
   *dma++ = u32(&amp;word);
<br/>
   *dma++ = u32(dst);
<br/>
   *dma = halfWords | (2 &lt;&lt; 23) | (1 &lt;&lt; 31);
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
It seems like the word argument gets corrupted (I was trying to fill a block with zeros and it got filled with junk instead). 
<br/>
<br/>
After a bit of poking, I discovered that making 'word' volatile fixes the problem, however it doesn't make any sense. Why does it have to be volatile? Is it a bug in gcc 4.1.1?
<br/>
<br/>
I'm worried that there might be other (more subtle) bugs elsewhere in the code so I'd really like to understand what's going on here. Did anyone experience a similar problem?
<br/>
<br/>
As soon as I have some spare time I'll try to compare the generated assembly - until then please feel free to speculate :-).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100822 - gmiller - Wed Aug 30, 2006 11:24 pm</h4>
    <div class="postbody"><span class="postbody">I would be converned that the code even worked in the first place:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
&amp;dma++ = (u32)(&amp;word);
<br/>
</td> </tr></table><span class="postbody">
<br/>
should put the address of the local variable 'word' into the DMA register which does not look like what you want.  I would have though you were passing the address of where to read from and this is not what I would expect.  Your functional header stated that 'word' is a u32 so I would think your call would be:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
short from[??]
<br/>
<br/>
dmaset16(0, (u32)&amp;from, VRAM, sizeof(from) &gt;&gt; 1);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
but I am not sure of your intent but the code as is should not work as I see it.  But I have been wrong before (and will be again).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100826 - dushan42 - Wed Aug 30, 2006 11:44 pm</h4>
    <div class="postbody"><span class="postbody">I'm guessing the 'word' thing is a copy&amp;paste error from the dmaset32 version of the function. It's only a style issue, functionally it makes no difference:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">inline void dmaset16(int c, u16 halfWord, volatile void *dst, u32 halfWords)
<br/>
{
<br/>
   volatile u32 *dma = &amp;REG_DM0SAD + 3*c;
<br/>
   *dma++ = u32(&amp;halfWord);
<br/>
   *dma++ = u32(dst);
<br/>
   *dma = halfWords | (2 &lt;&lt; 23) | (1 &lt;&lt; 31);
<br/>
} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The code above has the same problem if 'halfWord' isn't volatile.
<br/>
<br/>
Re: passing pointer to local variable - I believe this is ok in this case as GBA's dma transfers interrupt the CPU (i.e. the function won't return until the memset is over).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100829 - gmiller - Thu Aug 31, 2006 12:06 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
dushan42
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
What you are saying is that the following two lines are the same?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u32 foo;
<br/>
u32  foo1 = 0x6000000;
<br/>
<br/>
foo = foo1;
<br/>
foo = (u32)(&amp;foo);
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And I say they are completely different.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100831 - dushan42 - Thu Aug 31, 2006 12:15 am</h4>
    <div class="postbody"><span class="postbody">Huh? Clearly not, but I have no idea what you're implying.
<br/>
<br/>
The code above worked fine with gcc 3.xxx but gcc 4.1.1 requires the word/halfWord argument to be volatile. That's the mystery here - I don't really see your point...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100833 - gmiller - Thu Aug 31, 2006 12:26 am</h4>
    <div class="postbody"><span class="postbody">I was trying to make the point that the first code should not have worked either and the new code with the volatile proably should not work as well.  The volatile keyword just forces the compiler to generate extra instructions to refetch the value of a variable or what a pointer points to.  Generally it is used where the values can change in ways that the code does not make happen.  So any value that the compiler has saved might not be the current value so it needs to be forced to get the value again.  Now the fact that it is working leads me to the impression that the calling sequence of the routine is leading me astray. Could you paste examples of how you are calling the function so we can see what you are passing.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100836 - tepples - Thu Aug 31, 2006 12:51 am</h4>
    <div class="postbody"><span class="postbody">Often, function arguments and other automatic local variables are kept in CPU registers. The DMA controller can't see into CPU registers. Therefore, any function argument or automatic variable used as source data for DMA should be volatile in order to keep it in RAM that the DMA controller can see.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100837 - gmiller - Thu Aug 31, 2006 12:54 am</h4>
    <div class="postbody"><span class="postbody">My bad also in missing the inline keyword ... sorry</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100841 - dushan42 - Thu Aug 31, 2006 1:51 am</h4>
    <div class="postbody"><span class="postbody">Unfortunately the function is a bit obfuscated, let me explain what's going on.
<br/>
<br/>
I'm using DMA0 to clear a section of VRAM. It's setup so that during the transfer it only increments the destination address, so whatever u16 the source address is pointing to will get written repeatedly over the destination block. I'm using 16 bit transfer as VRAM doesn't support 32 bit access.
<br/>
<br/>
The parameters are:
<br/>
  int c - the DMA channel (in this case 0)
<br/>
  u16 halfWord - the u16 to be copied into the destination block
<br/>
  void* dst - pointer to the destination block
<br/>
  u32 halfWords - the size of the destionation block in half words (u16s).
<br/>
<br/>
Line 1:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">volatile u32 *dma = &amp;REG_DM0SAD + 3*c;</td> </tr></table><span class="postbody">
<br/>
<br/>
Works out the first control register for the specified dma channel. For channel 0, this means that 'dma == REG_DMA0SAD'.
<br/>
<br/>
Line 2:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">*dma++ = u32(&amp;halfWord);</td> </tr></table><span class="postbody">
<br/>
<br/>
Loads the DM0SAD (DMA0 source address register) with the address of the half word we want to copy all over the destination block (i.e. address of the 'halfWord' argument) . Incrementing dma makes it point to the next control register - REG_DMA0DAD.
<br/>
<br/>
Line 3:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">*dma++ = u32(dst);</td> </tr></table><span class="postbody">
<br/>
<br/>
Loads the DM0DAD (DMA0 destination address) with the address of the destination block. Incrementing dma makes it point to  REG_DMA0CNT.
<br/>
<br/>
Line 4:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">*dma = halfWords | (2 &lt;&lt; 23) | (1 &lt;&lt; 31);</td> </tr></table><span class="postbody">
<br/>
<br/>
Initialise the REG_DMA0CNT (DMA0 control register).
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
REG_DMA0CNT (stolen from CowBite Spec):
<br/>
<br/>
31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 10 09 08  07 06 05 04  03 02 01 00 
<br/>
 N  I  M  M   U  S  R  A   A  B  B  X   X  X  X  X   X  X  L  L   L  L  L  L   L  L  L  L   L  L  L  L
<br/>
<br/>
0-13  (L) = Number of words or halfwords to copy
<br/>
21-22 (B) = Type of increment applied to destination address.
<br/>
23-24 (A) = Type of increment applied to source address.
<br/>
25    (R) = Repeat.
<br/>
26    (S) = Size. If set, copy 32-bit quantities (words) If clear, copy 16-bit quantities (half words).
<br/>
27    (U) = Unknown.
<br/>
28-29 (M) = Start Mode.
<br/>
30    (I) = IRQ.
<br/>
31    (N) = Set this bit to enable DMA operation.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Line 4 sets up the following:
<br/>
<ul>
<br/>
0-13 (L) = 'halfWords'
<br/>
21-22 (B) = 0 (increment destination address after each copy)
<br/>
23-34 (A) = 2 (don't increment source address)
<br/>
26 (S) = 0 (16-bit mode)
<br/>
28-29 (M) = 0 (start immediately) 
<br/>
31 (N) = 1 (start the DMA transfer!).
<br/>
</ul>
<br/>
<br/>
As soon as I write into REG_DMA0CNT, the DMA transfer kicks off and copies the value of halfWord all over the 'dst' block. During the transfer the CPU is halted.
<br/>
<br/>
I would have thought that taking an address of a variable should be a big enough hint for the compiler not to optimise it out. I can only guess what 'u32(&amp;halfWord)' evaluates to when halfWord isn't volatile - it certainly doesn't point to anything resembling halfWord though.
<br/>
<br/>
I don't see what makes you think that this code is incorrect, it looks good to me and it's been working great for a long time. Making halfWord 'volatile' makes it work fine in gcc 4.1.1 - I'm just curious as to why this needs to be done.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100843 - dushan42 - Thu Aug 31, 2006 1:57 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Often, function arguments and other automatic local variables are kept in CPU registers. The DMA controller can't see into CPU registers. Therefore, any function argument or automatic variable used as source data for DMA should be volatile in order to keep it in RAM that the DMA controller can see.</td> </tr></table><span class="postbody">
<br/>
<br/>
That seems to be the case, but I don't think it should happen. If I take an address of a variable - the compiler can't just go 'oh, I only have this value in a register... ooh I'll just make up some random address for you!'. When I request a pointer to an argument passed via register, the compiler should allocate space on stack and copy the value there... or am I going crazy?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100844 - tepples - Thu Aug 31, 2006 2:01 am</h4>
    <div class="postbody"><span class="postbody">Don't try to second-guess the semantics that the compiler will apply, and don't make the compiler second-guess you either. If you intend for something to be in memory, put it in memory explicitly (keyword volatile). For a single int on the stack, it doesn't hurt performance to make it volatile, especially given that a large memset() that uses the 'stmia' instruction will be faster than DMA anyway because 'stmia' doesn't have to reread the source data word every time.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100846 - dushan42 - Thu Aug 31, 2006 2:22 am</h4>
    <div class="postbody"><span class="postbody">My understanding of 'volatile' was 'Hey compiler, that value might change at any time by things other than you. Don't keep it in a register'. Since 'halfWord' isn't being changed by anyone else, I didn't think volatile was appropriate. It does need to be in the memory but there's nothing stopping the compiler from caching it in a register.
<br/>
<br/>
Taking a pointer of something should be sufficient in telling the compiler that the value needs to be in the memory. Using volatile achieves that too - just seems like using a sledgehammer to open a walnut :-).
<br/>
<br/>
So I still think that gcc 4.1.1's optimisation is incorrect, but I agree with your advice &amp; I'll use volatile more liberally - it can't hurt.
<br/>
<br/>
EDIT:
<br/>
How about this code:
<br/>
<br/>
int x = 0;
<br/>
scanf("%i", &amp;x);
<br/>
return x;
<br/>
<br/>
I dread to think what would happen if the compiler decided to optimise x into a register and just pass some random pointer to scanf...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100854 - tepples - Thu Aug 31, 2006 4:59 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>dushan42 wrote:</b></span></td> </tr> <tr> <td class="quote">My understanding of 'volatile' was 'Hey compiler, that value might change at any time by things other than you. Don't keep it in a register'.</td> </tr></table><span class="postbody">
<br/>
Replace "change" with "change or be read" for the true meaning of 'volatile'.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Taking a pointer of something should be sufficient in telling the compiler that the value needs to be in the memory.</td> </tr></table><span class="postbody">
<br/>
To be in the memory at what time? How long does it need to stay in the memory? GCC doesn't know that writes to DM0CNT halt the CPU and start the equivalent of a memcpy() or memset().
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">How about this code:
<br/>
<br/>
int x = 0;
<br/>
scanf("%i", &amp;x);
<br/>
return x;
<br/>
<br/>
I dread to think what would happen if the compiler decided to optimise x into a register and just pass some random pointer to scanf...</td> </tr></table><span class="postbody">
<br/>
But then you're calling a function, and C guarantees that variables will be in their "architectural" state at the start and end of a function call. Not so with a write to a memory-mapped register with behavior that resembles function call; for that, you need to use 'volatile' more liberally.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#100856 - dushan42 - Thu Aug 31, 2006 5:17 am</h4>
    <div class="postbody"><span class="postbody">Makes sense. Don't you hate it when improvements in a compiler expose your bugs? :)
<br/>
<br/>
You're abslutely right, I don't know why assumed that volatile only refers to external writes - doh!
<br/>
<br/>
My faith in gcc is restored :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
