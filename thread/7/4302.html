<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Multiplications in for loop - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > Multiplications in for loop</h2>
<div id="posts">
<div class="post">
    <h4>#28343 - ScottLininger - Fri Oct 29, 2004 10:06 pm</h4>
    <div class="postbody"><span class="postbody">If I have a bit of code like this...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for(loop = 0; loop &lt; 128*4; loop++)
<br/>
{
<br/>
    // do something
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Is the compiler smart enough to replace the multiplication with a constant? (I know... one would simply put a constant in there... without magic numbers... this is kind of an academic question.)
<br/>
<br/>
Then what about something like this...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for(loop = 0; loop &lt; myVar*4; loop++)
<br/>
{
<br/>
    // do something
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
If a variable used in the comparison is NOT changed anywhere inside the loop, is the compiler smart enough to replace with a constant?
<br/>
<br/>
I have a situation like example #2, and I'm wondering if I'd save some cycles by precalculating myVar*4 and putting into a temporary variable... it's just kind of ugly to have an extra line or two of code when it can be done inside the FOR block.
<br/>
<br/>
I think I need to learn more about assembly so I can figure this stuff out myself. ;)
<br/>
<br/>
-Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28345 - jma - Fri Oct 29, 2004 10:32 pm</h4>
    <div class="postbody"><span class="postbody">As far are 2 constants go -- yes, the compile will "fold" them into the proper constant. As for your variable, it <span style="font-style: italic">might</span> put the value in a register (if one is available) -- then again, it might not. Consider this, though:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for(i = 0;i &lt; strlen(some_string);++i) { ... }</td> </tr></table><span class="postbody">
<br/>
<br/>
This is terrible code, because the <span style="font-weight: bold">strlen</span> will be executed each iteration of the loop. So, more specifically to your variable multiple question, if "myVar *4" is <span style="font-style: italic">not</span> put into a register (more importantly the value located at the RAM address that myVar points to), then each iteration a load and a multiply will occur.
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28347 - sajiimori - Fri Oct 29, 2004 11:50 pm</h4>
    <div class="postbody"><span class="postbody">...unless the compiler optimizes it to a shift, since it's a power of 2.  If you can't afford a load+shift, then check the compiler output because you're entering the realm of cycle counting.
<br/>
<br/>
On the other hand, if the loop body is complicated enough to prevent caching the limit (or better yet inverting the loop), then the load+shift probably wouldn't be your bottleneck anyway.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28360 - MumblyJoe - Sat Oct 30, 2004 3:29 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ScottLininger wrote:</b></span></td> </tr> <tr> <td class="quote">Then what about something like this...
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for(loop = 0; loop &lt; myVar*4; loop++)
<br/>
{
<br/>
    // do something
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
If a variable used in the comparison is NOT changed anywhere inside the loop, is the compiler smart enough to replace with a constant?
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Not really, because even if it doesn't change anywhere INSIDE the loop, there is no way for the compiler to know what the value of myVar is when the execution hits the loop, unless myVar is a constant (which I assume it isn't). Having said that, while the compiler can't know the value, it can know that it doesn't change and perform other optimisations.
<br/>
<br/>
Also, you can perform some optimisations yourself to allow things like this. If the compiler doesn't optimise correctly for what you want, and still performs the multiplication every time the for loop loops, you can just do the multiplication before the for loop as such:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const int tempval = myVar * 4;
<br/>
for(loop = 0; loop &lt; tempval; loop++)
<br/>
{
<br/>
    // do something
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I just tested this theory with this code however:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
extern "C" {
<br/>
<br/>
void yours()
<br/>
{
<br/>
   int myVar = 54;
<br/>
   myVar *= 10;
<br/>
   myVar++;
<br/>
   int val;
<br/>
<br/>
   for(int loop = 0; loop &lt; myVar*4; loop++)
<br/>
   {
<br/>
       val *= 2;
<br/>
   }
<br/>
<br/>
}
<br/>
<br/>
void mine()
<br/>
{
<br/>
<br/>
   int myVar = 54;
<br/>
   myVar *= 10;
<br/>
   myVar++;
<br/>
   int val;
<br/>
<br/>
   const int tempval = myVar * 4;
<br/>
   for(int loop = 0; loop &lt; tempval; loop++)
<br/>
   {
<br/>
      val*=2;
<br/>
   }
<br/>
<br/>
}
<br/>
<br/>
}//end of extern "C".
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
And I got this output (thumb code, optimised etc):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   .code   16
<br/>
   .file   "looptest.cpp"
<br/>
   .text
<br/>
   .align   2
<br/>
   .global   yours
<br/>
   .code 16
<br/>
   .thumb_func
<br/>
   .type   yours, %function
<br/>
yours:
<br/>
   push   {lr}
<br/>
   ldr   r3, .L11
<br/>
.L5:
<br/>
   sub   r3, r3, #1
<br/>
   cmp   r3, #0
<br/>
   bne   .L5
<br/>
   @ sp needed for prologue
<br/>
   pop   {r0}
<br/>
   bx   r0
<br/>
.L12:
<br/>
   .align   2
<br/>
.L11:
<br/>
   .word   2164
<br/>
   .size   yours, .-yours
<br/>
   .align   2
<br/>
   .global   mine
<br/>
   .code 16
<br/>
   .thumb_func
<br/>
   .type   mine, %function
<br/>
mine:
<br/>
   push   {lr}
<br/>
   ldr   r3, .L22
<br/>
.L17:
<br/>
   sub   r3, r3, #1
<br/>
   cmp   r3, #0
<br/>
   bne   .L17
<br/>
   @ sp needed for prologue
<br/>
   pop   {r0}
<br/>
   bx   r0
<br/>
.L23:
<br/>
   .align   2
<br/>
.L22:
<br/>
   .word   2164
<br/>
   .size   mine, .-mine
<br/>
   .ident   "GCC: (GNU) 3.4.1"
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Identical functions, clearly g++ is more clever that I give it credit for :P
<br/>
<br/>
Anyway, I'm done ranting, don't think I helped any anyway.<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28364 - MumblyJoe - Sat Oct 30, 2004 5:01 am</h4>
    <div class="postbody"><span class="postbody">I just changed the code in my above post to this to make it more interesting:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">extern "C" {
<br/>
<br/>
int yours(int&amp; myVar)
<br/>
{
<br/>
   int val = 1;
<br/>
<br/>
   for(int loop = 0; loop &lt; myVar*4; loop++)
<br/>
   {
<br/>
       val *= 2;
<br/>
   }
<br/>
<br/>
   return val;
<br/>
<br/>
}
<br/>
<br/>
int mine(int&amp; myVar)
<br/>
{
<br/>
<br/>
   int val = 1;
<br/>
<br/>
   const int tempval = myVar * 4;
<br/>
   for(int loop = 0; loop &lt; tempval; loop++)
<br/>
   {
<br/>
      val*=2;
<br/>
   }
<br/>
<br/>
   return val;
<br/>
<br/>
}
<br/>
<br/>
}//end of extern "C".</td> </tr></table><span class="postbody">
<br/>
<br/>
and got this output:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">   .code   16
<br/>
   .file   "looptest.cpp"
<br/>
   .text
<br/>
   .align   2
<br/>
   .global   yours
<br/>
   .code 16
<br/>
   .thumb_func
<br/>
   .type   yours, %function
<br/>
yours:
<br/>
   push   {lr}
<br/>
   ldr   r3, [r0]
<br/>
   lsl   r3, r3, #2
<br/>
   mov   r2, #1
<br/>
   cmp   r3, #0
<br/>
   ble   .L7
<br/>
.L5:
<br/>
   sub   r3, r3, #1
<br/>
   lsl   r2, r2, #1
<br/>
   cmp   r3, #0
<br/>
   bne   .L5
<br/>
.L7:
<br/>
   mov   r0, r2
<br/>
   @ sp needed for prologue
<br/>
   pop   {r1}
<br/>
   bx   r1
<br/>
   .size   yours, .-yours
<br/>
   .align   2
<br/>
   .global   mine
<br/>
   .code 16
<br/>
   .thumb_func
<br/>
   .type   mine, %function
<br/>
mine:
<br/>
   push   {lr}
<br/>
   ldr   r3, [r0]
<br/>
   lsl   r3, r3, #2
<br/>
   mov   r2, #1
<br/>
   cmp   r3, #0
<br/>
   ble   .L17
<br/>
.L15:
<br/>
   sub   r3, r3, #1
<br/>
   lsl   r2, r2, #1
<br/>
   cmp   r3, #0
<br/>
   bne   .L15
<br/>
.L17:
<br/>
   mov   r0, r2
<br/>
   @ sp needed for prologue
<br/>
   pop   {r1}
<br/>
   bx   r1
<br/>
   .size   mine, .-mine
<br/>
   .ident   "GCC: (GNU) 3.4.1"</td> </tr></table><span class="postbody">
<br/>
<br/>
So yeah, it turns out that gcc already performs this optimisation (unless myVar is volatile, then you get a crapload of generated code). So pretty much you are right, gcc will optimise the multiplication out of the loop. Also as a bonus, it optimises the multiplications into shifts in this example :P<br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28366 - sajiimori - Sat Oct 30, 2004 5:22 am</h4>
    <div class="postbody"><span class="postbody">Now if only it realized that the whole loop could be reduced to a single shift, rather than shifting by 1 bit on each iteration...
<br/>
<br/>
Anybody seen any instances of a compiler (for any language) replacing a loop (that cannot be proven to iterate less than 2 times) with a constant-time procedure?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28384 - poslundc - Sat Oct 30, 2004 3:37 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Anybody seen any instances of a compiler (for any language) replacing a loop (that cannot be proven to iterate less than 2 times) with a constant-time procedure?</td> </tr></table><span class="postbody">
<br/>
<br/>
I've seen compilers automatically unroll loops before, which I believe GCC is capable of with the -funroll-loops and -funroll-all-loops switches, although I don't believe they are very intelligent in their optimization.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28386 - sajiimori - Sat Oct 30, 2004 5:28 pm</h4>
    <div class="postbody"><span class="postbody">Unrolling a loop can't change an algorithm from O(n) to O(1), it just avoids branches.  The earlier example would be O(n) even if the loop were unrolled, because you still have to iterate more times as myVal gets larger.
<br/>
<br/>
Of course, if the compiler inlines the earlier code and the argument has a known value, then the whole thing can be replaced with a constant.
<br/>
<br/>
So, I should clarify that the number of iterations must be altogether unknown.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28387 - sgeos - Sat Oct 30, 2004 5:36 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Anybody seen any instances of a compiler (for any language) replacing a loop (that cannot be proven to iterate less than 2 times) with a constant-time procedure?</td> </tr></table><span class="postbody">
<br/>
Depending on who you use, a human compiler might be able to do it.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28395 - poslundc - Sat Oct 30, 2004 7:51 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Unrolling a loop can't change an algorithm from O(n) to O(1), it just avoids branches.  The earlier example would be O(n) even if the loop were unrolled, because you still have to iterate more times as myVal gets larger.</td> </tr></table><span class="postbody">
<br/>
<br/>
You're right, of course, but the trick is in the way you asked the question:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Anybody seen any instances of a compiler (for any language) replacing a loop (that cannot be proven to iterate less than 2 times) with a constant-time procedure?</td> </tr></table><span class="postbody">
<br/>
<br/>
It doesn't matter if it's iterating more than two times: if it iterates a constant amount then it's already O(1).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#28396 - sajiimori - Sat Oct 30, 2004 8:59 pm</h4>
    <div class="postbody"><span class="postbody">I didn't specify that it should be constant, but I neglected to specify that it couldn't be, which is hopefully clear by now.
<br/>
<br/>
But really, it should have been clear from the beginning because O(n) has no meaning if there's no n!</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
