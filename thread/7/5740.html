<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Enforcing object creation mechanisms - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Enforcing object creation mechanisms</h2>
<div id="posts">
<div class="post">
    <h4>#42877 - sajiimori - Sun May 15, 2005 10:37 pm</h4>
    <div class="postbody"><span class="postbody">I have a class hierarchy.  I want to prevent most people from creating objects in the hierarchy, but grant that right to one object.  The creator object should be able to create anything in the hierarchy, but should know about the base and only the base.
<br/>
<br/>
The following doesn't work because Derived can't access the Base constructor.  Obviously, I wouldn't want Derived to be a friend of Base.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class Creator;
<br/>
<br/>
class Base
<br/>
{
<br/>
private:
<br/>
   Base();
<br/>
   friend class Creator;
<br/>
};
<br/>
<br/>
class Derived : public Base
<br/>
{
<br/>
};
<br/>
<br/>
class Creator
<br/>
{
<br/>
public:
<br/>
   // This could be overloaded to take constructor arguments.
<br/>
   template&lt;class T&gt;
<br/>
   T* create()
<br/>
   {
<br/>
      T* t = new T;
<br/>
      method(t);
<br/>
      return t;
<br/>
   }
<br/>
<br/>
private:
<br/>
   void method(Base*)
<br/>
   {
<br/>
   }
<br/>
};
<br/>
<br/>
void test()
<br/>
{
<br/>
   Derived* d = Creator().create&lt;Derived&gt;();
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42883 - MumblyJoe - Mon May 16, 2005 2:21 am</h4>
    <div class="postbody"><span class="postbody">Alright, as a first stab in the dark, I have had a play around. Remember that friendship does not get inherited - just because you have a friend does not mean that your kids will be friends with them.
<br/>
<br/>
Here's my concept, it mildly changes the interface, in particular bieng that the constructor in Base in protected instead of private, and now the whole Creator class is a template instead of just the create function. Also, all classes that derive from Base must say they are friends of Creator&lt;whatever&gt;, and I'm not sure what happens when you derive from Derived. Seems to work with gcc and msvc.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">template&lt;class T&gt;
<br/>
class Creator;
<br/>
<br/>
class Base
<br/>
{
<br/>
   protected:
<br/>
   Base(){};
<br/>
};
<br/>
<br/>
class Derived : public Base
<br/>
{
<br/>
   private:
<br/>
   Derived(){};
<br/>
   friend class Creator&lt;Derived&gt;;
<br/>
};
<br/>
<br/>
template&lt;class T&gt;
<br/>
class Creator
<br/>
{
<br/>
   public:
<br/>
   T* create()
<br/>
   {
<br/>
      T* t = new T;
<br/>
      method(t);
<br/>
      return t;
<br/>
   }
<br/>
<br/>
   private:
<br/>
   void method(Base*)
<br/>
   {
<br/>
   }
<br/>
};
<br/>
<br/>
void test()
<br/>
{
<br/>
   Derived* d = Creator&lt;Derived&gt;().create();
<br/>
}
<br/>
<br/>
int main()
<br/>
{
<br/>
   test();
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42888 - sajiimori - Mon May 16, 2005 5:06 am</h4>
    <div class="postbody"><span class="postbody">Hmm... the game would really essplode if somebody accidentally circumvented the system, e.g. by holding one of the objects by value.  Since there are many classes in the hierarchy, and many of them create other objects, "protected" isn't very protected at all.
<br/>
<br/>
I hope there's some way to do this.  I already got a "random" crash from it today.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42889 - MumblyJoe - Mon May 16, 2005 7:01 am</h4>
    <div class="postbody"><span class="postbody">This will look really wierd until you have looked at it twice, but I think it's closer to the solution, however still not the most elegant or maintainable code possible, and it makes the idea of deriving again from Derived leave a bad taste in my mouth:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">template&lt;class B, class T&gt;
<br/>
class Creator
<br/>
{
<br/>
   public:
<br/>
<br/>
   static T* create()
<br/>
   {
<br/>
      T* t = new T;
<br/>
      method(t);
<br/>
      return t;
<br/>
   }
<br/>
<br/>
   private:
<br/>
<br/>
   static void method(B*){}
<br/>
};
<br/>
<br/>
class Base
<br/>
{
<br/>
   public:
<br/>
<br/>
   Base(){};
<br/>
<br/>
   private:
<br/>
<br/>
   virtual void base_ctor_protection()=0;
<br/>
};
<br/>
<br/>
class Derived : public Base, public Creator&lt;Base,Derived&gt;
<br/>
{
<br/>
   private:
<br/>
<br/>
   Derived(){};
<br/>
<br/>
   virtual void base_ctor_protection(){};
<br/>
<br/>
   friend class Creator&lt;Base,Derived&gt;;
<br/>
};
<br/>
<br/>
void test()
<br/>
{
<br/>
   Derived* d = Derived::create();
<br/>
}
<br/>
<br/>
int main()
<br/>
{
<br/>
   test();
<br/>
   return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><a class="postlink" href="http://www.hungrydeveloper.com" target="_blank">www.hungrydeveloper.com</a>
<br/>
Version 2.0 now up - guaranteed at least 100% more pleasing!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42902 - jma - Mon May 16, 2005 3:18 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">I have a class hierarchy.  I want to prevent most people from creating objects in the hierarchy, but grant that right to one object.  The creator object should be able to create anything in the hierarchy, but should know about the base and only the base.</td> </tr></table><span class="postbody">
<br/>
<br/>
After the initial gut-wrench from looking at the code, my first impulse is that you are going about this completely the wrong way (or perhaps I just don't understand your problem). Can you put this into a context?
<br/>
<br/>
However, I'd suggest making all available to the end-programmer, but just make Base worthless by itself. For example:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// -- interface.h
<br/>
<br/>
class Base {
<br/>
protected:
<br/>
  // data members inaccessible to outside
<br/>
};
<br/>
<br/>
class Interface {
<br/>
  // no data members, and worthless
<br/>
public:
<br/>
  // all virtual methods here
<br/>
};
<br/>
<br/>
// external access class
<br/>
class Derived : public Base, public Interface {
<br/>
  // has data members of Base
<br/>
  // has access methods of Interface
<br/>
};</td> </tr></table><span class="postbody">
<br/>
<br/>
Now just use <span style="font-weight: bold">new</span> and <span style="font-weight: bold">delete</span> normally. Someone can make instances of Base and Interface, but they are worthless alone. Derived (or a derivative thereof) is needed to do anything useful. 
<br/>
<br/>
Another quick question: why does Creator have to be a class? If you want to create the objects in some unique way (from a pool for example), just overload <span style="font-weight: bold">new</span>. Or, you can always just template a global function, too:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">template &lt;class T&gt; T* Create() {
<br/>
  // blah blah code
<br/>
  return new T;
<br/>
}
<br/>
<br/>
int main() {
<br/>
  int *x = Create&lt;int&gt;();
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Hope this helps,
<br/>
<br/>
Jeff M.<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42905 - poslundc - Mon May 16, 2005 4:00 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, I am having trouble understanding the nature of the problem as well. Perhaps you could provide some context as to why you would want to set up a system like this?
<br/>
<br/>
At first glance, it looks like the only point of forcing other programmers to use the Creator class to instantiate the objects is to make sure method() is being called on the base class after construction. But if this kind of post-construction behaviour were really necessary, you could just provide a separate Init() function in the base class and assert somewhere if Init() never gets called. That, to me, would be a lot less error-prone than attempting to automate the process with code that is difficult to understand/maintain.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42919 - sajiimori - Mon May 16, 2005 7:00 pm</h4>
    <div class="postbody"><span class="postbody">This is almost one of those "you'd have to be there" sort of problems.
<br/>
<br/>
All the objects in the hierarchy are conceptually self-managing: they do their work for as long as they exist, and then they die on their own.  (If you think this is a bad way to do things, then stop reading now because I don't care to hear arguments against it.)
<br/>
<br/>
To let the objects live independently of the client, they must be added to a list of all such objects, which will automatically be traversed every tic.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">gList.add(new Derived);</td> </tr></table><span class="postbody">
<br/>
This is repetitive and error prone, especially if you didn't know the object is supposed to go in the list, and <span style="font-style: italic">especially</span> if the object <span style="font-style: italic">expects</span> to be in the list.
<br/>
<br/>
The solution is to have the base class automatically add itself to the list.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Base::Base() { gList.add(this); }</td> </tr></table><span class="postbody">
<br/>
That makes the client code look like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">new Derived;</td> </tr></table><span class="postbody">
<br/>
First off, that's a little weird.  It looks like a memory leak.  Second, if somebody mistakenly thought that the object was derived from Base (or if it was but later wasn't), then they really did create a memory leak.
<br/>
<br/>
The solution is to have a creation mechanism that <span style="font-style: italic">must</span> be used for objects in the hierarchy, but <span style="font-style: italic">cannot</span> be used for other objects.  Then the compiler will catch the errors I've mentioned.
<br/>
<br/>
Dan: As always, I'm apt to initially invest in a system to simplify client code.  My level of investment is a function of how widely the system will be used and how much better each usage case will be on average.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42921 - poslundc - Mon May 16, 2005 8:07 pm</h4>
    <div class="postbody"><span class="postbody">I would just define a static Create() method in each of the subclasses that calls the protected constructor of the base class, and make their individual constructors private.
<br/>
<br/>
This requires more discipline on the part of the person creating the subclasses, to make sure that each derivative has a Create() method. But the objective is to reduce the workload on the users of the class, right?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class Base
<br/>
{
<br/>
protected:
<br/>
   Base()
<br/>
   {
<br/>
      gList.add(this);
<br/>
   }
<br/>
};
<br/>
<br/>
class Derived : public Base
<br/>
{
<br/>
public:
<br/>
   static void Create()
<br/>
   {
<br/>
      new Derived;
<br/>
   }
<br/>
<br/>
private:
<br/>
   Derived()
<br/>
   {
<br/>
   }
<br/>
};
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   Derived::Create();
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
(Coded from the hip)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42935 - sajiimori - Tue May 17, 2005 12:27 am</h4>
    <div class="postbody"><span class="postbody">As I mentioned earlier, due to the large number of classes in the hierarchy and their tendancy to create other derivatives, "protected" does not provide encapsulation.  The crash that I already saw was due to one derivative holding another by value.
<br/>
<br/>
Also, derived classes are clients of the base, and so the system is for their benefit as much as everyone else's.  Like stack frames in assembly or vtables in C, these Create methods may be a thing that the language is incapable of abstracting.
<br/>
<br/>
I'm currently using the "new Derived;" method, as weird as it is.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42937 - poslundc - Tue May 17, 2005 1:05 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">As I mentioned earlier, due to the large number of classes in the hierarchy and their tendancy to create other derivatives, "protected" does not provide encapsulation.  The crash that I already saw was due to one derivative holding another by value.</td> </tr></table><span class="postbody">
<br/>
<br/>
In my example, though, constructors of the derived classes are made private. Only the constructor of the base class is protected. Wouldn't this alleviate that problem?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I'm currently using the "new Derived;" method, as weird as it is.</td> </tr></table><span class="postbody">
<br/>
<br/>
&lt;shrug&gt; It's not so bad. If you're <span style="font-style: italic">really</span> worried about people misusing the class and trying to delete pointers returned by new, then you might want to make it convention to use "smart" pointers with your class... that way the refcounting would be out of the user's hands.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42939 - sajiimori - Tue May 17, 2005 1:44 am</h4>
    <div class="postbody"><span class="postbody">Hmm, yeah, your convention does keep each class encapsulated individually.
<br/>
<br/>
Bleh... the issues are so subtle.  Even holding these objects by value or deleting them yourself doesn't normally cause a problem.  It only breaks if the list of objects is currently being traversed, <span style="font-style: italic">and</span> the current object being updated is right next to the one being deleted (which is often the case if one object holds another by value, since they are constructed in sequence).  Then it invalidates the linked list iterator.  I don't even know what other issues there are.
<br/>
<br/>
All I have to say is: Garbage collection!  :P</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42940 - poslundc - Tue May 17, 2005 2:46 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Bleh... the issues are so subtle.  Even holding these objects by value or deleting them yourself doesn't normally cause a problem.  It only breaks if the list of objects is currently being traversed, <span style="font-style: italic">and</span> the current object being updated is right next to the one being deleted (which is often the case if one object holds another by value, since they are constructed in sequence).  Then it invalidates the linked list iterator.  I don't even know what other issues there are.</td> </tr></table><span class="postbody">
<br/>
<br/>
I'd consider usage like that to be programmer error more than a design flaw. (Maybe a flaw in the language, but that's another matter.) You can't protect coders from everything, and you can't protect them from themselves... there are certain logistics to managing things like a list class that you need to learn over time and from experience, I think.
<br/>
<br/>
Remember, STL doesn't expect every method to work in every situation. The documentation lists things like what can cause an iterator to become invalidated, but most programmers still need to figure it out for themselves sooner or later.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42942 - sajiimori - Tue May 17, 2005 4:04 am</h4>
    <div class="postbody"><span class="postbody">I started trying to explain the problem fully, but it's too hard.
<br/>
<br/>
Briefly: The list is automatically traversed every game loop to update all the objects.  The object that is currently being updated can signal that it wants to be deleted.  (It doesn't do "delete this" because that would hose the iteration.)  After the object is updated, the manager sees that the "delete me" flag is set and actually deletes it.  At this point, the iterator is just after the object that wanted to be deleted.
<br/>
<br/>
The problem is when the destructor for the object destroys the object that the iterator is now pointing at.  This happens implicitly if the object is being held by value, so it's hard to track down.
<br/>
<br/>
I agree that it's impossible to protect against anything that could crash the system (in C++), but conventional wisdom says you should hold things by value when possible, so I'd be more inclined to blame myself if somebody followed that guideline contrary to my intended usage.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42945 - DekuTree64 - Tue May 17, 2005 5:33 am</h4>
    <div class="postbody"><span class="postbody">So, the problem here is to warn the innocent coder who tries to delete an object by value when he should let it die on its own, right? Is there any reason you can't have a private flag in the Base class that only your creator touches, and assert on that in Base's destructor?
<br/>
<br/>
Something like:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class Creator; 
<br/>
<br/>
class Base 
<br/>
{ 
<br/>
private: 
<br/>
   Base() : wasCreatedProperly(false) {} 
<br/>
   ~Base() { ASSERT_TEXT(wasCreatedProperly, "Use the creator!"); }
<br/>
   friend class Creator; 
<br/>
   bool wasCreatedProperly;
<br/>
}; 
<br/>
<br/>
class Creator 
<br/>
{ 
<br/>
public: 
<br/>
   // This could be overloaded to take constructor arguments. 
<br/>
   template&lt;class T&gt; 
<br/>
   T* create() 
<br/>
   { 
<br/>
      T* t = new T; 
<br/>
      method(t); 
<br/>
      return t; 
<br/>
   } 
<br/>
<br/>
private: 
<br/>
   void method(Base *thing) 
<br/>
   { 
<br/>
      thing-&gt;wasCreatedProperly = true;
<br/>
   } 
<br/>
};</td> </tr></table><span class="postbody">
<br/>
<br/>
And possibly another to make sure it isn't deleted by anything but your system.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42963 - jma - Tue May 17, 2005 3:26 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Briefly: The list is automatically traversed every game loop to update all the objects.  The object that is currently being updated can signal that it wants to be deleted.  (It doesn't do "delete this" because that would hose the iteration.)  After the object is updated, the manager sees that the "delete me" flag is set and actually deletes it.  At this point, the iterator is just after the object that wanted to be deleted.</td> </tr></table><span class="postbody">
<br/>
<br/>
Are you using reference counting (or something similar) or are you just assuming that a single "delete" should clean the object? Could make a big difference in approaches taken. I'd seriously consider looking at Apple's Cocoa libraries in Objective-C. They did a pretty fine job of this. "Autorelease" being a beautiful method.
<br/>
<br/>
Jeff M.<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#42970 - sajiimori - Tue May 17, 2005 5:40 pm</h4>
    <div class="postbody"><span class="postbody">Deku:  Hmm, it's a runtime error, but that's a lot better than random crashes or memory leaks.  I think I'll use it -- thanks! :)
<br/>
<br/>
Ooh, since the creator is the one that iterates through the list, it can even check the flag while iterating to catch it immediately.
<br/>
<br/>
Jeff:  There's no reference counting.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
