<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>How to send a pointer to a function, and back? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > How to send a pointer to a function, and back?</h2>
<div id="posts">
<div class="post">
    <h4>#121229 - LOst? - Sat Mar 10, 2007 5:17 pm</h4>
    <div class="postbody"><span class="postbody">I have programmed a lot of C/C++ applications for years. So I have encountered this problem a few times. Sure I can handle it, but I want to know why it works this way.
<br/>
<br/>
So have a look:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
char global_name [] = "Peter";
<br/>
<br/>
int GetName (char* name)
<br/>
{
<br/>
 name = global_name;
<br/>
<br/>
 // "name" is now pointing to &amp;global_name [0]
<br/>
<br/>
 return 1;
<br/>
}
<br/>
<br/>
int main (void)
<br/>
{
<br/>
char* name = NULL;
<br/>
<br/>
GetName (name);
<br/>
<br/>
// Now "name" == NULL! Why didn't it survive past GetName()?
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
You all know in C, you can send a pointer of a structure as an argument. And it will survive. But why can't my name pointer survive?
<br/>
<br/>
My temporary fix for these problems is declaring GetName like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int GetName (char*&amp; name);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
However this is a C++ syntax. What if I want to go back to C? That's why I want some help.<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121234 - kusma - Sat Mar 10, 2007 6:09 pm</h4>
    <div class="postbody"><span class="postbody">double pointers
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int GetName (char** name); 
<br/>
<br/>
GetName(&amp;name); 
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121240 - sgeos - Sat Mar 10, 2007 7:06 pm</h4>
    <div class="postbody"><span class="postbody">Let me put it this way.  It is exactly the same with pointers:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define NULL_ID    0
<br/>
#define GLOBAL_ID  7
<br/>
<br/>
#define NG  0
<br/>
#define OK  1
<br/>
<br/>
int gId = GLOBAL_ID;
<br/>
<br/>
int getId(int pId)
<br/>
{
<br/>
   pId = gId;
<br/>
   // "pId" is now equal to gId
<br/>
<br/>
   return OK;
<br/>
}
<br/>
<br/>
int main (void) 
<br/>
{ 
<br/>
   int id = NULL_ID;
<br/>
<br/>
   getId(id);
<br/>
   // Now "id" == NULL_ID!  Why didn't it survive past getId()? 
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Clearly you would use a pointer to int to solve this problem.  If you want any value to survive a subroutine call, you need to pass a pointer to that value, because all of the variables local to the subroutine are destroyed when is returns.
<br/>
<br/>
The following does not (usually) work because local variables are destroyed when the function returns:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">char *getName(void)
<br/>
{
<br/>
   char name[MAX_SIZE] = "Evil Frog Man";
<br/>
   return name;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
You need to use some form of the following to retain values after functions return.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">*pointer = address;</td> </tr></table><span class="postbody">
<br/>
This even holds for pointers.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>kusma wrote:</b></span></td> </tr> <tr> <td class="quote">double pointers</td> </tr></table><span class="postbody">
<br/>
Also known as pointer to pointer.  Try something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">char gName[MAX_SIZE] = "Evil Frog Man (chocolate rice version, bonus sprinkles)";
<br/>
<br/>
int getName(char* pName[]) 
<br/>
{
<br/>
   *pName = gName; 
<br/>
   return OK;
<br/>
} </td> </tr></table><span class="postbody">
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121241 - keldon - Sat Mar 10, 2007 7:21 pm</h4>
    <div class="postbody"><span class="postbody">I think you might first want to know how you expect the function to work. Will the function place the name characters into the name pointer sent in the getName method? Double pointers is one way to achieve it, it all depends on how getName is supposed to work. Is it retrieving it from somewhere, is new memory allocated, I am currently under the assumption that getName is returning a constant so that should not be an issue.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121245 - poslundc - Sat Mar 10, 2007 7:41 pm</h4>
    <div class="postbody"><span class="postbody">Others have already explained the solutions (double pointers, or have the function allocate space and return the pointer to you). For an explanation of the problem, you just need to realize that in C you are always passing by value, not by reference, so you won't be able to use reference semantics unless you explicitly pass a reference in (which in C, means passing in a pointer to whatever you want to be modifiable).
<br/>
<br/>
Your code doesn't work as you expect it for the exact same reason this code doesn't behave in that way:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void foo(int a)
<br/>
{
<br/>
    a = 5;
<br/>
}
<br/>
<br/>
void main(void)
<br/>
{
<br/>
    int a = 0;
<br/>
<br/>
    foo(a);
<br/>
<br/>
    // Now "a" is still 0, even though foo changed its copy of a to 5.
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
When main() calls foo(), it passes "a" in by value, not by reference, so its local value for "a" doesn't change, even if foo changes its local copy of "a".
<br/>
<br/>
In the same way, when your version of main() passes "name" to GetName(), it passes it by value, not by reference, so GetName() can't change the value of "name". If "name" had pointed to something other than NULL, then it could change whatever data was in memory that "name" was pointing to, but it still wouldn't be able to change <span style="font-style: italic">where</span> "name" points to.
<br/>
<br/>
So in the same way I could make my foo() function alter "a" if I passed in a reference to "a" (by obtaining a pointer to it, for example, and passing in that pointer instead of the plain value), you could make GetName() alter "name" by passing in a reference to "name" (by obtaining a pointer to it, which, since "name" is already a pointer, would make your reference a double-pointer).
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121246 - LOst? - Sat Mar 10, 2007 7:48 pm</h4>
    <div class="postbody"><span class="postbody">Thank you kusma.
<br/>
<br/>
And very much appreciated for your explaination sgeos :)
<br/>
<br/>
The first problem occured to me when I was trying to create a set of help functions for a custom linked list I had created. I got very surprised by the pointer survival. And very confused when trying to debug the application to find where the value disappeared. I had to abort that linked list.
<br/>
<br/>
I had a function like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
char* ptr = new char [10];
<br/>
<br/>
if (AddTail (ptr) != true)
<br/>
{
<br/>
 delete [] ptr;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Failing to keep track of the actual allocated memory, and the application was doomed to crash. AddTail had some functions of it own to locate the list tail. So it got even worse trying to find a solution.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
bool AddTail (char*&amp; ptr)
<br/>
{
<br/>
 if (SearchListAndAddPtr (ptr)) // I know I know. I just want to demonstrate how hard it gets once you get here
<br/>
 { 
<br/>
   return true;
<br/>
 }
<br/>
<br/>
 return false;
<br/>
}
<br/>
<br/>
bool SearchListAndAddPtr (char*&amp; ptr)
<br/>
{
<br/>
 lst* list = root;
<br/>
<br/>
 while (list-&gt;next != 0)
<br/>
 {
<br/>
   list = list-&gt;next;
<br/>
 }
<br/>
<br/>
 // Allocate a new list node
<br/>
 AllocateListNode (list);
<br/>
<br/>
 ....... whatever you get the point
<br/>
}
<br/>
<br/>
void AllocateListNode (lst*&amp; ptr)
<br/>
{
<br/>
 ptr = new lst;
<br/>
<br/>
 // Imagine when this ptr gets lost! Memory leak trouble
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
The code above is a invalid as the result I got when I tried to make this system in the first place. God thanks for C++ templates!
<br/>
<br/>
<br/>
EDIT: Thanks poslundc! And nice to see you as a moderator here!
<br/>
Yea, sent by value. I have worked a lot with I386 assembler. The values get pushed onto the stack before the function call:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
xor ecx,ecx
<br/>
mov dword [a],ecx  ; a = 0
<br/>
<br/>
mov eax,[a]
<br/>
push eax ; Pushes the value of a onto the stack
<br/>
<br/>
call foo
<br/>
<br/>
</td> </tr></table><span class="postbody"><br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121251 - sgeos - Sat Mar 10, 2007 8:20 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">The first problem occured to me when I was trying to create a set of help functions for a custom linked list I had created.</td> </tr></table><span class="postbody">
<br/>
For what it's worth, I don't think dynamic allocation really needs to be used in games (if anyone disagrees, I disagree).  #define MAX_SIZE works well.  Statically allocated link lists certainly have their place, but you probably want to use indices instead of pointers.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">I got very surprised by the pointer survival.</td> </tr></table><span class="postbody">
<br/>
Things will survive on the stack, but they can be clobbered at any moment.  "But it worked" only means so much.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121275 - gmiller - Sun Mar 11, 2007 1:02 am</h4>
    <div class="postbody"><span class="postbody">Just remember that C/C++ are by default "pass-by-value" so the variable in the  function is a copy (created on the stack) not the original.  This allows you to change parameters without worrying about the values in the calling function (stack pointer is returned back to the pre-creation value when the function returns).  Should you wish to change the value variable that was passes it needs to be done by passing the variables address in some way (reference or pointer) or by assigning the variable to the functions return value.  There are pro's and con's to any approach you just need to decide what risks you are willing to take.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121312 - LOst? - Sun Mar 11, 2007 1:32 pm</h4>
    <div class="postbody"><span class="postbody">Oh I need help!
<br/>
<br/>
I get this error:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
cannot convert parameter 1 from 'char (*)[260]' to 'char **'
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I have a global array:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
char global_name [260];
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And I want to send it to a function, and I want the modification that this function did in that array to surive when the function returns:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int Function (char** array)
<br/>
{
<br/>
 *array [0] = 'A';
<br/>
 *array [1] = '\0';
<br/>
<br/>
 return 1;
<br/>
}
<br/>
<br/>
int main (void)
<br/>
{
<br/>
 Function (&amp;global_name); // Error! global_name acts like a pointer, but seems to be something else
<br/>
<br/>
 if (global_array [0] == 'A')
<br/>
  return 1; // Worked
<br/>
<br/>
 return 0; // Didn't work
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
Chaning "Function" declaration doesn't help:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int Function (char* array []);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
... Still gives a simular error:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
cannot convert parameter 1 from 'char (*)[260]' to 'char *[]'
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I am stuck unless I want to make a local ptr to point to global_array, and then send it in as a **parameter. And that can end up in a mess. Note that this "Function" is a help routine to avoid many simular routines doing the same work<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"><br/><br/>Last edited by LOst? on Sun Mar 11, 2007 5:01 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#121324 - sgeos - Sun Mar 11, 2007 4:28 pm</h4>
    <div class="postbody"><span class="postbody">I could give you the answer, but you wouldn't learn anything and this is important.  Look at this code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int Function (char** array)
<br/>
{
<br/>
 array [0] = 'A';
<br/>
 array [1] = '\0';
<br/>
<br/>
 return 1;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
What type is the variable array?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121328 - LOst? - Sun Mar 11, 2007 5:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">I could give you the answer, but you wouldn't learn anything and this is important.  Look at this code:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int Function (char** array)
<br/>
{
<br/>
 array [0] = 'A';
<br/>
 array [1] = '\0';
<br/>
<br/>
 return 1;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
What type is the variable array?
<br/>
<br/>
-Brendan</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Sorry I just missed the *:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
*array [0] = 'A';
<br/>
</td> </tr></table><span class="postbody">
<br/>
But that was a spelling error by me. The error appears when calling this function, and not inside the function.
<br/>
<br/>
To answer your question:
<br/>
array is of type "pointer to a pointer to a char".
<br/>
Note that I have almost never worked with double pointers. Exceptions are such as sending a &amp;LPDIRECTDRAW object to a COM method, or the int main (char* arg [],..... - int main (char** arg... That's why I know so little of how they work.
<br/>
<br/>
The error has something to do with the global_name being an array and not a pointer. But seriously I don't know how to fix this.<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121332 - sgeos - Sun Mar 11, 2007 6:14 pm</h4>
    <div class="postbody"><span class="postbody">If all you need to do is write to a buffer, you want to use pointer to character, and not char **.
<br/>
<br/>
Use char ** when you want to do something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void setName(char **pString, int pId)
<br/>
{
<br/>
        switch (pId)
<br/>
        {
<br/>
                case NAME_A:
<br/>
                        *pString = gNameA;
<br/>
                        break;
<br/>
                case NAME_B:
<br/>
                        *pString = gNameB;
<br/>
                        break;
<br/>
                default:
<br/>
                        *pString = gNameDefault;
<br/>
                break;
<br/>
        }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121337 - LOst? - Sun Mar 11, 2007 6:52 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">If all you need to do is write to a buffer, you want to use pointer to character, and not char **.
<br/>
<br/>
Use char ** when you want to do something like this:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void setName(char **pString, int pId)
<br/>
{
<br/>
        switch (pId)
<br/>
        {
<br/>
                case NAME_A:
<br/>
                        *pString = gNameA;
<br/>
                        break;
<br/>
                case NAME_B:
<br/>
                        *pString = gNameB;
<br/>
                        break;
<br/>
                default:
<br/>
                        *pString = gNameDefault;
<br/>
                break;
<br/>
        }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
-Brendan</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Ok. Thanks sgeos<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121340 - LOst? - Sun Mar 11, 2007 7:18 pm</h4>
    <div class="postbody"><span class="postbody">I found out a good way to pass an array into a function using a C++ function template. This works with Visual C++ 2005. Maybe it works in gcc too?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
template &lt;size_t Size&gt;
<br/>
int DoSomethingWithBuffer (char (&amp;buffer) [Size])
<br/>
{
<br/>
 for (unsigned int i = 0; i &lt; Size; i++)
<br/>
 {
<br/>
  buffer [i] = xxxxxxxxxxx
<br/>
 }
<br/>
<br/>
 return 0;
<br/>
}
<br/>
<br/>
char global_buffer [20];
<br/>
<br/>
int main (void)
<br/>
{
<br/>
 DoSomethingWithBuffer (global_buffer);
<br/>
<br/>
 return 0;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Sending just a pointer to a buffer, and you must pass its size too. I have no idea how this template works. For some reason &lt;Size&gt; is getting filled with 20 automatically. Very nice :)
<br/>
<br/>
And thank you all for the help on pointers to pointers!<br/>_________________<br/><span style="font-style: italic">Exceptions are fun</span></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121344 - sgeos - Sun Mar 11, 2007 8:07 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Sending just a pointer to a buffer, and you must pass its size too.</td> </tr></table><span class="postbody">
<br/>
Good plan.  You can use a vanilla pointer and a size in C.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void myfunction(type_t *pBuffer, int pSize)
<br/>
{
<br/>
  int i;
<br/>
<br/>
  for (i = 0; i &lt; pSize; i++)
<br/>
    // do something
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">I have no idea how this template works.</td> </tr></table><span class="postbody">
<br/>
I would fix that if I were to use this template.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">For some reason &lt;Size&gt; is getting filled with 20 automatically. Very nice :)</td> </tr></table><span class="postbody">
<br/>
My guess is that this "template" is just the C++ "modify array by reference" calling syntax.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">And thank you all for the help on pointers to pointers!</td> </tr></table><span class="postbody">
<br/>
Very welcome.  Good luck.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#121347 - tepples - Sun Mar 11, 2007 8:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>LOst? wrote:</b></span></td> </tr> <tr> <td class="quote">Sending just a pointer to a buffer, and you must pass its size too.</td> </tr></table><span class="postbody">
<br/>
Good plan.  You can use a vanilla pointer and a size in C.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void myfunction(type_t *pBuffer, int pSize)
<br/>
{
<br/>
  int i;
<br/>
<br/>
  for (i = 0; i &lt; pSize; i++)
<br/>
    // do something
<br/>
}</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
In fact, this is an incredibly common idiom in C, even in the standard library. Look at memset(), qsort(), and fwrite().<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
