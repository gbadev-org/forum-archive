<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>C volatile keyword - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > C volatile keyword</h2>
<div id="posts">
<div class="post">
    <h4>#163271 - Synthetic - Sun Sep 28, 2008 5:54 am</h4>
    <div class="postbody"><span class="postbody">Quick C question for the gurus:
<br/>
<br/>
Is the const/volatile flag set seperately from the rest of the type when you typecast an object?
<br/>
<br/>
lets say I have:
<br/>
<br/>
volatile int *foo;
<br/>
...
<br/>
(long *)foo=bar;
<br/>
<br/>
is it still volatile when I cast it as a long?  can I cast volatile seperately, like so?
<br/>
<br/>
(long *)(volatile *)foo=bar;
<br/>
<br/>
can one simply cast a pointer as volatile, will it automatically pick up a void if I do (volatile *)foo?
<br/>
<br/>
Thanks</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163272 - Dwedit - Sun Sep 28, 2008 6:38 am</h4>
    <div class="postbody"><span class="postbody">I know you get compiler warnings or errors when you assign a volatile pointer to a regular pointer without casting.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163375 - sajiimori - Wed Oct 01, 2008 12:14 am</h4>
    <div class="postbody"><span class="postbody">const and volatile are part of the type, so if you cast them away, they're really gone.
<br/>
<br/>
(volatile*) is really short for (volatile int*), just like (unsigned*) is short for (unsigned int*).  C++ compilers should give an error though, because implicit int is only supposed to work in C.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163393 - Miked0801 - Wed Oct 01, 2008 5:15 pm</h4>
    <div class="postbody"><span class="postbody">Which begs the question, why would you cast to/from volatile?  It has a very specific use and casting doesn't make much sense with it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163397 - sajiimori - Wed Oct 01, 2008 6:05 pm</h4>
    <div class="postbody"><span class="postbody">I guess a volatile u32* could be sensibly cast to a volatile u8*, and so on.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163402 - Synthetic - Wed Oct 01, 2008 6:58 pm</h4>
    <div class="postbody"><span class="postbody">What Sajiimori said, I have a memory address to a control register that I want to write to as a word and a dword, but mostly I was just curious.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163403 - sgeos - Wed Oct 01, 2008 7:43 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Which begs the question, why would you cast to/from volatile?  It has a very specific use and casting doesn't make much sense with it.</td> </tr></table><span class="postbody">
<br/>
You could force a read or a write that way.
<br/>
Maybe you want to make a gameshark resistant program that is free to leave the values of certain data on registers most of the time, but is force read or written to now and then?
<br/>
Then again, I doubt anyone actually does things like this.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163454 - Miked0801 - Thu Oct 02, 2008 6:28 pm</h4>
    <div class="postbody"><span class="postbody">If your casting vu8* to vu32*, you aren't adding or removing volatile from the mix and I completely understand that.  I was thinking you were doing something like u32* to vu32* and back.  That's just playing with the compiler and my mind :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#163459 - Synthetic - Thu Oct 02, 2008 7:28 pm</h4>
    <div class="postbody"><span class="postbody">yeah, in both cases it would be volatile, but I'm not using libnds typecasts, and I was getting tired of writing volatile everywhere =P</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
