<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>A problem with mode4 and individual pixel access. - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > A problem with mode4 and individual pixel access.</h2>
<div id="posts">
<div class="post">
    <h4>#11627 - ramirez - Tue Oct 14, 2003 10:36 pm</h4>
    <div class="postbody"><span class="postbody">Now, first of all I'd like to tell that I am fairly new in GBA development and currently coding in C using devkit advance. Me and my friend have been more into it for past few days and we have bumped into this error now and so we are looking for assistance.
<br/>
The problem we are having is with mode4's individual pixel access. First of all we DO know that it uses palette and you can't directly transfer the data as 8-bit.
<br/>
I wrote this simple function for putting individual pixel(s) to the buffer:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//all the typedefs are declared in typedefs.h
<br/>
<br/>
//structure for holding two 8-bit values; pretty self explotianary
<br/>
typedef struct multiPixel
<br/>
{
<br/>
   u8 px1;
<br/>
   u8 px2;
<br/>
} mltPixel;
<br/>
<br/>
inline void PutPixel(u8 px, u8 x, u8 y)
<br/>
{
<br/>
  u8 offset = x%2; //should overwrite the 1st or 2nd pixel in the 16-bit data
<br/>
  mltPixel * temp; //the structure variable for storing the pixels
<br/>
  temp = (mltPixel*)&amp;(VideoBuffer[y*120+x]); //the location to the 16-bit pixels
<br/>
  //if the modulus was 1 (2nd pixel), we'll update the 2nd pixel and don't touch to the first
<br/>
  if (offset)
<br/>
  {
<br/>
    temp-&gt;px2 = px;
<br/>
  }
<br/>
  //otherwise we do likewise
<br/>
  else
<br/>
  {
<br/>
  temp-&gt;px1 = px;
<br/>
  }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
Now, we see no error in this script, and it compiles fine also. But the problem is that when we for example use this for alternating the individual pixels:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for (y=0; y&lt;6; y++)
<br/>
{
<br/>
  for (x=0; x&lt;6; x++)
<br/>
  {
<br/>
    PutPixel(1,x,y);
<br/>
  }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
The 1 is white color in the palette (255|(255&lt;&lt;5)|(255&lt;&lt;10)). And it displays the area, but not like you'd expect. While I want it to shot 6x6 rectangle, it shows a 12x6 area. And to be honest I am out of understanding.
<br/>
So if anyone has any idea what we are doing wrong, we'd appreciate help.
<br/>
Thanks in advance. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11629 - Stroff - Tue Oct 14, 2003 10:50 pm</h4>
    <div class="postbody"><span class="postbody">You can only write 16 bit values to videoram.
<br/>
To plot a single pixel, you'll have to read a full 16 bit value, modify the upper or lower byte, than write back a full 16 bit value.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11630 - sajiimori - Tue Oct 14, 2003 10:53 pm</h4>
    <div class="postbody"><span class="postbody">There's also this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
VideoBuffer[y*120+x]
<br/>
</td> </tr></table><span class="postbody">
<br/>
Is VideoBuffer a u16* or a u8*?  If it's a u16*, then adding x will move over 2*x pixels.  If it's a u8*, multiplying by 120 only goes half a row.  I would guess it's a u16* because you reported getting wider shapes than expected.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11632 - jd - Tue Oct 14, 2003 11:04 pm</h4>
    <div class="postbody"><span class="postbody">Whilst it isn't technically a bug, I should point out that the following is very, very slow..
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>ramirez wrote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u8 offset = x%2;
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
..this is because modulus requires a division which the GBA has to emulate through software. In this case, the same result can be achieved using..
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
u8 offset = x&amp;1;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Also, you should use int's for variables wherever possible (rather that u8s), otherwise the processor will have to mask off the upper bits each time it does a calculation.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11634 - Burton Radons - Tue Oct 14, 2003 11:24 pm</h4>
    <div class="postbody"><span class="postbody">GCC produces identical code in this case because the input is unsigned, so modulus and logical AND have identical results.  If the input is signed the output range of modulus is different (-1, 0, or 1), so the operations aren't the same.  But in that case with these parameters it's only two instructions slower.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11657 - ramirez - Wed Oct 15, 2003 6:27 am</h4>
    <div class="postbody"><span class="postbody">Well, I obviosly made mistake with the "[y*120+x]" since the VideoBuffer is 16-bit so actually with x = 2 I edited x = 4 in the buffer. However I created a 240 long unsigned char lookup table for the x and now I use:
<br/>
"[y*120+lookupx[x]]" and it works fine, except that I have other weird problem.
<br/>
Here is a part of the code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">for (x=0; x&lt;120; x=x+2)
<br/>
{
<br/>
  PutPixel(1,x,y);
<br/>
}</td> </tr></table><span class="postbody">
<br/>
This should obviosly plot a pixel to every 2nd pixel in the screen while x is less than 120, but yet it draws pixel to EACH pixel in the screen while x is less than 120. Here is the current PutPixel() code:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">inline void PutPixel(u8 px, u8 x, u8 y)
<br/>
{
<br/>
   u8 offset = x&amp;2;
<br/>
   mltPixel * temp;
<br/>
   temp = (mltPixel*)&amp;(VideoBuffer[y*120+lookupx[x]]);
<br/>
   if (offset) {
<br/>
      temp-&gt;px2 = px;
<br/>
   }
<br/>
   else {
<br/>
      temp-&gt;px1 = px;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Any help is appriciated again. :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11658 - Master S - Wed Oct 15, 2003 6:59 am</h4>
    <div class="postbody"><span class="postbody">Just pointing a 2 byte sizeed structure into the video mem, and then changing one of the bytes in this structure dosent change that you are doing a 8bit write !!!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11670 - sajiimori - Wed Oct 15, 2003 5:44 pm</h4>
    <div class="postbody"><span class="postbody">A few things:
<br/>
<br/>
1)  There's a new bug in your function.  x&amp;2 will check the second bit of x, not the lowest bit.  You were probably thinking of x&amp;1.
<br/>
<br/>
2)  It seems like you missed Stroff's comment that you cannot write 8 bits at a time to VRAM.  Assigning to an 8 bit field in a struct is writing 8 bits.  You have to read out the existing 16 bit value, then modify it and store it again.
<br/>
<br/>
3)  There is no guarantee that gcc will put the 2 fields of the struct in adjacent bytes.  Even if it does in this version, it might change later, because the C standard allows compilers to pad structs for alignment.
<br/>
<br/>
4)  I don't see the point of using a struct at all.
<br/>
<br/>
5)  The lookup table presumably just maps x -&gt; x/2, so you may as well shift x right one bit instead.
<br/>
<br/>
I'm not sure if this is right (mainly because I'm not sure if the left pixel is the high byte or the low byte):
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline void PutPixel(int color, int x, int y)
<br/>
{
<br/>
   u16* dest = VideoBuffer + y*120 + (x &gt;&gt; 1);
<br/>
<br/>
   if(x &amp; 1)
<br/>
      *dest = (*dest &amp; 0xff00) | color;
<br/>
   else
<br/>
      *dest = (*dest &amp; 0x00ff) | (color &lt;&lt; 8);
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11676 - DekuTree64 - Wed Oct 15, 2003 6:28 pm</h4>
    <div class="postbody"><span class="postbody">The left pixel is the low byte, right pixel is high, so switch those 2 statements and it will work. But in general, don't use a putpixel function unless you really only need to draw a few pixels. It's just too slow, and even worse on GBA than a PC because of the pixel alignment. Make your drawing functions write 2 or 4 pixels at a time directly with pointers whenever possible.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#11688 - jd - Wed Oct 15, 2003 11:35 pm</h4>
    <div class="postbody"><span class="postbody">Alternatively, for maximum speed you could put a bit of ARM assembler in IWRAM like this: (this routine is untested, but it <span style="font-style: italic">should</span> work)
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
.TEXT
<br/>
.SECTION    .iwram0,"ax",%progbits
<br/>
.ALIGN
<br/>
.ARM
<br/>
<br/>
.GLOBAL PutPixel
<br/>
.EXTERN VideoBuffer
<br/>
<br/>
.pool
<br/>
<br/>
@ CODE_IN_IWRAM void PutPixel( int color, int x, int y )
<br/>
<br/>
PutPixel:
<br/>
  ldr r12,=VideoBuffer
<br/>
  add r12,r12,r1
<br/>
  eor r12,r12,#1
<br/>
  add r12,r12,r2,lsl #8
<br/>
  ldrb r2,[r12,-r2,lsl #4]!
<br/>
  ands r1,r1,#1
<br/>
  addne r2,r2,r0,lsl #8
<br/>
  addeq r2,r0,r2,lsl #8
<br/>
  strh r2,[r12,-r1]
<br/>
  bx lr
<br/>
<br/>
.pool
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
To add clipping, you could put the following instructions at the beginning of the PutPixel routine:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
cmp r1,#239
<br/>
bxhi lr
<br/>
cmp r2,#159
<br/>
bxhi lr
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Of course, like DekuTree64 said, you should try to write out lots of pixels at once instead for the very best performance.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21388 - lylh - Fri May 28, 2004 5:29 pm</h4>
    <div class="postbody"><span class="postbody">wouldn't it be better to use:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
inline void
<br/>
PutPixel (int x, int y, int color)
<br/>
{
<br/>
  u16* dest = VideoBuffer + (y&lt;&lt;7)-(y&lt;&lt;3) + (x &gt;&gt; 1); 
<br/>
  *dest = (*dest &amp; 0xffff) | color | (color &lt;&lt; 8);
<br/>
} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Also, remember if you are drawing a horizontal line, remove (x &gt;&gt; 1) (which divides by two), and downsize your loop instead ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#21417 - sajiimori - Fri May 28, 2004 10:33 pm</h4>
    <div class="postbody"><span class="postbody">jd's is still faster.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22343 - FPChris - Sat Jun 19, 2004 2:50 am</h4>
    <div class="postbody"><span class="postbody">You could also just typecast the video memory as 8bit
<br/>
Then read and write individual pixels
<br/>
<br/>
u8* cbuf = (u8*)(VideoBuffer);
<br/>
<br/>
cbuf[(y*240)+x] = color; //or what ever</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22345 - dagamer34 - Sat Jun 19, 2004 3:45 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>FPChris wrote:</b></span></td> </tr> <tr> <td class="quote">You could also just typecast the video memory as 8bit
<br/>
Then read and write individual pixels
<br/>
<br/>
u8* cbuf = (u8*)(VideoBuffer);
<br/>
<br/>
cbuf[(y*240)+x] = color; //or what ever</td> </tr></table><span class="postbody">
<br/>
<br/>
I don't think that works. The GBA Memory controller <span style="font-weight: bold">only</span> writes to VRAM in 16/32 bits, not 8. Sorry, but it's not quite that simple (I wish I were!)<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22354 - FPChris - Sat Jun 19, 2004 5:27 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">I don't think that works. The GBA Memory controller only writes to VRAM in 16/32 bits, not 8. Sorry, but it's not quite that simple (I wish I were!)</td> </tr></table><span class="postbody">
<br/>
<br/>
Hmm... I've done this and it runs on my GBA SP.
<br/>
<br/>
Chris</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22356 - FPChris - Sat Jun 19, 2004 5:44 am</h4>
    <div class="postbody"><span class="postbody">Ok, I rechecked it. I am able to typecast an u8* but due
<br/>
to may texture I was useing I did not realize it was still
<br/>
writing u16 regaudless. The typecasting however didn't through
<br/>
an error or fail on the hardware. Live and learn. Thanks.
<br/>
<br/>
Chris</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
