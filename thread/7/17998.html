<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Avoiding floating point precision issues - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Avoiding floating point precision issues</h2>
<div id="posts">
<div class="post">
    <h4>#178195 - Rajveer - Fri Jun 27, 2014 3:04 pm</h4>
    <div class="postbody"><span class="postbody">I have a question about mitigating floating point accuracy and an example to help discuss it. I have an AABB class which defines the volume with a centre vector and an extents vector
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">//Vector3 has just 3 floating-point values, x y and z
<br/>
class AABB
<br/>
{
<br/>
   Vector3 centre;
<br/>
   Vector3 extents;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
I set an AABB for a group of vertices using the min and max of the group with this method:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void AABB::setFromMinMax(const Vector3&amp; min, const Vector3&amp; max)
<br/>
{ 
<br/>
   extents.x = (max.x - min.x) / 2.0f;
<br/>
   extents.y = (max.y - min.y) / 2.0f;
<br/>
   extents.z = (max.z - min.z) / 2.0f;
<br/>
   
<br/>
   centre.x = min.x + extents.x; 
<br/>
   centre.y = min.y + extents.y; 
<br/>
   centre.z = min.z + extents.z; 
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
The rounding/truncation of these floating point operations causes extents to be slightly smaller than what it's supposed to be containing. This in turn causes an issue in my octree partitioning code when I have an axis-aligned polygon on the edge of the scene to be split and I'm testing if the triangle and AABB intersect, as it would test to be slightly outside of it's AABB when it's actually on it.
<br/>
<br/>
How would you go about accounting for the inaccuracies caused in this situation? Is there any way to force the rounding used when performing floating point arithmetic operations (e.g. to infinity, to zero e.t.c)? I see that std::numeric_limits has a range of information (epsilon(), round_error() e.t.c), I've never used this but should I be?</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
