<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Memory management issues - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Memory management issues</h2>
<div id="posts">
<div class="post">
    <h4>#166733 - Schala - Mon Feb 16, 2009 4:36 am</h4>
    <div class="postbody"><span class="postbody">I know for PC programming, it's better to use the stack for simple data and the heap for complex structures and what not. However, for GBA programming, I'm rather concerned about using the heap for such stuff. Is it okay to use the heap for structure/class instances on GBA?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166735 - Dwedit - Mon Feb 16, 2009 5:50 am</h4>
    <div class="postbody"><span class="postbody">The stack is inside IWRAM, which is 32KB total to be shared among the stack, global variables, and high performance code intentionally placed in IWRAM.
<br/>
<br/>
The heap is inside EWRAM, which is 256KB total.  If your game is a Multiboot game which runs without a cartridge, then it is shared with your code.  Otherwise, it's all free for any heap use, or you can also statically allocate variables there using special declarations.
<br/>
<br/>
The only problem with the heap is that malloc and free suck.  It's sensitive to the order things are allocated and freed.  If you allocate something big, then allocate something tiny, then free something big, your memory doesn't come back until you've freed the tiny thing.  Horrible fragmentation issues there.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166736 - Schala - Mon Feb 16, 2009 6:02 am</h4>
    <div class="postbody"><span class="postbody">So I should use EWRAM for instantiation as opposed to malloc/free?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166739 - elwing - Mon Feb 16, 2009 9:24 am</h4>
    <div class="postbody"><span class="postbody">never looked at memory fragmentation, but if malloc/free are really so bad on the GBA someone surelly wrote a new memory allocator, no?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166745 - Pete_Lockwood - Mon Feb 16, 2009 1:26 pm</h4>
    <div class="postbody"><span class="postbody">By default, malloc and free have the <span style="font-style: italic">potential</span> to be bad.  Libraries exist which do their best to improve things (recommended reading: <a class="postlink" href="http://g.oswego.edu/dl/html/malloc.html" target="_blank">http://g.oswego.edu/dl/html/malloc.html</a> and it's possible something similar is used by devKitPro) or if you're using malloc and free a lot and know the dynamics of your program well enough you can usually optimize allocations for your specific case.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166747 - elwing - Mon Feb 16, 2009 2:21 pm</h4>
    <div class="postbody"><span class="postbody">quite interesting article, I've read something looking like that in game programming gems7 trough they only use bins for small allocation and work using tree for bigger allocation, now my question underneath was not how to program an allocator, but is there a good one floating around?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166750 - gauauu - Mon Feb 16, 2009 4:17 pm</h4>
    <div class="postbody"><span class="postbody">For relatively simple games, I've found that it's often easier to allocate big hunks of memory up front, and doing your own custom memory management from those hunks.
<br/>
<br/>
Simple example:
<br/>
In my game, you can have at most 40 "character" objects at once.  So up front, I allocate an array of 40 character objects.  I then manage which ones are active, and when a new one is needed, return one of the inactive ones.  I never need to allocate more memory for them, and I never need to free the big hunk of memory (since the game never really exits)  
<br/>
<br/>
This only works in fairly simple programs, where you're not needing to allocate/free tons of different objects all over the place.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166752 - sgeos - Mon Feb 16, 2009 4:25 pm</h4>
    <div class="postbody"><span class="postbody">Even for games of medium complexity you can make multiple game state structs that contain large numbers of arrays for various things.  I suppose you could even make a union of game state structs, or a game state struct that contains unions (or both) and manage things that way.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166763 - Schala - Tue Feb 17, 2009 1:40 am</h4>
    <div class="postbody"><span class="postbody">So... what? malloc/free is okay to use for large games?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166765 - gauauu - Tue Feb 17, 2009 2:54 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Schala wrote:</b></span></td> </tr> <tr> <td class="quote">So... what? malloc/free is okay to use for large games?</td> </tr></table><span class="postbody">
<br/>
<br/>
It's "okay" to use anywhere.  But avoiding the performance hits, unpredictability, or hassle of normal memory management often makes it worth finding other solutions.  Those other solutions are simpler in simpler projects.  
<br/>
<br/>
With any size project, you'll want to think through how you want to manage memory, and implement it with whatever method seems the best.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166766 - Schala - Tue Feb 17, 2009 3:01 am</h4>
    <div class="postbody"><span class="postbody">Well, you mentioned EWRAM/IWRAM. Any method for those?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166768 - sgeos - Tue Feb 17, 2009 4:22 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Schala wrote:</b></span></td> </tr> <tr> <td class="quote">So... what? malloc/free is okay to use for large games?</td> </tr></table><span class="postbody">
<br/>
On a portable where malloc can fail, I'd say avoid it whenever you can.  When can't avoid it, tred with extreme caution (and always, always check the return status of malloc).  Memory related bugs are often strange and hard to track down.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166770 - eKid - Tue Feb 17, 2009 4:33 am</h4>
    <div class="postbody"><span class="postbody">You don't really need to worry about malloc unless you're allocating very large buffers, or large arrays of objects. I got away with using malloc/free everywhere in my gba game, which was a multiboot game with only 16-32k of ewram remaining.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166771 - sajiimori - Tue Feb 17, 2009 5:51 am</h4>
    <div class="postbody"><span class="postbody">We use tons of heap allocation on our DS games.  We don't check the results of memory allocations; we assert inside the allocator.
<br/>
<br/>
Since assets have to be copied to main RAM on the DS, it's not uncommon to be left with little more than 256K of general-purpose working memory, just like we'd have on GBA.
<br/>
<br/>
Our memory optimizations are rarely in the form of "pre-allocate an array of X character structs" and usually more like "aggressively destroy off-screen objects".</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166793 - sgeos - Wed Feb 18, 2009 9:07 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">We use tons of heap allocation on our DS games.  We don't check the results of memory allocations; we assert inside the allocator.</td> </tr></table><span class="postbody">
<br/>
I'm under the impression you are using custom memory allocation routines.  Either way, you need to be sure you actually get memory the memory you ask for.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166805 - Miked0801 - Wed Feb 18, 2009 6:00 pm</h4>
    <div class="postbody"><span class="postbody">Umm, all memory allocation routines are pretty much custom on the DS/GBA right?  :)
<br/>
<br/>
And if you don't get memory you ask for, your screwed in just about every case.  When we create a system where memory allocation is a maybe, we set aside a special pool or heap just for that memory and have special case fail code only for it, otherwise just assert fatal and find the memory leak.  Memory allocation is already one of our slower tasks, no need to burden it further if there is no need.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166810 - sajiimori - Wed Feb 18, 2009 10:39 pm</h4>
    <div class="postbody"><span class="postbody">There's only one way to guarantee that you always get the memory you ask for: Never ask for memory that isn't available!  ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166812 - sgeos - Thu Feb 19, 2009 3:30 am</h4>
    <div class="postbody"><span class="postbody">You can ask for memory that is available, but not in a continuous block.  Ie, fragmentation can be a killer.  Hence the statically allocated arrays some people use.  Either you get the memory every time, or you do not ever get it.
<br/>
<br/>
IIRC, some of the old NES games failed to spawn things if there were already too many objects in play.  This solution could be used even yet, although there certainly are other uses for dynamically allocated memory that can not just fail.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166813 - elwing - Thu Feb 19, 2009 9:40 am</h4>
    <div class="postbody"><span class="postbody">hum, so there is no "bins" based allocator as the one described by Dimitar lazarov in game programming gems7 in the abstract "High Performance Heap allocator"? looks like something interesting to write...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166825 - Miked0801 - Thu Feb 19, 2009 6:26 pm</h4>
    <div class="postbody"><span class="postbody">Again, you can ask for a large, contiguous chunk of memory, but if you're doing things that fragment ram, you had better ask for them early before they get gobbled.  Then you are indeed getting into a bin type system.  
<br/>
<br/>
Anyways, iff one is a little bit careful, you can usually avoid massive memory fragmentation.  Swap trick your stl containers when done or not in use, try to allocate and free stuff in without other allocs in the middle, etc.
<br/>
<br/>
Or, just try not to code things that take contiguous memory.  It's a lot easier to find space in a somewhat fragmented heap for 10x20k blocks than 1 200k block.  I find myself doing optimizations like this more than preallocate and pray.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#166841 - sajiimori - Fri Feb 20, 2009 3:40 am</h4>
    <div class="postbody"><span class="postbody">Exactly.  "Don't ask for memory that isn't available" can mean "make more memory available" or "don't ask for so much."
<br/>
<br/>
I hate being super careful everywhere, under threat of failed allocation.  I'd much rather ask for less contiguous memory, and make special accomodations for large allocations that would otherwise be at risk of failure.
<br/>
<br/>
Those "special accomodations" are pretty much always for assets, so it's not even an issue on GBA.  A single general-purpose heap is all I would use on GBA.
<br/>
<br/>
If you have super large C++ objects (over 5k or so), by all means, split them up!  Hold some data members by reference, and allocate them separately.  There's no need to require so much contiguous memory.
<br/>
<br/>
If you still get a failed allocation, even when your objects are small, then either you're truly out of memory, or you have a sadistic fragmentation problem the likes of which I've never seen.
<br/>
<br/>
And if you're truly out of memory, you would have ran out much sooner using preallocated buckets, because preallocation is inherently wasteful -- it's basically a way to "pay off" the fragmentation troll to make it go away.
<br/>
<br/>
Edit: That's not to say I never pay off the fragmentation troll.  I opt to waste memory on a large music heap, which is always partially unused, because I don't want to think about whether a particular song is going to use too much memory and cause some other allocation to fail.  I want to pay for music and forget about it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#167235 - keldon - Fri Mar 06, 2009 6:07 pm</h4>
    <div class="postbody"><span class="postbody">I've written some [basic] memory management algorithms with the following properties:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/*
<br/>
*
<br/>
* \brief   The DYNAMIC_IDX_ALLOCATOR allocates 'offsets' with an associated
<br/>
*         size very much the same way that &lt;code&gt;malloc&lt;/code&gt; will allocate
<br/>
*         a pointer. This class can be used an implementation for dynamically
<br/>
*         allocating memory.
<br/>
*
<br/>
*         The DYNAMIC_IDX_ALLOCATOR preallocates all operational memory,
<br/>
*         providing it with predictable space and time requirements.
<br/>
*         Allocating operates in O(N) and deallocating memory operates in O(1) time.
<br/>
*
<br/>
*         The implementation allows a limited number of allocations set at
<br/>
*         compile time though the SIZE template argument. The allocations can
<br/>
*         span any space using those allocations, for example a 2GB space
<br/>
*         could [in theory] be managed by an implementation that only allows
<br/>
*         128 allocations.
<br/>
*
<br/>
*         The template implementation takes three parameters; the SIZE
<br/>
*         determines the maximum number of allocations, OFFSET_TYPE
<br/>
*         is the data type returned for allocations of offsets, whilst
<br/>
*         the IDX_TYPE is the type used to reference the internal
<br/>
*         allocations. IDX_TYPE must be able to represent SIZE, whilst
<br/>
*         OFFSET_TYPE must be able to represent the size specified in either
<br/>
*         the constructor or &lt;code&gt;init_memory_space()&lt;/code&gt;.
<br/>
*
<br/>
*         sizeof(DYNAMIC_IDX_ALLOCATOR&lt;SIZE,OFFSET_TYPE, IDX_TYPE&gt;) can be calculated as
<br/>
*         such:
<br/>
*         - sizeof(MEMORY_BLOCK[SIZE]) + sizeof(ALLOCATOR) + sizeof(size_t)
<br/>
*            &gt; sizeof(MEMORY_BLOCK) == sizeof(OFFSET_TYPE)*2
<br/>
*            &gt; sizeof(ALLOCATOR) == sizeof(IDX_TYPE)*(SIZE+3)
<br/>
*         - Which is an accumulation of:
<br/>
*            &gt; sizeof(OFFSET_TYPE[SIZE*2])            ## MEMORY_BLOCK
<br/>
*            &gt; sizeof(IDX_TYPE[SIZE+3])               ## ALLOCATOR
<br/>
*            &gt; sizeof(size_t)                     ## size 
<br/>
*         - Which is equal to:
<br/>
*            &gt; sizeof(OFFSET_TYPE[SIZE * 2]) + sizeof(IDX_TYPE[SIZE + 3]) + sizeof(SIZE_T)*/</td> </tr></table><span class="postbody">
<br/>
<br/>
I've not long updated my algo to use a partitioned set that is iterable so the commenting is very out of date (well, non existant now &lt;_&lt;). I use it for allocating sprite/bg names - it does take up a fair amount of space, but its predictable and preallocated!
<br/>
<br/>
Recently moved home and haven't sorted out my own connection just yet, but if anyone is interested ... I may upload it.
<br/>
<br/>
<span style="font-weight: bold">Edit</span>: correct wrong description of deallocation speed.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
