<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Const arrays - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Const arrays</h2>
<div id="posts">
<div class="post">
    <h4>#1068 - Japster - Tue Jan 14, 2003 9:51 am</h4>
    <div class="postbody"><span class="postbody">Are arrays that are constants stored in the internal ram in GBA or in the ROM in game cart? I noticed that internal ram is so small that few arrays overlaps each other.(sorry for my english skills...)
<br/>
<br/>
Thanks, Jasper.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1069 - anli - Tue Jan 14, 2003 10:09 am</h4>
    <div class="postbody"><span class="postbody">It will be stored in ROM!
<br/>
<br/>
An easy way to find out is to use the address operator &amp; and print
<br/>
out the address of a variable.
<br/>
<br/>
/anli</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1070 - Touchstone - Tue Jan 14, 2003 10:29 am</h4>
    <div class="postbody"><span class="postbody">An even easier way to figure out where your data is located is by having the linker produce a map file. This is done by passing the switch '-Map myproject.map' to the linker.<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1072 - bomberman - Tue Jan 14, 2003 11:05 am</h4>
    <div class="postbody"><span class="postbody">How do you force your code to run in ram rather than in rom?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1073 - anli - Tue Jan 14, 2003 11:16 am</h4>
    <div class="postbody"><span class="postbody">Here is how you put it in .iwram, however, I didnt manage to use .wram instead of .iwram:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void foo(void) __attribute__ ((section(".iwram")));
<br/>
<br/>
void foo()
<br/>
{
<br/>
}
<br/>
<br/>
void AgbMain()
<br/>
{
<br/>
  foo();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
/anli</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1074 - Quirky - Tue Jan 14, 2003 11:34 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define CODE_IN_IWRAM __attribute__ ((section (".iwram"), long_call))
<br/>
<br/>
void foo(void) CODE_IN_IWRAM;
<br/>
<br/>
CODE_IN_IWRAM void foo()
<br/>
{
<br/>
}
<br/>
<br/>
void AgbMain()
<br/>
{
<br/>
  foo();
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
That's it taken from devrs.com. foo should be in a seperate object file to the calling routine. And I you may well need -mthumb-interwork on your cflags in the make file for the objects calling that bit of code.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1077 - anli - Tue Jan 14, 2003 12:29 pm</h4>
    <div class="postbody"><span class="postbody">You can also to put the code in .ewram.
<br/>
<br/>
(Which you have plenty of compared to the .iwram:
<br/>
256K compared to 32K, but it is slower).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1083 - Touchstone - Tue Jan 14, 2003 2:00 pm</h4>
    <div class="postbody"><span class="postbody">I belive external RAM accesses are slower than ROM accesses. Can someone confirm?<br/>_________________<br/>You can't beat our meat</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1088 - Splam - Tue Jan 14, 2003 2:24 pm</h4>
    <div class="postbody"><span class="postbody">afaik the cache doesn't work on ram so you can set the 1st access waitstates for ram and rom to be the same speed but 2nd sequential access (and any from there) will be faster in rom than ram due to the cache (not to be confused with the iwram prefetch which only works on instructions not ram access).</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#1117 - tepples - Tue Jan 14, 2003 8:05 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Touchstone wrote:</b></span></td> </tr> <tr> <td class="quote">I belive external RAM accesses are slower than ROM accesses. Can someone confirm?</td> </tr></table><span class="postbody">
<br/>
<br/>
EWRAM and ROM run at about the same speed for data tables or for code with a lot of branches. A typical ROM has 3 wait states for random access and 1 for sequential access; EWRAM has 2 for both. One advantage of EWRAM is that accessing EWRAM drains the battery less than accessing ROM.
<br/>
<br/>
Another trick: Store variables in unused areas of VRAM; it's 16-bit wide with less than 1 wait state on average, but byte writes don't work.  It should work well for DMA buffers such as mode 1/2 scanline parameter tables and audio mix buffers that have to persist across IWRAM overlays.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
