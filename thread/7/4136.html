<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>GAH! A really evil bug if you think about it... - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > GAH! A really evil bug if you think about it...</h2>
<div id="posts">
<div class="post">
    <h4>#26863 - LOst? - Mon Sep 27, 2004 10:35 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   if (ObjectOffset != 0)
<br/>
      DMA3(OAMMem, sprites, (ObjectOffset &lt;&lt; 1), DMA_32NOW);
<br/>
<br/>
   ObjectOffset = 0;
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
This screws up my VBlank, and I found out why. It looks so correct until you realize DMA3 is a macro that looks like this:
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define   DMA3(dst, src, cnt, mode)      \
<br/>
   REG_DMA3SAD = (u32) src;         \
<br/>
   REG_DMA3DAD = (u32) dst;         \
<br/>
   REG_DMA3CNT = (cnt | mode);         \
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
So I fixed it by putting { } around the macro call:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
   if (ObjectOffset != 0)
<br/>
   {
<br/>
      DMA3(OAMMem, sprites, (ObjectOffset &lt;&lt; 1), DMA_32NOW);
<br/>
   }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I have never used macros before so I have never come across this problem before.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26868 - DekuTree64 - Mon Sep 27, 2004 11:33 pm</h4>
    <div class="postbody"><span class="postbody">Yup, that's a sneaky one. To prevent future errors of that sort, I'd suggest putting the {}'s into the macro itself. They're perfectly legal without an if or anything before them.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26869 - tepples - Mon Sep 27, 2004 11:40 pm</h4>
    <div class="postbody"><span class="postbody">I think you need to convert DMA3() into an inline function to prevent this from happening in the future. Toss this in your header to replace the macro:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static inline void DMA3(void *dst, const void *src, u32 cnt, u32 mode)
<br/>
{
<br/>
  REG_DMA3SAD = (u32) src;
<br/>
  REG_DMA3DAD = (u32) dst;
<br/>
  REG_DMA3CNT = (cnt | mode);
<br/>
}</td> </tr></table><span class="postbody"><br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26870 - LOst? - Tue Sep 28, 2004 12:53 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">I think you need to convert DMA3() into an inline function to prevent this from happening in the future. Toss this in your header to replace the macro:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">static inline void DMA3(void *dst, const void *src, u32 cnt, u32 mode)
<br/>
{
<br/>
  REG_DMA3SAD = (u32) src;
<br/>
  REG_DMA3DAD = (u32) dst;
<br/>
  REG_DMA3CNT = (cnt | mode);
<br/>
}</td> </tr></table><span class="postbody"></span></td> </tr></table><span class="postbody">
<br/>
<br/>
Great! Thanks!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26877 - SmileyDude - Tue Sep 28, 2004 1:46 am</h4>
    <div class="postbody"><span class="postbody">Deku's suggestion is also valid -- especially when you are coding in C.  inline functions technically aren't a part of C until you get to C99.<br/>_________________<br/>dennis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26879 - sajiimori - Tue Sep 28, 2004 2:53 am</h4>
    <div class="postbody"><span class="postbody">...which GCC supports quite well.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26880 - poslundc - Tue Sep 28, 2004 2:56 am</h4>
    <div class="postbody"><span class="postbody">GCC supports inline functions without using the C99 extensions. They are probably a GNU-specific extension to the ANSI standard or something, but they are there.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26887 - getch - Tue Sep 28, 2004 11:18 am</h4>
    <div class="postbody"><span class="postbody">I dont know exactly what the problem with the macro is?
<br/>
Could it be fixed by removing the last backslash?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26888 - DialogPimp - Tue Sep 28, 2004 11:26 am</h4>
    <div class="postbody"><span class="postbody">It's probably irrelevant to the thread, but it's precisely because of things like this that our coding standard at work requires us to block any "if" statement regardless of whether it's one line or not.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26892 - SmileyDude - Tue Sep 28, 2004 12:20 pm</h4>
    <div class="postbody"><span class="postbody">well, in all honesty, gcc lets you do a lot of things that may or may not be allowed in the standard.  But, the nice thing about coding to the standard is that it will work even if the compiler doesn't support things like inline functions in C code.
<br/>
<br/>
Personally, if the code is for yourself, use whatever method you are comfortable with.  But, if you don't have control over where the code is going to be compiled/used, it's best to stick to the standard.
<br/>
<br/>
:)<br/>_________________<br/>dennis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26893 - SmileyDude - Tue Sep 28, 2004 12:24 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>getch wrote:</b></span></td> </tr> <tr> <td class="quote">I dont know exactly what the problem with the macro is?
<br/>
Could it be fixed by removing the last backslash?</td> </tr></table><span class="postbody">
<br/>
<br/>
The problem with the macro is that it expands out to 3 statements.  As long as you are not in something like an if/while/do, it's okay.  It's also okay if you block out the if/while/do in {}s.  But, in the case where you don't block out the {}s, the if will only do the first statement inside the if, and the other 2 outside the if.
<br/>
<br/>
And, this is one of the bigger (biggest?) drawbacks to the C preprocessor.  It's pretty dumb about what it does.  Since the preprocessor simply replaces the macro with whatever was defined, it has no idea that since the code was in an if, that it needs to block it out.
<br/>
<br/>
But, the simplest solution is to put the {}s in the macro definition -- that way, it always works.<br/>_________________<br/>dennis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26896 - poslundc - Tue Sep 28, 2004 2:00 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>SmileyDude wrote:</b></span></td> </tr> <tr> <td class="quote">And, this is one of the bigger (biggest?) drawbacks to the C preprocessor.  It's pretty dumb about what it does.</td> </tr></table><span class="postbody">
<br/>
<br/>
I blame the programmer. :P
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26903 - sajiimori - Tue Sep 28, 2004 6:24 pm</h4>
    <div class="postbody"><span class="postbody">It still wouldn't work as an expression, and expressions should be the preferred form of macro expansion.  I recommend using an inline function or a parenthesized comma-seperated expression.
<br/>
<br/>
Depending on how you look at it, there are no drawbacks to the C preprocessor.  It does exactly what it does, and what it does is plain text substitution.  It's only a disappointment if you are expecting something more.  If you want real macros, use Lisp.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26904 - jma - Tue Sep 28, 2004 6:48 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">..., use Lisp.</td> </tr></table><span class="postbody">
<br/>
/cheer sajiimori
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26905 - poslundc - Tue Sep 28, 2004 7:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Depending on how you look at it, there are no drawbacks to the C preprocessor.  It does exactly what it does, and what it does is plain text substitution.  It's only a disappointment if you are expecting something more.</td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, yes, thank you. This is precisely what I think whenever I hear programmers upset at this kind of behaviour. Multiple inclusion, linker errors due to multiple symbol generation, problematic macro expansion... everyone is so quick to blame the frailty of the language for these problems when the only real problem is ignorance of what the directives they're using actually do.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26906 - tepples - Tue Sep 28, 2004 7:52 pm</h4>
    <div class="postbody"><span class="postbody">Which free Lisp compiler emits decent Thumb code?
<br/>
<br/>
None?
<br/>
<br/>
That's why most of us use C instead.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26907 - sajiimori - Tue Sep 28, 2004 8:05 pm</h4>
    <div class="postbody"><span class="postbody">That's the thing about a Lisp recommendation.  It's often packaged with an implicit lament that the recommendation probably shouldn't be taken.  =)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26909 - jma - Tue Sep 28, 2004 9:58 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Which free Lisp compiler emits decent Thumb code?
<br/>
<br/>
None?
<br/>
<br/>
That's why most of us use C instead.</td> </tr></table><span class="postbody">
<br/>
Hardly. Here, with my compliments. If you use this, please, give me credit where due:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">;;; Thumb assember for GBA
<br/>
;;;
<br/>
;;; Created 9/13/04 by Jeff Massung
<br/>
;;;
<br/>
;;; THUMB.LISP
<br/>
;;;
<br/>
<br/>
;(load "gba.lisp")
<br/>
<br/>
(defparameter *mnemonics* (make-hash-table))
<br/>
<br/>
;; Assembles a body of code
<br/>
(defun assemble-form (&amp;rest body)
<br/>
  (let ((locals (collect-labels body)) 
<br/>
        (here 0)
<br/>
        (asm (make-array 0 
<br/>
                         :element-type 'unsigned-byte
<br/>
                         :adjustable t
<br/>
                         :fill-pointer t)))
<br/>
    (loop for form in body do
<br/>
          (unless (keywordp form)
<br/>
            (let ((operands (expand-labels (cdr form) locals here)))
<br/>
              (incf here (assemble-instruction (car form) operands asm)))))
<br/>
    asm))
<br/>
<br/>
;; Collect all the labels in a form
<br/>
(defun collect-labels (body)
<br/>
  (do ((i body (cdr i)) (here 0) (locals (make-hash-table)))
<br/>
      ((null i) locals)
<br/>
    (let ((form (car i)))
<br/>
      (if (keywordp form)
<br/>
          (setf (gethash form locals) here)
<br/>
        (let ((mnemonic (gethash (car form) *mnemonics*)))
<br/>
          (if (null mnemonic)
<br/>
              (error "Unknown instruction ~A" (car form))
<br/>
            (incf here (mnemonic-size mnemonic))))))))
<br/>
<br/>
;; Replace all labels in an instruction call with their address
<br/>
(defun expand-labels (operands labels here)
<br/>
  (loop for form in operands collect
<br/>
        (if (keywordp form)
<br/>
            (let ((label (gethash form labels)))
<br/>
              (if (null label)
<br/>
                  (error "Undefined label ~A" form)
<br/>
                (- label (+ here 4))))
<br/>
          form)))
<br/>
<br/>
;; Assemble an instruction into a form and return number of bytes
<br/>
(defun assemble-instruction (symbol operands form)
<br/>
  (let* ((mnemonic (gethash symbol *mnemonics*))
<br/>
         (bytes (apply (mnemonic-builder mnemonic) operands))
<br/>
         (size (mnemonic-size mnemonic)))
<br/>
    (loop for i from 0 to (1- size) do
<br/>
          (vector-push-extend (logand (ash bytes (- (* i 8))) #xff) form))
<br/>
    size))
<br/>
<br/>
;; Simple mnemonic function
<br/>
(defstruct mnemonic builder size)
<br/>
<br/>
;; Define a new mnemonic function
<br/>
(defmacro defmnemonic (symbol args size &amp;body body)
<br/>
  `(setf (gethash ',symbol *mnemonics*) 
<br/>
         (make-mnemonic :builder (lambda ,args ,@body)
<br/>
                        :size ,size)))
<br/>
<br/>
;; Get the index of a lo register (r0-r7)
<br/>
(defun lo-reg (r)
<br/>
  (do ((lo '(r0 r1 r2 r3 r4 r5 r6 r7) (cdr lo))
<br/>
       (reg-index 0 (1+ reg-index)))
<br/>
      ((eq r (car lo)) reg-index)
<br/>
    (unless lo 
<br/>
      (error "Not a lo register ~A" r))))
<br/>
<br/>
;; Get the index of a hi register (r8-r15)
<br/>
(defun hi-reg (r)
<br/>
  (do ((hi '(r8 r9 r10 r11 r12 r13 r14 r15) (cdr hi))
<br/>
       (reg-index 8 (1+ reg-index)))
<br/>
      ((eq r (car hi)) reg-index)
<br/>
    (unless hi 
<br/>
      (error "Not a lo register ~A" r))))
<br/>
<br/>
;; Any register (with hi/lo return value)
<br/>
(defun any-reg (r)
<br/>
  (do ((any '(r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15) (cdr any))
<br/>
       (reg-index 0 (1+ reg-index)))
<br/>
      ((eq r (car any)) (if (&gt;= reg-index 8)
<br/>
                            (values (- reg-index 8) t)
<br/>
                          (values reg-index nil)))
<br/>
    (unless any
<br/>
      (error "Not a register ~A" r))))
<br/>
<br/>
;; Create a register list bitfield
<br/>
(defun make-reglist (list &amp;key allow-pc allow-lr)
<br/>
  (do ((rd list (cdr rd)) (acc 0))
<br/>
      ((null rd) acc)
<br/>
    (if (or (and allow-pc (eq (car rd) 'pc))
<br/>
            (and allow-lr (eq (car rd) 'lr)))
<br/>
        (incf acc #x100)
<br/>
      (incf acc (ash 1 (lo-reg (car rd)))))))
<br/>
<br/>
;; Hi/lo register arguments
<br/>
(defun hi-lo-regs (opcode rm rn &amp;optional allow-both-lo)
<br/>
  (multiple-value-bind (rm h1) (any-reg rm)
<br/>
    (multiple-value-bind (rn h2) (any-reg rn)
<br/>
      (cond
<br/>
       ((and (null h1) h2) (logior opcode #x80 (ash rn 3) rm))
<br/>
       ((and h1 (null h2)) (logior opcode #x40 (ash rn 3) rm))
<br/>
       ((and h1 h2)        (logior opcode #xc0 (ash rn 3) rm))
<br/>
       (allow-both-lo      (logior allow-both-lo (ash rn 3) rm))
<br/>
       (t                  (error "Invalid operands"))))))
<br/>
<br/>
;; Make sure the mnemonics is clean before defining assembly instructions
<br/>
(clrhash *mnemonics*)
<br/>
<br/>
;; Simple ALU operations
<br/>
(defun simple-alu (rd rm opcode)
<br/>
  (let ((rd (lo-reg rd)) (rm (lo-reg rm)))
<br/>
    (logior opcode (ash rm 3) rd)))
<br/>
<br/>
(defmnemonic adc (rd rm) 2 (simple-alu rd rm #x4140))
<br/>
(defmnemonic and (rd rm) 2 (simple-alu rd rm #x4000))
<br/>
(defmnemonic bic (rd rm) 2 (simple-alu rd rm #x4380))
<br/>
(defmnemonic cmn (rd rm) 2 (simple-alu rd rm #x42c0))
<br/>
(defmnemonic eor (rd rm) 2 (simple-alu rd rm #x4040))
<br/>
(defmnemonic mul (rd rm) 2 (simple-alu rd rm #x4340))
<br/>
(defmnemonic mvn (rd rm) 2 (simple-alu rd rm #x43c0))
<br/>
(defmnemonic neg (rd rm) 2 (simple-alu rd rm #x4240))
<br/>
(defmnemonic orr (rd rm) 2 (simple-alu rd rm #x4300))
<br/>
(defmnemonic ror (rd rm) 2 (simple-alu rd rm #x41c0))
<br/>
(defmnemonic sbc (rd rm) 2 (simple-alu rd rm #x4180))
<br/>
(defmnemonic tst (rd rm) 2 (simple-alu rd rm #x4200))
<br/>
<br/>
;; Unconditional branch
<br/>
(defmnemonic b (offset) 2
<br/>
  (if (not (zerop (logand offset 1)))
<br/>
      (error "Invalid offset ~A" offset)
<br/>
    (logior #xe000 (ash offset -1))))
<br/>
<br/>
;; Conditional branches
<br/>
(defmacro cond-branch (offset cc)
<br/>
  `(if (not (zerop (logand ,offset 1)))
<br/>
       (error "Invalid offset ~A" ,offset)
<br/>
     (logior #xd000 ,cc (ash ,offset -1))))
<br/>
<br/>
(defmnemonic beq (offset) 2 (cond-branch offset #x000))
<br/>
(defmnemonic bne (offset) 2 (cond-branch offset #x100))
<br/>
(defmnemonic bcs (offset) 2 (cond-branch offset #x200))
<br/>
(defmnemonic bcc (offset) 2 (cond-branch offset #x300))
<br/>
(defmnemonic bhs (offset) 2 (cond-branch offset #x200))
<br/>
(defmnemonic blo (offset) 2 (cond-branch offset #x300))
<br/>
(defmnemonic bmi (offset) 2 (cond-branch offset #x400))
<br/>
(defmnemonic bpl (offset) 2 (cond-branch offset #x500))
<br/>
(defmnemonic bvs (offset) 2 (cond-branch offset #x600))
<br/>
(defmnemonic bvc (offset) 2 (cond-branch offset #x700))
<br/>
(defmnemonic bhi (offset) 2 (cond-branch offset #x800))
<br/>
(defmnemonic bls (offset) 2 (cond-branch offset #x900))
<br/>
(defmnemonic bge (offset) 2 (cond-branch offset #xa00))
<br/>
(defmnemonic blt (offset) 2 (cond-branch offset #xb00))
<br/>
(defmnemonic bgt (offset) 2 (cond-branch offset #xc00))
<br/>
(defmnemonic ble (offset) 2 (cond-branch offset #xd00))
<br/>
<br/>
;; Branch with link
<br/>
(defmnemonic bl (offset) 4
<br/>
  (if (logand offset 1)
<br/>
      (error "Invalid branch with link offset ~A" offset)
<br/>
    (let ((offset (ash offset -1)))
<br/>
      (logior #xf800f000 
<br/>
              (ash (logand offset #x3ff) 16) 
<br/>
              (logand (ash offset -10) #x3ff)))))
<br/>
<br/>
;; Branch and exchange
<br/>
(defmnemonic bx (rm) 2
<br/>
  (multiple-value-bind (rm hi) (any-reg rm)
<br/>
    (logior #x4700 (ash rm 3) (if hi #x40 #x00))))
<br/>
<br/>
;; Load multiple registers
<br/>
(defmnemonic ldmia (rm &amp;rest list) 2
<br/>
  (let ((rm (lo-reg rm)))
<br/>
    (logior #xc800 (ash rm 8) (make-reglist list))))
<br/>
<br/>
;; Store multiple registers
<br/>
(defmnemonic stmia (rm &amp;rest list) 2
<br/>
  (let ((rm (lo-reg rm)))
<br/>
    (logior #xc000 (ash rm 8) (make-reglist list))))
<br/>
<br/>
;; Push registers onto the stack
<br/>
(defmnemonic push (&amp;rest list) 2
<br/>
  (logior #xb400 (make-reglist list :allow-lr t)))
<br/>
<br/>
;; Pop registers off the stack
<br/>
(defmnemonic pop (&amp;rest list) 2
<br/>
  (logior #xbc00 (make-reglist list :allow-pc t)))
<br/>
<br/>
;; Arithmetic shift right
<br/>
(defmnemonic asr (rd rm &amp;optional n) 2
<br/>
  (let ((operands (logior (ash (lo-reg rm) 3) (lo-reg rd))))
<br/>
    (if (null n)
<br/>
        (logior #x4100 operands)
<br/>
      (logior #x1000 (ash n 6) operands))))
<br/>
<br/>
;; Logical shift left
<br/>
(defmnemonic lsl (rd rm &amp;optional n) 2
<br/>
  (let ((operands (logior (ash (lo-reg rm) 3) (lo-reg rd))))
<br/>
    (if (null n)
<br/>
        (logior #x4080 operands)
<br/>
      (logior #x0000 (ash n 6) operands))))
<br/>
<br/>
;; Logical shift right
<br/>
(defmnemonic lsr (rd rm &amp;optional n) 2
<br/>
<br/>
  (let ((operands (logior (ash (lo-reg rm) 3) (lo-reg rd))))
<br/>
    (if (null n)
<br/>
        (logior #x40c0 operands)
<br/>
      (logior #x0800 (ash n 6) operands))))
<br/>
<br/>
;; Compare register
<br/>
(defmnemonic cmp (rm n) 2
<br/>
  (if (integerp n)
<br/>
      (logior #x2800 (ash (lo-reg rm) 8) n)
<br/>
    (hi-lo-regs #x4500 rm n #x4280)))
<br/>
<br/>
;; Move register
<br/>
(defmnemonic mov (rm n) 2
<br/>
  (if (integerp n)
<br/>
      (logior #x2000 (ash (lo-reg rm) 8) n)
<br/>
    (hi-lo-regs #x4600 rm n)))
<br/>
<br/>
;; Add
<br/>
(defmnemonic add (rd rm &amp;optional n) 2
<br/>
  (if (null n)
<br/>
      (if (integerp rm)
<br/>
          (logior #x3000 (ash (lo-reg rd) 8) rm)
<br/>
        (if (eq rd 'sp)
<br/>
            (logior #xb000 (ash rm -2))
<br/>
          (hi-lo-regs #x4400 rd rm)))
<br/>
    (if (integerp n)
<br/>
        (case rm
<br/>
          (pc        (logior #xa800 (ash (lo-reg rd) 8) (ash n -2)))
<br/>
          (sp        (logior #xa000 (ash (lo-reg rd) 8) (ash n -2)))
<br/>
          (otherwise (logior #x1c00 (ash (lo-reg rm) 3) (ash n 6) (lo-reg rd))))
<br/>
      (logior #x1800 (ash (lo-reg n) 6) (ash (lo-reg rm) 3) (lo-reg rd)))))
<br/>
<br/>
;; Subtract
<br/>
(defmnemonic sub (rd rm &amp;optional n) 2
<br/>
  (if (null n)
<br/>
      (if (eq rd 'sp)
<br/>
          (logior #xb080 (ash rm -2))
<br/>
        (logior #x3800 (ash (lo-reg rd) 8) rm))
<br/>
    (if (integerp n)
<br/>
        (logior #x1e00 (ash n 6) (ash (lo-reg rm) 3) (lo-reg rd))
<br/>
      (logior #x1a00 (ash (lo-reg n) 6) (ash (lo-reg rm) 3) (lo-reg rd)))))
<br/>
<br/>
;; Load register with word
<br/>
(defmnemonic ldr (rd rm &amp;optional n) 2
<br/>
  (let ((rd (lo-reg rd)))
<br/>
    (if (or (integerp n) (null n))
<br/>
        (let ((n (if (null n) 0 (ash n -2))))
<br/>
          (case rm
<br/>
            (pc        (logior #x4800 (ash rd 8) n))
<br/>
            (sp        (logior #x9800 (ash rd 8) n))
<br/>
            (otherwise (logior #x6800 (ash n 6) (ash (lo-reg rm) 3) rd))))
<br/>
      (logior #x5800 (ash (lo-reg n) 6) (ash (lo-reg rm) 3) rd))))
<br/>
<br/>
;; Load register with halfword
<br/>
(defmnemonic ldrh (rd rm &amp;optional n) 2
<br/>
  (let ((rd (lo-reg rd)) (rm (lo-reg rm)))
<br/>
    (if (or (integerp n) (null n))
<br/>
        (let ((n (if (null n) 0 (ash n -1))))
<br/>
          (logior #x8800 (ash n 6) (ash rm 3) rd))
<br/>
      (logior #x5a00 (ash (lo-reg n) 6) (ash rm 3) rd))))
<br/>
<br/>
;; Load register with byte
<br/>
(defmnemonic ldrb (rd rm &amp;optional n) 2
<br/>
  (let ((rd (lo-reg rd)) (rm (lo-reg rm)))
<br/>
    (if (or (integerp n) (null n))
<br/>
        (let ((n (if (null n) 0 n)))
<br/>
          (logior #x7800 (ash n 6) (ash rm 3) rd))
<br/>
      (logior #x5c00 (ash (lo-reg n) 6) (ash rm 3) rd))))
<br/>
<br/>
;; Store register
<br/>
(defmnemonic str (rd rm &amp;optional n) 2
<br/>
  (let ((rd (lo-reg rd)))
<br/>
    (if (or (integerp n) (null n))
<br/>
        (let ((n (if (null n) 0 (ash n -2))))
<br/>
          (case rm
<br/>
            (sp        (logior #x9000 (ash rd 8) n))
<br/>
            (otherwise (logior #x6000 (ash n 6) (ash (lo-reg rm) 3) rd))))
<br/>
      (logior #x5000 (ash (lo-reg n) 6) (ash (lo-reg rm) 3) rd))))
<br/>
  
<br/>
;; Store halfword register
<br/>
(defmnemonic strh (rd rm &amp;optional n) 2
<br/>
  (let ((rd (lo-reg rd)) (rm (lo-reg rm)))
<br/>
    (if (or (integerp n) (null n))
<br/>
        (let ((n (if (null n) 0 (ash n -1))))
<br/>
          (logior #x8000 (ash n 6) (ash rm 3) rd))
<br/>
      (logior #x5200 (ash (lo-reg n) 6) (ash rm 3) rd))))
<br/>
<br/>
;; Load byte register
<br/>
(defmnemonic strb (rd rm &amp;optional n) 2
<br/>
  (let ((rd (lo-reg rd)) (rm (lo-reg rm)))
<br/>
    (if (or (integerp n) (null n))
<br/>
        (let ((n (if (null n) 0 n)))
<br/>
          (logior #x7000 (ash n 6) (ash rm 3) rd))
<br/>
      (logior #x5400 (ash (lo-reg n) 6) (ash rm 3) rd))))
<br/>
<br/>
;; Software interrupt
<br/>
(defmnemonic swi (n) 2
<br/>
  (if (or (&gt;= n #x100) (not (plusp n)))
<br/>
      (error "Invalid software interrupt ~A" n)
<br/>
    (logior #xdf n)))
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
And for usage (this is snipped from the source code to the Dragon BASIC compiler):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">;;; Dragon BASIC API for the GBA
<br/>
;;;
<br/>
;;; Created 9/16/04 by Jeff Massung
<br/>
;;;
<br/>
;;; DBAPI.LISP
<br/>
;;;
<br/>
<br/>
(load "thumb.lisp")
<br/>
<br/>
(defparameter *api* (make-hash-table))
<br/>
<br/>
;; Structure that holds the adress and arguments to an API function
<br/>
(defstruct api address arglist bytes)
<br/>
<br/>
;; Define a new assembler api function
<br/>
(defmacro defapi (symbol args &amp;body body)
<br/>
  (setf (gethash symbol *api*) 
<br/>
        (make-api :bytes (apply #'assemble-form body)
<br/>
                  :arglist args)))
<br/>
<br/>
;; Compile all the API functions into a stream
<br/>
(defun compile-api ()
<br/>
  (maphash #'(lambda (key value)
<br/>
               (declare (ignore key))
<br/>
               (setf (api-address value) (file-position *bank*))
<br/>
               (compile-asm (api-bytes value)))
<br/>
           *api*))
<br/>
<br/>
;; Clear the API function table
<br/>
(clrhash *api*)
<br/>
<br/>
;; Set the current graphics mode (0-5)
<br/>
(defapi graphics (mode :integer)
<br/>
  (mov r2 4)
<br/>
  (cmp r0 3)
<br/>
  (blt :t1)
<br/>
  (lsl r1 r2 8)
<br/>
  (add r0 r0 r1)
<br/>
  :t1
<br/>
  (lsl r1 r2 24)
<br/>
  (strh r0 r1)
<br/>
  (pop r0)
<br/>
  (bx r14))
<br/>
<br/>
;; Wait for the next vertical blank
<br/>
(defapi vblank ()
<br/>
  (mov r2 4)
<br/>
  (lsl r2 r2 24)
<br/>
  :t1
<br/>
  (ldrh r1 r2 6)
<br/>
  (cmp r1 160)
<br/>
  (bne :t1)
<br/>
  (bx r14))
<br/>
<br/>
;; Get the current keypad state (1=pressed)
<br/>
(defapi keys ()
<br/>
  (mov r2 4)
<br/>
  (lsl r2 r2 24)
<br/>
  (push r0)
<br/>
  (add r2 130)
<br/>
  (ldrh r0 r2)
<br/>
  (mvn r0 r0)
<br/>
  (bx r14))
<br/>
<br/>
;; Check to see if a keypad button is pressed (1=pressed)
<br/>
(defapi key (mask :integer)
<br/>
  (mov r2 4)
<br/>
  (lsl r2 r2 24)
<br/>
  (add r2 130)
<br/>
  (ldrh r1 r2)
<br/>
  (mvn r1 r1)
<br/>
  (and r0 r1)
<br/>
  (bx r14))
<br/>
<br/>
;; Returns true if a button was just hit
<br/>
(defapi keyhit (mask :integer prev-state :integer)
<br/>
  (mov r2 4)
<br/>
  (lsl r2 r2 24)
<br/>
  (add r2 130)
<br/>
  (ldrh r1 r2)
<br/>
  (mvn r1 r1)
<br/>
  (and r1 r0)
<br/>
  (pop r2)
<br/>
  (and r2 r0)
<br/>
  (cmp r1 r2)
<br/>
  (sbc r0 r0)
<br/>
  (mvn r0 r0)
<br/>
  (bx r14))
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
As you see.. Dragon BASIC is written in a combination of Lisp and Forth. So, next time, don't drag down the language -- meaning Lisp or Forth -- please ;)
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"><br/><br/>Last edited by jma on Tue Sep 28, 2004 10:13 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#26910 - SmileyDude - Tue Sep 28, 2004 10:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">Yes, yes, thank you. This is precisely what I think whenever I hear programmers upset at this kind of behaviour. Multiple inclusion, linker errors due to multiple symbol generation, problematic macro expansion... everyone is so quick to blame the frailty of the language for these problems when the only real problem is ignorance of what the directives they're using actually do.</td> </tr></table><span class="postbody">
<br/>
<br/>
Ahh, so I bet that you sneer at people who don't code in assembly language because they consider it too complex.  When in reality, it's just their ignorance of what the instructions actually do.
<br/>
<br/>
Look, any good C programmer knows how to use the C preprocessor correctly.  Just like a good assembly programmer knows how to use all of the instructions that are available, and a good Lisp programmer knows how to do that Lisp stuff (*GRIN*).
<br/>
<br/>
But, the C preprocessor is fragile.  Even with quite a bit of C/C++ experience behind me, I still end up making the occasional screw-up that ends up going back to a #define someplace where I didn't surround one of the parameters in ()s or something similar to that.
<br/>
<br/>
Just because it does what it was originally intended to do, doesn't mean that it does what I need/want it to do.<br/>_________________<br/>dennis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26912 - poslundc - Tue Sep 28, 2004 10:19 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>SmileyDude wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote">Yes, yes, thank you. This is precisely what I think whenever I hear programmers upset at this kind of behaviour. Multiple inclusion, linker errors due to multiple symbol generation, problematic macro expansion... everyone is so quick to blame the frailty of the language for these problems when the only real problem is ignorance of what the directives they're using actually do.</td> </tr></table><span class="postbody">
<br/>
<br/>
Ahh, so I bet that you sneer at people who don't code in assembly language because they consider it too complex.  When in reality, it's just their ignorance of what the instructions actually do.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
No, I sneer at people who code in assembly language and use the add instruction to load data into a register. If you're going to attack my character at least get your analogies straight.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Look, any good C programmer knows how to use the C preprocessor correctly.  Just like a good assembly programmer knows how to use all of the instructions that are available, and a good Lisp programmer knows how to do that Lisp stuff (*GRIN*).
<br/>
<br/>
But, the C preprocessor is fragile.  Even with quite a bit of C/C++ experience behind me, I still end up making the occasional screw-up that ends up going back to a #define someplace where I didn't surround one of the parameters in ()s or something similar to that.</td> </tr></table><span class="postbody">
<br/>
<br/>
And sometimes I screw up when performing a search and replace (which is what the preprocessor basically does with macros). I don't blame the search and replace function for it when I do, though.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Just because it does what it was originally intended to do, doesn't mean that it does what I need/want it to do.</td> </tr></table><span class="postbody">
<br/>
<br/>
Then why are you using it for that purpose? I don't complain that the search/replace function in my text editor doesn't correct my spelling errors.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26915 - sajiimori - Tue Sep 28, 2004 10:35 pm</h4>
    <div class="postbody"><span class="postbody">tepples meant a program that compiles Lisp to Thumb.  I don't think he was dragging down the language, either.  In fact, it says something positive about Lisp if people would use it on GBA given a good, free implementation.
<br/>
<br/>
Edit: Can we sum up the preprocessor debate by saying that we sometimes wish we didn't have to rely on a simple text replacement tool to do things that could use a bit more power?  While you could simply avoid all problems that are hindered by the simplicity of the preprocessor, most of us try to twist to fit our problems from time to time.
<br/>
<br/>
Another alternative is to use a more powerful language from the start.  At that point one might complain: "I wish C were more powerful so I wouldn't have to use something else, because C is fast and it has good, free implementations, and a wide user base."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26922 - sgeos - Wed Sep 29, 2004 6:51 am</h4>
    <div class="postbody"><span class="postbody">IMHO, enclosing a macro in do{}while(0) the "correct" way of handling multi line macros.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define   DMA3(dst, src, cnt, mode)   \
<br/>
   do {            \
<br/>
      REG_DMA3SAD = (u32) src;   \
<br/>
      REG_DMA3DAD = (u32) dst;   \
<br/>
      REG_DMA3CNT = (cnt | mode);   \
<br/>
   while (0)</td> </tr></table><span class="postbody">
<br/>
When this is expanded, the trailing semicolon will finish off the while(0).  (Redundant semicolons cause warnings on some compilers.)  The whole block will be treated as a single statement.
<br/>
<br/>
Commas are less good way of setting up multiline macros:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define   DMA3(dst, src, cnt, mode)   \
<br/>
   REG_DMA3SAD = (u32) src,   \
<br/>
   REG_DMA3DAD = (u32) dst,   \
<br/>
   REG_DMA3CNT = (cnt | mode)</td> </tr></table><span class="postbody">
<br/>
Note the lack of semicolons.  The user supplies the last one.  (The only one in this case.)
<br/>
<br/>
NOTE:  The last line of your macro does not need or want a backslash followed by a newline.  It is harmless if a blank line follows your macro.  It is <span style="font-weight: bold">not good</span> if the following line not blank.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26926 - Cearn - Wed Sep 29, 2004 10:28 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">IMHO, enclosing a macro in do{}while(0) the "correct" way of handling multi line macros.
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define   DMA3(dst, src, cnt, mode)   \
<br/>
   do {            \
<br/>
      REG_DMA3SAD = (u32) src;   \
<br/>
      REG_DMA3DAD = (u32) dst;   \
<br/>
      REG_DMA3CNT = (cnt | mode);   \
<br/>
   while (0)</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
Except, of course, in this case you'd never get it compiled because you missed the closing curly bracket :P. And before anyone complains about me fussing about a minor typo, remember that because macros will only be 'compiled' when used, this kind of mistake can lay dormant for a good while. You're lucky to get an error message if you finally do use this macro, unlike the macro that started this thread which messes up at runtime.
<br/>
Another problem might be extra spaces behind the backslashes. GCC gives a warning about this so you know there's something wrong, but I think I've seen such a thing seriously mess up the macro in the past.
<br/>
Macros should probably come with "CAVEAT EMPTOR" stamped on them in big angry red letters.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26929 - jma - Wed Sep 29, 2004 4:12 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">IMHO, enclosing a macro in do{}while(0) the "correct" way of handling multi line macros.</td> </tr></table><span class="postbody">
<br/>
Yes, but for a different reason that trailing semi-colons. Most compilers won't complain about: ";;;;" in code somewhere -- they are just empty statements -- like multiple newlines. But consider the following code with and without the <span style="font-weight: bold">do { } while(0)</span> in the macro:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">if (x &gt; y) DMA3(oam_copy, OAM, 0x100, 32);
<br/>
else do_something_else();</td> </tr></table><span class="postbody">
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#26941 - tepples - Wed Sep 29, 2004 9:55 pm</h4>
    <div class="postbody"><span class="postbody">The (statement, statement, statement, value) trick given by sgeos works for simple statements in ANSI C, but 1. make sure you put parentheses around the whole thing, or it will take up multiple arguments to a function, and 2. don't try it with switch or while inside the parentheses.
<br/>
<br/>
Because almost all GBA programmers are using GCC, I'd suggest using <a class="postlink" href="http://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html" target="_blank">GCC's extensions to the C language</a> and documenting that your code uses such extensions. Favorite extensions include <ul><li>static inline </li><li>inner functions </li><li><a class="postlink" href="http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs" target="_blank">compound statement expressions</a>
<br/>
({ statement; statement; statement; value; })
<br/>
which is similar to what sgeos proposed but allows local variables and if, while, do, and switch blocks </li></ul>
<br/>
<br/>
And yes, jma, by "Lisp compiler" I did mean a free compiler that takes Lisp source code as input and outputs either Thumb assembly code or Thumb object code. Such a compiler would attract a lot of Lisp coders to ARM platforms. In fact, I'd like to see somebody get <a class="postlink" href="http://www.gnu.org/software/gcl/gcl.html" target="_blank">GCL</a> working on the GBA if it's possible.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
