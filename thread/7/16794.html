<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Need help rearranging an array - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > Need help rearranging an array</h2>
<div id="posts">
<div class="post">
    <h4>#169683 - DiscoStew - Wed Jul 29, 2009 6:30 pm</h4>
    <div class="postbody"><span class="postbody">So I have this array that I want to reorganize. It currently looks like this (the 2D representation, then the 1D representation)...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> ___________    ___________________________________________________________
<br/>
| 1 | 6 | B |  | 1 | 6 | B | 2 | 7 | C | 3 | 8 | D | 4 | 9 | E | 5 | A | F |
<br/>
| 2 | 7 | C |   -----------------------------------------------------------
<br/>
| 3 | 8 | D |
<br/>
| 4 | 9 | E |
<br/>
| 5 | A | F |
<br/>
 ----------- </td> </tr></table><span class="postbody">
<br/>
<br/>
...and what I want to do is rearrange it to look like this...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code"> ___________    ___________________________________________________________
<br/>
| 1 | 2 | 3 |  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
<br/>
| 4 | 5 | 6 |   -----------------------------------------------------------
<br/>
| 7 | 8 | 9 |
<br/>
| A | B | C |
<br/>
| D | E | F |
<br/>
 ----------- </td> </tr></table><span class="postbody">
<br/>
<br/>
The array can be of different sizes (and the number of rows and columns are known for each). While it seems like something simple with the use of allocating a new array and copying to there (and de-allocating the old), I'm using arrays far larger that the example here, and am trying not to go about with that method (mainly because I'm trying to prevent excessive gaps in the heap of Main RAM).
<br/>
<br/>
Would anyone have any info pertaining to this type of restructuring? Thx in advance.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169684 - Dwedit - Wed Jul 29, 2009 8:01 pm</h4>
    <div class="postbody"><span class="postbody">Look for "in place matrix transpose", there are algorithms for that.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169692 - Pete_Lockwood - Thu Jul 30, 2009 1:48 pm</h4>
    <div class="postbody"><span class="postbody">Did you find something for this?
<br/>
<br/>
Out of interest, is this transformation something you need to do many times at high speed for a large number of equally dimensioned objects?  Or few times?  Or small number of objects?  Or lots of differently sized objects?  Or speed isn't of the essence?
<br/>
<br/>
It's trivial to auto-generate a LUT of a size slightly below w*h/2 for a rectangular array or w*h/4 for a square, which would give you a very fast way to achieve the translation but wouldn't be so practical if you have lots of objects that are different shapes.
<br/>
<br/>
It also feels intuitively as though there should be a method of doing this that would use probably at most 'w' temporary elements, but not knowing your underlying requirements I didn't look further into it.
<br/>
<br/>
I know the problem has been solved by others but it's kinda interesting to think about..<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169693 - sgeos - Thu Jul 30, 2009 3:25 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Pete_Lockwood wrote:</b></span></td> </tr> <tr> <td class="quote">I know the problem has been solved by others but it's kinda interesting to think about..</td> </tr></table><span class="postbody">
<br/>
But, as you mentioned, we don't know what the problem is exactly, so the best answer can not be given.
<br/>
<br/>
You need to sort your array.  How depends on exactly what you are doing.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169695 - Pete_Lockwood - Thu Jul 30, 2009 4:31 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">But, as you mentioned, we don't know what the problem is exactly, so the best answer can not be given.</td> </tr></table><span class="postbody">
<br/>
<br/>
Hence my questions :)<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169696 - DiscoStew - Thu Jul 30, 2009 4:50 pm</h4>
    <div class="postbody"><span class="postbody">What I wanted to do was what Dwedit suggested, which is in place matrix transposing, or in other words, swapping columns to rows in a rectangular matrix. Unfortunately, when I searched for something like that online, I mostly got examples that involved copying to another array.
<br/>
<br/>
The size of my arrays have been known to range from a few kBytes to upwards of almost 600kBytes. It's all part of data loading, so speed isn't necessarily an issue.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169697 - Miked0801 - Thu Jul 30, 2009 5:18 pm</h4>
    <div class="postbody"><span class="postbody">Wow, that is an interesting problem.  My first attempt (fail) is here
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
    int matrix[5][3] = {{0x1,0x6,0xB},{0x2,0x7,0xC},{0x3,0x8,0xD},{0x4,0x9,0xE},{0x5,0xA,0xF}};
<br/>
<br/>
    int (*matrixDest)[3][5];
<br/>
    (int *)matrixDest = (int *)(&amp;matrix);
<br/>
<br/>
    for(int i=0; i&lt;5; i++)
<br/>
    {
<br/>
        for(int j=0; j&lt;3; j++)
<br/>
            {
<br/>
                int temp = (*matrixDest)[j][i];
<br/>
                (*matrixDest)[j][i] = matrix[i][j];
<br/>
                matrix[i][j] = temp;
<br/>
            }
<br/>
    }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Works until I double assign something after a swap.  Hmm.  Thinking...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169698 - Miked0801 - Thu Jul 30, 2009 5:37 pm</h4>
    <div class="postbody"><span class="postbody">A huge LUT would make it easier, but with 600k arrays, that becomes a problem on GBA/DS.  But if it's done on PC.  Hmmm.
<br/>
<br/>
Ok, I've got a solution, but it needs a little RAM.  Can you afford 1 bit per array element of temp memory?  It may need a lot less, but my second idea should work.  Give me a few to code and test it...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169699 - Cearn - Thu Jul 30, 2009 6:41 pm</h4>
    <div class="postbody"><span class="postbody">I think I may have a solution that needs one row of temp space and works in W*W*H time, but I'm really thinking out loud here.
<br/>
<br/>
Example with Width W=5, Height H=3:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">0 1 2
<br/>
3 4 5     0 3 6 9 C
<br/>
6 7 8  -&gt; 1 4 7 A D
<br/>
9 A B     2 5 8 B E
<br/>
C D E
<br/>
<br/>
That is:
<br/>
<br/>
From 
<br/>
    0 1 2 3 4 5 6 7 8 9 A B C D E
<br/>
To 
<br/>
    0 3 6 9 C 1 4 7 A D 2 5 8 B E
<br/>
<br/>
<br/>
Algorithm:
<br/>
<br/>
0 1 2 3 4 5 6 7 8 9 A B C D E          Start.
<br/>
0 3 6 9 C                              Gather Col-0 in temp array (offset=3) ; H time
<br/>
          1 2 4 5 7 8 A B D E          Compress other elements ; W*(H-1) time
<br/>
0 3 6 9 C 1 2 4 5 7 8 A B D E          Insert temp row. Col-0 done.
<br/>
          1 4 7 A D                    Col-1 to temp (offset=2) ; H time
<br/>
                    2 5 8 B E          Compress other elements ; (W-1)*(H-2) time
<br/>
          1 4 7 A D 2 5 8 B E          Insert temp. Col-1 done. Col-2 as well because 
<br/>
                                       it's the last one.
<br/>
</td> </tr></table><span class="postbody">
<br/>
It's still kinda wasteful, but it should be fairly easy to implement.
<br/>
<br/>
Are you sure the transposition is necessary though? You can basically swap the order of matrix-traversal by swapping x and y coordinates. Cache might not like it, but it's an easy solution. Or you could pre-transpose everything before the NDS ever gets its hands on it.
<br/>
<br/>
What are the number of elements we're talking about here? (width and height, not just total matrix size)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169700 - elhobbs - Thu Jul 30, 2009 7:01 pm</h4>
    <div class="postbody"><span class="postbody">what about iterating over all of the elements in the array in sequential order from 0 to widthxlength and calculating the index values in the original array and the transposed array? if the indexes are different then swap
<br/>
<br/>
if index is the sequential item from 0 to total count (in this example 15)
<br/>
if the original array is 3 columns by 5 rows then
<br/>
<br/>
original
<br/>
index0 = index/3
<br/>
index1 = index % 3
<br/>
<br/>
if the destination array is 5 x 3
<br/>
new
<br/>
index0 = index%3
<br/>
index1 = index/3</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169701 - Karatorian - Thu Jul 30, 2009 7:25 pm</h4>
    <div class="postbody"><span class="postbody">Ok, maybe I'm crazy, but isn't this the sort of thing you should be preproccessing at build time? Or is that why you're asking?
<br/>
<br/>
Or do you need the array both ways? If you need it both ways, it seems like it'd be better to use some method to share the storage space and "virtualize" the indexing for the lesser used case.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169702 - Miked0801 - Thu Jul 30, 2009 7:40 pm</h4>
    <div class="postbody"><span class="postbody">Elhobbs's solution is very close to mine.  The problem is double swapping indexes.   To solve it, you take a start location and put it in a temp.  You go to it's final destination and swap with the temp.  you then go to the new value's final location and swap again.  do while you haven't visited that location (hence the 1-bit visited values).  Start walking up the array until you find a value not swapped and repeat until complete.  For the 5x3 example, 0,0 swaps with 0,0 and you're done as you've already swapped the target.  The next of 1,0 swaps with 0,1 -&gt; 1,2 -&gt;3,2 -&gt;3,0 -&gt;1,0 which is already swapped so you are done.  0,2 also swaps out 6 values which just leaves 2,1 and 4,2 - both which swap themselves.
<br/>
<br/>
I've run out of time to debug my code solution, but the above algorithm is my idea.  It only takes 1 element of storage, a few counters, and the bool / bit array to know where you've visited.  It could also be there there is a deeper pattern with visiting such that you always know that there are either no swaps or (Major Axis size) + 1 swaps needed to move stuff - which would make storage trivial.  I'm not sure if that pattern holds outside of 5x3 and 4x4 though.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169704 - Miked0801 - Thu Jul 30, 2009 7:45 pm</h4>
    <div class="postbody"><span class="postbody">Just realized that were basically talking about a sort here (I'm slow I know.)  As such, sorting via the 'new' index order should be a matter of calling any canned sort and going from there.  My sort runs o(N) time (wee!) and requires N swaps.  Pretty good.  Any sort would do though if you didn't caree about run time much.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169705 - Pete_Lockwood - Thu Jul 30, 2009 7:59 pm</h4>
    <div class="postbody"><span class="postbody">To sort by the index, don't you need w*h extra storage elements to hold the index that you'll sort (which I thought was outside the scope of the request) - and you can find better ways to do it because your array isn't random unsorted data.
<br/>
<br/>
<br/>
Separate thought: looks rather like any translation you make at the beginning of the array can also be made, mirrored, at the end of the array.<br/>_________________<br/>It's not an illusion, it just looks like one.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169706 - Miked0801 - Thu Jul 30, 2009 8:40 pm</h4>
    <div class="postbody"><span class="postbody">There are many in-place sorts.  Shell sort comes to mind for efficiency.  A properly coded QSort will also not eat too much space up.  But because we have good preknowledge, we can get away with linear time and no big overhead.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169708 - elhobbs - Thu Jul 30, 2009 9:55 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">Just realized that were basically talking about a sort here (I'm slow I know.)  As such, sorting via the 'new' index order should be a matter of calling any canned sort and going from there.  My sort runs o(N) time (wee!) and requires N swaps.  Pretty good.  Any sort would do though if you didn't caree about run time much.</td> </tr></table><span class="postbody">removed to avoid embarassing myself</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169711 - Miked0801 - Thu Jul 30, 2009 11:42 pm</h4>
    <div class="postbody"><span class="postbody">Bah - I put my first, very failed attempt up for fun.  No harm in showing ideas :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169712 - keldon - Fri Jul 31, 2009 12:09 am</h4>
    <div class="postbody"><span class="postbody">This is a little tricky if you don't have any memory to work with because of the whole "double assign something after a swap" issue. So what I have done is made the code work out where that swap has been moved to.
<br/>
<br/>
I have not compiled or tested this, it's more of me writing code to communicate my thinking of it. Although do bear in mind it's way past my bed-time so I'm just going to hope an explanation fairy will pop up and explain the in-between bits :D
<br/>
<br/>
<span style="font-weight: bold">Edit:</span> I can confirm that this compiles, but does not work; result!
<br/>
<span style="font-weight: bold">Edit:</span> I have fixed it, and <span style="font-weight: bold">IT WORKS!</span> ... please note that I do not typically code like this, that struct was ineffective and added nothing to the code.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">typedef unsigned char u8;
<br/>
typedef unsigned long u32;
<br/>
<br/>
// ----
<br/>
// Function Declarations
<br/>
// ----
<br/>
<br/>
template&lt;class TYPE&gt;
<br/>
void swap( TYPE &amp;a, TYPE &amp;b );
<br/>
<br/>
template&lt;class TYPE&gt; 
<br/>
void swap( TYPE *array, size_t width, u32 source_x, u32 source_y, u32 dest_x, u32 dest_y );
<br/>
<br/>
u32 calculate_source_idx_from_dest_idx( size_t width, size_t height, u32 dest_idx );
<br/>
<br/>
void calculate_source_position( size_t width, size_t height, u32 dest_x, u32 dest_y, u32 &amp;source_x, u32 &amp;source_y );
<br/>
<br/>
template&lt;class TYPE&gt; 
<br/>
void reorganize_array( TYPE *array, size_t width, size_t height );
<br/>
<br/>
<br/>
<br/>
// ----
<br/>
// Methods
<br/>
// ----
<br/>
<br/>
<br/>
template&lt;class TYPE&gt;
<br/>
void swap( TYPE &amp;a, TYPE &amp;b )
<br/>
{
<br/>
   TYPE tmp = a;
<br/>
   a = b;
<br/>
   b = tmp;
<br/>
} // swap
<br/>
<br/>
// ---- 
<br/>
// Swap array elements 
<br/>
// ---- 
<br/>
template&lt;class TYPE&gt; 
<br/>
void swap( TYPE *array, size_t width, u32 source_x, u32 source_y, u32 dest_x, u32 dest_y ) 
<br/>
{ 
<br/>
   swap( array[ source_x + ( source_y * width ) ], array[ dest_x + ( dest_y * width ) ] ); 
<br/>
} // swap 
<br/>
<br/>
<br/>
// ---- 
<br/>
// This method reorganizes an array according to the problem as defined in the 
<br/>
// following URL (http://forum.gbadev.org/viewtopic.php?p=169683#169683) 
<br/>
// ---- 
<br/>
template&lt;class TYPE&gt; 
<br/>
void reorganize_array( TYPE *array, size_t width, size_t height ) 
<br/>
{ 
<br/>
   for( u32 dest_y = 0; dest_y &lt; static_cast&lt;u32&gt;(height); ++dest_y )
<br/>
   {  
<br/>
      for( u32 dest_x = 0; dest_x &lt; static_cast&lt;u32&gt;(width); ++dest_x ) 
<br/>
      { 
<br/>
         u32 source_x, source_y; 
<br/>
         calculate_source_position( width, height, dest_x, dest_y, source_x, source_y ); 
<br/>
         swap( array, width, source_x, source_y, dest_x, dest_y ); 
<br/>
      } 
<br/>
   } 
<br/>
} // reorganize_array 
<br/>
<br/>
<br/>
// ---- 
<br/>
// Calculates the source position based on the destination. This works by 
<br/>
// identifying the source array index that corresponds to a destination index. 
<br/>
// However if the source index is found to be less than the destination index 
<br/>
// then the algorithm knows that that element has been swapped, and then 
<br/>
// searches for where that index was swapped from. 
<br/>
// ---- 
<br/>
void calculate_source_position( size_t width, size_t height, u32 dest_x, u32 dest_y, u32 &amp;source_x, u32 &amp;source_y ) 
<br/>
{ 
<br/>
   u32 dest_idx = ( dest_x + dest_y * static_cast&lt;u32&gt;( width ) ); 
<br/>
<br/>
   u32 source_idx = dest_idx; 
<br/>
<br/>
   do 
<br/>
   { 
<br/>
      source_idx = calculate_source_idx_from_dest_idx( width, height, source_idx ); 
<br/>
   } 
<br/>
   while( dest_idx &gt; source_idx ); 
<br/>
<br/>
   source_x = source_idx % width;
<br/>
   source_y = source_idx / width;
<br/>
<br/>
} // calculate_source_position 
<br/>
<br/>
<br/>
u32 calculate_source_idx_from_dest_idx( size_t width, size_t height, u32 dest_idx ) 
<br/>
{ 
<br/>
   u32 source_x = dest_idx / static_cast&lt;u32&gt;( height ); 
<br/>
   u32 source_y = dest_idx % static_cast&lt;u32&gt;( height ); 
<br/>
<br/>
   return source_x + ( source_y * static_cast&lt;u32&gt;( width ) ); 
<br/>
} // calculate_source_idx_from_dest_idx
<br/>
<br/>
<br/>
typedef struct ARRAY_FORMAT
<br/>
{
<br/>
   size_t width;
<br/>
   size_t height;
<br/>
}
<br/>
ARRAY_FORMAT;
<br/>
<br/>
<br/>
template&lt;class T&gt;
<br/>
void fill_source_array( T *array, const ARRAY_FORMAT &amp;array_format )
<br/>
{
<br/>
   if( array == NULL ) return;
<br/>
<br/>
   for( u32 x = 0; x &lt; static_cast&lt;u32&gt;( array_format.width ); ++x )
<br/>
   {
<br/>
      for( u32 y = 0; y &lt; static_cast&lt;u32&gt;( array_format.height); ++y )
<br/>
      {
<br/>
         array[ x + (y * array_format.width) ] = static_cast&lt;T&gt;(y + (x * static_cast&lt;u32&gt;(array_format.height)) );
<br/>
      }
<br/>
   }
<br/>
} // fill_source_array
<br/>
<br/>
<br/>
template&lt;class T&gt;
<br/>
void print_array( T *arr, const ARRAY_FORMAT &amp;array_format )
<br/>
{
<br/>
   printf( "&gt;&gt;&gt; Printing array\n" );
<br/>
   
<br/>
   for( int i = 0; i &lt; static_cast&lt;int&gt;( array_format.width * array_format.height); ++i )
<br/>
   {
<br/>
      printf( "%d, ", arr[i] );
<br/>
   }
<br/>
   
<br/>
   printf( "\n&lt;&lt;&lt;\n\n" );
<br/>
} // print_array
<br/>
<br/>
<br/>
void test_array_transpose( size_t width, size_t height )
<br/>
{
<br/>
   if( (width * height) == 0 ) return;
<br/>
<br/>
   ARRAY_FORMAT array_format = { width, height };
<br/>
   
<br/>
   int *t_array = new int[ width * height ];
<br/>
   
<br/>
   fill_source_array( t_array, array_format );
<br/>
   print_array( t_array, array_format );
<br/>
   
<br/>
   reorganize_array( t_array, array_format.width, array_format.height );
<br/>
   print_array( t_array, array_format );
<br/>
   
<br/>
   delete []t_array;
<br/>
   
<br/>
   return;
<br/>
   
<br/>
} // test_array_transpose
<br/>
<br/>
<br/>
<br/>
int _tmain(int argc, _TCHAR* argv[])
<br/>
{
<br/>
   test_array_transpose( 32, 44 );
<br/>
   (void) getchar();
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169718 - keldon - Fri Jul 31, 2009 10:03 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">...
<br/>
I've run out of time to debug my code solution, but the above algorithm is my idea.  It only takes 1 element of storage, a few counters, and the bool / bit array to know where you've visited.  It could also be there there is a deeper pattern with visiting such that you always know that there are either no swaps or (Major Axis size) + 1 swaps needed to move stuff - which would make storage trivial.  I'm not sure if that pattern holds outside of 5x3 and 4x4 though ...</td> </tr></table><span class="postbody">
<br/>
<br/>
That would not work because numbers can be swapped more than once. Even with the example given the source 6 is swapped for the two, and then again when placing the fourth as it is in the way. You could add a check into my code to count this.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169719 - Dwedit - Fri Jul 31, 2009 2:05 pm</h4>
    <div class="postbody"><span class="postbody">People actually use Size_T and Static Cast?  o_O<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169730 - keldon - Fri Jul 31, 2009 8:49 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Dwedit wrote:</b></span></td> </tr> <tr> <td class="quote">People actually use Size_T and Static Cast?  o_O</td> </tr></table><span class="postbody">
<br/>
<br/>
Don't act like you've never done (or been a witness to) anything like that before. Besides, it's an acquired taste &lt;_&lt;</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169784 - Miked0801 - Mon Aug 03, 2009 5:56 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">...
<br/>
I've run out of time to debug my code solution, but the above algorithm is my idea.  It only takes 1 element of storage, a few counters, and the bool / bit array to know where you've visited.  It could also be there there is a deeper pattern with visiting such that you always know that there are either no swaps or (Major Axis size) + 1 swaps needed to move stuff - which would make storage trivial.  I'm not sure if that pattern holds outside of 5x3 and 4x4 though ...</td> </tr></table><span class="postbody">
<br/>
<br/>
That would not work because numbers can be swapped more than once. Even with the example given the source 6 is swapped for the two, and then again when placing the fourth as it is in the way. You could add a check into my code to count this.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
My bool array was there to prevent this - read teh array before seapping.  If true, go to next number.  
<br/>
<br/>
This is a very fun problem :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169807 - keldon - Tue Aug 04, 2009 1:55 pm</h4>
    <div class="postbody"><span class="postbody">It has just occurred to me that this algorithm efficiently transforms between interleaved and non-interleaved data streams. Interesting!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169808 - sgeos - Tue Aug 04, 2009 3:03 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>keldon wrote:</b></span></td> </tr> <tr> <td class="quote">It has just occurred to me that this algorithm efficiently transforms between interleaved and non-interleaved data streams. Interesting!</td> </tr></table><span class="postbody">
<br/>
This was the original goal.  Half of solving a problem is properly defining it.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169832 - DiscoStew - Wed Aug 05, 2009 7:34 pm</h4>
    <div class="postbody"><span class="postbody">Thanks everyone for your help with this problem. I didn't want to create an entirely new array to copy to because of memory fragmentation, and I didn't want to restructure the entire thing externally because I wanted to keep the data in it's purest form.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169834 - keldon - Wed Aug 05, 2009 8:55 pm</h4>
    <div class="postbody"><span class="postbody">Hi DS, how was my implementation for you? It fits your requirements in regards to memory usage (i.e. it does not allocate new memory, or copy to a new destination).
<br/>
<br/>
Benchmarks for 600k (744 * 744)
<br/>
- 600k swaps
<br/>
- 900k indirections
<br/>
<br/>
I have also written <span style="font-weight: bold">reorganize_array()</span> as a template method. I'm sure this can all be optimized heavily, for example if you know your sizes before hand then that can be a template parameter - allowing the compiler to optimize the divides or rewriting the code to use reciprocals, amongst other obvious optimizations.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169839 - DiscoStew - Thu Aug 06, 2009 8:23 pm</h4>
    <div class="postbody"><span class="postbody">Works pretty well, though I was kinda worried about the number of divides used. It's all loading time anyways. One thing I did forget to mention is that while the biggest array I've had was around 600Kbytes, the element size most of the time is 128 bytes, which makes for some good news in that there will be far less swapping of sections to get it all organized.
<br/>
<br/>
However, that is also the bad news, and I've only recently noticed this after knowing more about the format I'm working with and fixing the bugs involved with it. It appears that most of the data I've been working with have a length that is divisible by 128, while the rest are not, which in turn screws up when trying to sort those arrays.
<br/>
<br/>
That's not to say that the algorithm can't be used. It just means that I can only use it on those arrays that have a length divisible by 128 (which is at least 90% of the files I'm using), and the rest will have to be sorted with one of the other non-efficient method, like copying to another array.<br/>_________________<br/><span style="font-weight: bold">DS</span> - It's all about <span style="font-weight: bold">D</span>isco<span style="font-weight: bold">S</span>tew</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
