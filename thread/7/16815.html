<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Some questions about pass by reference - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>C/C++ > Some questions about pass by reference</h2>
<div id="posts">
<div class="post">
    <h4>#169897 - brave_orakio - Tue Aug 11, 2009 4:27 am</h4>
    <div class="postbody"><span class="postbody">Hi guys, I'm confused about this declaration:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const std::string&amp; getCode() const { return _Code; }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Why use the &amp; and the const? Wouldn't it be better to not use the &amp; so as not to need the const? I have to admit that I 'm not too good at C++ advanced declarations. I'm more comfortable with standard C.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169900 - kusma - Tue Aug 11, 2009 9:05 am</h4>
    <div class="postbody"><span class="postbody">A std::string needs to be copied if you don't pass a reference to it. The consts are to maintain const correctness, so that you don't end up modifying a const object by returning a non-const reference to a member that can then be changed.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169902 - brave_orakio - Tue Aug 11, 2009 9:54 am</h4>
    <div class="postbody"><span class="postbody">I see, thank you. But I have to wonder why use a reference in the first place. The code came from an application that isn't on an embedded device<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169903 - keldon - Tue Aug 11, 2009 10:09 am</h4>
    <div class="postbody"><span class="postbody">It's called avoiding premature pessimism. If the string is returned by value then each time the method is called, new memory will be allocated and the text will be copied. There is no benefit in creating a design that forces this to happen each time when all you want to do is read the text.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169910 - brave_orakio - Thu Aug 13, 2009 2:59 am</h4>
    <div class="postbody"><span class="postbody">Ok, then another question whats the point of this?
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void getClass(class*&amp; name) {//function process}
<br/>
</td> </tr></table><span class="postbody">
<br/>
and
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void getClass(class*&amp; name) const {//function process}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Int the first, isn't it technically the same as
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void getClass(class* name)
<br/>
</td> </tr></table><span class="postbody">
<br/>
And in the second function why put the const there?<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169911 - Miked0801 - Thu Aug 13, 2009 6:22 am</h4>
    <div class="postbody"><span class="postbody">The second one makes sure that the function doesn't change anything at all with the class * (which is a little strange - pointers and references don't mix often.)  It tells the compiler not to allow any member value changes nor allow non-const member functions.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169912 - brave_orakio - Thu Aug 13, 2009 7:39 am</h4>
    <div class="postbody"><span class="postbody">Heh, so do you guys see functions like these used often? The one with the mixed *&amp;? If you do, why use it? C++ has a lot of weirdness to it, or maybe I'm just not used to it?<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169913 - Dwedit - Thu Aug 13, 2009 12:55 pm</h4>
    <div class="postbody"><span class="postbody">Stuff like *&amp; you might see in functions dealing with linked lists which need the head pointer, because they might change it.<br/>_________________<br/>"We are merely sprites that dance at the beck and call of our button pressing overlord."</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169914 - sajiimori - Thu Aug 13, 2009 6:04 pm</h4>
    <div class="postbody"><span class="postbody">If a coder on my team wrote *&amp;, I'd tell them to change it and never do it again.
<br/>
<br/>
References should be used for two things:
<br/>
<br/>
  - To transparently optimize pass/return by value (but use const references only!)
<br/>
  - To implement operator* and operator[]
<br/>
<br/>
In all other cases, use pointers or plain values.
<br/>
<br/>
Beginner C++ books often use references "just because".  Don't do that -- it's horribly confusing.  For instance, you can't recognize output parameters at the call site.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169915 - vuurrobin - Thu Aug 13, 2009 10:13 pm</h4>
    <div class="postbody"><span class="postbody">I use *&amp; to deallocate memory using the pointer and then set the pointer to NULL. avoids pointers to invalid memory.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">/**
<br/>
    @brief a template function to deallocate raw memory.
<br/>
<br/>
    this function will deallocate memory and set the pointer to NULL, but it wont call destructors.
<br/>
<br/>
    @param oldMemPointer a referrence to a pointer to the previously allocated memory.
<br/>
*/
<br/>
template &lt;typename T&gt;
<br/>
inline void deallocRawMemNoError(T*&amp; oldMemPointer)//a referrence to a pointer (I hope)
<br/>
{
<br/>
    if(oldMemPointer != NULL)
<br/>
    {
<br/>
        free(oldMemPointer);
<br/>
        oldMemPointer = NULL;
<br/>
    }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">  - To implement operator* and operator[]</td> </tr></table><span class="postbody">
<br/>
and operator= with all it friends (+=, *=, ect)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#169916 - sajiimori - Thu Aug 13, 2009 11:45 pm</h4>
    <div class="postbody"><span class="postbody">That anti-pattern provides next to zero protection against real-world dangling pointers.  It is a feeble band-aid for only the absolute simplest case: basic single ownership.  Even for that simple case, all other copies of the pointer are left dangling, and it doesn't even begin to address memory leaks.
<br/>
<br/>
Speaking of which, don't do manual deletes, where "manual" means "anything that can be forgotten", such as "deallocRawMemNoError".
<br/>
<br/>
For basic single ownership, use boost::scoped_ptr.  If you don't want to use Boost, roll your own scoped_ptr -- it's absolutely trivial.  Choosing the right smart pointers eliminates memory leaks 100%, and dangling pointers 99% (in my experience in a team environment).
<br/>
<br/>
operator= doesn't need non-const references.  It typically accepts its argument by const reference, but even that isn't strictly necessary -- it's just an optimization.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170155 - brave_orakio - Fri Sep 04, 2009 4:45 am</h4>
    <div class="postbody"><span class="postbody">heh, been busy here in the office. what about this?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
Class* varName;
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
the above is a member of a class. in thew deconstructor i see this
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
if(varName)
<br/>
{
<br/>
    delete varName;
<br/>
    varName = 0
<br/>
}
<br/>
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
I'm not sure what happens inside one of the libraries, but the delete makes me think that somewhere a new was used. When exactly do we use new? For C++, I have never understood when.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170164 - Miked0801 - Fri Sep 04, 2009 9:47 pm</h4>
    <div class="postbody"><span class="postbody">New allocates dynamic memory.  Without a new call on varName, that delete would either do 'bad things' if varName was not initialized somwhere to null in a constructor, or nothing at all do to the minimal protection of the if(null) check.
<br/>
<br/>
varName = 0 should warn like crazy about int to pointer conversions as well.
<br/>
<br/>
Now, when you wanted to actually create an instance of varName somewhere to use, you would need to new it first, otherwise again you are doing very bad things with either null or garbage.  It will not exist until new'd because it is only a pointer to a class.  Without the pointer, it would be instantiated as soon as the containing class was created.
<br/>
<br/>
Hope that helps.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170168 - sajiimori - Sat Sep 05, 2009 4:36 am</h4>
    <div class="postbody"><span class="postbody">Literal 0 will implicitly convert to all pointer types.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170169 - Miked0801 - Sat Sep 05, 2009 5:32 am</h4>
    <div class="postbody"><span class="postbody">And you learn something new every day :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170190 - brave_orakio - Mon Sep 07, 2009 2:37 am</h4>
    <div class="postbody"><span class="postbody">I see. So new is very much like malloc() then. I do remember a thread here asking if its ok  to free a new or to delete a malloc. Of course we all know that no is the answer.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170191 - elwing - Mon Sep 07, 2009 6:37 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Literal 0 will implicitly convert to all pointer types.</td> </tr></table><span class="postbody">
<br/>
<br/>
just to emphasis this, here is the NULL definition I'm using from Visual studio 2005 for win32 binary...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#ifdef __cplusplus
<br/>
#define NULL    0
<br/>
#else
<br/>
#define NULL    ((void *)0)
<br/>
#endif
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
not sure if that mean that pointer = 0 will make some warning with the C compiler or not... but at least using a void* cast work without warning for sure</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170227 - keldon - Wed Sep 09, 2009 8:32 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>brave_orakio wrote:</b></span></td> </tr> <tr> <td class="quote">I see. So new is very much like malloc() then. I do remember a thread here asking if its ok  to free a new or to delete a malloc. Of course we all know that no is the answer.</td> </tr></table><span class="postbody">
<br/>
<br/>
New will also make a call to the constructor, e.g.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class MyClass
<br/>
{
<br/>
public:
<br/>
   MyClass( int a, int b ) { (void) a; (void) b; }; // N.b. the (void)a statement is required to compile since &lt;a&gt; and &lt;b&gt; are never used in the function.
<br/>
};
<br/>
<br/>
<br/>
void function( void )
<br/>
{
<br/>
   MyClass *ptr = new MyClass(10, 20);
<br/>
   // Will call new, as well as the MyClass constructor
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
In regards to the ((void *)0), it would not work in C++ as void pointers require explicit casts to a class pointer. E.g.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">void function( void )
<br/>
{
<br/>
   MyClass *ptr;
<br/>
   ptr = (void *)0); // Will fail compilation, as an explicit cast is needed
<br/>
<br/>
   ptr = (MyClass*) ((void *)0); // will compile as it has an explicit ...
<br/>
}</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170241 - brave_orakio - Fri Sep 11, 2009 2:59 am</h4>
    <div class="postbody"><span class="postbody">I see. Malloc() only reserves memory while new actually calls the constructor to create initial values for members. So I guess delete calls the destructor as well.<br/>_________________<br/>help me</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170244 - vuurrobin - Fri Sep 11, 2009 8:14 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>brave_orakio wrote:</b></span></td> </tr> <tr> <td class="quote">I see. Malloc() only reserves memory while new actually calls the constructor to create initial values for members. So I guess delete calls the destructor as well.</td> </tr></table><span class="postbody">
<br/>
<br/>
yes. 
<br/>
<br/>
new and delete will also check for overloaded operator new and delete. but I don't think that many people uses that.<br/>_________________<br/>my blog:
<br/>
<a href="http://vuurrobin.100webcustomers.com/" target="_blank">http://vuurrobin.100webcustomers.com/</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170245 - Miked0801 - Fri Sep 11, 2009 2:39 pm</h4>
    <div class="postbody"><span class="postbody">You'd be surprised...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#170249 - Drovor - Fri Sep 11, 2009 3:24 pm</h4>
    <div class="postbody"><span class="postbody">I've found a new/delete overload immensely useful for my DS application for tracking memory usage.  I found a memory leak with it too. :)
<br/>
<br/>
<a href="http://forum.gbadev.org/viewtopic.php?t=16528" target="_blank">http://forum.gbadev.org/viewtopic.php?t=16528</a></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
