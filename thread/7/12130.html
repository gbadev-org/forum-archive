<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>OOP Principle: Encapsulation - is it reasonable for C++ ? - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. A new forum can be found <a href="https://forum.gbadev.net/" target="_blank">here</a>.</i><br />

        <h2>C/C++ > OOP Principle: Encapsulation - is it reasonable for C++ ?</h2>
<div id="posts">
<div class="post">
    <h4>#114745 - Izhido - Wed Jan 10, 2007 4:36 pm</h4>
    <div class="postbody"><span class="postbody">Hi!
<br/>
<br/>
I was reading this the other day:
<br/>
<br/>
<a href="http://codebetter.com/blogs/raymond.lewallen/articles/59908.aspx" target="_blank">http://codebetter.com/blogs/raymond.lewallen/articles/59908.aspx</a>
<br/>
<br/>
Among other things, it explains that, under the principle of encapsulation, we shouldn't allow any member variables of a class to be public, and access to them should be restricted to "getters" &amp; "setters". 
<br/>
<br/>
Now, everyone around me is always telling me that, while good in theory, in practice using functions to get and/or set member variables will actually make your program (slightly) lengthier and (slightly) slower, these being commodities a C++ developer cannot afford to lose on resource-constrained devices like GBA, DS, PDAs, phones, and many others.
<br/>
<br/>
But, if I understand things correctly, C++ compilers are becoming, day by day, wild beasts of pure, raw optimizing power, right?. Would it be too far-fetched to think that modern C++ compilers are smart enough to strip away pieces of code that, from a machine-language point of view, are not really required, like, say, providing direct access to the memory address of a member variable, instead of forcing a call to the getter/setter functions IF all they do is just get/set the value of that variable?
<br/>
<br/>
I'd be really happy if that would be the case, since that means I can use OOP principles on my applications without remorse of any kind. I could use getters/setters for all external access to my classes's variables, allowing me to both A) not worry about related performance issues, and B) alter the behavior of getters/setters without any hassles, knowing that everything will work OK (or as OK as it could get :) ).
<br/>
<br/>
What would you guys think about it? Am I right to be hopeful about this?
<br/>
<br/>
- Izhido</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114754 - sgeos - Wed Jan 10, 2007 5:11 pm</h4>
    <div class="postbody"><span class="postbody">Maybe, but I'm sure that it depends on what you have.  I don't think that something like this could be optimized:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">interface I
<br/>
{
<br/>
   int getValue(void);
<br/>
}
<br/>
<br/>
class A implements I
<br/>
{
<br/>
   int mValue;
<br/>
<br/>
   int getValue(void)
<br/>
   {
<br/>
      return mValue;
<br/>
   }
<br/>
}
<br/>
<br/>
class B implements I
<br/>
{
<br/>
   int getValue(void)
<br/>
   {
<br/>
      return 0;
<br/>
   }
<br/>
}
<br/>
<br/>
class C extends A
<br/>
{
<br/>
   static int mSharedValue;
<br/>
<br/>
   int getValue(void)
<br/>
   {
<br/>
      int value;
<br/>
      value = Super.getValue() + mSharedValue;
<br/>
      return value;
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
I may or may not have a variable.  A may or may not have just one variable.  B can be optimized if you know you have B.  C does more than get a single variable.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114758 - Izhido - Wed Jan 10, 2007 5:31 pm</h4>
    <div class="postbody"><span class="postbody">Agreed. I would think that, too. But what of this?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
class A
<br/>
{
<br/>
    int X;
<br/>
<br/>
    int getX();
<br/>
    void setX(int NewValue);
<br/>
};
<br/>
<br/>
int X::getX()
<br/>
{
<br/>
   return X;
<br/>
}
<br/>
<br/>
void X::setX(int NewValue)
<br/>
{
<br/>
   X=NewValue;
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Would that be optimizable?
<br/>
<br/>
- Izhido</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114760 - sgeos - Wed Jan 10, 2007 5:40 pm</h4>
    <div class="postbody"><span class="postbody">As long as no sub-class of A overrides getX(), or setX() it is optimizable.  Whether modern compilers catch this particular optimization or not, I don't know.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114767 - Miked0801 - Wed Jan 10, 2007 6:45 pm</h4>
    <div class="postbody"><span class="postbody">Guys, premature optimization of code is a root of pure evil.  It is better to write code that is easier to maintain and modify and then go back and change the 1 or 2 areas that need extra help than too throw away the whole OO idea because it is a bit slower in some circumstances.
<br/>
<br/>
I'll take 1% (or even 10%) slower overall and have code that follows OO maintainability and flexibility.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114776 - tepples - Wed Jan 10, 2007 8:04 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Izhido wrote:</b></span></td> </tr> <tr> <td class="quote">under the principle of encapsulation, we shouldn't allow any member variables of a class to be public, and access to them should be restricted to "getters" &amp; "setters". 
<br/>
<br/>
Now, everyone around me is always telling me that, while good in theory, in practice using functions to get and/or set member variables will actually make your program (slightly) lengthier and (slightly) slower</td> </tr></table><span class="postbody">
<br/>
If they're not virtual, they'll probably be inlined.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Would it be too far-fetched to think that modern C++ compilers are smart enough to strip away pieces of code that, from a machine-language point of view, are not really required, like, say, providing direct access to the memory address of a member variable, instead of forcing a call to the getter/setter functions IF all they do is just get/set the value of that variable?</td> </tr></table><span class="postbody">
<br/>
To an extent, yes, compilers are gaining <a class="postlink" href="http://www.google.com/search?q=automatic%20inlining" target="_blank">automatic inlining</a>.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114780 - DekuTree64 - Wed Jan 10, 2007 8:16 pm</h4>
    <div class="postbody"><span class="postbody">One thing to be aware of is that code defined in one .cpp can never be inlined in another .cpp, because they know nothing of eachother's existence until linker time. So for get/set functions to be inlined, they must be defined in the header:
<br/>
<br/>
Foo.h:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class Foo
<br/>
{
<br/>
public:
<br/>
    int getX() const;
<br/>
    void setX(int value);
<br/>
<br/>
    void printX() const;
<br/>
<br/>
private:
<br/>
    int x;
<br/>
};
<br/>
<br/>
#include "Foo.inl"   // Good habit to keep things organized</td> </tr></table><span class="postbody">
<br/>
<br/>
Foo.inl:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">inline int Foo::getX() const
<br/>
{
<br/>
    return x;
<br/>
}
<br/>
<br/>
inline void Foo::setX(int value)
<br/>
{
<br/>
    x = value;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Foo.cpp:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#include "Foo.h"
<br/>
<br/>
void Foo::printX() const
<br/>
{
<br/>
    cout &lt;&lt; x;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Then when some other file uses Foo, setX and getX will be inlined if the compiler decides it would be advantageous (for such simple functions, this should be always), and printX will never be inlined, because that other file doesn't know what it does.
<br/>
<br/>
One thing I'm curious about though... where does the code from an inline function go if the compiler decides not to inline it? Is a copy made for each file it's called in, or is the linker smart enough to only keep a single copy as if it were defined in a .cpp file in the first place? Difficult to figure out because it has no global symbol in the linker map file.<br/>_________________<br/>___________
<br/>
The best optimization is to do nothing at all.
<br/>
Therefore a fully optimized program doesn't exist.
<br/>
-Deku</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114782 - sajiimori - Wed Jan 10, 2007 8:21 pm</h4>
    <div class="postbody"><span class="postbody">Agreed that inlining works fine in modern compilers.  But when you care about whether something is inlined, check the output.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Now, everyone around me is always telling me that, while good in theory, in practice using functions to get and/or set member variables will actually make your program (slightly) lengthier and (slightly) slower, these being commodities a C++ developer cannot afford to lose on resource-constrained devices like GBA, DS, PDAs, phones, and many others.</td> </tr></table><span class="postbody">
<br/>
I hear statements like this a lot, and I always wonder which <span style="font-style: italic">non</span>-resource-constrained device the author is thinking about.
<br/>
<br/>
<span style="font-style: italic">Every</span> system has limited resources.  Handheld developers seem to forget that console and PC developers do more with their hardware -- it's not as if they're making GBA games for XBox 360 and setting up hammocks around the office for all the relaxation time that results from the lack of resource constraints.
<br/>
<br/>
If you truly believed that you can't afford (slightly) lengthier and (slightly) slower code, you'd be writing everything in assembler.  The reality is that writing it in C makes the object code <span style="font-style: italic">way</span> lengthier and <span style="font-style: italic">way</span> slower than writing in assembler, in the short run.
<br/>
<br/>
But in the long run, the time saved by developing in C (or C++) allows you to explicitly allocate time to optimize portions of the game that need it.  If you're working on a large project with limited time, coding everything in assembler is likely to make your game <span style="font-style: italic">slower</span> because you're wasting time optimizing things that don't need it.
<br/>
<br/>
Every hour of optimization counts -- spend it wisely.  =)</span><span class="gensmall"><br/><br/>Last edited by sajiimori on Wed Jan 10, 2007 8:25 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#114784 - sajiimori - Wed Jan 10, 2007 8:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">One thing I'm curious about though... where does the code from an inline function go if the compiler decides not to inline it?</td> </tr></table><span class="postbody">Most often, I've seen compilers act as if the function was declared 'static' -- each module that calls it will get its own copy.
<br/>
<br/>
It's also possible for compilers to generate a single global copy, which is how non-inlined templatized code typically works these days.  The linker will strip out all the instances after the first one it sees.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114804 - Izhido - Wed Jan 10, 2007 9:19 pm</h4>
    <div class="postbody"><span class="postbody">DekuTree64: AHA! So that's why I keep on seeing ".inl" files all over the place! It seems a good idea; I don't particularly like to be forced to implement functions in header files. I think I'll give them a try. Thanks!
<br/>
<br/>
sajimori: Yes. I use the term "resource-constrained devices" a lot. Maybe it's wrong, I don't know. Primarily, I use the term for small, portable devices; anything "below" a PC is tagged by me as a resource-constrained device. 
<br/>
(And, please, I beg you, don't make me explain what "below" means in that context. That's precisely why I use this term. :D )</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114806 - tepples - Wed Jan 10, 2007 9:30 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote"><span style="font-style: italic">Every</span> system has limited resources.  Handheld developers seem to forget that console and PC developers do more with their hardware -- it's not as if they're making GBA games for XBox 360 and setting up hammocks around the office for all the relaxation time that results from the lack of resource constraints.</td> </tr></table><span class="postbody">
<br/>
They're making business applications, where the ratio of programmer time to runtime is tilted more toward programmer time than it is for real-time games. And they're making <span style="font-style: italic">Hexic</span> and <span style="font-style: italic">Geometry Wars</span>, which don't come close to using all the power of the Xbox 360; they're just on the higher platform because the higher platform has a download shop.
<br/>
<br/>
The term I prefer is "battery-powered devices" or "fixed hardware" or "embedded systems" depending on the context.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114811 - Izhido - Wed Jan 10, 2007 9:47 pm</h4>
    <div class="postbody"><span class="postbody">To add more to the confusion: did you know that the Xbox 360, with all its processing power &amp; graphics &amp; whatnot, uses a *STRIPPED DOWN* version of the .NET *COMPACT* Framework for managed applications (games)? Quite mindboggling, if you ask me :) 
<br/>
<br/>
Sometimes it's hard to come with a consistent way to classify computing devices.
<br/>
<br/>
- Izhido</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114813 - keldon - Wed Jan 10, 2007 9:53 pm</h4>
    <div class="postbody"><span class="postbody">Well there comes a point where there is enough processing power to 'play' with, and you can begin to focus on the project itself and less about the hardware limitations.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114819 - sajiimori - Wed Jan 10, 2007 10:41 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">They're making business applications, where the ratio of programmer time to runtime is tilted more toward programmer time than it is for real-time games. And they're making Hexic and Geometry Wars, which don't come close to using all the power of the Xbox 360; they're just on the higher platform because the higher platform has a download shop.</td> </tr></table><span class="postbody">And they're making Gears of War, and they're making F.E.A.R., and they're making World of Warcraft.
<br/>
<br/>
Yes, there are applications that don't push the hardware very hard.  Brain Age for Nintendo DS is another example.
<br/>
<br/>
So again, it's not a matter of how many resources are available, or whether the system uses ROMs or DVDs, or whether it's battery powered, or whether it has upgradable components.  It's a matter of how hard the application is pushing the hardware, and there are game developers on all major platforms that are concerned with pushing the hardware.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114864 - sgeos - Thu Jan 11, 2007 5:08 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Izhido wrote:</b></span></td> </tr> <tr> <td class="quote">I use the term "resource-constrained devices" a lot. Maybe it's wrong,</td> </tr></table><span class="postbody">
<br/>
It's not wrong, it just doesn't really mean anything if you think about it.  "Low spec devices" or "especially resource-constrained" may better convey what you are trying to say- if you overly think things.  Anyone with common a little sense should know what you are talking about even if they think the wording is goofy.
<br/>
<br/>
-Brendan
<br/>
<br/>
<span style="font-weight: bold">EDIT:</span>  Fixed name.  =P</span><span class="gensmall"><br/><br/>Last edited by sgeos on Thu Jan 11, 2007 12:45 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#114877 - tepples - Thu Jan 11, 2007 6:37 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Yes, there are applications that don't push the hardware very hard.  Brain Age for Nintendo DS is another example.</td> </tr></table><span class="postbody">
<br/>
If only they could have pushed the hardware a bit harder to recognize the word "blue" more reliably. Perhaps Microsoft could have helped; its Windows division seems to know all about the color blue.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114902 - sgeos - Thu Jan 11, 2007 12:47 pm</h4>
    <div class="postbody"><span class="postbody">Wasn't brain age made in about four months?  Or was it four people?  Or was it both?  At any rate, it's not a budgetfest.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114962 - sajiimori - Thu Jan 11, 2007 10:27 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Anyone with common a little sense should know what you are talking about even if they think the wording is goofy.</td> </tr></table><span class="postbody">Call them what you will: resource-constrained, low-spec, embedded... (I often say "small".)  The same point applies regardless of terminology.  If you're trying to push the hardware, then efficiency matters, period.
<br/>
<br/>
So, to recap...
<br/>
<br/>
Myth: One uses a higher-level language on larger systems because efficiency is less important on those systems.
<br/>
<br/>
Reality: One often uses a higher-level language <span style="font-style: italic">because</span> efficiency is very important.
<br/>
<br/>
If you have X number of hours to make your game fast, what would you rather do: view a performance profile and spend your hours on the areas that need attention, or randomly distribute your hours across the entire program?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114979 - sgeos - Fri Jan 12, 2007 12:37 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Reality: One often uses a higher-level language <span style="font-style: italic">because</span> efficiency is very important.</td> </tr></table><span class="postbody">
<br/>
Fantastic point.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114980 - gmiller - Fri Jan 12, 2007 12:45 am</h4>
    <div class="postbody"><span class="postbody">I agree with sajiimori but would like to add that some times high level languages come with a lot of baggage and generally it is not obvious that it is there.  I have been on projects where the high level language was chosen because it had all these "features" that got used and the system performance "sucked".  You can produce a gem in performance in any language as long as you understand how it relates to the platform you are targeting,  you can also produce a dog in performance in any language.  Understanding your tools and how they work with the hardware can allow you to produce code that flies and low level languages are NOT a requirement to meet performance goals.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114987 - ScottLininger - Fri Jan 12, 2007 1:30 am</h4>
    <div class="postbody"><span class="postbody">Homebrew projects are primarily learning time, and there's no better way to learn than to try all kinds of goofy stuff.
<br/>
<br/>
So in that context, I'll throw out the idea that code optimization for optimization's sake is <span style="font-weight: bold">great</span>. Once you've done it 20 or 30 times and the time comes to actually deliver a project, you'll have the background to know where it's worth focusing and where it's not.
<br/>
<br/>
The only way to know if your compiler will do a good job is to try it.
<br/>
<br/>
-Scott</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114992 - sajiimori - Fri Jan 12, 2007 1:42 am</h4>
    <div class="postbody"><span class="postbody">Yes indeed!  Experiment away.  :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#114995 - gmiller - Fri Jan 12, 2007 1:50 am</h4>
    <div class="postbody"><span class="postbody">In the class I used teach in optimization we studied methods of determining where you are spending your time and then try to focus on what can be done to make things better.  In embedded systems you re constrained on the tools you can use but some of the emulators have some good performance gather options.  On the x86 I use Vtune and in the GBA I use the performance data the VBA emulator will gather to get a target area.  Of course emulators are not the real thing so where you are "fixing" might not  be the real issue.  Having some sort of hardware harness for the platform you are targeting would be better but those types of setup are usually not in the casual developers price range.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115033 - sgeos - Fri Jan 12, 2007 11:24 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">Having some sort of hardware harness for the platform you are targeting would be better but those types of setup are usually not in the casual developers price range.</td> </tr></table><span class="postbody">
<br/>
Even if you have the money to buy it, you won't be able find it easily.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115035 - keldon - Fri Jan 12, 2007 11:52 am</h4>
    <div class="postbody"><span class="postbody">Didn't the later Playstation Devkits have a so called 'performance analyser' that was key in identifying where time was being spent. In c++ the profiling wasn't too bad; I was able to identfy which methods took most of the processing time, but in java it was a pain; the program would move at snails pace, taking a minute to process a single frame with the profiler on!!!
<br/>
<br/>
And if only the page would load, I would be able to show you some <a class="postlink" href="http://tykje.com/talk/" target="_blank">amazing optimisations</a> that were made by swedish developers with optimising a database engine to search at 2000 times the speed of Posgresql on extremely large queries.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115097 - tepples - Sat Jan 13, 2007 12:16 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>gmiller wrote:</b></span></td> </tr> <tr> <td class="quote">Having some sort of hardware harness for the platform you are targeting would be better but those types of setup are usually not in the casual developers price range.</td> </tr></table><span class="postbody">
<br/>
Even if you have the money to buy it, you won't be able find it easily.</span></td> </tr></table><span class="postbody">
<br/>
If you have the money to pay programmers and artists in a developed country, then you probably have the money to write a business plan, make a prototype for PC or PDA, get office space, get a Nintendo license, and get a devkit.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#115155 - sgeos - Sat Jan 13, 2007 9:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sgeos wrote:</b></span></td> </tr> <tr> <td class="quote">Even if you have the money to buy it, you won't be able find it easily.</td> </tr></table><span class="postbody">
<br/>
If you have the money to pay programmers and artists in a developed country, then you probably have the money to write a business plan, make a prototype for PC or PDA, get office space, get a Nintendo license, and get a devkit.</span></td> </tr></table><span class="postbody">
<br/>
Sure, but if all you have is enough money to buy one devkit, you will have a hard time finding it.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116366 - blargg - Wed Jan 24, 2007 10:03 pm</h4>
    <div class="postbody"><span class="postbody">To get back to the original question, I've come across many articles recommending against get()/set() interfaces, but without really explaining why these are a problem, usually simply equating them with public members, <span style="font-style: italic">which we all know are evil</span> (never mind <span style="font-style: italic">why</span>, so we could make an informed decision). I've found a few authors who really explain the reason (Allen Holub's <a class="postlink" href="http://www.javaworld.com/cgi-bin/mailto/x_java.cgi?pagetosend=/export/home/httpd/javaworld/javaworld/jw-09-2003/jw-0905-toolbox.html&amp;pagename=/javaworld/jw-09-2003/jw-0905-toolbox.html&amp;pageurl=http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html&amp;site=jw_development" target="_blank">Why getter and setter methods are evil</a> is good). A possible problem with designs that use public members or many get()/set() functions is that it results in more coupling between modules. Changes will affect more users than in a design which provides higher-level behaviors. It ties in with the general principle of designing systems so that complexity reduced by dividing it up into multiple modules that each interact in well-defined ways. The interactions should be carefully chosen so that they are likely to remain stable during changes to the system. The most stable interactions are ones that allow one module to request the services of another, with as few unnecessary details as to how that request is granted. In this light, public members and get()/set() functions have their place, but they are often inferior to other possible ways of organizing things.
<br/>
<br/>
In C++, using an inline accessor should be no less efficient than using a public member:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class X {
<br/>
public:
<br/>
    int i;
<br/>
};
<br/>
<br/>
class Y {
<br/>
    int i;
<br/>
public:
<br/>
    int get_i() const;
<br/>
};
<br/>
<br/>
inline int Y::get_i() const { return i; }</td> </tr></table><span class="postbody">
<br/>
<br/>
This will not be the case if the accessor is virtual and the type of the object is not known:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">class Z {
<br/>
    int i;
<br/>
public:
<br/>
    virtual int get_i() const;
<br/>
};
<br/>
<br/>
inline int Z::get_i() const { return i; }
<br/>
<br/>
void f( Z* z )
<br/>
{
<br/>
    z-&gt;get_i(); // compiler must make virtual call
<br/>
    
<br/>
    Z local;
<br/>
    local.get_i(); // compiler can inline, since it knows complete type
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
As others have said, code for clarity, then it'll be easy to optimize that 5-10% that turns out to be where most of the time is spent. Or, optimize everything and be unable to make any high-level optimizations later, due to the (unnecessary) complexity of it all.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116377 - sajiimori - Wed Jan 24, 2007 11:34 pm</h4>
    <div class="postbody"><span class="postbody">Mr. Holub would be hard pressed to convince me that it's bad to have a setPosition method on my Creature class.  Anything else is an obfuscation of the brain-dead simple fact that I want to change the position of my creature.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116380 - gmiller - Wed Jan 24, 2007 11:50 pm</h4>
    <div class="postbody"><span class="postbody">If the compiler can inline you can also possibly eliminate the aliasing concerns that object methods can create for you.  Generally if the value is retrieved for you with a method the compiler must assume that it needs to get the value each time so either way (inline or method invocation) the data is retrieved.  This means that loops that have limit values based on a method call will execute the method each loop iteration. also if you use the get method multiple time in a loop the code will be executed each time it is referenced by the method.  It is generally easy to work around these issues but it is not always obvious that the problem is even there.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116382 - sajiimori - Thu Jan 25, 2007 12:10 am</h4>
    <div class="postbody"><span class="postbody">gmiller, I don't understand this sentence:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Generally if the value is retrieved for you with a method the compiler must assume that it needs to get the value each time so either way (inline or method invocation) the data is retrieved.</td> </tr></table><span class="postbody">Are you saying that the compiler can't cache data member values if they're accessed via methods, whether inlined or not?  If that's what you're saying, I disagree.  Modern compilers can optimize equally well when using inlined methods as compared to direct data member access.
<br/>
<br/>
It's fine to use such inlined methods in loops.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116387 - blargg - Thu Jan 25, 2007 1:54 am</h4>
    <div class="postbody"><span class="postbody">I doubt the author would unconditionally argue against all accessors. Whether it's the <span style="font-style: italic">best</span> design depends on the context. If most clients need to nudge a creature around rather than set its position, it would make more sense to have offsetPosition( delta_x, delta_y ) than have clients get and set the position. On the other hand if there's only one other client, Teleporter, which randomly moves creatures around, a setPosition() would make more sense. The point I got from the article was that accessors which merely get and set members might be less effective than operations that allow clients to more directly express their intent, since the former will result in unnecessary coupling and thus resistance to change. Obviously it's somewhat hard to predict how a system will evolve in directions you aren't planning for.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116388 - sajiimori - Thu Jan 25, 2007 2:49 am</h4>
    <div class="postbody"><span class="postbody">I've learned to avoid making design decisions based on which use cases I predict will be more common.  It's better to provide a complete, minimal, and orthogonal interface, even if it makes some "common" use cases slightly more verbose.
<br/>
<br/>
Even if I guess right about the frequency of my own use cases, my assumptions will likely be wrong for other users, and they'll be cursing my name for getting cute with the design.  =)
<br/>
<br/>
Since all movement operations are trivially supported by a get/set pair for position, but not all movement operations are supported by offsetPosition, the former is strongly preferred.
<br/>
<br/>
If someone wants to make an abbreviation for a common operation, they're free to define their own non-member functions.
<br/>
<br/>
<br/>
Edit: To summarize my standpoint: Before adding a get/set pair, consider whether it's the best solution.
<br/>
<br/>
The author should consider whether there is a reasonably-sized and statically-known set of higher-level operations that could be provided instead of a get/set pair.
<br/>
<br/>
If not, then use get/set.
<br/>
<br/>
If so, then the author should further consider whether clients can use some combination of those operations to get the full functionality of a get/set pair -- that is, are they a <span style="font-style: italic">superset</span> of the functionality supplied by get/set?
<br/>
<br/>
If so, use get/set and write the other operations as non-member utilities.  Providing them as the fundamental interface is an obfuscation of get/set.
<br/>
<br/>
An example of a bad substitute for get/set would be supplying these two methods:</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Vector3 Creature::vectorFromPointToSelf(const Vector3&amp; point) const;
<br/>
void Creature::offsetPosition(const Vector3&amp; moveBy);</td> </tr></table><span class="postbody">Those methods can be used to implement get/set as external utility functions, and the net result is purely an obfuscation.
<br/>
<br/>
After deciding to use some variant of get/set, use the first of these schemes that's acceptable:
<br/>
<br/>
- 'get' only, return something by value.  Completely hides internal representation.
<br/>
<br/>
- 'get' only, return const reference to abstract base of something.  Hides concrete representation, but reveals that there <span style="font-style: italic">is</span> a concrete representation: it can't be a "virtual" property of the object, such as a position that's procedurally calculated.
<br/>
<br/>
- 'get' only, return const reference to conrete object.  Reveals full representation, but no mutation is allowed.
<br/>
<br/>
- get/set pair.  Mutation is allowed, but class author can enforce additional invariants, such as automatically sending a notification to other objects when its position is changed.
<br/>
<br/>
- public data, or a 'get' method returning a non-const reference.  At this point, encapsulation and invariants are out the window and the difference between schemes is splitting hairs.
<br/>
<br/>
At any rate, calling get/set "evil" is a major overstatement.</span><span class="gensmall"><br/><br/>Last edited by sajiimori on Thu Jan 25, 2007 3:23 am; edited 2 times in total</span></div>    
</div>
<div class="post">
    <h4>#116389 - tepples - Thu Jan 25, 2007 3:19 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">Mr. Holub would be hard pressed to convince me that it's bad to have a setPosition method on my Creature class.</td> </tr></table><span class="postbody">
<br/>
You mean Creature::moveTo()?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116390 - sajiimori - Thu Jan 25, 2007 3:29 am</h4>
    <div class="postbody"><span class="postbody">Actually, moveTo seems a little ambiguous compared to setPosition.  It sounds like an instruction to attempt a pathfinding operation, but it could also be synonymous with setPosition.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116391 - tepples - Thu Jan 25, 2007 3:47 am</h4>
    <div class="postbody"><span class="postbody">In object-oriented programming, method names should reflect behaviors that an object is capable of doing. If it spawns, Creature(x, y) (the constructor) is appropriate. If it can walk somewhere, findPathTo(x, y) is appropriate. If it can teleport somewhere, teleportTo(x, y) is appropriate.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116393 - sajiimori - Thu Jan 25, 2007 6:47 am</h4>
    <div class="postbody"><span class="postbody">"Set" works as an instruction in a complete sentence: "Creature, set your position to x."  In English, the word "change" might be slightly more natural, but they both work and "set" is an exceedingly common prefix.  Virtually nobody is confused by it.
<br/>
<br/>
There's really no need to get cute with method names when all I want to do is set a position.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116395 - tepples - Thu Jan 25, 2007 7:18 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">"Set" works as an instruction in a complete sentence: "Creature, set your position to x."</td> </tr></table><span class="postbody">
<br/>
It's also a filler word, just as "is" is a filler word. The only way "set" carries any meaning is as a collection of distinct elements, none of which is the collection itself. The content word here is "position", which is a property, not a behavior. What <span style="font-style: italic">behavior of the object</span> results in setting this position?<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116406 - sajiimori - Thu Jan 25, 2007 9:27 am</h4>
    <div class="postbody"><span class="postbody">If you can grant that "change" has a substantive meaning here, then I will hereby define "set" as being synonymous, which is typical.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116415 - sgeos - Thu Jan 25, 2007 12:56 pm</h4>
    <div class="postbody"><span class="postbody">Teleport and move to could very well be the same thing:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">Interface I
<br/>
{
<br/>
   bool move(int x, int y);
<br/>
}
<br/>
<br/>
// move to
<br/>
Class A implements I
<br/>
{
<br/>
   bool move(int x, int y)
<br/>
   {
<br/>
      // attept to teleport to xy
<br/>
      // random teleport if xy is blocked
<br/>
      return true;
<br/>
   }
<br/>
}
<br/>
<br/>
// teleport
<br/>
Class B implements I
<br/>
{
<br/>
   bool move(int x, int y)
<br/>
   {
<br/>
      // find a path to xy
<br/>
      // take a few steps in that direction
<br/>
      // return true if steps taken
<br/>
      // return false if no path
<br/>
   }
<br/>
}
<br/>
<br/>
// failure parasite
<br/>
Class C implements I
<br/>
{
<br/>
   bool move(int x, int y)
<br/>
   {
<br/>
      // if rand(0, maxrate) &lt; failrate, return false
<br/>
      // else return host.move(x, y)
<br/>
   }
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#116441 - sajiimori - Thu Jan 25, 2007 7:53 pm</h4>
    <div class="postbody"><span class="postbody">If that scheme solves a problem in your application, then go for it.  If it doesn't solve a problem, it's merely obfuscation.
<br/>
<br/>
Either way, I'd start with something simple, like a setPosition method and a pathfindTo method.  If an additional abstraction is needed to give those two methods a common interface, that abstraction should be provided separately, and the original interface should not be modified.
<br/>
<br/>
Again, it is not a good idea to get fancy with the <span style="font-style: italic">fundamental</span> interface to an object.  Provide something clear, simple, and orthogonal.  If something fancy is needed, implement it separately in terms of the fundamental interface.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
