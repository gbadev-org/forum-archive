<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Inline asm - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Inline asm</h2>
<div id="posts">
<div class="post">
    <h4>#34205 - beelzebub - Sat Jan 15, 2005 12:26 pm</h4>
    <div class="postbody"><span class="postbody">This has nothing to do with the GBA, or the standard question about how to do inline asm - but it seemed like a good place to ask my question...
<br/>
<br/>
I'm using GCC on a non-standard embedded CPU, the memory layout of this chip uses segments and offsets (like in the old days of DOS programming) but the version of GCC I've been given does not support "far" pointers.
<br/>
<br/>
I've got a macro that uses inline assembler to retreive the segment of my const ROM based resources (graphics, sounds etc..) but I can only use it in code, either in an assignment or as an argument to a function.
<br/>
<br/>
But what I would like to be able to do is to make const data tables of the segments and offsets for the resources. But the macro I have now doesn't compile (gcc says "Parse error before asm") when uses in a const unsigned array.
<br/>
<br/>
this is my macro that works...
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">#define SEGMENT(_symbol)   \
<br/>
      ( { unsigned   tmp;      \
<br/>
      asm   (" %0 = seg _" #_symbol "\n"   \
<br/>
      :   "=r"(tmp)         \
<br/>
      : /*input*/            \
<br/>
      /* : clobber */ );         \
<br/>
      tmp; } )
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Which can be used thus:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
void far_memcpy (unsigned dstseg,void *dstoffset, unsigned srcseg,void *srcoffset, unsigned length);
<br/>
<br/>
far_memcpy (0,near_memory, SEGMENT (MY_RESOURCE),MY_RESOURCE, 42);
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
So can anybody suggest how I can
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
const unsigned  resource_table [][2] = 
<br/>
{
<br/>
    { SEGMENT(MY_RESOURCE), &amp;MY_RESOURCE },
<br/>
};
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#34212 - tepples - Sat Jan 15, 2005 6:12 pm</h4>
    <div class="postbody"><span class="postbody">C language implementations in environments that often use segment:offset addressing, such as 8086 real mode and 80286 protected mode, often have a separate data type for far pointers, possibly internally represented as a 32-bit word (containing a 16-bit segment and a 16-bit offset) or in newer designs a 64-bit word (containing a 16-bit segment and a 48-bit offset or a 32-bit segment and a 32-bit offset). For example, one of the early stages of the development of TOD used Borland C++, which provided data types such as 'char far *'. Refer to your compiler's documentation for more details.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
