<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>creating a random map - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/static/pure-min.css" />
        <link rel="stylesheet" href="/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > creating a random map</h2>
<div id="posts">
<div class="post">
    <h4>#3707 - phr0zn - Wed Mar 05, 2003 7:37 pm</h4>
    <div class="postbody"><span class="postbody">Hey everyone.  I am working on a "random map" generator for my GBA project.  I coded it so that I would create a double scripted map array called "map[30][20]".  I then set the entire array to equal zero, then "randomly" place 1s around the map in an organized fashion to create rooms and paths.  However, my problem is converting this to the gba.  
<br/>
<br/>
What I want to do is create two background tiles, both 8x8 (hence getting a 240x160 pixel screen if there are 30x8 + 20x8 tiles).  However, I cannot load them as sprites (this wouldn't make sense anyway for a background) because it would create more than the max 128 sprites at a time.  
<br/>
<br/>
So I am wondering if it is possible to do it like this (please note im fairly new to programming for the game boy advance): by loading them into the videobuffer for each tile.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
//the two tiles
<br/>
#include "tile1.h"
<br/>
#include "tile2.h"
<br/>
<br/>
u16 i,x,y;
<br/>
<br/>
for(x=0; x&lt;20; x++)
<br/>
      for(y=0; y&lt;30; y++)
<br/>
       {
<br/>
            if(map[x][y] == 1)
<br/>
            {
<br/>
                  for(i = 0; i&lt;256; i++)
<br/>
                          theScreenPalette[i] = tile1Palette[i];
<br/>
                   
<br/>
                  u16* tempData = (u16*)tile1;
<br/>
                  for(x=0; x&lt;8; x++)
<br/>
                     for(y=0; y&lt;8; y++)
<br/>
                         theVideoBuffer[y*8+8] = tempData[y*8+8];
<br/>
           }
<br/>
           else if(map[x][y] == 0)
<br/>
           {
<br/>
                  for(i = 0; i&lt;256; i++)
<br/>
                          theScreenPalette[i] = tile2Palette[i];
<br/>
                   
<br/>
                  u16* tempData = (u16*)tile2;
<br/>
                  for(x=0; x&lt;8; x++)
<br/>
                     for(y=0; y&lt;8; y++)
<br/>
                         theVideoBuffer[y*8+8] = tempData[y*8+8];
<br/>
            }
<br/>
}
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
<br/>
I really doubt this will work but my goal was to draw the tile for each time the tile is 1 or 0, to create a random background.
<br/>
<br/>
Any help and direction would be much appreciated.  I can post more code if you need it.
<br/>
<br/>
Thanks a lot.
<br/>
<a href="mailto:shad0an@hotmail.com">shad0an@hotmail.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3716 - Quirky - Thu Mar 06, 2003 8:34 am</h4>
    <div class="postbody"><span class="postbody">Do you only have 2 tiles? Why not load the data for 2 tiles into vram first, then you only have to update the part of vram that contains the map. See <a href="http://www.thepernproject.com" target="_blank">www.thepernproject.com</a> for how to do tiled backgrounds. This way, you only  use up the VRAM for your 2 tiles (128 bytes or less depending on bits per pixel) and for the map (1024 bytes for a 32 by 32 8*8 tile map)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3733 - phr0zn - Thu Mar 06, 2003 10:47 pm</h4>
    <div class="postbody"><span class="postbody">herm.  ive checked that out before.  the problem is most of the tutorials deal with loading entire maps at once...or so thats what I have found.  They use map editors and the such.
<br/>
<br/>
Ah...I have an idea now.  I will just look at the source that the map editor outputs :-D  thanks.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3752 - peebrain - Fri Mar 07, 2003 6:01 pm</h4>
    <div class="postbody"><span class="postbody">First problem I see is that you think that each tile can have it's own palette... There is no such thing as a "tile palette".  All tiles use the same palette, the background palette.  All sprite tiles use the same palette, the object palette.
<br/>
<br/>
~Sean<br/>_________________<br/><a href="http://www.pbwhere.com" target="_blank">http://www.pbwhere.com</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3754 - Daikath - Fri Mar 07, 2003 6:13 pm</h4>
    <div class="postbody"><span class="postbody">Sprites can use 1 256 colour pallette or 16 16 colour palette's.<br/>_________________<br/>?There are no stupid questions but there are a LOT of inquisitive idiots.?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3757 - phr0zn - Fri Mar 07, 2003 10:21 pm</h4>
    <div class="postbody"><span class="postbody">what if I kept the tiles in the same file, then used the entire file as a palette.  then because I know that since the file would be 32x16 (two 16x16 tiles...i think this will be easier), I could say that the first tile ends at 16x...so 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
<br/>
//the two tiles 
<br/>
#include "tiles.h"
<br/>
<br/>
u16 i,x,y; 
<br/>
<br/>
for(i = 0; i&lt;256; i++) 
<br/>
      theScreenPalette[i] = tilesPalette[i]; 
<br/>
u16* tempData = (u16*)tiles; 
<br/>
<br/>
for(x=0; x&lt;20; x++) 
<br/>
      for(y=0; y&lt;30; y++) 
<br/>
       { 
<br/>
            if(map[x][y] == 1) 
<br/>
            {        
<br/>
                  for(x=0; x&lt;16; x++) 
<br/>
                     for(y=0; y&lt;16; y++) 
<br/>
                         theVideoBuffer[y*16+16] = tempData[y*16+16]; 
<br/>
           } 
<br/>
           else if(map[x][y] == 0) 
<br/>
           { 
<br/>
                  for(x=16; x&lt;32; x++) 
<br/>
                     for(y=0; y&lt;16; y++) 
<br/>
                         theVideoBuffer[y*16+16] = tempData[y*16+16]; 
<br/>
            } 
<br/>
} 
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
is this how I should do it?  I will test it out later (not on a comp that can compile now).  thanks guys.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#3760 - phr0zn - Fri Mar 07, 2003 10:43 pm</h4>
    <div class="postbody"><span class="postbody">here is my code as it is now if anyone cares.  
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// Typdefs
<br/>
typedef unsigned char u8;
<br/>
typedef unsigned short u16;
<br/>
typedef unsigned long u32;
<br/>
<br/>
typedef signed char s8;
<br/>
typedef signed short s16;
<br/>
typedef signed long s32;
<br/>
<br/>
// Defines
<br/>
#define REG_DISPCNT      *(volatile u16*)0x4000000
<br/>
#define REG_BG2CNT      *(volatile u16*)0x400000C
<br/>
#define VCOUNT         *(volatile u16*)0x4000006
<br/>
#define REG_BG2X      *(volatile u32*)0x4000028
<br/>
<br/>
//define the keys and macros
<br/>
#define KEYSTART 8
<br/>
#define KEYS (*(volatile u16*)0x4000130)
<br/>
#define KEY_DOWN(k) (!((KEYS)&amp;k))
<br/>
<br/>
//define our background
<br/>
#define REG_BG2Y      *(volatile u32*)0x400002C
<br/>
<br/>
//define colour macro
<br/>
#define COLOUR(r, g, b)   ((b &lt;&lt; 10) | (g &lt;&lt; 5) | r)
<br/>
<br/>
//video memory globals
<br/>
u16* VRAM = (u16*)0x6000000;
<br/>
u16* paletteMem = (u16*)0x5000000;
<br/>
<br/>
//our random maximum
<br/>
#define RAND_MAX 4
<br/>
<br/>
//our directions
<br/>
#define LEFT 0
<br/>
#define RIGHT 1
<br/>
#define UP 2
<br/>
#define DOWN 3
<br/>
<br/>
//this is so it works with my MBV2 cable so I can test it on the Hardware
<br/>
#define MULTIBOOT volatile const u8 __gba_multiboot;   
<br/>
MULTIBOOT
<br/>
<br/>
//random data global
<br/>
volatile s32 RAND_RandomData; 
<br/>
<br/>
void PlotPixel(int x, int y, u16 c);
<br/>
void ClearScreen(void);
<br/>
void SeedRandom(void);
<br/>
s32 RAND(s32 Value);
<br/>
<br/>
//our includes
<br/>
#include "char.h"
<br/>
#include "messages.h"
<br/>
#include "tiles.h" //our tiles file
<br/>
<br/>
int main(void)
<br/>
{
<br/>
   REG_DISPCNT = 0x1403;
<br/>
   REG_BG2CNT = 0x0000;
<br/>
<br/>
<br/>
   u16 map[15][10]; //a 15x10 16x16 tile map
<br/>
   u16 dir; //our current direction
<br/>
   u16 xpos; //our x position
<br/>
   u16 ypos; //our Y position
<br/>
   u16 i; //a counter
<br/>
<br/>
   u16 x, y, j;  //for the palettes, etc.
<br/>
<br/>
   //set up the screenpalette and the temporary data for "tiles"
<br/>
   for(i = 0; i&lt;256; i++) 
<br/>
      paletteMem[i] = tilesPalette[i]; 
<br/>
    u16* tempData = (u16*)tiles; 
<br/>
<br/>
<br/>
   for(xpos=0; xpos &lt; 10; xpos++)  //make every single int in map[15][10] = 0
<br/>
    {
<br/>
       for(ypos = 0; ypos &lt; 15; ypos++)
<br/>
       {
<br/>
              map[ypos][xpos] = 0;
<br/>
       }
<br/>
    }
<br/>
    
<br/>
    map[7][5] = 1;  //set absolute middle to equal 1.
<br/>
    
<br/>
    xpos = 7;  //set the X and Y starting position...at (15,10)
<br/>
    ypos = 5;
<br/>
<br/>
   i=1; //reset i to 1
<br/>
      
<br/>
   DisplayText(helpstring, 20, 0, 145);  //our initial screen text
<br/>
<br/>
   if(KEY_DOWN(KEYSTART))  //if the key 'start' is down
<br/>
   {
<br/>
         ClearScreen();  //clear the screen
<br/>
<br/>
    while(1) //the game has begun
<br/>
   {
<br/>
<br/>
      SeedRandom();
<br/>
<br/>
      while(i&lt;75)
<br/>
      {
<br/>
         dir = RAND(4); //get a random number between 0 and 3
<br/>
        
<br/>
         if(dir == LEFT)     
<br/>
         {
<br/>
            if(xpos&gt;0)
<br/>
            {
<br/>
               xpos--;
<br/>
               if(map[xpos][ypos] == 0)
<br/>
               {
<br/>
                  map[xpos][ypos] = 1;
<br/>
                  i++;
<br/>
               }
<br/>
            }
<br/>
         }
<br/>
         else if(dir == RIGHT) //ibit
<br/>
         {
<br/>
            if(xpos&lt;29)
<br/>
            {
<br/>
               xpos++;
<br/>
               if(map[xpos][ypos] == 0)
<br/>
               {
<br/>
                  map[xpos][ypos] = 1;
<br/>
                  i++;
<br/>
               }
<br/>
            }   //make it equal one  
<br/>
         }
<br/>
         else if(dir == UP)  //ibit
<br/>
         {
<br/>
            if(ypos&lt;19)
<br/>
            {
<br/>
               ypos++;
<br/>
               if(map[xpos][ypos] == 0)
<br/>
               {
<br/>
                   map[xpos][ypos] = 1;
<br/>
                  i++;
<br/>
               }
<br/>
            }
<br/>
         }
<br/>
         else if(dir == DOWN)  //ibit
<br/>
         { 
<br/>
            if(ypos&gt;0)
<br/>
            {
<br/>
               ypos--;
<br/>
               if(map[xpos][ypos] == 0)
<br/>
               {
<br/>
                  map[xpos][ypos] = 1;
<br/>
                  i++;
<br/>
               }
<br/>
            }
<br/>
         }
<br/>
      }
<br/>
<br/>
<br/>
for(xpos=0; xpos &lt; 10; xpos++)
<br/>
   {
<br/>
       for(ypos = 0; ypos &lt; 15; ypos++)
<br/>
      {
<br/>
          if(map[xpos][ypos] == 1) 
<br/>
            {     //draw the first half the the image
<br/>
                  for(x=0; x&lt;16; x++) 
<br/>
                     for(y=0; y&lt;16; y++) 
<br/>
                         VRAM[y*16+x] = tempData[y*16+x]; 
<br/>
           } 
<br/>
           else if(map[xpos][ypos] == 0) 
<br/>
           {      //draw the second half
<br/>
                  for(x=16; x&lt;32; x++) 
<br/>
                     for(y=0; y&lt;16; y++) 
<br/>
                         VRAM[y*32+x] = tempData[y*32+x]; 
<br/>
            } 
<br/>
<br/>
      }
<br/>
   }
<br/>
<br/>
   #ifndef DDEBUG
<br/>
      DisplayNumber(i, 235, 150);
<br/>
   #endif
<br/>
<br/>
   } //end while
<br/>
<br/>
} //end if
<br/>
<br/>
   return 0;
<br/>
}
<br/>
<br/>
void PlotPixel(int x, int y, u16 c)
<br/>
{
<br/>
   VRAM[x + (y * 240)] = c;
<br/>
}
<br/>
<br/>
void ClearScreen(void)
<br/>
{
<br/>
   REG_BG2X = 0;
<br/>
   REG_BG2Y = 0;
<br/>
   u16 x,y;
<br/>
   for(y = 0; y &lt;160; y++)
<br/>
      for(x = 0; x &lt; 240; x++)
<br/>
         PlotPixel(x,y,0x0000);
<br/>
}
<br/>
<br/>
<br/>
void SeedRandom(void)
<br/>
{
<br/>
   RAND_RandomData = VCOUNT;
<br/>
}
<br/>
<br/>
<br/>
s32 RAND(s32 Value)
<br/>
{
<br/>
   RAND_RandomData *= 20077;
<br/>
   RAND_RandomData += 12345;
<br/>
<br/>
   return ((((RAND_RandomData &gt;&gt; 16) &amp; RAND_MAX) * Value) &gt;&gt; 15);
<br/>
}
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
