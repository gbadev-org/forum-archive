<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>unions - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > unions</h2>
<div id="posts">
<div class="post">
    <h4>#22548 - sgeos - Thu Jun 24, 2004 1:19 am</h4>
    <div class="postbody"><span class="postbody">Aside from when I was learning the syntax, I have never had any reason to use a union.  How often does anyone else use them?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22549 - tepples - Thu Jun 24, 2004 1:36 am</h4>
    <div class="postbody"><span class="postbody"><a class="postlink" href="http://www.wired.com/news/business/0,1367,63558,00.html?tw=wn_3bizhead" target="_blank">SBC workers use them</a> ;-)<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22551 - Miked0801 - Thu Jun 24, 2004 1:38 am</h4>
    <div class="postbody"><span class="postbody">Unions are useful in situations where memory is tight or where you need to map the output of a hardware device depending on registers or headers.  For the first, imagine you have a title where there are a bunch of different mini-games.  Each mini-game needs to know nothing about the other games.  Instead of creating 7 different sets of structures per game and statically allocating the RAM 7 times, you put the structs into a union and the compiler only allocates the memory once thus saving memory (or you dynamically allocate, but I digress).  For my second, image that when setting a HW register, the type of memory being accessed changes (like GBA vram when you go from a text mode to a bmp mode.)  You can still access the memory in a unified way with a union.  You just set one entry to the text style and another to the bmp style.  This also helps to hide the HW level and makes things easier to code.
<br/>
<br/>
Mike</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22554 - poslundc - Thu Jun 24, 2004 2:51 am</h4>
    <div class="postbody"><span class="postbody">I usually use #defines to accomplish what I could with unions, in order to avoid having to use their syntax. Unions are probably a much cleaner, more professional way, though. ;)
<br/>
<br/>
For the record, the need doesn't arrive often. The main reason I can think of has to do with what Mike said, when I want a static pool of memory for multiple purposes that don't overlap, and I want to be able to treat that pool of memory as a different structure depending on the situation.
<br/>
<br/>
And tepples, I thought you were supposed to have Asperger's...? Again, ;)
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22556 - jma - Thu Jun 24, 2004 2:59 am</h4>
    <div class="postbody"><span class="postbody">Unions are almost unbeatable in embedded systems where space is at a premium. For example, they allow you to access byte ordering as it was meant to be:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">union uint32 {
<br/>
   unsigned long u32;
<br/>
   unsigned char b[4];
<br/>
};</td> </tr></table><span class="postbody">
<br/>
<br/>
This lets you access the same 32-bit number without shifting, bit swapping, etc, and gives you the proper byte ordering. Very handy. There are lots of other similar uses. And BTW, using unions to handle variant data types is a waste, IMHO, but I'm sure others here would disagree with me.
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22558 - dagamer34 - Thu Jun 24, 2004 4:09 am</h4>
    <div class="postbody"><span class="postbody">Here's one example that actually makes sense and doesn't take that long to read. :)
<br/>
<br/>
Use unions when memory overlaps and has multiple uses, but not at a single time. A perfect example would be attribute 1 of OAM memory and how it is different depending on whether the sprite is in rot/scale mode or not.<br/>_________________<br/>Little kids and Playstation 2's don't mix. :(</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22561 - sajiimori - Thu Jun 24, 2004 6:08 am</h4>
    <div class="postbody"><span class="postbody">I use unions for objects when implementing dynamically-typed languages.  In such languages, it is the value that carries a type, not the variable.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
enum
<br/>
{
<br/>
  TYPE_INT,
<br/>
  TYPE_STRING,
<br/>
  ...
<br/>
}
<br/>
<br/>
struct Object
<br/>
{
<br/>
  int type;
<br/>
  union
<br/>
  {
<br/>
    int i;
<br/>
    char* s;
<br/>
    ...
<br/>
  } value;
<br/>
};
<br/>
</td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22565 - sgeos - Thu Jun 24, 2004 10:10 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Miked0801 wrote:</b></span></td> </tr> <tr> <td class="quote">(or you dynamically allocate, but I digress)</td> </tr></table><span class="postbody">What about dynamic allocation do you dislike?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22575 - Nessie - Thu Jun 24, 2004 3:15 pm</h4>
    <div class="postbody"><span class="postbody">Just from that comment, it's not clear to me that he was either for or against dynamic allocation.  However, one reason a person might not like dynamic allocation is that, on a machine that does not have virutal memory, say like the GBA, dynamic allocation can fail.  
<br/>
<br/>
So, in some ways I prefer the approach of allocating all needed assets for a given level at the time that this level is loaded.  
<br/>
<br/>
It may take more time to prep the level, but at least then you will know that the allocation is failing (if you are doing your job), and this problem should be 100% reproducible (the same allocations happen at the 'load' of this level, right?) and therefore trivial to address.
<br/>
<br/>
Otherwise, I guess you run the risk of a potentially essential dynamic allocation being able to fail when Venus and Mars align on a late Friday afternoon, but only when it's an even numbered day. ...which is my way of saying, rare combinations of events creating a situation where you can encounter an allocation failure.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22576 - poslundc - Thu Jun 24, 2004 3:31 pm</h4>
    <div class="postbody"><span class="postbody">On the GBA, I have yet to ever use dynamic allocation for anything. For dynamic structures such as linked lists I just use fixed-size chunks of memory (such that the list has a pre-determined maximum length).
<br/>
<br/>
Why bother running the risk of heap fragmentation or running out of memory, I figure, when it's just about as easy for me to manage the memory myself.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22578 - jma - Thu Jun 24, 2004 3:55 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>sajiimori wrote:</b></span></td> </tr> <tr> <td class="quote">I use unions for objects when implementing dynamically-typed languages.  In such languages, it is the value that carries a type, not the variable.
<br/>
&lt;code snipped&gt;</td> </tr></table><span class="postbody">
<br/>
This is what I meant by variant data types. This method of doing it is just wrong (not to be rude). The problem is that <span style="font-style: italic">all</span> your created "objects" will all have the size of the largest one in your variant type (or union).
<br/>
<br/>
Variant data types are much better implemented with just a (void*) to somewhere in memory. Or, if designing an actual language (like Lisp) that has dynamic typing, use a large hunk of memory to hold all your variables, like a mempool, and then just index into it the exact size of each object.
<br/>
<br/>
Your method is simple and quick, but is a waste of memory. On a desktop, that's probably alright. But on another system (like a console) you're just throwing away bits...
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22579 - poslundc - Thu Jun 24, 2004 4:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>jma wrote:</b></span></td> </tr> <tr> <td class="quote">This is what I meant by variant data types. This method of doing it is just wrong (not to be rude). The problem is that <span style="font-style: italic">all</span> your created "objects" will all have the size of the largest one in your variant type (or union).</td> </tr></table><span class="postbody">
<br/>
<br/>
But that's the point of a union: to interpret the same chunk of data through different data types.
<br/>
<br/>
If one of your data types doesn't use all the memory, and that's a problem for you, then you should probably be using dynamic allocation.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Variant data types are much better implemented with just a (void*) to somewhere in memory.</td> </tr></table><span class="postbody">
<br/>
<br/>
You still need to allocate memory for the object. How are you going to allocate it? If you're using static allocation, it's no different from a union.
<br/>
<br/>
Personally, I think dynamic allocation is for chumps. :D
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22581 - Miked0801 - Thu Jun 24, 2004 5:03 pm</h4>
    <div class="postbody"><span class="postbody">Actually, I'll usually use dynamic allocation over unions myself.  The only place I don't is when allocating in IWRAM where dynamic memory block headers just eat too much space.  Nothing's free...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22582 - jma - Thu Jun 24, 2004 5:25 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>poslundc wrote:</b></span></td> </tr> <tr> <td class="quote"><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>jma wrote:</b></span></td> </tr> <tr> <td class="quote">This is what I meant by variant data types. This method of doing it is just wrong (not to be rude). The problem is that <span style="font-style: italic">all</span> your created "objects" will all have the size of the largest one in your variant type (or union).</td> </tr></table><span class="postbody">
<br/>
<br/>
But that's the point of a union: to interpret the same chunk of data through different data types.</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Yes, but on an <span style="font-style: italic">embedded </span>system, you want to make sure that you aren't wasting space. If you are statically allocating space in a union (for example, an 80 character string) that could also be a 2-byte short, you're killing yourself.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">If one of your data types doesn't use all the memory, and that's a problem for you, then you should probably be using dynamic allocation.</td> </tr></table><span class="postbody">
<br/>
<br/>
No, you can still use static allocation, just create pointers to them. Of course, now we're not talking about unions any more :) But this is much more memory friendly -- and <span style="font-style: italic">much</span> faster than dynamically allocating memory on the fly.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">You still need to allocate memory for the object. How are you going to allocate it? If you're using static allocation, it's no different from a union.</td> </tr></table><span class="postbody">
<br/>
<br/>
Using C++ for readability's sake (I would use C in real life):
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">MemoryPool mem_pool(2048); // allocate 2K at start of program
<br/>
<br/>
struct Variant {
<br/>
  enum TYPE type;
<br/>
  void *value;
<br/>
};
<br/>
<br/>
int main() {
<br/>
  Variant x,s;
<br/>
<br/>
  x.type = TYPE_INT;
<br/>
  x.value = mem_pool.request(4); // get 4 byte pointer
<br/>
<br/>
  s.type = TYPE_STRING;
<br/>
  s.value = mem_pool.request(256); // get 256 byte pointer
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
In the above example, no space has been wasted and the memory is statically allocated at the start of the program. Using unions for the above example, x and s would both take up 260 bytes (4 byte type and 256 bytes of value data).
<br/>
<br/>
Using a MemoryPool style class or API, you can allow yourself to align data as well, release the data when done with it, etc. All <span style="font-style: italic">very fast</span>, without dynamic allocation.
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22585 - sajiimori - Thu Jun 24, 2004 5:39 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
The problem is that all your created "objects" will all have the size of the largest one in your variant type (or union). 
<br/>
</td> </tr></table><span class="postbody">
<br/>
...which is a pointer.  Compound or boxed objects have seperate structures.  This indirection is what makes closures work.
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
Variant data types are much better implemented with just a (void*) to somewhere in memory.
<br/>
</td> </tr></table><span class="postbody">
<br/>
Yeah, and I could cast it to int or char when it's a constant, but unions are nicer.
<br/>
<br/>
Also, for fast symbol tables (implemented as arrays where symbols are ints), the reference objects need to all be the same size.  As is so often the case, there is a tradeoff between space and time when working with larger objects.
<br/>
<br/>
Edit:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">
<br/>
In the above example, no space has been wasted and the memory is statically allocated at the start of the program.
<br/>
</td> </tr></table><span class="postbody">
<br/>
I might say you wasted 4 bytes for the int, when you could have stored it in the void*.  Maybe you were about to capture it in a closure. ;)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22586 - jma - Thu Jun 24, 2004 6:00 pm</h4>
    <div class="postbody"><span class="postbody">Yes, but right now we're talking about trivial examples. However, things get a lot more complicated when you are talking about sound bytes, character models, and entire game levels instead of just int, string, char...
<br/>
<br/>
I think we understand each other, and if we happen to disagree, that's fine -- we don't have to work with each other's code ;) However, as a last little "argument":
<br/>
<br/>
Unions in C also have the disadvantage that they only accept the first member of the union for data setting and it is what the compiler uses. So, for example, the following union:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">union variant {
<br/>
  char c;
<br/>
  void *p;
<br/>
  char *string;
<br/>
  int x;
<br/>
}</td> </tr></table><span class="postbody">
<br/>
<br/>
Is not guaranteed to be 4-byte aligned (because the byte is the first member). So care must be taken when declaring a union. Also, you can't set it at compile time:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// using above variant union
<br/>
const variant vars[] = { "Hello, world", 1000 };</td> </tr></table><span class="postbody">
<br/>
<br/>
This is invalid, because it is only looking at the 'c' member of the union. This can be a real pain in the neck. My code method can take care of this by just putting addresses into the array. However, this is more of a hack-solution than a real one.
<br/>
<br/>
While this is hardly a "serious" argument one way or the other, I figured these were a couple "hic-ups" that the OP should be aware of when using unions.
<br/>
<br/>
Jeff<br/>_________________<br/><a href="mailto:massung@gmail.com">massung@gmail.com</a>
<br/>
<a href="http://www.retrobyte.org" target="_blank">http://www.retrobyte.org</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22599 - sajiimori - Thu Jun 24, 2004 11:58 pm</h4>
    <div class="postbody"><span class="postbody">Just when I thought I knew C!  heheh</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22604 - sgeos - Fri Jun 25, 2004 3:23 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Nessie wrote:</b></span></td> </tr> <tr> <td class="quote">Just from that comment, it's not clear to me that he was either for or against dynamic allocation.</td> </tr></table><span class="postbody">
<br/>
Before reading this thread, I would have used dynamic allocation to tackle a bunch of mini games.  (Actually I would put each game in a separate routine complete with local variables.)  I had not even considered unions and figured that there must be a reason why dynamic allocation is not the Obvious Choice.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">in some ways I prefer the approach of allocating all needed assets for a given level at the time that this level is loaded.</td> </tr></table><span class="postbody">
<br/>
This is an everything at once version of dynamic allocation.  Although the question has been answered, I meant to ask "Are there any reasons why one would use a union instead of some version of dynamic allocation?"
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">It may take more time to prep the level,</td> </tr></table><span class="postbody">
<br/>
What might one do that would take more than an extra frame or two of prep time?
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22622 - Nessie - Fri Jun 25, 2004 3:23 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">This is an everything at once version of dynamic allocation.</td> </tr></table><span class="postbody">
<br/>
The way I see it, there is dynamic allocation...and then there is <span style="font-style: italic">dynamic allocation</span>.  
<br/>
<br/>
Sort of OT, I worked on a console title that used static allocation.  Basically it was an STL-like implementation that provided fixed-sized containers, with the container size being specified compile time by the programmer.  
<br/>
<br/>
I guess the idea was to try and provide the flexibility of STL with a system that was designed to eliminate heap fragmentation problems.    Another design goal was to provide safety checking that might not be present with access to raw arrays, maps, lists, etc.
<br/>
<br/>
However, there were a few annoying effects of this decision.  I'll leave it as an exercise for the interested reader to figure out the problems with this approach. :)  Of course there were some good things about it as well...
<br/>
<br/>
Anyway, to get back to the original statement.  I don't have a problem with dynamic alloaction.  I would just tend to prefer that it happens in a more predicatable way to make it easier to detect potential problems, ie, up-front in a level.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#22623 - poslundc - Fri Jun 25, 2004 3:54 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Nessie wrote:</b></span></td> </tr> <tr> <td class="quote">Sort of OT, I worked on a console title that used static allocation.  Basically it was an STL-like implementation that provided fixed-sized containers, with the container size being specified compile time by the programmer.</td> </tr></table><span class="postbody">
<br/>
<br/>
That is pretty much what I do for my "dynamic" entities. (Except I don't bother with templates or any of the OO baggage that comes with STL.)
<br/>
<br/>
IMO, "real" dynamic allocation is just not worth the trouble more often than not when programming for a low-level embedded console.
<br/>
<br/>
Dan.</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
