<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Loop using different types - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > Loop using different types</h2>
<div id="posts">
<div class="post">
    <h4>#107767 - QuantumDoja - Wed Nov 01, 2006 9:11 pm</h4>
    <div class="postbody"><span class="postbody">Hi, I have an array that holds whether a location in memeory is full, it is defined as:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">u16 OAMArray[7];</td> </tr></table><span class="postbody">
<br/>
<br/>
my array has the following values set:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
OAMArray[0] = 1; //full
<br/>
   OAMArray[1] = 1; //full
<br/>
   OAMArray[2] = 0;
<br/>
   OAMArray[3] = 0;
<br/>
   OAMArray[4] = 0;
<br/>
   OAMArray[5] = 0;
<br/>
   OAMArray[6] = 0;
<br/>
   OAMArray[7] = 0;
<br/>
</td> </tr></table><span class="postbody"> - 
<br/>
<br/>
I can then have this loop see if a memeory location is full, if so, get the next free slot.</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
int f = 0;
<br/>
               for (k = 0; k &lt; 8; k++) {
<br/>
                  if (f == 0) {
<br/>
                     if (OAMArray[k] == 0) {
<br/>
                        OAMArray[k] = 1; //set full.
<br/>
                        OAMPtr = k;
<br/>
                        f = 1;
<br/>
                     }
<br/>
                  }
<br/>
               }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
the issue is, If my array is not u16 it doesnt work and i dont know why, I have tried my array as u8,int and u32 all produce different results....i just want to have an array of 0 or 1! - should i be using u16's??<br/>_________________<br/>Chris Davis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107768 - sajiimori - Wed Nov 01, 2006 9:17 pm</h4>
    <div class="postbody"><span class="postbody">You're overrunning your array.  You allocated 7 elements, but you wrote to the 8th one.  If you declare an array with n elements, don't index past n-1.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107786 - gmiller - Wed Nov 01, 2006 11:56 pm</h4>
    <div class="postbody"><span class="postbody">If you only need 1 or zero then this "array" could be in one 32 bit int (32 1 bit flags).  Here are some macros that might be be helpful:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define setBitu32(arName,bitNum) arName[(bitNum) &gt;&gt; 5] &amp;= (1 &lt;&lt; ((bitNum) &amp; 31))
<br/>
#define clrBitu32(arName,bitNum) arName[(bitNum) &gt;&gt; 5] &amp;= ~(1 &lt;&lt; ((bitNum) &amp; 31))
<br/>
#define tstBitu32(arName,bitNum) arName[(bitNum) &gt;&gt; 5] |= (1 &lt;&lt; ((bitNum) &amp; 31))
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Then to use it:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
unsigned int OAMarray[1];
<br/>
<br/>
OAMarray[0] = 0; //clear all 32 bits
<br/>
<br/>
setBitu32(OAMarray, 0); // set bit zero
<br/>
setBitu32(OAMarray, 1); // set bit One
<br/>
<br/>
int f = 0;
<br/>
<br/>
for (k = 0; k &lt; 7; k++) { // search 7 elements (0 - 6) 
<br/>
  if (tstBitu32(OAMarray, k) == 0) {
<br/>
     setBitu32(OAMarray, k);
<br/>
     break;
<br/>
  }
<br/>
}
<br/>
<br/>
if (f != 0) { // found
<br/>
 }
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
There may be a typo here I just did this without compiler checking but I believe it is correct.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107795 - sajiimori - Thu Nov 02, 2006 1:17 am</h4>
    <div class="postbody"><span class="postbody">If you eventually go the bitfield route, figure out how to do it by hand, and then immediately stop doing it by hand, and instead start compiling as C++ (if you're not already) and use the std::bitset class.  Even if you use no other C++ features, this one will save you a lot of headache at practically zero cost.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107802 - gmiller - Thu Nov 02, 2006 4:31 am</h4>
    <div class="postbody"><span class="postbody">I agree somewhat with the bitfield use as sajiimori says but I have found that most iplementations of bitfields just "suck" so I stopped using them.  The bit fields in C are 3 to four times the code size they need to be and at least twice as slow as doing them by hand.  My experience with bit fields in C++ was pretty bad so I stopped using them as well.  But to be fair that was 10 years ago so their might have been changes that would change my mind.  To me doing it by hand is zero cost at this time so I continue to do it that way.  I guess I am just scary that way ...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107823 - sgeos - Thu Nov 02, 2006 10:59 am</h4>
    <div class="postbody"><span class="postbody">I'd write a clearArrayU16() function, and then do something like this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">// Prototype
<br/>
void clearArrayU16(u16 *pData, int pSize, u16 pClear);
<br/>
<br/>
#define OAM_ARRAY_SIZE 8
<br/>
u16 OAMArray[OAM_ARRAY_SIZE];
<br/>
<br/>
clearArrayU16(OAMArray, OAM_ARRAY_SIZE, 0);
<br/>
OAMArray[0] = 1;</td> </tr></table><span class="postbody">
<br/>
If you want to set the first four elements, you can do this instead:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">clearArrayU16(OAMArray, OAM_ARRAY_SIZE, 0);
<br/>
clearArrayU16(OAMArray, 4, 1);</td> </tr></table><span class="postbody">
<br/>
Or if you want to skip the first element and set the four after that:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">clearArrayU16(OAMArray, OAM_ARRAY_SIZE, 0);
<br/>
clearArrayU16(&amp;OAMArray[1], 4, 1);</td> </tr></table><span class="postbody">
<br/>
Note that you can easily overrun your array if you are not careful.
<br/>
You'll have to write the clear function yourself.  For what it's worth, you've basically written it already.
<br/>
<br/>
-Brendan</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107833 - QuantumDoja - Thu Nov 02, 2006 1:22 pm</h4>
    <div class="postbody"><span class="postbody">Thanks for your replies, I may use the bitfield, but have just found through countless iterations of trial and error that if i do this:
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__attribute__((section (".ewram")))  int OAMArray[8];</td> </tr></table><span class="postbody">
<br/>
<br/>
it works fine, so maybe i was having a memory overwrite issue???<br/>_________________<br/>Chris Davis</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107835 - gmiller - Thu Nov 02, 2006 2:01 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>QuantumDoja wrote:</b></span></td> </tr> <tr> <td class="quote">Thanks for your replies, I may use the bitfield, but have just found through countless iterations of trial and error that if i do this:
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">__attribute__((section (".ewram")))  int OAMArray[8];</td> </tr></table><span class="postbody">
<br/>
<br/>
it works fine, so maybe i was having a memory overwrite issue???</span></td> </tr></table><span class="postbody">
<br/>
<br/>
Just remember that the array you are declaring uses subscripts 0 - 7.  By default the data would be in EWRAM anyway so you may be just over writting something else by the directive use.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107875 - sajiimori - Thu Nov 02, 2006 7:35 pm</h4>
    <div class="postbody"><span class="postbody">QuantumDoja, perhaps you missed my post, because I already told you about the array length.  :)
<br/>
<br/>
gmiller, I agree that bitfields are not fast on most compilers, but I was talking specifically about std::bitset.  Have you ever used it?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107878 - gmiller - Thu Nov 02, 2006 8:17 pm</h4>
    <div class="postbody"><span class="postbody">I used an early implementation on SUN Solaris and it's performace was so bad we removed it and did the work with macros and it was 500% faster and 50% the size.  But ... that was 10 years ago so I don't know now.  I guess I should look at it again.  I don't use C++ that often because of the way it works but there are application types where it is just a must "GUI".  Since most of what I write is background processing I don't need the features that often and when I do I usually just put C++ wrappers around the C.  Not a generally recommended way of approaching the problem space but it works for me.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#107896 - sajiimori - Thu Nov 02, 2006 11:21 pm</h4>
    <div class="postbody"><span class="postbody">Yeah, a lot has happened in the compiler world since then.  :)</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
