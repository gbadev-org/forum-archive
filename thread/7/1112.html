<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Appending/including a binary file - gbadev.org forum archive</title>
        <link rel="stylesheet" href="static/pure-min.css" />
        <link rel="stylesheet" href="static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        This is a mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. <br />

        <h2>C/C++ > Appending/including a binary file</h2>
<div id="posts">
<div class="post">
    <h4>#5485 - bakery2k - Tue Apr 29, 2003 5:25 pm</h4>
    <div class="postbody"><span class="postbody">I have a relatively large binary file I would like to include in my ROM, so that the code can access it.
<br/>
<br/>
One option is to write a parser which will convert the file into a text file containing an array of u8 data, which can then be #included.
<br/>
<br/>
Is there a simpler way, for example somehow adding the binary data to the ROM at the compiling/linking stage?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5487 - niltsair - Tue Apr 29, 2003 6:05 pm</h4>
    <div class="postbody"><span class="postbody">I started a program where i need to do just that. Here's a solution...</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
#define END_OF_FILE          (0x08000000+ Size)
<br/>
u8* pMyData;
<br/>
<br/>
pMyData = (u8*)END_OF_FILE;
<br/>
<br/>
....
<br/>
... do stuff with pMyData
<br/>
....</td> </tr></table><span class="postbody">
<br/>
-Compile your program.
<br/>
-Note the exact size of the rom
<br/>
-Replace in the code 'size' with the exact size.
<br/>
-Then just do this : copy yourRom.gba+yourRes.bin Rom.gba
<br/>
-And voil?, Rom.gba contains both program and ressource.
<br/>
<br/>
This can be bothersome, since everytime change your program, the rom size will change accordingly. So, a workaround would be to pick a 'fixed size', say '400000'. And you create a small proggy that fills you rom with 0s untill you reach size '400000'. Then you append your datas.
<br/>
<br/>
<br/>
If you have multiple ressources, you can do this (this is what i settled on) :
<br/>
Basicly fill your rom with 0s 'till you reach a predefiend size(like earlier) then keep a certain amount of free space(depends on on many ressources you want to inludes) Let's refer to this area as Header.
<br/>
<br/>
After the Header, append all of your ressources, and for every one of them, write a pointer to it in the 'Header' area. 
<br/>
<br/>
In your program, you only need to reads 32bits values starting at the predefined address (say 0x08000000 + 400000) which give you a pointer to the ressources. To get the next ressource, get the address to it at (0x08000000 + 400004), and so foth. 
<br/>
<br/>
Hope i wasn't to vague :)</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5488 - tepples - Tue Apr 29, 2003 6:37 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>niltsair wrote:</b></span></td> </tr> <tr> <td class="quote">-Note the exact size of the rom
<br/>
</td> </tr></table><span class="postbody">
<br/>
Not needed.  Devkit Advance R5 beta 3 or later gives the exact size of the ROM in one of the header fields.
<br/>
<br/>
If you can't afford to wait for Devkit Advance R5 beta 3, you can pad the ROM size to (say) a 256 byte boundary, place a magic cookie at the start of your appended data, and search ROM space for the magic cookie.  This is the approach of my <a class="postlink" href="http://www.pineight.com/gba/#gbfs" target="_blank">GBFS</a>.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">If you have multiple ressources, you can do this (this is what i settled on) :</td> </tr></table><span class="postbody">
<br/>
What you describe is equivalent to making a primitive directory for the appended assets.  GBFS does that too.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5490 - niltsair - Tue Apr 29, 2003 6:59 pm</h4>
    <div class="postbody"><span class="postbody">Yes, this is bascily what i do minus the 'magic number'. I developped the method as i was going. For now just saying that the Headers are at position X is suffcient for me. Less versatile though.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5491 - lordmetroid - Tue Apr 29, 2003 7:07 pm</h4>
    <div class="postbody"><span class="postbody">or you could use the tool which you can find on gbadev.org by anli bin2o which creates a variable with your prefered data for you... and then it's upto you how you want to define that variable and where you want to put it.<br/>_________________<br/>*Spam*
<br/>
Open Solutions for an open mind, <a href="http://www.areta.org" target="_blank">www.areta.org</a>
<br/>
<br/>
Areta is an organization of coders codeing mostly open source project, but there is alot of sections like GBA dev, Language learning communities, RPG communities, etc...</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5499 - Paul Shirley - Tue Apr 29, 2003 8:48 pm</h4>
    <div class="postbody"><span class="postbody">removed</span><span class="gensmall"><br/><br/>Last edited by Paul Shirley on Sun Mar 28, 2004 9:59 pm; edited 1 time in total</span></div>    
</div>
<div class="post">
    <h4>#5897 - Jason Wilkins - Mon May 12, 2003 3:31 pm</h4>
    <div class="postbody"><span class="postbody">You get a strange warning if you use that command line.  To prevent it use this instead:
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
objcopy -I binary -O elf32-arm -B arm data.bin data.o
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
DevKit Advance R5 has a defines a few variable which contain information about appended assets.  I'll write up an explanation right here, and later, post it to the DevKit web site.  Please note that I do not have my laptop with me, so I may get some variable names wrong in this post.
<br/>
<br/>
In DevKit Advance R5, there are several variables which can be used to find the beginning and end of assets appended to the program image.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
// This variable is in a well known location in the header
<br/>
// and points to the __load_*_appended_ptr variables.
<br/>
// Can be used by external programs to modify those variables.
<br/>
// This is not very useful at runtime.
<br/>
extern char *__crt0_footer_ptr;
<br/>
<br/>
// These variables are used at runtime to find appended assets,
<br/>
/  appended end is not always useful, use this instead:
<br/>
//  __appended_start + (__load_break_appended_ptr - __load_start_appended_ptr);
<br/>
extern char __appended_start[];
<br/>
extern char __appended_end[];
<br/>
<br/>
// These variables are stored at the end of a virgin program image.
<br/>
extern char *__load_start_appended_ptr;
<br/>
extern char *__load_break_appended_ptr; // end of assets in image
<br/>
extern char *__load_limit_appended_ptr; // maximum assets
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
When you append something to the ROM, the variable __load_break_appended_ptr will become incorrect.
<br/>
I intend to write a tool which will correct the value for you, but until Beta 4, i'll tell you how that tool will be written.
<br/>
<br/>
The variable __crt0_footer_ptr is located at file offset E0 on a typical rom.  If the address starts with 0x02,  substract 0x02000000 from it and use fseek, otherwise, subtracted 0x08000000 from it.
<br/>
<br/>
The first value at *__crt_footer_ptr is __load_break_appended_ptr.  This value needs to be adjusted to the new end of image.  It will either be 0x02000000 + filesize or 0x08000000 + filesize depending on if __crt0_footer_ptr started with 0x02 or 0x08.  
<br/>
<br/>
A good program will make sure that the new __load_break_appended_ptr is not greater than __load_limit_appended_ptr.  It is located at the footer offset + 8 in the file.  Keep in mind that by default, this value equals __load_start_appended_ptr, so a program will have to adjust it to be the desired maximum size first.
<br/>
<br/>
The last value, __load_start_appended_ptr points to the first address of the appended data in the image.  This value is here so the the footer can be expanded in the future, because it points past the last address of the footer.  This value is located at the footer file offset + 4.
<br/>
<br/>
All these values are stored little endian, and they will all be file offsets + 0x02000000 or 0x08000000, depending on if the image is multiboot or a cartridge ROM.
<br/>
<br/>
You do not access assets at runtime using the __load_*_appended variables.  These values are file offsets, and may not match the runtime address of the appended assets.  The correct variable to use is __appended_start.  The variable __appended_end points to the end of assets included by using the .appended section.  This section is for debugging purposes (it allows you to have appended assets in a .elf file), so it will not equal the actual end of assets appended using an external program.
<br/>
<br/>
To find the end of appended assets are runtime, use __appended_start + (__load_break_appended_ptr - __load_break_start_ptr)
<br/>
<br/>
As mentioned before, it is possible to simulate appending assets by carefully placing variables in the .appended section.  The resulting program image will have correct footer variables and appended assets just as if it had been done later.  This is useful for creating mockups of appended data and then using a debugger to test the code which accesses them.  Otherwise it would be difficult to test appended asset code because assets can only be appended to a binary and binaries contain no debug information.
<br/>
<br/>
I hope this is clear.  I hope to write this up a little better soon, and provide example code, and a program which can, at a minimum, correct the footer after appending variables using cat.exe.  This is just an example of how such a program would work!
<br/>
<br/>
EDIT: I modified the cat command line to keep the original binary.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
$ assfix -v --set-limit=256k game0.mb
<br/>
limit was 0x020080FC, is now 0x02040000 
<br/>
$ cat game0.mb assets.bin &gt; game.mb
<br/>
$ assfix -v game.mb
<br/>
188kb new assets appended.
<br/>
old break was 0x020080FC
<br/>
new break is 0x02037400
<br/>
limit is 0x02040000
<br/>
35.8kb remain.
<br/>
$
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Of course, the program will have a more tactful name than that ^_^<br/>_________________<br/><a href="http://devkitadv.sourceforge.net" target="_blank">http://devkitadv.sourceforge.net</a></span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#5929 - Quirky - Tue May 13, 2003 8:06 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Jason Wilkins wrote:</b></span></td> </tr> <tr> <td class="quote">You get a strange warning if you use that command line.  To prevent it use this instead:
<br/>
<br/>
<table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Code:</b></span></td> </tr> <tr> <td class="code">
<br/>
objcopy -I binary -O elf32-arm -B arm data.bin data.o
<br/>
</td> </tr></table><span class="postbody">
<br/>
</span></td> </tr></table><span class="postbody">
<br/>
<br/>
The version of objcopy in Devkit R5 (GNU objcopy 2.11.2) doesn't support the -B option.
<br/>
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote"><span style="font-size: 9px; line-height: normal">&gt; objcopy -I binary -O elf32-arm -B arm gfx.raw gfx.all.rodata.o
<br/>
<br/>
/cygdrive/d/devkitadv/bin/objcopy: invalid option -- B
<br/>
Usage: /cygdrive/d/devkitadv/bin/objcopy &lt;switches&gt; in-file [out-file]
<br/>
 The switches are:
<br/>
  -I --input-target &lt;bfdname&gt;      Assume input file is in format &lt;bfdname&gt;
<br/>
  -O --output-target &lt;bfdname&gt;     Create an output file in format &lt;bfdname&gt;
<br/>
  -F --target &lt;bfdname&gt;            Set both input and output format to &lt;bfdname&gt;
<br/>
<br/>
     --debugging                   Convert debugging information, if possible
<br/>
  -p --preserve-dates              Copy modified/access timestamps to the output
<br/>
<br/>
  -j --only-section &lt;name&gt;         Only copy section &lt;name&gt; into the output
<br/>
  -R --remove-section &lt;name&gt;       Remove section &lt;name&gt; from the output
<br/>
  -S --strip-all                   Remove all symbol and relocation information
<br/>
  -g --strip-debug                 Remove all debugging symbols
<br/>
     --strip-unneeded              Remove all symbols not needed by relocations
<br/>
  -N --strip-symbol &lt;name&gt;         Do not copy symbol &lt;name&gt;
<br/>
  -K --keep-symbol &lt;name&gt;          Only copy symbol &lt;name&gt;
<br/>
  -L --localize-symbol &lt;name&gt;      Force symbol &lt;name&gt; to be marked as a local
<br/>
  -G --keep-global-symbol &lt;name&gt;   Localize all symbols except &lt;name&gt;
<br/>
  -W --weaken-symbol &lt;name&gt;        Force symbol &lt;name&gt; to be marked as a weak
<br/>
     --weaken                      Force all global symbols to be marked as weak
<br/>
<br/>
  -x --discard-all                 Remove all non-global symbols
<br/>
  -X --discard-locals              Remove any compiler-generated symbols
<br/>
  -i --interleave &lt;number&gt;         Only copy one out of every &lt;number&gt; bytes
<br/>
  -b --byte &lt;num&gt;                  Select byte &lt;num&gt; in every interleaved block
<br/>
     --gap-fill &lt;val&gt;              Fill gaps between sections with &lt;val&gt;
<br/>
     --pad-to &lt;addr&gt;               Pad the last section up to address &lt;addr&gt;
<br/>
     --set-start &lt;addr&gt;            Set the start address to &lt;addr&gt;
<br/>
    {--change-start|--adjust-start} &lt;incr&gt;
<br/>
                                   Add &lt;incr&gt; to the start address
<br/>
    {--change-addresses|--adjust-vma} &lt;incr&gt;
<br/>
                                   Add &lt;incr&gt; to LMA, VMA and start addresses
<br/>
    {--change-section-address|--adjust-section-vma} &lt;name&gt;{=|+|-}&lt;val&gt;
<br/>
                                   Change LMA and VMA of section &lt;name&gt; by &lt;val&gt;
<br/>
<br/>
     --change-section-lma &lt;name&gt;{=|+|-}&lt;val&gt;
<br/>
                                   Change the LMA of section &lt;name&gt; by &lt;val&gt;
<br/>
     --change-section-vma &lt;name&gt;{=|+|-}&lt;val&gt;
<br/>
                                   Change the VMA of section &lt;name&gt; by &lt;val&gt;
<br/>
    {--[no-]change-warnings|--[no-]adjust-warnings}
<br/>
                                   Warn if a named section does not exist
<br/>
     --set-section-flags &lt;name&gt;=&lt;flags&gt;
<br/>
                                   Set section &lt;name&gt;'s properties to &lt;flags&gt;
<br/>
     --add-section &lt;name&gt;=&lt;file&gt;   Add section &lt;name&gt; found in &lt;file&gt; to output
<br/>
     --change-leading-char         Force output format's leading character style
<br/>
<br/>
     --remove-leading-char         Remove leading character from global symbols
<br/>
     --redefine-sym &lt;old&gt;=&lt;new&gt;    Redefine symbol name &lt;old&gt; to &lt;new&gt;
<br/>
     --srec-len &lt;number&gt;           Restrict the length of generated Srecords
<br/>
     --srec-forceS3                Restrict the type of generated Srecords to S3
<br/>
<br/>
     --strip-symbols &lt;file&gt;        -N for all symbols listed in &lt;file&gt;
<br/>
     --keep-symbols &lt;file&gt;         -K for all symbols listed in &lt;file&gt;
<br/>
     --localize-symbols &lt;file&gt;     -L for all symbols listed in &lt;file&gt;
<br/>
     --keep-global-symbols &lt;file&gt;  -G for all symbols listed in &lt;file&gt;
<br/>
     --weaken-symbols &lt;file&gt;       -W for all symbols listed in &lt;file&gt;
<br/>
  -v --verbose                     List all object files modified
<br/>
  -V --version                     Display this program's version number
<br/>
  -h --help                        Display this output
<br/>
/cygdrive/d/dev/devkitadv/bin/objcopy: supported targets: elf32-littlearm elf32-
<br/>
bigarm elf32-little elf32-big coff-arm-little coff-arm-big a.out-arm-little a.ou
<br/>
t-arm-big srec symbolsrec tekhex binary ihex</span></td> </tr></table><span class="postbody"></span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
