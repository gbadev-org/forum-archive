<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Fast Math - gbadev.org forum archive</title>
        <link rel="stylesheet" href="/forum-archive/static/pure-min.css" />
        <link rel="stylesheet" href="/forum-archive/static/main.css" />
    </head>
    <body>
        <h1>gbadev.org forum archive</h1>

        <i>This is a read-only mirror of the content originally found on forum.gbadev.org
        (now offline), salvaged from Wayback machine copies. </i><br />

        <h2>C/C++ > Fast Math</h2>
<div id="posts">
<div class="post">
    <h4>#9372 - Domovoi - Sun Aug 03, 2003 12:34 am</h4>
    <div class="postbody"><span class="postbody">So... I'm wondering about math on the GBA. In general, I believe that additions are faster than subtractions which are faster than multiplications which are faster than divisions. Right?
<br/>
<br/>
Also, bit shifting should be faster than multiplying. For instance, a * 32 is slower than a &lt;&lt; 5, which produces the same outcome, right? Is this also true on GBA? 
<br/>
<br/>
Is there a way to do fast MOD's? I'm using val = thing%8 a lot.. I'm wondering if there's some clever and faster way to do this. Dividing by eight, for instance, is simply a bitshift to the right: thing&gt;&gt;3. Is there something you can do for mods too?
<br/>
<br/>
In short, do all these little math tricks work on the ARM CPU too, or are there exceptions? Or is it all just futile, because the compiler, for instance, already optimizes such calculations for you?</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9373 - tepples - Sun Aug 03, 2003 12:40 am</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Domovoi wrote:</b></span></td> </tr> <tr> <td class="quote">So... I'm wondering about math on the GBA. In general, I believe that additions are faster than subtractions which are faster than multiplications which are faster than divisions. Right?</td> </tr></table><span class="postbody">
<br/>
Additions and subtractions take about one cycle. Multiplications take three to six, depending on the second operand. Divisions require a slow SWI call; division by a non-power-of-two constant can often be replaced with an ARM-mode multiply by inverse.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Also, bit shifting should be faster than multiplying. For instance, a * 32 is slower than a &lt;&lt; 5, which produces the same outcome, right? Is this also true on GBA?</td> </tr></table><span class="postbody">
<br/>
Shifting by a constant takes one cycle.  Shifting by a variable (a &lt;&lt; b) takes two.  There's no difference between one cycle and two if you're running code from ROM and using prefetch.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Is there a way to do fast MOD's? I'm using val = thing%8 a lot.. I'm wondering if there's some clever and faster way to do this. Dividing by eight, for instance, is simply a bitshift to the right: thing&gt;&gt;3. Is there something you can do for mods too?</td> </tr></table><span class="postbody">
<br/>
If b is a positive power of 2, then a % b == a &amp; (b - 1).  For example, thing % 8 == thing - 7. But as usual, there's an exception: when thing is negative, the answer might be off by one, as % rounds toward 0, whereas &amp; rounds toward negative infinity.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9375 - mtg101 - Sun Aug 03, 2003 1:48 am</h4>
    <div class="postbody"><span class="postbody">That mod trick is very clever.  I asume there are other tricks like it for other forms of calculation. Does anyone know of a site that lists such tricks?<br/>_________________<br/>---
<br/>
Speaker for the Dead</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9378 - crossraleigh - Sun Aug 03, 2003 2:28 am</h4>
    <div class="postbody"><span class="postbody">Try <span style="font-style: italic">Hacker's Delight</span> by Dr. Henry S. Warren, Jr., published by AW. It has all sorts of bit fiddling tricks.
<br/>
<br/>
If you spend any amount with computer arithmetic, you will love this book.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9386 - Domovoi - Sun Aug 03, 2003 8:05 am</h4>
    <div class="postbody"><span class="postbody">Indeed, that mod thing is great. I find that when working with tilemode, you get a lot of multiplications by 32 and divisions or mods by eight... both positive powers of two. Excellent. 
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>tepples wrote:</b></span></td> </tr> <tr> <td class="quote">Divisions require a slow SWI call; division by a non-power-of-two constant can often be replaced with an ARM-mode multiply by inverse.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Hmmm... Where can I learn more about an ARM-mode multiply by inverse? What's the difference between a normal multiply by inverse and an ARM-mode one? Oh, and what exactly is an SWI call?
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Shifting by a constant takes one cycle.  Shifting by a variable (a &lt;&lt; b) takes two.  There's no difference between one cycle and two if you're running code from ROM and using prefetch.
<br/>
</td> </tr></table><span class="postbody">
<br/>
<br/>
Prefetch, huh? I looked it up... Seems like simply enabling a single bit. Are there any drawbacks to using prefetch, or can you just simply enable it all the time?
<br/>
<br/>
Thanks a lot for the tips, by the way!</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9391 - tepples - Sun Aug 03, 2003 3:22 pm</h4>
    <div class="postbody"><span class="postbody"></span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Domovoi wrote:</b></span></td> </tr> <tr> <td class="quote">Hmmm... Where can I learn more about an ARM-mode multiply by inverse? What's the difference between a normal multiply by inverse and an ARM-mode one?</td> </tr></table><span class="postbody">
<br/>
Thumb allows only for 32x32=32 bit multiplication, where the lower 32 bits are kept. Multiplying by a reciprocal typically requires the upper 32 bits from a 32x32=64 bit multiplication, and that's an ARM instruction.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Oh, and what exactly is an SWI call?</td> </tr></table><span class="postbody">
<br/>
Software interrupt. Read all about them in the <a class="postlink" href="http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm" target="_blank">CowBite spec</a>, and use Andrew P. Bilyk's library to access them.
<br/>
<br/>
</span><table align="center" border="0" cellpadding="3" cellspacing="1" width="90%"><tr> <td><span class="genmed"><b>Quote:</b></span></td> </tr> <tr> <td class="quote">Prefetch, huh? I looked it up... Seems like simply enabling a single bit. Are there any drawbacks to using prefetch, or can you just simply enable it all the time?</td> </tr></table><span class="postbody">
<br/>
Prefetch makes the GBA draw about 10 percent more current from its batteries.<br/>_________________<br/>-- Where is he?
<br/>
-- Who?
<br/>
-- You know, the human.
<br/>
-- I think he moved to Tilwick.</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9397 - mtg101 - Sun Aug 03, 2003 8:06 pm</h4>
    <div class="postbody"><span class="postbody">So... prefetch...  apart from the batt drain - are there any other things to take into account?  Are there any cases, like when you've got lots of jumps in your code, that you may not want to enable it?<br/>_________________<br/>---
<br/>
Speaker for the Dead</span><span class="gensmall"></span></div>    
</div>
<div class="post">
    <h4>#9452 - Cyberman - Tue Aug 05, 2003 5:40 am</h4>
    <div class="postbody"><span class="postbody">Prefetch refers to instruction prefetch it gets you better performance if you have a long sequence of instructions to execute and they are sequential.  However you will get the queue emptied on any branch instruction.  The reason the prefetch draws more power is the bus is busier and the prefetch hardware is active, on the thumb processor.  I'm not certain but I believe it will affect DMA some as well.
<br/>
<br/>
I don't think Prefetch will get you as much as loading critical routines (IE functions that are called a lot during game execution) into IRAM  and switching to ARM mode when they are run instead of runing them from ROM in thumb mode. you won't need to twiddle with prefetch for this.
<br/>
<br/>
Cyb</span><span class="gensmall"></span></div>    
</div>
</div>

    </body>
</html>
